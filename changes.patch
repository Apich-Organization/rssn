diff --git a/src/symbolic/calculus.rs b/src/symbolic/calculus.rs
index 62a7649..5a3e5e7 100644
--- a/src/symbolic/calculus.rs
+++ b/src/symbolic/calculus.rs
@@ -3,6 +3,7 @@
 use crate::symbolic::core::{Expr, PathType};
 use crate::symbolic::polynomial::{is_polynomial, leading_coefficient, polynomial_degree};
 use crate::symbolic::simplify::is_zero;
+use crate::symbolic::core::DagOp;
 use crate::symbolic::simplify::simplify;
 use crate::symbolic::solve::solve;
 use num_bigint::BigInt;
@@ -22,58 +23,60 @@
 /// # Returns
 /// A new `Expr` with all occurrences of `var` replaced by `replacement`.
 pub fn substitute(expr: &Expr, var: &str, replacement: &Expr) -> Expr {
-    match expr {
-        Expr::Variable(name) if name == var => replacement.clone(),
-        Expr::Add(a, b) => Expr::new_add(
-            substitute(a, var, replacement),
-            substitute(b, var, replacement),
-        ),
-        Expr::Sub(a, b) => Expr::new_sub(
-            substitute(a, var, replacement),
-            substitute(b, var, replacement),
-        ),
-        Expr::Mul(a, b) => Expr::new_mul(
-            substitute(a, var, replacement),
-            substitute(b, var, replacement),
-        ),
-        Expr::Div(a, b) => Expr::new_div(
-            substitute(a, var, replacement),
-            substitute(b, var, replacement),
-        ),
-        Expr::Power(base, exp) => Expr::new_pow(
-            substitute(base, var, replacement),
-            substitute(exp, var, replacement),
-        ),
-        Expr::Sin(arg) => Expr::new_sin(substitute(arg, var, replacement)),
-        Expr::Cos(arg) => Expr::new_cos(substitute(arg, var, replacement)),
-        Expr::Tan(arg) => Expr::new_tan(substitute(arg, var, replacement)),
-        Expr::Exp(arg) => Expr::new_exp(substitute(arg, var, replacement)),
-        Expr::Log(arg) => Expr::new_log(substitute(arg, var, replacement)),
-        Expr::Integral {
-            integrand,
-            var: int_var,
-            lower_bound,
-            upper_bound,
-        } => Expr::Integral {
-            integrand: Arc::new(substitute(integrand, var, replacement)),
-            var: int_var.clone(),
-            lower_bound: Arc::new(substitute(lower_bound, var, replacement)),
-            upper_bound: Arc::new(substitute(upper_bound, var, replacement)),
-        },
-        Expr::Sum {
-            body,
-            var: sum_var,
-            from,
-            to,
-        } => {
-            let new_from = substitute(from, var, replacement);
-            let new_to = substitute(to, var, replacement);
-            let new_body = if let Expr::Variable(v) = &**sum_var {
-                if v == var {
-                    body.clone()
-                } else {
-                    Arc::new(substitute(body, var, replacement))
-                }
-            } else {
-                Arc::new(substitute(body, var, replacement))
-            };
-            Expr::Sum {
-                body: new_body.clone(),
-                var: sum_var.clone(),
-                from: Arc::new(new_from),
-                to: Arc::new(new_to),
-            }
-        }
-        _ => expr.clone(),
+    let mut stack = vec![expr.clone()];
+    let mut cache = std::collections::HashMap::new();
+
+    while let Some(current_expr) = stack.last().cloned() {
+        if cache.contains_key(&current_expr) {
+            stack.pop();
+            continue;
+        }
+
+        let mut children_pending = false;
+        if let DagOp::Sum = current_expr.op() {
+            let children = current_expr.children();
+            let sum_var_expr = &children[1];
+            if let DagOp::Variable(v) = sum_var_expr.op() {
+                if v == var {
+                    for child in children.iter().skip(1) {
+                        if !cache.contains_key(child) {
+                            stack.push(child.clone());
+                            children_pending = true;
+                        }
+                    }
+                } else {
+                    for child in children {
+                        if !cache.contains_key(&child) {
+                            stack.push(child);
+                            children_pending = true;
+                        }
+                    }
+                }
+            }
+        } else {
+            for child in current_expr.children() {
+                if !cache.contains_key(&child) {
+                    stack.push(child);
+                    children_pending = true;
+                }
+            }
+        }
+
+        if children_pending {
+            continue;
+        }
+
+        let processed_expr = stack.pop().unwrap();
+        let op = processed_expr.op();
+        let children = processed_expr.children();
+
+        let result = match op {
+            DagOp::Variable(name) if name == var => replacement.clone(),
+            DagOp::Add => Expr::new_add(cache[&children[0]].clone(), cache[&children[1]].clone()),
+            DagOp::Sub => Expr::new_sub(cache[&children[0]].clone(), cache[&children[1]].clone()),
+            DagOp::Mul => Expr::new_mul(cache[&children[0]].clone(), cache[&children[1]].clone()),
+            DagOp::Div => Expr::new_div(cache[&children[0]].clone(), cache[&children[1]].clone()),
+            DagOp::Power => Expr::new_pow(cache[&children[0]].clone(), cache[&children[1]].clone()),
+            DagOp::Sin => Expr::new_sin(cache[&children[0]].clone()),
+            DagOp::Cos => Expr::new_cos(cache[&children[0]].clone()),
+            DagOp::Tan => Expr::new_tan(cache[&children[0]].clone()),
+            DagOp::Exp => Expr::new_exp(cache[&children[0]].clone()),
+            DagOp::Log => Expr::new_log(cache[&children[0]].clone()),
+            DagOp::Neg => Expr::new_neg(cache[&children[0]].clone()),
+            _ => processed_expr.clone(),
+        };
+        cache.insert(processed_expr, result);
+    }
+
+    cache.get(expr).cloned().unwrap_or_else(|| expr.clone())
+}
@@ -96,100 +99,102 @@
-pub(crate) fn get_real_imag_parts(expr: &Expr) -> (Expr, Expr) {
-/// # Returns
-/// A new `Expr` representing the symbolic derivative.
-pub fn differentiate(expr: &Expr, var: &str) -> Expr {
-    match expr {
-        Expr::Constant(_) | Expr::BigInt(_) | Expr::Rational(_) | Expr::Pi | Expr::E => {
-            Expr::BigInt(BigInt::zero())
-        }
-        Expr::Variable(name) if name == var => Expr::BigInt(BigInt::one()),
-        Expr::Variable(_) => Expr::BigInt(BigInt::zero()),
-        Expr::Add(a, b) => simplify(Expr::new_add(differentiate(a, var), differentiate(b, var))),
-        Expr::Sub(a, b) => simplify(Expr::new_sub(differentiate(a, var), differentiate(b, var))),
-        Expr::Mul(a, b) => simplify(Expr::new_add(
-            Expr::new_mul(differentiate(a, var), b.clone()),
-            Expr::new_mul(a.clone(), differentiate(b, var)),
-        )),
-        Expr::Div(a, b) => simplify(Expr::new_div(
-            Expr::new_sub(
-                Expr::new_mul(differentiate(a, var), b.clone()),
-                Expr::new_mul(a.clone(), differentiate(b, var)),
-            ),
-            Expr::new_pow(b.clone(), Expr::BigInt(BigInt::from(2))),
-        )),
-        Expr::Power(base, exp) => {
-            let d_base = differentiate(base, var);
-            let d_exp = differentiate(exp, var);
-            let term1_val = Expr::new_log(base.clone());
-            let term1 = Expr::new_mul(d_exp, term1_val);
-            let term1_arc = Arc::new(term1);
-            let div_val = Expr::new_div(d_base, base.clone());
-            let term2_val = Expr::new_mul(exp.clone(), div_val);
-            let term2_arc = Arc::new(term2_val);
-            let combined_term = Arc::new(Expr::new_add(term1_arc, term2_arc));
-            simplify(Expr::new_mul(
-                Expr::new_pow(base.clone(), exp.clone()),
-                combined_term,
-            ))
-        }
-        Expr::Sin(arg) => simplify(Expr::new_mul(
-            Expr::new_cos(arg.clone()),
-            differentiate(arg, var),
-        )),
-        Expr::Cos(arg) => simplify(Expr::new_mul(
-            Expr::new_neg(Expr::new_sin(arg.clone())),
-            differentiate(arg, var),
-        )),
-        Expr::Tan(arg) => simplify(Expr::new_mul(
-            Expr::new_pow(Expr::new_sec(arg.clone()), Expr::BigInt(BigInt::from(2))),
-            differentiate(arg, var),
-        )),
-        Expr::Sec(arg) => simplify(Expr::new_mul(
-            Expr::new_sec(arg.clone()),
-            Expr::new_mul(Expr::new_tan(arg.clone()), differentiate(arg, var)),
-        )),
-        Expr::Csc(arg) => simplify(Expr::new_mul(
-            Expr::new_neg(Expr::new_csc(arg.clone())),
-            Expr::new_mul(Expr::new_cot(arg.clone()), differentiate(arg, var)),
-        )),
-        Expr::Cot(arg) => simplify(Expr::new_mul(
-            Expr::new_neg(Expr::new_pow(
-                Expr::new_csc(arg.clone()),
-                Expr::BigInt(BigInt::from(2)),
-            )),
-            differentiate(arg, var),
-        )),
-        Expr::Sinh(arg) => simplify(Expr::new_mul(
-            Expr::new_cosh(arg.clone()),
-            differentiate(arg, var),
-        )),
-        Expr::Cosh(arg) => simplify(Expr::new_mul(
-            Expr::new_sinh(arg.clone()),
-            differentiate(arg, var),
-        )),
-        Expr::Tanh(arg) => simplify(Expr::new_mul(
-            Expr::new_pow(Expr::new_sech(arg.clone()), Expr::BigInt(BigInt::from(2))),
-            differentiate(arg, var),
-        )),
-        Expr::Exp(arg) => simplify(Expr::new_mul(
-            Expr::new_exp(arg.clone()),
-            differentiate(arg, var),
-        )),
-        Expr::Log(arg) => simplify(Expr::new_div(differentiate(arg, var), arg.clone())),
-        Expr::ArcCot(arg) => simplify(Expr::new_neg(Expr::new_div(
-            differentiate(arg, var),
-            Expr::new_add(
-                Expr::BigInt(BigInt::one()),
-                Expr::new_pow(arg.clone(), Expr::BigInt(BigInt::from(2))),
-            ),
-        ))),
-        Expr::ArcSec(arg) => simplify(Expr::new_div(
-            differentiate(arg, var),
-            Expr::new_mul(
-                Expr::new_abs(arg.clone()),
-                Expr::new_sqrt(Expr::new_sub(
-                    Expr::new_pow(arg.clone(), Expr::BigInt(BigInt::from(2))),
-                    Expr::BigInt(BigInt::one()),
-                )),
-            ),
-        )),
-        Expr::ArcCsc(arg) => simplify(Expr::new_neg(Expr::new_div(
-            differentiate(arg, var),
-            Expr::new_mul(
-                Expr::new_abs(arg.clone()),
-                Expr::new_sqrt(Expr::new_sub(
-                    Expr::new_pow(arg.clone(), Expr::BigInt(BigInt::from(2))),
-                    Expr::BigInt(BigInt::one()),
-                )),
-            ),
-        ))),
-        Expr::Coth(arg) => simplify(Expr::new_neg(Expr::new_pow(
-            Expr::new_csch(arg.clone()),
-            Expr::BigInt(BigInt::from(2)),
-        ))),
-        Expr::Sech(arg) => simplify(Expr::new_neg(Expr::new_mul(
-            Expr::new_sech(arg.clone()),
-            Expr::new_tanh(arg.clone()),
-        ))),
-        Expr::Csch(arg) => simplify(Expr::new_neg(Expr::new_mul(
-            Expr::new_csch(arg.clone()),
-            Expr::new_coth(arg.clone()),
-        ))),
-        Expr::ArcSinh(arg) => simplify(Expr::new_div(
-            differentiate(arg, var),
-            Expr::new_sqrt(Expr::new_add(
-                Expr::new_pow(arg.clone(), Expr::BigInt(BigInt::from(2))),
-                Expr::BigInt(BigInt::one()),
-            )),
-        )),
-        Expr::ArcCosh(arg) => simplify(Expr::new_div(
-            differentiate(arg, var),
-            Expr::new_sqrt(Expr::new_sub(
-                Expr::new_pow(arg.clone(), Expr::BigInt(BigInt::from(2))),
-                Expr::BigInt(BigInt::one()),
-            )),
-        )),
-        Expr::ArcTanh(arg) => simplify(Expr::new_div(
-            differentiate(arg, var),
-            Expr::new_sub(
-                Expr::BigInt(BigInt::one()),
-                Expr::new_pow(arg.clone(), Expr::BigInt(BigInt::from(2))),
-            ),
-        )),
-        Expr::ArcCoth(arg) => simplify(Expr::new_div(
-            differentiate(arg, var),
-            Expr::new_sub(
-                Expr::BigInt(BigInt::one()),
-                Expr::new_pow(arg.clone(), Expr::BigInt(BigInt::from(2))),
-            ),
-        )),
-        Expr::ArcSech(arg) => simplify(Expr::new_neg(Expr::new_div(
-            differentiate(arg, var),
-            Expr::new_mul(
-                arg.clone(),
-                Expr::new_sqrt(Expr::new_sub(
-                    Expr::BigInt(BigInt::one()),
-                    Expr::new_pow(arg.clone(), Expr::BigInt(BigInt::from(2))),
-                )),
-            ),
-        ))),
-        Expr::ArcCsch(arg) => simplify(Expr::new_neg(Expr::new_div(
-            differentiate(arg, var),
-            Expr::new_mul(
-                Expr::new_abs(arg.clone()),
-                Expr::new_sqrt(Expr::new_add(
-                    Expr::BigInt(BigInt::one()),
-                    Expr::new_pow(arg.clone(), Expr::BigInt(BigInt::from(2))),
-                )),
-            ),
-        ))),
-        Expr::Integral {
-            integrand,
-            var: int_var,
-            ..        } => {
-            if *int_var.clone() == Expr::Variable(var.to_string()) {
-                integrand.as_ref().clone()
-            } else {
-                Expr::Derivative(Arc::new(expr.clone()), var.to_string())
-            }
-        }
-        Expr::Sum {
-            body,
-            var: sum_var,
-            from,
-            to,
-        } => {
-            let diff_body = differentiate(body, var);
-            Expr::Sum {
-                body: Arc::new(diff_body),
-                var: sum_var.clone(),
-                from: from.clone(),
-                to: to.clone(),
-            }
-        }
-        _ => Expr::Derivative(Arc::new(expr.clone()), var.to_string()),
+    let mut stack = vec![expr.clone()];
+    let mut cache: HashMap<Expr, Expr> = HashMap::new();
+
+    while let Some(current_expr) = stack.last().cloned() {
+        if cache.contains_key(&current_expr) {
+            stack.pop();
+            continue;
+        }
+
+        let mut children_pending = false;
+        for child in current_expr.children() {
+            if !cache.contains_key(&child) {
+                stack.push(child);
+                children_pending = true;
+            }
+        }
+
+        if children_pending {
+            continue;
+        }
+
+        let processed_expr = stack.pop().unwrap();
+        let op = processed_expr.op();
+        let children = processed_expr.children();
+
+        let result = match op {
+            DagOp::Constant(_) | DagOp::BigInt(_) | DagOp::Rational(_) | DagOp::Pi | DagOp::E => {
+                Expr::BigInt(BigInt::zero())
+            }
+            DagOp::Variable(name) if name == var => Expr::BigInt(BigInt::one()),
+            DagOp::Variable(_) => Expr::BigInt(BigInt::zero()),
+            DagOp::Add => {
+                let a = &children[0];
+                let b = &children[1];
+                simplify(Expr::new_add(cache[a].clone(), cache[b].clone()))
+            }
+            DagOp::Sub => {
+                let a = &children[0];
+                let b = &children[1];
+                simplify(Expr::new_sub(cache[a].clone(), cache[b].clone()))
+            }
+            DagOp::Mul => {
+                let a = &children[0];
+                let b = &children[1];
+                simplify(Expr::new_add(
+                    Expr::new_mul(cache[a].clone(), b.clone()),
+                    Expr::new_mul(a.clone(), cache[b].clone()),
+                ))
+            }
+            DagOp::Div => {
+                let a = &children[0];
+                let b = &children[1];
+                simplify(Expr::new_div(
+                    Expr::new_sub(
+                        Expr::new_mul(cache[a].clone(), b.clone()),
+                        Expr::new_mul(a.clone(), cache[b].clone()),
+                    ),
+                    Expr::new_pow(b.clone(), Expr::BigInt(BigInt::from(2))),
+                ))
+            }
+            DagOp::Power => {
+                let base = &children[0];
+                let exp = &children[1];
+                let d_base = cache[base].clone();
+                let d_exp = cache[exp].clone();
+                let term1_val = Expr::new_log(base.clone());
+                let term1 = Expr::new_mul(d_exp, term1_val);
+                let term1_arc = Arc::new(term1);
+                let div_val = Expr::new_div(d_base, base.clone());
+                let term2_val = Expr::new_mul(exp.clone(), div_val);
+                let term2_arc = Arc::new(term2_val);
+                let combined_term = Arc::new(Expr::new_add(term1_arc, term2_arc));
+                simplify(Expr::new_mul(
+                    Expr::new_pow(base.clone(), exp.clone()),
+                    combined_term,
+                ))
+            }
+            DagOp::Sin => {
+                let arg = &children[0];
+                simplify(Expr::new_mul(Expr::new_cos(arg.clone()), cache[arg].clone()))
+            }
+            DagOp::Cos => {
+                let arg = &children[0];
+                simplify(Expr::new_mul(
+                    Expr::new_neg(Expr::new_sin(arg.clone())),
+                    cache[arg].clone(),
+                ))
+            }
+            DagOp::Tan => {
+                let arg = &children[0];
+                simplify(Expr::new_mul(
+                    Expr::new_pow(Expr::new_sec(arg.clone()), Expr::BigInt(BigInt::from(2))),
+                    cache[arg].clone(),
+                ))
+            }
+            _ => Expr::Derivative(Arc::new(processed_expr.clone()), var.to_string()),
+        };
+        cache.insert(processed_expr, result);
     }
+
+    cache.get(expr).cloned().unwrap_or_else(|| expr.clone())
 }
 /// Performs symbolic integration of an expression with respect to a variable.
 ///
     None
 }
@@ -341,50 +346,50 @@
-pub(crate) fn substitute_expr(expr: &Expr, to_replace: &Expr, replacement: &Expr) -> Expr {
-    if expr == to_replace {
-        return replacement.clone();
-    }
-    match expr {
-        Expr::Add(a, b) => Expr::new_add(
-            substitute_expr(a, to_replace, replacement),
-            substitute_expr(b, to_replace, replacement),
-        ),
-        Expr::Sub(a, b) => Expr::new_sub(
-            substitute_expr(a, to_replace, replacement),
-            substitute_expr(b, to_replace, replacement),
-        ),
-        Expr::Mul(a, b) => Expr::new_mul(
-            substitute_expr(a, to_replace, replacement),
-            substitute_expr(b, to_replace, replacement),
-        ),
-        Expr::Div(a, b) => Expr::new_div(
-            substitute_expr(a, to_replace, replacement),
-            substitute_expr(b, to_replace, replacement),
-        ),
-        Expr::Power(base, exp) => Expr::new_pow(
-            substitute_expr(base, to_replace, replacement),
-            substitute_expr(exp, to_replace, replacement),
-        ),
-        Expr::Sin(arg) => Expr::new_sin(substitute_expr(arg, to_replace, replacement)),
-        Expr::Cos(arg) => Expr::new_cos(substitute_expr(arg, to_replace, replacement)),
-        Expr::Tan(arg) => Expr::new_tan(substitute_expr(arg, to_replace, replacement)),
-        Expr::Sec(arg) => Expr::new_sec(substitute_expr(arg, to_replace, replacement)),
-        Expr::Csc(arg) => Expr::new_csc(substitute_expr(arg, to_replace, replacement)),
-        Expr::Cot(arg) => Expr::new_cot(substitute_expr(arg, to_replace, replacement)),
-        Expr::Sinh(arg) => Expr::new_sinh(substitute_expr(arg, to_replace, replacement)),
-        Expr::Cosh(arg) => Expr::new_cosh(substitute_expr(arg, to_replace, replacement)),
-        Expr::Tanh(arg) => Expr::new_tanh(substitute_expr(arg, to_replace, replacement)),
-        Expr::Exp(arg) => Expr::new_exp(substitute_expr(arg, to_replace, replacement)),
-        Expr::Log(arg) => Expr::new_log(substitute_expr(arg, to_replace, replacement)),
-        Expr::Complex(re, im) => Expr::new_complex(
-            substitute_expr(re, to_replace, replacement),
-            substitute_expr(im, to_replace, replacement),
-        ),
-        Expr::Abs(arg) => Expr::new_abs(substitute_expr(arg, to_replace, replacement)),
-        Expr::Neg(arg) => Expr::new_neg(substitute_expr(arg, to_replace, replacement)),
-        Expr::ArcSin(arg) => Expr::new_arcsin(substitute_expr(arg, to_replace, replacement)),
-        Expr::ArcCos(arg) => Expr::new_arccos(substitute_expr(arg, to_replace, replacement)),
-        Expr::ArcTan(arg) => Expr::new_arctan(substitute_expr(arg, to_replace, replacement)),
-        _ => expr.clone(),
+pub(crate) fn substitute_expr(expr: &Expr, to_replace: &Expr, replacement: &Expr) -> Expr {
+    let mut stack = vec![expr.clone()];
+    let mut cache = std::collections::HashMap::new();
+
+    while let Some(current_expr) = stack.last().cloned() {
+        if &current_expr == to_replace {
+            cache.insert(current_expr, replacement.clone());
+            stack.pop();
+            continue;
+        }
+
+        if cache.contains_key(&current_expr) {
+            stack.pop();
+            continue;
+        }
+
+        let mut children_pending = false;
+        for child in current_expr.children() {
+            if !cache.contains_key(&child) {
+                stack.push(child);
+                children_pending = true;
+            }
+        }
+
+        if children_pending {
+            continue;
+        }
+
+        let processed_expr = stack.pop().unwrap();
+        let op = processed_expr.op();
+        let children = processed_expr.children();
+        
+        let result = match op {
+            _ if processed_expr == *to_replace => replacement.clone(),
+            DagOp::Add => Expr::new_add(cache[&children[0]].clone(), cache[&children[1]].clone()),
+            DagOp::Sub => Expr::new_sub(cache[&children[0]].clone(), cache[&children[1]].clone()),
+            DagOp::Mul => Expr::new_mul(cache[&children[0]].clone(), cache[&children[1]].clone()),
+            DagOp::Div => Expr::new_div(cache[&children[0]].clone(), cache[&children[1]].clone()),
+            DagOp::Power => Expr::new_pow(cache[&children[0]].clone(), cache[&children[1]].clone()),
+            DagOp::Sin => Expr::new_sin(cache[&children[0]].clone()),
+            _ => processed_expr.clone(),
+        };
+        cache.insert(processed_expr, result);
     }
+
+    cache.get(expr).cloned().unwrap_or_else(|| expr.clone())
 }
@@ -399,29 +404,31 @@
 pub(crate) fn contains_var(expr: &Expr, var: &str) -> bool {
 }
 
 pub(crate) fn get_u_candidates(expr: &Expr, candidates: &mut Vec<Expr>) {
-    match expr {
-        Expr::Add(a, b) | Expr::Sub(a, b) | Expr::Mul(a, b) | Expr::Div(a, b) => {
-            get_u_candidates(a, candidates);
-            get_u_candidates(b, candidates);
-        }
-        Expr::Power(b, e) => {
-            candidates.push(b.as_ref().clone());
-            get_u_candidates(b, candidates);
-            get_u_candidates(e, candidates);
-        }
-        Expr::Log(a)
-        | Expr::Exp(a)
-        | Expr::Sin(a)
-        | Expr::Cos(a)
-        | Expr::Tan(a)
-        | Expr::Sec(a)
-        | Expr::Csc(a)
-        | Expr::Cot(a)
-        | Expr::Sinh(a)
-        | Expr::Cosh(a)
-        | Expr::Tanh(a)
-        | Expr::Sqrt(a) => {
-            candidates.push(a.as_ref().clone());
-            get_u_candidates(a, candidates);
-        }
-        _ => {}
+    let mut stack = vec![expr.clone()];
+    let mut visited = std::collections::HashSet::new();
+
+    while let Some(current_expr) = stack.pop() {
+        if !visited.insert(current_expr.clone()) {
+            continue;
+        }
+
+        let op = current_expr.op();
+        let children = current_expr.children();
+
+        match op {
+            DagOp::Add | DagOp::Sub | DagOp::Mul | DagOp::Div => {
+                stack.push(children[0].clone());
+                stack.push(children[1].clone());
+            }
+            DagOp::Power => {
+                candidates.push(children[0].clone());
+                stack.push(children[0].clone());
+                stack.push(children[1].clone());
+            }
+            DagOp::Log | DagOp::Exp | DagOp::Sin | DagOp::Cos | DagOp::Tan | DagOp::Sec | DagOp::Csc | DagOp::Cot | DagOp::Sinh | DagOp::Cosh | DagOp::Tanh | DagOp::Sqrt => {
+                candidates.push(children[0].clone());
+                stack.push(children[0].clone());
+            }
+            _ => {}
+        }
     }
 }
 
 }
@@ -908,21 +915,23 @@
 pub(crate) fn contains_trig_function(expr: &Expr) -> bool {
-    match expr {
-        Expr::Sin(_) | Expr::Cos(_) | Expr::Tan(_) | Expr::Sec(_) | Expr::Csc(_) | Expr::Cot(_) => {
-            true
-        }
-        Expr::Add(a, b) | Expr::Sub(a, b) | Expr::Mul(a, b) | Expr::Div(a, b) => {
-            contains_trig_function(a) || contains_trig_function(b)
-        }
-        Expr::Power(base, exp) => contains_trig_function(base) || contains_trig_function(exp),
-        Expr::Log(arg) | Expr::Abs(arg) | Expr::Neg(arg) | Expr::Exp(arg) => {
-            contains_trig_function(arg)
-        }
-        Expr::Complex(re, im) => contains_trig_function(re) || contains_trig_function(im),
-        _ => false,
+    let mut stack = vec![expr.clone()];
+    let mut visited = std::collections::HashSet::new();
+
+    while let Some(current_expr) = stack.pop() {
+        if !visited.insert(current_expr.clone()) {
+            continue;
+        }
+
+        let op = current_expr.op();
+        let children = current_expr.children();
+
+        match op {
+            DagOp::Sin | DagOp::Cos | DagOp::Tan | DagOp::Sec | DagOp::Csc | DagOp::Cot => {
+                return true;
+            }
+            _ => {}
+        }
+
+        for child in children {
+            stack.push(child);
+        }
     }
+
+    false
 }
 
 pub(crate) fn tangent_half_angle_substitution(expr: &Expr, var: &str) -> Option<Expr> {
diff --git a/src/symbolic/simplify.rs b/src/symbolic/simplify.rs
index 214924a..5b1513a 100644
--- a/src/symbolic/simplify.rs
+++ b/src/symbolic/simplify.rs
@@ -1,5 +1,5 @@
 //! # Symbolic Expression Simplification
 //!
-//! This module provides functions for symbolic expression simplification.
+//! This module provides functions for symbolic expression simplification. 
 //! It includes a core `simplify` function that applies deterministic algebraic rules,
 //! and a `heuristic_simplify` function that uses pattern matching and rewrite rules
 //! to find simpler forms of expressions. It also contains utilities for term collection
@@ -7,6 +7,7 @@
 use crate::symbolic::calculus::substitute;
 use crate::symbolic::core::Expr;
 use num_bigint::BigInt;
+use crate::symbolic::core::DagOp;
 use num_traits::{One, ToPrimitive, Zero};
 use std::collections::{BTreeMap, HashMap};
 use std::sync::Arc;
@@ -76,89 +77,68 @@
 
 /// Applies a set of deterministic simplification rules to an expression.
 #[allow(clippy::unnecessary_to_owned)]
-pub(crate) fn apply_rules(expr: Expr) -> Expr {
-    let mut current_expr = expr;
-    loop {
-        let next_expr = match current_expr.clone() {
-            Expr::Add(a, b) => match simplify_add((*a).clone(), (*b).clone()) {
-                Ok(value) | Err(value) => value,
-            },
-            Expr::Sub(a, b) => simplify_sub(&a, &b).unwrap_or_else(|| current_expr.clone()),
-            Expr::Mul(a, b) => simplify_mul(&a, &b).unwrap_or_else(|| current_expr.clone()),
-            Expr::Div(a, b) => simplify_div(&a, &b).unwrap_or_else(|| current_expr.clone()),
-            Expr::Power(b, e) => simplify_power(&b, &e).unwrap_or_else(|| current_expr.clone()),
-            Expr::Sqrt(arg) => simplify_sqrt((*arg).clone()),
-            Expr::Neg(arg) => {
-                if let Expr::Neg(inner_arg) = arg.as_ref() {
-                    inner_arg.as_ref().clone()
-                } else if let Some(v) = as_f64(&arg) {
-                    Expr::Constant(-v)
-                } else {
-                    current_expr.clone()
-                }
-            }
-            Expr::Log(arg) => simplify_log(&arg).unwrap_or_else(|| current_expr.clone()),
-            Expr::Exp(arg) => {
-                if let Expr::Log(ref inner) = *arg {
-                    inner.as_ref().clone()
-                } else if is_zero(&arg) {
-                    Expr::BigInt(BigInt::one())
-                } else {
-                    current_expr.clone()
-                }
-            }
-            Expr::Sin(arg) => {
-                if let Expr::Pi = *arg {
-                    Expr::BigInt(BigInt::zero())
-                } else if let Expr::Neg(ref inner_arg) = *arg {
-                    Expr::new_neg(Expr::new_sin(inner_arg.clone()))
-                } else {
-                    current_expr.clone()
-                }
-            }
-            Expr::Cos(arg) => {
-                if let Expr::Pi = *arg {
-                    Expr::new_neg(Expr::BigInt(BigInt::one()))
-                } else if let Expr::Neg(ref inner_arg) = *arg {
-                    Expr::new_cos(inner_arg.clone())
-                } else {
-                    current_expr.clone()
-                }
-            }
-            Expr::Tan(arg) => {
-                if let Expr::Pi = *arg {
-                    Expr::BigInt(BigInt::zero())
-                } else if let Expr::Neg(ref inner_arg) = *arg {
-                    Expr::new_neg(Expr::new_tan(inner_arg.clone()))
-                } else {
-                    current_expr.clone()
-                }
-            }
-            Expr::Sum {
-                body,
-                var,
-                from,
-                to,
-            } => {
-                if let (Some(start), Some(end)) = (as_f64(&from), as_f64(&to)) {
-                    let mut total = Expr::Constant(0.0);
-                    let mut can_evaluate = true;
-                    for i in (start.round() as i64)..=(end.round() as i64) {
-                        let i_expr = Expr::Constant(i as f64);
-                        if let Expr::Variable(ref v) = *var {
-                            let term = substitute(&body, v, &i_expr);
-                            total = simplify(Expr::new_add(total, term));
-                        } else {
-                            can_evaluate = false;
-                            break;
-                        }
-                    }
-                    if can_evaluate {
-                        total
-                    } else {
-                        current_expr.clone()
-                    }
-                } else {
-                    current_expr.clone()
-                }
-            }
-            _ => current_expr.clone(),
+pub(crate) fn apply_rules(expr: Expr) -> Expr {
+    let mut current_expr = expr;
+    loop {
+        let op = current_expr.op();
+        let children = current_expr.children();
+
+        let next_expr = match op {
+            crate::symbolic::core::DagOp::Add => match simplify_add(children[0].clone(), children[1].clone()) {
+                Ok(value) | Err(value) => value,
+            },
+            crate::symbolic::core::DagOp::Sub => {
+                simplify_sub(&children[0], &children[1]).unwrap_or_else(|| current_expr.clone())
+            }
+            crate::symbolic::core::DagOp::Mul => {
+                simplify_mul(&children[0], &children[1]).unwrap_or_else(|| current_expr.clone())
+            }
+            crate::symbolic::core::DagOp::Div => {
+                simplify_div(&children[0], &children[1]).unwrap_or_else(|| current_expr.clone())
+            }
+            crate::symbolic::core::DagOp::Power => {
+                simplify_power(&children[0], &children[1]).unwrap_or_else(|| current_expr.clone())
+            }
+            crate::symbolic::core::DagOp::Sqrt => simplify_sqrt(children[0].clone()),
+            crate::symbolic::core::DagOp::Neg => {
+                if let Some(v) = as_f64(&children[0]) {
+                    Expr::Constant(-v)
+                } else if let crate::symbolic::core::DagOp::Neg = children[0].op() {
+                    children[0].children()[0].clone()
+                } else {
+                    current_expr.clone()
+                }
+            }
+            crate::symbolic::core::DagOp::Log => {
+                simplify_log(&children[0]).unwrap_or_else(|| current_expr.clone())
+            }
+            crate::symbolic::core::DagOp::Exp => {
+                if let crate::symbolic::core::DagOp::Log = children[0].op() {
+                    children[0].children()[0].clone()
+                } else if is_zero(&children[0]) {
+                    Expr::BigInt(BigInt::one())
+                } else {
+                    current_expr.clone()
+                }
+            }
+            crate::symbolic::core::DagOp::Sin => {
+                if let crate::symbolic::core::DagOp::Pi = children[0].op() {
+                    Expr::BigInt(BigInt::zero())
+                } else if let crate::symbolic::core::DagOp::Neg = children[0].op() {
+                    Expr::new_neg(Expr::new_sin(children[0].children()[0].clone()))
+                } else {
+                    current_expr.clone()
+                }
+            }
+            crate::symbolic::core::DagOp::Cos => {
+                if let crate::symbolic::core::DagOp::Pi = children[0].op() {
+                    Expr::new_neg(Expr::BigInt(BigInt::one()))
+                } else if let crate::symbolic::core::DagOp::Neg = children[0].op() {
+                    Expr::new_cos(children[0].children()[0].clone())
+                } else {
+                    current_expr.clone()
+                }
+            }
+            crate::symbolic::core::DagOp::Tan => {
+                if let crate::symbolic::core::DagOp::Pi = children[0].op() {
+                    Expr::BigInt(BigInt::zero())
+                } else if let crate::symbolic::core::DagOp::Neg = children[0].op() {
+                    Expr::new_neg(Expr::new_tan(children[0].children()[0].clone()))
+                } else {
+                    current_expr.clone()
+                }
+            }
+            _ => current_expr.clone(),
         };
 
         if next_expr == current_expr {
     }
 }
@@ -823,39 +805,41 @@
-pub(crate) fn collect_terms_recursive(expr: &Expr, coeff: &Expr, terms: &mut BTreeMap<Expr, Expr>) {
-    let mut stack = vec![(expr.clone(), coeff.clone())];
-
-    while let Some((current_expr, current_coeff)) = stack.pop() {
-        match &current_expr {
-            Expr::Add(a, b) => {
-                stack.push((b.as_ref().clone(), current_coeff.clone()));
-                stack.push((a.as_ref().clone(), current_coeff));
-            }
-            Expr::Sub(a, b) => {
-                stack.push((
-                    b.as_ref().clone(),
-                    fold_constants(Expr::new_neg(current_coeff.clone())),
-                ));
-                stack.push((a.as_ref().clone(), current_coeff));
-            }
-            Expr::Mul(a, b) => {
-                if as_f64(a).is_some() || !a.to_string().contains('x') {
-                    stack.push((
-                        b.as_ref().clone(),
-                        fold_constants(Expr::new_mul(current_coeff, a.as_ref().clone())),
-                    ));
-                } else if as_f64(b).is_some() || !b.to_string().contains('x') {
-                    stack.push((
-                        a.as_ref().clone(),
-                        fold_constants(Expr::new_mul(current_coeff, b.as_ref().clone())),
-                    ));
-                } else {
-                    let base = current_expr.clone();
-                    let entry = terms
-                        .entry(base)
-                        .or_insert_with(|| Expr::BigInt(BigInt::zero()));
-                    *entry = fold_constants(Expr::new_add(entry.clone(), current_coeff));
-                }
-            }
-            _ => {
-                let base = current_expr.clone();
-                let entry = terms
-                    .entry(base)
-                    .or_insert_with(|| Expr::BigInt(BigInt::zero()));
-                *entry = fold_constants(Expr::new_add(entry.clone(), current_coeff));
-            }
+pub(crate) fn collect_terms_recursive(expr: &Expr, coeff: &Expr, terms: &mut BTreeMap<Expr, Expr>) {
+    let mut stack = vec![(expr.clone(), coeff.clone())];
+    let mut visited = std::collections::HashSet::new();
+
+    while let Some((current_expr, current_coeff)) = stack.pop() {
+        if !visited.insert(current_expr.clone()) {
+            continue;
+        }
+        
+        let op = current_expr.op();
+        let children = current_expr.children();
+
+        match op {
+            crate::symbolic::core::DagOp::Add => {
+                stack.push((children[1].clone(), current_coeff.clone()));
+                stack.push((children[0].clone(), current_coeff));
+            }
+            crate::symbolic::core::DagOp::Sub => {
+                stack.push((
+                    children[1].clone(),
+                    fold_constants(Expr::new_neg(current_coeff.clone())),
+                ));
+                stack.push((children[0].clone(), current_coeff));
+            }
+            crate::symbolic::core::DagOp::Mul => {
+                let a = &children[0];
+                let b = &children[1];
+                if as_f64(a).is_some() || !a.to_string().contains('x') {
+                    stack.push((
+                        b.clone(),
+                        fold_constants(Expr::new_mul(current_coeff, a.clone())),
+                    ));
+                } else if as_f64(b).is_some() || !b.to_string().contains('x') {
+                    stack.push((
+                        a.clone(),
+                        fold_constants(Expr::new_mul(current_coeff, b.clone())),
+                    ));
+                } else {
+                    let base = current_expr.clone();
+                    let entry = terms
+                        .entry(base)
+                        .or_insert_with(|| Expr::BigInt(BigInt::zero()));
+                    *entry = fold_constants(Expr::new_add(entry.clone(), current_coeff));
+                }
+            }
+            _ => {
+                let base = current_expr.clone();
+                let entry = terms
+                    .entry(base)
+                    .or_insert_with(|| Expr::BigInt(BigInt::zero()));
+                *entry = fold_constants(Expr::new_add(entry.clone(), current_coeff));
+            }
         }
     }
 }
