#ifndef RSSN_H
#define RSSN_H

/* Generated with cbindgen:0.29.2 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#ifdef __cplusplus
namespace rssn {
#endif  // __cplusplus

/*
 Atomic mass unit (kg)
 */
#define rssn_ATOMIC_MASS_UNIT 1.660539067e-27

/*
 Avogadro's number (mol⁻¹)
 */
#define rssn_AVOGADRO_NUMBER 6.02214076e23

/*
 Bohr radius (m)
 */
#define rssn_BOHR_RADIUS 5.291772109e-11

/*
 Boltzmann constant (J/K)
 */
#define rssn_BOLTZMANN_CONSTANT 1.380649e-23

/*
 Boltzmann constant in SI units (J/K)
 */
#define rssn_BOLTZMANN_CONSTANT_SI 1.380649e-23

/*
 Coulomb constant k = 1/(4πε₀) (N·m²/C²)
 */
#define rssn_COULOMB_CONSTANT 8.987551787e9

/*
 Electron mass (kg)
 */
#define rssn_ELECTRON_MASS 9.10938356e-31

/*
 Elementary charge (C)
 */
#define rssn_ELEMENTARY_CHARGE 1.602176634e-19

/*
 Reduced unit for energy (using argon as reference)
 1 reduced energy = ε ≈ 1.65e-21 J for argon
 */
#define rssn_ENERGY_UNIT_ARGON 1.65e-21

/*
 Fine structure constant
 */
#define rssn_FINE_STRUCTURE_CONSTANT 7.297352566e-3

/*
 Gas constant R = NA × kB (J/(mol·K))
 */
#define rssn_GAS_CONSTANT 8.314462618

/*
 Gravitational constant (m³/(kg·s²))
 */
#define rssn_GRAVITATIONAL_CONSTANT 6.67430e-11

/*
 Reduced Planck's constant ħ = h/(2π) (J·s)
 */
#define rssn_HBAR 1.054571817e-34

/*
 Reduced unit for length (using argon as reference)
 1 reduced length = σ ≈ 3.4 Å for argon
 */
#define rssn_LENGTH_UNIT_ARGON 3.4e-10

/*
 Neutron mass (kg)
 */
#define rssn_NEUTRON_MASS 1.674927351e-27

/*
 Planck's constant (J·s)
 */
#define rssn_PLANCK_CONSTANT 6.62607015e-34

/*
 Proton mass (kg)
 */
#define rssn_PROTON_MASS 1.672621898e-27

/*
 Speed of light in vacuum (m/s)
 */
#define rssn_SPEED_OF_LIGHT 299792458.0

/*
 Standard Earth gravity (m/s²)
 */
#define rssn_STANDARD_GRAVITY 9.80665

/*
 Stefan-Boltzmann constant (W/(m²·K⁴))
 */
#define rssn_STEFAN_BOLTZMANN 5.670374419e-8

/*
 Reduced unit for temperature (using argon as reference)
 1 reduced temperature = `ε/k_B` ≈ 120 K for argon
 */
#define rssn_TEMPERATURE_UNIT_ARGON 119.8

/*
 Vacuum permeability μ₀ (H/m)
 */
#define rssn_VACUUM_PERMEABILITY 1.256637061e-6

/*
 Vacuum permittivity ε₀ (F/m)
 */
#define rssn_VACUUM_PERMITTIVITY 8.854187817e-12

/*
 Represents the result of a convergence test.
 */
typedef enum rssn_ConvergenceResult {
    /*
     The series is determined to converge.
     */
    RssnConvergenceResultConverges,
    /*
     The series is determined to diverge.
     */
    RssnConvergenceResultDiverges,
    /*
     The convergence could not be determined with the available tests.
     */
    RssnConvergenceResultInconclusive,
} rssn_ConvergenceResult;

/*
 Defines the monomial ordering to be used in polynomial division.
 */
typedef enum rssn_MonomialOrder {
    /*
     Dictionary order: compares exponents of variables in a fixed sequence.
     */
    RssnMonomialOrderLexicographical,
    /*
     Compares total degree first, then uses lexicographical order to break ties.
     */
    RssnMonomialOrderGradedLexicographical,
    /*
     Compares total degree first, then uses reverse lexicographical order to break ties.
     */
    RssnMonomialOrderGradedReverseLexicographical,
} rssn_MonomialOrder;

/*
 Supported coordinate systems for symbolic transformations.
 */
typedef enum rssn_CoordinateSystem {
    /*
     Standard 3D Cartesian coordinates (x, y, z).
     */
    RssnCoordinateSystemCartesian,
    /*
     Cylindrical coordinates (r, theta, z).
     */
    RssnCoordinateSystemCylindrical,
    /*
     Spherical coordinates (rho, theta, phi).
     */
    RssnCoordinateSystemSpherical,
} rssn_CoordinateSystem;

typedef struct rssn_Arc_FiniteField rssn_Arc_FiniteField;

/*
 Represents a Banach space, a complete normed vector space.

 This implementation specifically models L^p([a, b]), the space of functions for which
 the p-th power of their absolute value is Lebesgue integrable.
 */
typedef struct rssn_BanachSpace rssn_BanachSpace;

/*
 Represents a Bézier curve defined by a set of control points.

 A Bézier curve of degree `n` is defined by `n + 1` control points. The curve
 starts at the first control point and ends at the last control point,
 passing smoothly between them based on the Bernstein polynomial basis.
 */
typedef struct rssn_BezierCurve rssn_BezierCurve;

/*
 Represents a quantum state using Dirac notation (Bra).

 Symbolically, a bra is represented as `<state|`.
 */
typedef struct rssn_Bra rssn_Bra;

/*
 Represents the full Cylindrical Algebraic Decomposition of R^n.
 */
typedef struct rssn_Cad rssn_Cad;

/*
 RGBA color with values in [0, 1].
 */
typedef struct rssn_Color rssn_Color;

/*
 Represents a complex dynamical system defined by z_{n+1} = `f(z_n)` + c.
 */
typedef struct rssn_ComplexDynamicalSystem rssn_ComplexDynamicalSystem;

/*
 A thread-safe cache for computation results.

 This cache stores the mapping from expressions to their computed values.
 It avoids re-computing the value of the same expression multiple times.
 */
typedef struct rssn_ComputationResultCache rssn_ComputationResultCache;

/*
 Represents a crystal lattice with basis vectors.
 */
typedef struct rssn_CrystalLattice rssn_CrystalLattice;

/*
 Opaque type for cubic spline closure.
 */
typedef struct rssn_CubicSplineHandle rssn_CubicSplineHandle;

/*
 Represents a point on an elliptic curve, including the point at infinity.
 */
typedef struct rssn_CurvePoint rssn_CurvePoint;

/*
 Represents a differential k-form.

 A k-form is a mathematical object that can be integrated over a k-dimensional manifold.
 It is a sum of terms, where each term is a scalar function (coefficient) multiplied by
 a wedge product of k basis 1-forms (like dx, dy, etc.).

 For example, a 2-form in R^3 could be `f(x,y,z) dx^dy + g(x,y,z) dx^dz`.

 Here, the basis wedge products (e.g., `dx^dy`) are represented by a bitmask (`blade`).
 If `vars = ["x", "y", "z"]`, then `dx` is `1<<0`, `dy` is `1<<1`, `dz` is `1<<2`.
 The wedge product `dx^dy` corresponds to the bitmask `(1<<0) | (1<<1) = 3`.
 */
typedef struct rssn_DifferentialForm rssn_DifferentialForm;

/*
 ECDH key pair containing private and public keys.
 */
typedef struct rssn_EcdhKeyPair rssn_EcdhKeyPair;

/*
 ECDSA signature containing r and s components.
 */
typedef struct rssn_EcdsaSignature rssn_EcdsaSignature;

/*
 Represents an elliptic curve over a prime field: y^2 = x^3 + ax + b.
 */
typedef struct rssn_EllipticCurve rssn_EllipticCurve;

/*
 The central enum representing a mathematical expression in the symbolic system.

 `Expr` is an Abstract Syntax Tree (AST) that can represent a wide variety of
 mathematical objects and operations. Manual implementations for `Debug`, `Clone`,
 `PartialEq`, `Eq`, and `Hash` are provided to handle variants containing types
 that do not derive these traits automatically (e.g., `f64`, `Arc<dyn Distribution>`).
 */
typedef struct rssn_Expr rssn_Expr;

/*
 A C-compatible wrapper for a `Vec<Expr>`, used for returning lists of expressions via FFI.
 */
typedef struct rssn_ExprList rssn_ExprList;

/*
 FFI-compatible optimization result containing the solution and convergence information.

 This structure holds the outcome of a numerical optimization procedure and is designed
 to be safely passed across FFI boundaries.
 */
typedef struct rssn_FfiOptimizationResult rssn_FfiOptimizationResult;

/*
 Represents a univariate polynomial with coefficients from a prime finite field.
 */
typedef struct rssn_FiniteFieldPolynomial rssn_FiniteFieldPolynomial;

/*
 Represents a Fredholm integral equation of the second kind.

 The equation has the form: `y(x) = f(x) + lambda * integral_a_b(K(x, t) * y(t) dt)`,
 where `y(x)` is the unknown function to be solved for.
 */
typedef struct rssn_FredholmEquation rssn_FredholmEquation;

/*
 Represents a graph with weighted edges for numerical algorithms.
 The graph is represented by an adjacency list.
 */
typedef struct rssn_Graph rssn_Graph;

/*
 Represents a group with its multiplication table.
 */
typedef struct rssn_Group rssn_Group;

/*
 Represents a Hilbert space, a complete inner product space.
 This implementation specifically models L^2([a, b]), the space of square-integrable
 complex-valued functions on an interval [a, b].
 */
typedef struct rssn_HilbertSpace rssn_HilbertSpace;

/*
 Represents an Iterated Function System (IFS).

 An IFS is a finite set of contraction mappings on a complete metric space.
 It is often used to construct fractals (e.g., Sierpinski triangle, Barnsley fern).
 */
typedef struct rssn_IteratedFunctionSystem rssn_IteratedFunctionSystem;

/*
 The JIT Engine for compiling and executing code.
 */
typedef struct rssn_JitEngine rssn_JitEngine;

/*
 Represents a quantum state using Dirac notation (Ket).

 Symbolically, a ket is represented as `|state>`.
 */
typedef struct rssn_Ket rssn_Ket;

/*
 Represents a Lie algebra, defined by its name and basis elements.
 */
typedef struct rssn_LieAlgebra rssn_LieAlgebra;

/*
 Represents common linear operators that act on functions in a vector space.
 */
typedef struct rssn_LinearOperator rssn_LinearOperator;

/*
 Represents the solution to a system of linear equations.
 */
typedef struct rssn_LinearSolution rssn_LinearSolution;

/*
 A generic dense matrix over any type that implements the Field trait.
 */
typedef struct rssn_Matrix_f64 rssn_Matrix_f64;

/*
 Represents a 1D simulation domain, composed of a series of cells.
 */
typedef struct rssn_Mesh rssn_Mesh;

/*
 Represents a numerical Möbius transformation: f(z) = (az + b) / (cz + d)
 */
typedef struct rssn_MobiusTransformation rssn_MobiusTransformation;

/*
 Represents a multivector in a Clifford algebra.

 The basis blades are represented by a bitmask. E.g., in 3D:
 001 (1) -> e1, 010 (2) -> e2, 100 (4) -> e3
 011 (3) -> e12, 101 (5) -> e13, 110 (6) -> e23
 111 (7) -> e123 (pseudoscalar)
 */
typedef struct rssn_Multivector rssn_Multivector;

/*
 Represents a multivector in 3D Geometric Algebra (`G_3`).
 Components are: 1 (scalar), e1, e2, e3 (vectors), e12, e23, e31 (bivectors), e123 (pseudoscalar)
 */
typedef struct rssn_Multivector3D rssn_Multivector3D;

/*
 Represents a quantum operator.

 Symbolically, an operator `A` acts on a state `|ψ>` as `A|ψ>`.
 */
typedef struct rssn_Operator rssn_Operator;

/*
 Represents a parameterized curve C given by r(t).
 */
typedef struct rssn_ParametricCurve rssn_ParametricCurve;

/*
 Represents a parameterized surface S given by r(u, v).
 */
typedef struct rssn_ParametricSurface rssn_ParametricSurface;

/*
 A thread-safe cache for parsed expressions.

 This cache stores the mapping from input strings to parsed `Expr` objects.
 It avoids re-parsing the same string multiple times.
 */
typedef struct rssn_ParsingCache rssn_ParsingCache;

/*
 Represents the analytic continuation of a function along a path.
 It is stored as a chain of series expansions, each centered at a point on the path.
 */
typedef struct rssn_PathContinuation rssn_PathContinuation;

/*
 Represents a 3D object as a polygon mesh.
 A mesh is composed of a list of vertices (3D points) and a list of polygons (faces)
 that connect those vertices.
 */
typedef struct rssn_PolygonMesh rssn_PolygonMesh;

/*
 Represents a polynomial with f64 coefficients for numerical operations.
 */
typedef struct rssn_Polynomial rssn_Polynomial;

/*
 Represents an element in a prime field GF(p), where p is the modulus.

 The value is stored as a `u64`, and all arithmetic operations are performed
 modulo the specified `modulus`.
 */
typedef struct rssn_PrimeFieldElement rssn_PrimeFieldElement;

/*
 Represents a group representation.
 */
typedef struct rssn_Representation rssn_Representation;

/*
 Represents a rewrite rule, e.g., `lhs -> rhs`.
 */
typedef struct rssn_RewriteRule rssn_RewriteRule;

/*
 Opaque handle for a Matrix<f64>.
 */
typedef struct rssn_RssnMatrixHandle rssn_RssnMatrixHandle;

/*
 Opaque handle for a Matrix<f64>.
 */
typedef struct rssn_RssnMatrixHandle rssn_RssnMatrixHandle;

/*
 The SPH system.
 */
typedef struct rssn_SPHSystem rssn_SPHSystem;

/*
 Represents a k-simplex as a set of its vertex indices.
 */
typedef struct rssn_Simplex rssn_Simplex;

/*
 Represents a simplicial complex.
 */
typedef struct rssn_SimplicialComplex rssn_SimplicialComplex;

/*
 Represents a singularity type in complex analysis.
 */
typedef struct rssn_SingularityType rssn_SingularityType;

/*
 Represents the state of a computation.

 This struct holds intermediate values and other context information
 required during a computation.
 */
typedef struct rssn_State rssn_State;

/*
 Represents a k-chain as a formal linear combination of k-simplices (symbolic version).
 */
typedef struct rssn_SymbolicChain rssn_SymbolicChain;

/*
 Represents a symbolic tensor of arbitrary rank.
 */
typedef struct rssn_Tensor rssn_Tensor;

typedef struct rssn_Vec_CriticalPoint rssn_Vec_CriticalPoint;

typedef struct rssn_Vec_Expr rssn_Vec_Expr;

typedef struct rssn_Vec_FiniteFieldPolynomial rssn_Vec_FiniteFieldPolynomial;

typedef struct rssn_Vec_HashMap_Expr__Expr rssn_Vec_HashMap_Expr__Expr;

typedef struct rssn_Vec_RewriteRule rssn_Vec_RewriteRule;

typedef struct rssn_Vec_SparsePolynomial rssn_Vec_SparsePolynomial;

typedef struct rssn_Vec_String rssn_Vec_String;

typedef struct rssn_Vec_Vec_usize rssn_Vec_Vec_usize;

typedef struct rssn_Vec_f64 rssn_Vec_f64;

/*
 Represents a symbolic vector in 3D space.
 */
typedef struct rssn_Vector rssn_Vector;

/*
 Represents a Volterra integral equation of the second kind.

 The equation has the form: `y(x) = f(x) + lambda * integral_a_x(K(x, t) * y(t) dt)`.
 It is similar to the Fredholm equation, but the upper limit of integration is the variable `x`.
 */
typedef struct rssn_VolterraEquation rssn_VolterraEquation;

/*
 Represents a volume V for triple integration.
 Defines the integration order as dz dy dx.
 */
typedef struct rssn_Volume rssn_Volume;

/*
 A buffer containing binary data from bincode serialization.

 The caller is responsible for freeing this buffer using `rssn_free_bincode_buffer`.
 */
typedef struct rssn_BincodeBuffer {
    /*
     Pointer to the binary data.
     */
    uint8_t *mData;
    /*
     Length of the binary data in bytes.
     */
    size_t mLen;
} rssn_BincodeBuffer;

/*
 Opaque type for Graph<String> to work with cbindgen
 */
typedef struct rssn_RssnGraph {
    uint8_t mPrivate[0];
} rssn_RssnGraph;

/*
 A point in 2D space for FFI communication.
 */
typedef struct rssn_FfiPoint {
    double mX;
    double mY;
} rssn_FfiPoint;

/*
 Structure to hold two expressions (e.g., transformed x and t).
 */
typedef struct rssn_ExprPair {
    /*
     The first expression in the pair.
     */
    struct rssn_Expr *mFirst;
    /*
     The second expression in the pair.
     */
    struct rssn_Expr *mSecond;
} rssn_ExprPair;

/*
 Result handle for the Ising model simulation containing spin grid and magnetization.

 This C-compatible struct encapsulates the output of an Ising model Monte Carlo
 simulation, providing both the final spin configuration and the computed magnetization.
 */
typedef struct rssn_IsingResultHandle {
    /*
     Pointer to a Matrix containing the final spin configuration as f64 values (±1.0).
     */
    struct rssn_Matrix_f64 *mGrid;
    /*
     Average magnetization M = ⟨∑ᵢsᵢ⟩/N, ranging from -1 (all spins down) to +1 (all spins up).
     */
    double mMagnetization;
} rssn_IsingResultHandle;

/*
 Result handles for the Navier-Stokes simulation containing velocity and pressure fields.

 This C-compatible struct encapsulates the output of an incompressible Navier-Stokes
 solver, providing matrix handles to the computed velocity components and pressure.
 */
typedef struct rssn_NavierStokesResultHandles {
    /*
     Pointer to a Matrix containing the horizontal velocity field u(x,y) in m/s.
     */
    struct rssn_Matrix_f64 *mU;
    /*
     Pointer to a Matrix containing the vertical velocity field v(x,y) in m/s.
     */
    struct rssn_Matrix_f64 *mV;
    /*
     Pointer to a Matrix containing the pressure field p(x,y) in Pa.
     */
    struct rssn_Matrix_f64 *mP;
} rssn_NavierStokesResultHandles;











#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/*
 Calculates the residue of a function at a given singularity.

 Takes a raw pointer to an `Expr` (the function), a C-style string for the variable,
 and a raw pointer to an `Expr` for the singularity.
 Returns a raw pointer to an `Expr` representing the residue.
 */
rssn_
struct rssn_Expr *calculate_residue(const struct rssn_Expr *aFunc,
                                    const char *aVar,
                                    const struct rssn_Expr *aSingularity)
;

/*
 Calculates the residue of a function at a given singularity.

 Takes a bincode-serialized `Expr` (the function), a C-style string for the variable,
 and a bincode-serialized `Expr` for the singularity.
 Returns a bincode-serialized `Expr` representing the residue.
 */
rssn_
struct rssn_BincodeBuffer calculate_residue_bincode(struct rssn_BincodeBuffer aFuncBincode,
                                                    const char *aVar,
                                                    struct rssn_BincodeBuffer aSingularityBincode)
;

/*
 Calculates the residue of a function at a given singularity.

 Takes a JSON-serialized `Expr` (the function), a C-style string for the variable,
 and a JSON-serialized `Expr` for the singularity.
 Returns a JSON-serialized `Expr` representing the residue.
 */
rssn_
char *calculate_residue_json(const char *aFuncJson,
                             const char *aVar,
                             const char *aSingularityJson)
;

/*
 Applies Cauchy's derivative formula.

 Takes a raw pointer to an `Expr` (the function), a C-style string for the variable,
 a raw pointer to an `Expr` for the point `z0`, and an integer `n` for the order of the derivative.
 Returns a raw pointer to an `Expr` representing the nth derivative of the function at `z0`.
 */
rssn_
struct rssn_Expr *cauchy_derivative_formula(const struct rssn_Expr *aFunc,
                                            const char *aVar,
                                            const struct rssn_Expr *aZ0,
                                            size_t aN)
;

/*
 Applies Cauchy's derivative formula.

 Takes a bincode-serialized `Expr` (the function), a C-style string for the variable,
 a bincode-serialized `Expr` for the point `z0`, and an integer `n` for the order of the derivative.
 Returns a bincode-serialized `Expr` representing the nth derivative of the function at `z0`.
 */
rssn_
struct rssn_BincodeBuffer cauchy_derivative_formula_bincode(struct rssn_BincodeBuffer aFuncBincode,
                                                            const char *aVar,
                                                            struct rssn_BincodeBuffer aZ0Bincode,
                                                            size_t aN)
;

/*
 Applies Cauchy's Derivative Formula to compute the nth derivative of a function at a given point.

 Takes a JSON-serialized `Expr` (the function), a C-style string for the variable,
 a JSON-serialized `Expr` for the point `z0`, and an integer `n` for the order of the derivative.
 Returns a JSON-serialized `Expr` representing the nth derivative.
 */
rssn_
char *cauchy_derivative_formula_json(const char *aFuncJson,
                                     const char *aVar,
                                     const char *aZ0Json,
                                     size_t aN)
;

/*
 Applies Cauchy's integral formula.

 Takes a raw pointer to an `Expr` (the function), a C-style string for the variable,
 and a raw pointer to an `Expr` for the point `z0`.
 Returns a raw pointer to an `Expr` representing the value of the function at `z0`.
 */
rssn_
struct rssn_Expr *cauchy_integral_formula(const struct rssn_Expr *aFunc,
                                          const char *aVar,
                                          const struct rssn_Expr *aZ0)
;

/*
 Applies Cauchy's integral formula.

 Takes a bincode-serialized `Expr` (the function), a C-style string for the variable,
 and a bincode-serialized `Expr` for the point `z0`.
 Returns a bincode-serialized `Expr` representing the value of the function at `z0`.
 */
rssn_
struct rssn_BincodeBuffer cauchy_integral_formula_bincode(struct rssn_BincodeBuffer aFuncBincode,
                                                          const char *aVar,
                                                          struct rssn_BincodeBuffer aZ0Bincode)
;

/*
 Applies Cauchy's Integral Formula to a function at a given point.

 Takes a JSON-serialized `Expr` (the function), a C-style string for the variable,
 and a JSON-serialized `Expr` for the point `z0`.
 Returns a JSON-serialized `Expr` representing the result of the integral.
 */
rssn_
char *cauchy_integral_formula_json(const char *aFuncJson,
                                   const char *aVar,
                                   const char *aZ0Json)
;

/*
 Classifies the singularity of a function at a given point.

 Takes a raw pointer to an `Expr` (the function), a C-style string for the variable,
 a raw pointer to an `Expr` for the singularity point, and an integer for the order.
 Returns a raw pointer to a `SingularityType` enum.
 */
rssn_
struct rssn_SingularityType *classify_singularity(const struct rssn_Expr *aFunc,
                                                  const char *aVar,
                                                  const struct rssn_Expr *aSingularity,
                                                  size_t aOrder)
;

/*
 Classifies the singularity of a function at a given point.

 Takes a bincode-serialized `Expr` (the function), a C-style string for the variable,
 a bincode-serialized `Expr` for the singularity point, and an integer for the order.
 Returns a bincode-serialized `SingularityType` enum.
 */
rssn_
struct rssn_BincodeBuffer classify_singularity_bincode(struct rssn_BincodeBuffer aFuncBincode,
                                                       const char *aVar,
                                                       struct rssn_BincodeBuffer aSingularityBincode,
                                                       size_t aOrder)
;

/*
 Classifies the singularity of a function at a given point.

 Takes a JSON-serialized `Expr` (the function), a C-style string for the variable,
 a JSON-serialized `Expr` for the singularity point, and an integer for the order.
 Returns a JSON-serialized `SingularityType` enum.
 */
rssn_
char *classify_singularity_json(const char *aFuncJson,
                                const char *aVar,
                                const char *aSingularityJson,
                                size_t aOrder)
;

/*
 Computes the argument of a complex number `arg(z)`.

 Takes a raw pointer to an `Expr` representing `z`.
 Returns a raw pointer to an `Expr` representing `arg(z)`.
 */
rssn_
struct rssn_Expr *complex_arg(const struct rssn_Expr *aZ)
;

/*
 Computes the argument of a complex number `arg(z)`.

 Takes a bincode-serialized `Expr` representing `z`.
 Returns a bincode-serialized `Expr` representing `arg(z)`.
 */
rssn_
struct rssn_BincodeBuffer complex_arg_bincode(struct rssn_BincodeBuffer aZBincode)
;

/*
 Computes the argument (phase angle) of a given complex number.

 Takes a JSON-serialized `Expr` representing the complex number `z`.
 Returns a JSON-serialized `Expr` representing the argument of `z`.
 */
rssn_
char *complex_arg_json(const char *aZJson)
;

/*
 Calculates the distance between two complex numbers.

 Takes two raw pointers to `Expr` representing the complex numbers.
 Returns an `f64` representing the distance.
 */
rssn_
double complex_distance(const struct rssn_Expr *aP1,
                        const struct rssn_Expr *aP2)
;

/*
 Calculates the distance between two complex numbers.

 Takes two bincode-serialized `Expr` representing the complex numbers.
 Returns an `f64` representing the distance.
 */
rssn_
double complex_distance_bincode(struct rssn_BincodeBuffer aP1Bincode,
                                struct rssn_BincodeBuffer aP2Bincode)
;

/*
 Calculates the distance between two complex numbers.

 Takes two JSON-serialized `Expr` representing the complex numbers.
 Returns an `f64` representing the distance.
 */
rssn_
double complex_distance_json(const char *aP1Json,
                             const char *aP2Json)
;

/*
 Computes the complex exponential `e^z`.

 Takes a raw pointer to an `Expr` representing `z`.
 Returns a raw pointer to an `Expr` representing `e^z`.
 */
rssn_
struct rssn_Expr *complex_exp(const struct rssn_Expr *aZ)
;

/*
 Computes the complex exponential `e^z`.

 Takes a bincode-serialized `Expr` representing `z`.
 Returns a bincode-serialized `Expr` representing `e^z`.
 */
rssn_
struct rssn_BincodeBuffer complex_exp_bincode(struct rssn_BincodeBuffer aZBincode)
;

/*
 Computes the complex exponential of a given complex number.

 Takes a JSON-serialized `Expr` representing the complex number `z`.
 Returns a JSON-serialized `Expr` representing `e^z`.
 */
rssn_
char *complex_exp_json(const char *aZJson)
;

/*
 Computes the complex logarithm `log(z)`.

 Takes a raw pointer to an `Expr` representing `z`.
 Returns a raw pointer to an `Expr` representing `log(z)`.
 */
rssn_
struct rssn_Expr *complex_log(const struct rssn_Expr *aZ)
;

/*
 Computes the complex logarithm `log(z)`.

 Takes a bincode-serialized `Expr` representing `z`.
 Returns a bincode-serialized `Expr` representing `log(z)`.
 */
rssn_
struct rssn_BincodeBuffer complex_log_bincode(struct rssn_BincodeBuffer aZBincode)
;

/*
 Computes the complex natural logarithm of a given complex number.

 Takes a JSON-serialized `Expr` representing the complex number `z`.
 Returns a JSON-serialized `Expr` representing `ln(z)`.
 */
rssn_
char *complex_log_json(const char *aZJson)
;

/*
 Computes the modulus of a complex number `|z|`.

 Takes a raw pointer to an `Expr` representing `z`.
 Returns a raw pointer to an `Expr` representing `|z|`.
 */
rssn_
struct rssn_Expr *complex_modulus(const struct rssn_Expr *aZ)
;

/*
 Computes the modulus \(|z|\) of a complex number encoded as an `Expr` and returns it via bincode.

 # Arguments

 * `z_bincode` - Bincode buffer encoding an `Expr` representing the complex number `z`.

 # Returns

 A bincode buffer encoding an `Expr` for the modulus \(|z|\).

 # Safety

 This function is unsafe because it dereferences a bincode buffer that must contain
 a valid serialized `Expr`.
 */
rssn_
struct rssn_BincodeBuffer complex_modulus_bincode(struct rssn_BincodeBuffer aZBincode)
;

/*
 Computes the modulus (magnitude) of a given complex number.

 Takes a JSON-serialized `Expr` representing the complex number `z`.
 Returns a JSON-serialized `Expr` representing the modulus of `z`.
 */
rssn_
char *complex_modulus_json(const char *aZJson)
;

/*
 Calculates a contour integral using the residue theorem.

 Takes a raw pointer to an `Expr` (the function), a C-style string for the variable,
 a raw pointer to an array of `Expr` for the singularities, and the length of the array.
 Returns a raw pointer to an `Expr` representing the result of the integral.
 */
rssn_
struct rssn_Expr *contour_integral_residue_theorem(const struct rssn_Expr *aFunc,
                                                   const char *aVar,
                                                   const struct rssn_Expr *const *aSingularities,
                                                   size_t aSingularitiesLen)
;

/*
 Calculates a contour integral using the residue theorem.

 Takes a bincode-serialized `Expr` (the function), a C-style string for the variable,
 and a bincode-serialized `Vec<Expr>` for the singularities.
 Returns a bincode-serialized `Expr` representing the result of the integral.
 */
rssn_
struct rssn_BincodeBuffer contour_integral_residue_theorem_bincode(struct rssn_BincodeBuffer aFuncBincode,
                                                                   const char *aVar,
                                                                   struct rssn_BincodeBuffer aSingularitiesBincode)
;

/*
 Calculates a contour integral using the residue theorem.

 Takes a JSON-serialized `Expr` (the function), a C-style string for the variable,
 and a JSON-serialized `Vec<Expr>` for the singularities.
 Returns a JSON string representing the `Expr` of the integral.
 */
rssn_
char *contour_integral_residue_theorem_json(const char *aFuncJson,
                                            const char *aVar,
                                            const char *aSingularitiesJson)
;

/*
 Estimates the radius of convergence of a series.

 Takes a raw pointer to an `Expr` (the series), a C-style string for the variable,
 a raw pointer to an `Expr` for the center, and an integer for the order.
 Returns an `f64` representing the estimated radius of convergence.
 */
rssn_
double estimate_radius_of_convergence(const struct rssn_Expr *aSeriesExpr,
                                      const char *aVar,
                                      const struct rssn_Expr *aCenter,
                                      size_t aOrder)
;

/*
 Estimates the radius of convergence of a series.

 Takes a bincode-serialized `Expr` (the series), a C-style string for the variable,
 a bincode-serialized `Expr` for the center, and an integer for the order.
 Returns an `f64` representing the estimated radius of convergence.
 */
rssn_
double estimate_radius_of_convergence_bincode(struct rssn_BincodeBuffer aSeriesExprBincode,
                                              const char *aVar,
                                              struct rssn_BincodeBuffer aCenterBincode,
                                              size_t aOrder)
;

/*
 Estimates the radius of convergence of a series.

 Takes a JSON-serialized `Expr` (the series), a C-style string for the variable,
 a JSON-serialized `Expr` for the center, and an integer for the order.
 Returns an `f64` representing the estimated radius of convergence.
 */
rssn_
double estimate_radius_of_convergence_json(const char *aSeriesExprJson,
                                           const char *aVar,
                                           const char *aCenterJson,
                                           size_t aOrder)
;

/*
 Computes the definite integral of an `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_definite_integrate(struct rssn_Expr *aHandle,
                                          const char *aVarPtr,
                                          struct rssn_Expr *aLowerHandle,
                                          struct rssn_Expr *aUpperHandle)
;

/*
 Differentiates an `Expr` and returns a handle to the new, derivative expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_differentiate(struct rssn_Expr *aHandle,
                                     const char *aVarPtr)
;

/*
 Computes the indefinite integral of an `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_integrate(struct rssn_Expr *aHandle,
                                 const char *aVarPtr)
;

/*
 Computes the limit of an `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_limit(struct rssn_Expr *aHandle,
                             const char *aVarPtr,
                             struct rssn_Expr *aToHandle)
;

/*
 Simplifies an `Expr` and returns a handle to the new, simplified expression.

 The caller is responsible for freeing the returned handle using `expr_free`.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_simplify(struct rssn_Expr *aHandle)
;

/*
 Solves an equation for a given variable and returns the solutions as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *expr_solve(struct rssn_Expr *aHandle,
                 const char *aVarPtr)
;

/*
 Substitutes a variable in an `Expr` with another `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_substitute(struct rssn_Expr *aHandle,
                                  const char *aVarPtr,
                                  struct rssn_Expr *aReplacementHandle)
;

/*
 Converts an expression to a LaTeX string.

 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_
DEPRECATED_WITH_NOTE
char *expr_to_latex(struct rssn_Expr *aHandle)
;

/*
 Converts an expression to a formatted, pretty-printed string.

 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_
DEPRECATED_WITH_NOTE
char *expr_to_pretty_string(struct rssn_Expr *aHandle)
;

/*
 Returns the string representation of an `Expr` handle.

 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_
DEPRECATED_WITH_NOTE
char *expr_to_string(struct rssn_Expr *aHandle)
;

/*
 Attempts to unify the units within an expression.

 Returns a JSON string representing a `FfiResult` which contains either the
 new `Expr` object in the `ok` field or an error message in the `err` field.
 The caller can then use `expr_from_json` to get a handle to the new expression.
 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_
DEPRECATED_WITH_NOTE
char *expr_unify_expression(struct rssn_Expr *aHandle)
;

/*
 Frees a C string that was allocated by this library.
 */
rssn_
void free_string(char *aS)
;

/*
 Evaluates a point on a Bézier curve and returns the coordinates as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *interpolate_bezier_curve(const char *aJsonPtr)
;

/*
 Computes a Lagrange interpolating polynomial and returns its coefficients as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *interpolate_lagrange(const char *aJsonPtr)
;

/*
 Computes the Laurent series of a function.

 Takes a raw pointer to an `Expr` (the function), a C-style string for the variable,
 a raw pointer to an `Expr` for the center, and an integer for the order.
 Returns a raw pointer to an `Expr` representing the Laurent series.
 */
rssn_
struct rssn_Expr *laurent_series(const struct rssn_Expr *aFunc,
                                 const char *aVar,
                                 const struct rssn_Expr *aCenter,
                                 size_t aOrder)
;

/*
 Computes the Laurent series of a function.

 Takes a bincode-serialized `Expr` (the function), a C-style string for the variable,
 a bincode-serialized `Expr` for the center, and an integer for the order.
 Returns a bincode-serialized `Expr` representing the Laurent series.
 */
rssn_
struct rssn_BincodeBuffer laurent_series_bincode(struct rssn_BincodeBuffer aFuncBincode,
                                                 const char *aVar,
                                                 struct rssn_BincodeBuffer aCenterBincode,
                                                 size_t aOrder)
;

/*
 Computes the Laurent series of a function.

 Takes a JSON-serialized `Expr` (the function), a C-style string for the variable,
 a JSON-serialized `Expr` for the center, and an integer for the order.
 Returns a JSON-serialized `Expr` representing the Laurent series.
 */
rssn_
char *laurent_series_json(const char *aFuncJson,
                          const char *aVar,
                          const char *aCenterJson,
                          size_t aOrder)
;

/*
 Adds two matrices and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_add(struct rssn_Expr *aH1,
                             struct rssn_Expr *aH2)
;

/*
 Computes the characteristic polynomial of a matrix and returns the result as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_characteristic_polynomial(struct rssn_Expr *aHandle,
                                       const char *aVarPtr)
;

/*
 Computes the determinant of a matrix and returns a handle to the resulting expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_determinant(struct rssn_Expr *aHandle)
;

/*
 Computes the eigenvalue decomposition of a matrix and returns the eigenvalues and eigenvectors as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_eigen_decomposition(struct rssn_Expr *aHandle)
;

/*
 Creates an identity matrix of a given size and returns a handle to it.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_identity(size_t aSize)
;

/*
 Inverts a matrix and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_inverse(struct rssn_Expr *aHandle)
;

/*
 Computes the LU decomposition of a matrix and returns the L and U matrices as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_lu_decomposition(struct rssn_Expr *aHandle)
;

/*
 Multiplies two matrices and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_mul(struct rssn_Expr *aH1,
                             struct rssn_Expr *aH2)
;

/*
 Computes the null space of a matrix and returns the result as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_null_space(struct rssn_Expr *aHandle)
;

/*
 Computes the Reduced Row Echelon Form (RREF) of a matrix and returns the result as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_rref(struct rssn_Expr *aHandle)
;

/*
 Multiplies a matrix by a scalar and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_scalar_mul(struct rssn_Expr *aScalarHandle,
                                    struct rssn_Expr *aMatrixHandle)
;

/*
 Subtracts the second matrix from the first and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_sub(struct rssn_Expr *aH1,
                             struct rssn_Expr *aH2)
;

/*
 Computes the trace of a matrix and returns the result as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_trace(struct rssn_Expr *aHandle)
;

/*
 Transposes a matrix and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_transpose(struct rssn_Expr *aHandle)
;

/*
 Applies a Mobius transformation to a complex number.

 Takes a raw pointer to a `MobiusTransformation` object and a raw pointer to an `Expr` (complex number).
 Returns a raw pointer to an `Expr` representing the result.
 */
rssn_
struct rssn_Expr *mobius_transformation_apply(const struct rssn_MobiusTransformation *aMobius,
                                              const struct rssn_Expr *aZ)
;

/*
 Applies a Mobius transformation to a complex number.

 Takes a bincode-serialized `MobiusTransformation` object and a bincode-serialized `Expr` (complex number).
 Returns a bincode-serialized `Expr` representing the result.
 */
rssn_
struct rssn_BincodeBuffer mobius_transformation_apply_bincode(struct rssn_BincodeBuffer aMobiusBincode,
                                                              struct rssn_BincodeBuffer aZBincode)
;

/*
 Applies a Mobius Transformation to a complex number.

 Takes a JSON-serialized `MobiusTransformation` object and a JSON-serialized `Expr` representing the complex number `z`.
 Returns a JSON-serialized `Expr` representing the result of the transformation.
 */
rssn_
char *mobius_transformation_apply_json(const char *aMobiusJson,
                                       const char *aZJson)
;

/*
 Composes two Mobius transformations.

 Takes two raw pointers to `MobiusTransformation` objects.
 Returns a raw pointer to a `MobiusTransformation` representing their composition.
 */
rssn_
struct rssn_MobiusTransformation *mobius_transformation_compose(const struct rssn_MobiusTransformation *aMobius1,
                                                                const struct rssn_MobiusTransformation *aMobius2)
;

/*
 Composes two Mobius transformations.

 Takes two bincode-serialized `MobiusTransformation` objects.
 Returns a bincode-serialized `MobiusTransformation` representing their composition.
 */
rssn_
struct rssn_BincodeBuffer mobius_transformation_compose_bincode(struct rssn_BincodeBuffer aMobius1Bincode,
                                                                struct rssn_BincodeBuffer aMobius2Bincode)
;

/*
 Composes two Mobius Transformations.

 Takes two JSON-serialized `MobiusTransformation` objects.
 Returns a JSON-serialized `MobiusTransformation` object representing their composition.
 */
rssn_
char *mobius_transformation_compose_json(const char *aMobius1Json,
                                         const char *aMobius2Json)
;

/*
 Creates an identity Mobius transformation.

 Takes no arguments and returns a raw pointer to a `MobiusTransformation` object.
 */
rssn_
struct rssn_MobiusTransformation *mobius_transformation_identity(void)
;

/*
 Creates an identity Mobius transformation.

 Takes no arguments and returns a bincode-serialized `MobiusTransformation` object.
 */
rssn_
struct rssn_BincodeBuffer mobius_transformation_identity_bincode(void)
;

/*
 Creates an identity `MobiusTransformation` object.

 Returns a JSON-serialized identity `MobiusTransformation` object.
 */
rssn_
char *mobius_transformation_identity_json(void)
;

/*
 Computes the inverse of a Mobius transformation.

 Takes a raw pointer to a `MobiusTransformation` object.
 Returns a raw pointer to a `MobiusTransformation` representing its inverse.
 */
rssn_
struct rssn_MobiusTransformation *mobius_transformation_inverse(const struct rssn_MobiusTransformation *aMobius)
;

/*
 Computes the inverse of a Mobius transformation.

 Takes a bincode-serialized `MobiusTransformation` object.
 Returns a bincode-serialized `MobiusTransformation` representing its inverse.
 */
rssn_
struct rssn_BincodeBuffer mobius_transformation_inverse_bincode(struct rssn_BincodeBuffer aMobiusBincode)
;

/*
 Computes the inverse of a Mobius Transformation.

 Takes a JSON-serialized `MobiusTransformation` object.
 Returns a JSON-serialized `MobiusTransformation` object representing the inverse.
 */
rssn_
char *mobius_transformation_inverse_json(const char *aMobiusJson)
;

/*
 Creates a new Mobius transformation.

 Takes four raw pointers to `Expr` representing the parameters a, b, c, and d.
 Returns a raw pointer to a new `MobiusTransformation` object.
 */
rssn_
struct rssn_MobiusTransformation *mobius_transformation_new(const struct rssn_Expr *aA,
                                                            const struct rssn_Expr *aB,
                                                            const struct rssn_Expr *aC,
                                                            const struct rssn_Expr *aD)
;

/*
 Creates a new Mobius transformation.

 Takes four bincode-serialized `Expr` representing the parameters a, b, c, and d.
 Returns a bincode-serialized `MobiusTransformation` object.
 */
rssn_
struct rssn_BincodeBuffer mobius_transformation_new_bincode(struct rssn_BincodeBuffer aABincode,
                                                            struct rssn_BincodeBuffer aBBincode,
                                                            struct rssn_BincodeBuffer aCBincode,
                                                            struct rssn_BincodeBuffer aDBincode)
;

/*
 Creates a new `MobiusTransformation` object from JSON-serialized coefficients.

 Takes JSON-serialized `Expr` for coefficients `a`, `b`, `c`, and `d`.
 Returns a JSON-serialized `MobiusTransformation` object.
 */
rssn_
char *mobius_transformation_new_json(const char *aAJson,
                                     const char *aBJson,
                                     const char *aCJson,
                                     const char *aDJson)
;

/*
 Computes the modular inverse (a^-1 mod b) using input from a JSON string.

 This function is deprecated.
 */
rssn_
DEPRECATED_WITH_NOTE
char *nt_mod_inverse(const char *aJsonPtr)
;

/*
 Computes the modular exponentiation (base^exp % modulus) using input from a JSON string.

 This function is deprecated.
 */
rssn_
DEPRECATED_WITH_NOTE
char *nt_mod_pow(const char *aJsonPtr)
;

/*
 Computes the numerical gradient of an expression.

 This function is deprecated.
 */
rssn_
DEPRECATED_WITH_NOTE
char *numerical_gradient(const char *aJsonPtr)
;

/*
 Performs numerical integration of an expression.

 This function is deprecated.
 */
rssn_
DEPRECATED_WITH_NOTE
char *numerical_integrate(const char *aJsonPtr)
;

/*
 Frees an optimization result handle previously allocated by an optimization function.

 # Arguments

 * `handle` - Pointer to an `FfiOptimizationResult` instance to deallocate

 # Safety

 The caller must ensure the handle was previously returned by one of the optimization
 functions in this module and has not already been freed. Passing a null pointer is safe
 but has no effect.
 */
rssn_
void numerical_optimize_drop_result_handle(struct rssn_FfiOptimizationResult *aHandle)
;

/*
 Frees a JSON string previously allocated by `numerical_optimize_solve_json`.

 # Arguments

 * `ptr` - Pointer to a C string to deallocate

 # Safety

 The caller must ensure the pointer was previously returned by
 `numerical_optimize_solve_json` and has not already been freed.
 Passing a null pointer is safe but has no effect.
 */
rssn_
void numerical_optimize_free_json(char *aPtr)
;

/*
 Retrieves the optimal cost from an optimization result handle.

 # Arguments

 * `handle` - Pointer to an `FfiOptimizationResult` instance

 # Returns

 The minimum cost achieved, or `NaN` if the handle is null.
 */
rssn_
double numerical_optimize_get_result_cost_handle(const struct rssn_FfiOptimizationResult *aHandle)
;

/*
 Retrieves the iteration count from an optimization result handle.

 # Arguments

 * `handle` - Pointer to an `FfiOptimizationResult` instance

 # Returns

 The number of iterations performed, or 0 if the handle is null.
 */
rssn_
uint64_t numerical_optimize_get_result_iterations_handle(const struct rssn_FfiOptimizationResult *aHandle)
;

/*
 Copies the optimal parameter vector from an optimization result handle to a buffer.

 # Arguments

 * `handle` - Pointer to an `FfiOptimizationResult` instance
 * `buffer` - Pointer to a pre-allocated buffer to receive the parameter data

 # Returns

 `true` if the copy succeeded, `false` if either pointer is null.

 # Safety

 The caller must ensure `buffer` points to an allocation with sufficient capacity
 to hold the parameter vector (obtainable via `numerical_optimize_get_result_param_len_handle`).
 */
rssn_
bool numerical_optimize_get_result_param_handle(const struct rssn_FfiOptimizationResult *aHandle,
                                                double *aBuffer)
;

/*
 Retrieves the parameter vector length from an optimization result handle.

 # Arguments

 * `handle` - Pointer to an `FfiOptimizationResult` instance

 # Returns

 The length of the optimal parameter vector, or 0 if the handle is null.
 */
rssn_
size_t numerical_optimize_get_result_param_len_handle(const struct rssn_FfiOptimizationResult *aHandle)
;

/*
 Optimizes the Rosenbrock function using BFGS quasi-Newton method via handle-based FFI.

 The BFGS (Broyden-Fletcher-Goldfarb-Shanno) algorithm is a quasi-Newton method that
 approximates the Hessian matrix for faster convergence on smooth problems.

 # Arguments

 * `a` - First parameter of the Rosenbrock function (typically 1.0)
 * `b` - Second parameter of the Rosenbrock function (typically 100.0)
 * `init_param_ptr` - Pointer to the initial parameter array
 * `init_param_len` - Length of the initial parameter array
 * `max_iters` - Maximum number of optimization iterations
 * `tolerance` - Convergence tolerance for termination

 # Returns

 A raw pointer to `FfiOptimizationResult` containing the optimization outcome,
 or null if the input is invalid or optimization fails. The caller must free
 the result using `numerical_optimize_drop_result_handle`.
 */
rssn_
struct rssn_FfiOptimizationResult *numerical_optimize_rosenbrock_bfgs_handle(double aA,
                                                                             double aB,
                                                                             const double *aInitParamPtr,
                                                                             size_t aInitParamLen,
                                                                             uint64_t aMaxIters,
                                                                             double aTolerance)
;

/*
 Optimizes the Rosenbrock function using gradient descent via handle-based FFI.

 The Rosenbrock function is a non-convex test function commonly used to evaluate
 optimization algorithms: f(x,y) = (a-x)² + b(y-x²)²

 # Arguments

 * `a` - First parameter of the Rosenbrock function (typically 1.0)
 * `b` - Second parameter of the Rosenbrock function (typically 100.0)
 * `init_param_ptr` - Pointer to the initial parameter array
 * `init_param_len` - Length of the initial parameter array
 * `max_iters` - Maximum number of optimization iterations
 * `tolerance` - Convergence tolerance for termination

 # Returns

 A raw pointer to `FfiOptimizationResult` containing the optimization outcome,
 or null if the input is invalid or optimization fails. The caller must free
 the result using `numerical_optimize_drop_result_handle`.
 */
rssn_
struct rssn_FfiOptimizationResult *numerical_optimize_rosenbrock_gd_handle(double aA,
                                                                           double aB,
                                                                           const double *aInitParamPtr,
                                                                           size_t aInitParamLen,
                                                                           uint64_t aMaxIters,
                                                                           double aTolerance)
;

/*
 Solves a numerical optimization problem using bincode serialization.

 This function performs gradient descent optimization on well-known test problems
 (Rosenbrock, Sphere) via FFI. The optimization configuration and problem parameters
 are deserialized from the input buffer.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `OptimizeRequest` with:
   - `problem_type`: Name of the optimization problem ("Rosenbrock" or "Sphere")
   - `init_param`: Initial parameter vector for optimization
   - `max_iters`: Maximum number of iterations allowed
   - `tolerance`: Convergence tolerance threshold
   - `rosenbrock_a`: Optional parameter `a` for Rosenbrock function (default: 1.0)
   - `rosenbrock_b`: Optional parameter `b` for Rosenbrock function (default: 100.0)

 # Returns

 A bincode-encoded buffer containing `OptimizeResponse` with:
 - `success`: Whether optimization succeeded
 - `best_param`: Optimal parameter vector found
 - `best_cost`: Minimum cost achieved
 - `iterations`: Number of iterations performed
 - `error`: Error message if optimization failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer numerical_optimize_solve_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Solves a numerical optimization problem using JSON serialization.

 This function performs gradient descent optimization on well-known test problems
 (Rosenbrock, Sphere) via FFI. The optimization configuration and problem parameters
 are deserialized from a JSON string.

 # Arguments

 * `json_ptr` - A null-terminated C string containing JSON with:
   - `problem_type`: Name of the optimization problem ("Rosenbrock" or "Sphere")
   - `init_param`: Initial parameter vector for optimization
   - `max_iters`: Maximum number of iterations allowed
   - `tolerance`: Convergence tolerance threshold
   - `rosenbrock_a`: Optional parameter `a` for Rosenbrock function (default: 1.0)
   - `rosenbrock_b`: Optional parameter `b` for Rosenbrock function (default: 100.0)

 # Returns

 A C string pointer containing JSON-encoded `OptimizeResponse` with:
 - `success`: Whether optimization succeeded
 - `best_param`: Optimal parameter vector found
 - `best_cost`: Minimum cost achieved
 - `iterations`: Number of iterations performed
 - `error`: Error message if optimization failed

 The caller must free the returned string using `numerical_optimize_free_json`.
 Returns null if the input pointer is invalid.
 */
rssn_
char *numerical_optimize_solve_json(const char *aJsonPtr)
;

/*
 Optimizes the sphere function using gradient descent via handle-based FFI.

 The sphere function is a convex test function: f(x) = Σx_i², commonly used
 to verify that optimization algorithms can find the global minimum at the origin.

 # Arguments

 * `init_param_ptr` - Pointer to the initial parameter array
 * `init_param_len` - Length of the initial parameter array
 * `max_iters` - Maximum number of optimization iterations
 * `tolerance` - Convergence tolerance for termination

 # Returns

 A raw pointer to `FfiOptimizationResult` containing the optimization outcome,
 or null if the input is invalid or optimization fails. The caller must free
 the result using `numerical_optimize_drop_result_handle`.
 */
rssn_
struct rssn_FfiOptimizationResult *numerical_optimize_sphere_gd_handle(const double *aInitParamPtr,
                                                                       size_t aInitParamLen,
                                                                       uint64_t aMaxIters,
                                                                       double aTolerance)
;

/*
 Continues the analytic continuation along a given path.

 Takes a raw mutable pointer to a `PathContinuation` object, a raw pointer to an array of `Expr` (path points),
 and the length of the array.
 Returns a C-style string "OK" on success, or an error message on failure.
 */
rssn_
char *path_continuation_continue_along_path(struct rssn_PathContinuation *aPc,
                                            const struct rssn_Expr *const *aPathPoints,
                                            size_t aPathPointsLen)
;

/*
 Continues the analytic continuation along a given path.

 Takes a bincode-serialized `PathContinuation` object and a bincode-serialized `Vec<Expr>` representing the path points.
 Returns a bincode-serialized string "OK" on success, or an error message on failure.
 */
rssn_
struct rssn_BincodeBuffer path_continuation_continue_along_path_bincode(struct rssn_BincodeBuffer aPcBincode,
                                                                        struct rssn_BincodeBuffer aPathPointsBincode)
;

/*
 Continues the analytic continuation along a given path.

 Takes a JSON-serialized `PathContinuation` object and a JSON-serialized `Vec<Expr>` representing the path points.
 Returns a C-style string "OK" on success, or an error message on failure.
 */
rssn_
char *path_continuation_continue_along_path_json(const char *aPcJson,
                                                 const char *aPathPointsJson)
;

/*
 Gets the final expression after analytic continuation.

 Takes a raw pointer to a `PathContinuation` object.
 Returns a raw pointer to an `Expr` representing the final expression.
 */
rssn_
struct rssn_Expr *path_continuation_get_final_expression(const struct rssn_PathContinuation *aPc)
;

/*
 Gets the final expression after analytic continuation.

 Takes a bincode-serialized `PathContinuation` object.
 Returns a bincode-serialized `Expr` representing the final expression.
 */
rssn_
struct rssn_BincodeBuffer path_continuation_get_final_expression_bincode(struct rssn_BincodeBuffer aPcBincode)
;

/*
 Gets the final expression after analytic continuation.

 Takes a JSON-serialized `PathContinuation` object.
 Returns a JSON-serialized `Expr` representing the final expression.
 */
rssn_
char *path_continuation_get_final_expression_json(const char *aPcJson)
;

/*
 Creates a new `PathContinuation` object.

 Takes a raw pointer to an `Expr` (the function), a C-style string for the variable,
 a raw pointer to an `Expr` for the start point, and a `usize` for the order.
 Returns a raw pointer to a new `PathContinuation` object.
 */
rssn_
struct rssn_PathContinuation *path_continuation_new(const struct rssn_Expr *aFunc,
                                                    const char *aVar,
                                                    const struct rssn_Expr *aStartPoint,
                                                    size_t aOrder)
;

/*
 Constructs a new analytic path continuation object from a function, variable, and start point.

 This initializes a [`PathContinuation`] for analytic continuation of a complex-valued
 function along a path in the complex plane, using a truncated series of the given order.

 # Arguments

 * `func_bincode` - Bincode buffer encoding an `Expr` for the holomorphic function.
 * `var` - C string pointer naming the complex variable of the function.
 * `start_point_bincode` - Bincode buffer encoding an `Expr` for the starting point.
 * `order` - Truncation order of the local series expansion used for continuation.

 # Returns

 A bincode buffer encoding a [`PathContinuation`] object capturing the initial state.

 # Safety

 This function is unsafe because it dereferences a raw C string pointer and expects
 valid bincode-encoded `Expr` values.
 */
rssn_
struct rssn_BincodeBuffer path_continuation_new_bincode(struct rssn_BincodeBuffer aFuncBincode,
                                                        const char *aVar,
                                                        struct rssn_BincodeBuffer aStartPointBincode,
                                                        size_t aOrder)
;

/*
 Creates a new `PathContinuation` object.

 Takes JSON-serialized inputs for the function, variable, start point, and order.
 Returns a JSON-serialized `PathContinuation` object.
 */
rssn_
char *path_continuation_new_json(const char *aFuncJson,
                                 const char *aVar,
                                 const char *aStartPointJson,
                                 size_t aOrder)
;

/*
 Solves the 1D advection-diffusion equation.

 This function is deprecated.
 */
rssn_
DEPRECATED_WITH_NOTE
char *physics_solve_advection_diffusion_1d(const char *aJsonPtr)
;

/*
 Computes the degree of a polynomial expression with respect to a given variable.

 This function is deprecated.
 */
rssn_
DEPRECATED_WITH_NOTE
int64_t poly_degree(const char *aJsonPtr)
;

/*
 Creates a polynomial expression from a vector of its coefficients.

 This function is deprecated.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *poly_from_coeffs_vec(const char *aJsonPtr)
;

/*
 Checks if an expression is a polynomial with respect to a given variable.

 This function is deprecated.
 */
rssn_
DEPRECATED_WITH_NOTE
bool poly_is_polynomial(const char *aJsonPtr)
;

/*
 Computes the leading coefficient of a polynomial expression with respect to a given variable.

 This function is deprecated.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *poly_leading_coefficient(struct rssn_Expr *aHandle,
                                           const char *aVarPtr)
;

/*
 Performs polynomial long division on two expressions with respect to a given variable.

 This function is deprecated.
 */
rssn_
DEPRECATED_WITH_NOTE
char *poly_long_division(const char *aJsonPtr)
;

/*
 Converts a polynomial expression to a vector of its coefficients.

 This function is deprecated.
 */
rssn_
DEPRECATED_WITH_NOTE
char *poly_to_coeffs_vec(const char *aJsonPtr)
;

/*
 Checks if an expression contains a variable (handle-based)
 */
rssn_
bool polynomial_contains_var_handle(const struct rssn_Expr *aExprHandle,
                                    const char *aVar)
;

/*
 Computes the degree of a polynomial (handle-based)
 */
rssn_
int64_t polynomial_degree_handle(const struct rssn_Expr *aExprHandle,
                                 const char *aVar)
;

/*
 Frees an Expr handle
 */
rssn_
void polynomial_free_expr_handle(struct rssn_Expr *aExprHandle)
;

/*
 Checks if an expression is a polynomial in the given variable (handle-based)
 */
rssn_
bool polynomial_is_polynomial_handle(const struct rssn_Expr *aExprHandle,
                                     const char *aVar)
;

/*
 Finds the leading coefficient of a polynomial (handle-based)
 */
rssn_
struct rssn_Expr *polynomial_leading_coefficient_handle(const struct rssn_Expr *aExprHandle,
                                                        const char *aVar)
;

/*
 Performs polynomial long division (handle-based)
 */
rssn_
void polynomial_long_division_handle(const struct rssn_Expr *aDividendHandle,
                                     const struct rssn_Expr *aDivisorHandle,
                                     const char *aVar,
                                     struct rssn_Expr **aQuotientOut,
                                     struct rssn_Expr **aRemainderOut)
;

/*
 Computes absolute value (magnitude) of complex number (Handle)
 */
rssn_
struct rssn_Expr *rssn_abs_handle(const struct rssn_Expr *aZ)
;

rssn_
struct rssn_Expr *rssn_adjoint_representation_algebra(const struct rssn_Expr *aX,
                                                      const struct rssn_Expr *aY)
;

rssn_
struct rssn_Expr *rssn_adjoint_representation_group(const struct rssn_Expr *aG,
                                                    const struct rssn_Expr *aX)
;

/*
 Computes the analytic continuation of a series.

 Takes a raw pointer to `Expr` (expression), a C-style string (variable),
 raw pointers to `Expr` (original center), `Expr` (new center), and a `usize` (order).
 Returns a raw pointer to a new `Expr` representing the analytic continuation.
 */
rssn_
struct rssn_Expr *rssn_analytic_continuation_handle(const struct rssn_Expr *aExpr,
                                                    const char *aVar,
                                                    const struct rssn_Expr *aOrigCenter,
                                                    const struct rssn_Expr *aNewCenter,
                                                    size_t aOrder)
;

/*
 Analyzes the convergence of a series using direct pointers.

 Takes a pointer to an `Expr` representing the series term and a C-style string
 for the variable.
 Returns a `ConvergenceResult` enum indicating the analysis outcome.
 */
rssn_
enum rssn_ConvergenceResult rssn_analyze_convergence_handle(const struct rssn_Expr *aTerm,
                                                            const char *aVar)
;

/*
 Analyzes stability of a fixed point (Handle)
 */
rssn_
struct rssn_Expr *rssn_analyze_stability(const struct rssn_Expr *aMapPtr,
                                         const char *aVar,
                                         const struct rssn_Expr *aFixedPointPtr)
;

/*
 Applies a set of rewrite rules to an expression until a normal form is reached.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `rules` is a valid array.
 */
rssn_
struct rssn_Expr *rssn_apply_rules_to_normal_form(const struct rssn_Expr *aExpr,
                                                  const struct rssn_RewriteRule *const *aRules,
                                                  size_t aRulesLen)
;

/*
 Applies rewrite rules to an expression (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_apply_rules_to_normal_form_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Applies rewrite rules to an expression (JSON).

 Input: JSON object with "expr" and "rules" fields
 Output: JSON-serialized Expr (the normal form)
 */
rssn_
char *rssn_apply_rules_to_normal_form_json(const char *aJsonStr)
;

/*
 Checks if two graphs are potentially isomorphic using WL test.
 */
rssn_
int rssn_are_isomorphic_heuristic(const struct rssn_RssnGraph *aG1,
                                  const struct rssn_RssnGraph *aG2)
;

/*
 Checks if two functions are orthogonal in a Hilbert space.

 # Arguments
 * `space` - Handle to the Hilbert space.
 * `f` - Handle to the first expression.
 * `g` - Handle to the second expression.

 # Returns
 `true` if orthogonal, `false` otherwise.
 */
rssn_
bool rssn_are_orthogonal(const struct rssn_HilbertSpace *aSpace,
                         const struct rssn_Expr *aF,
                         const struct rssn_Expr *aG)
;

/*
 Computes argument (angle) of complex number (Handle)
 */
rssn_
struct rssn_Expr *rssn_arg_handle(const struct rssn_Expr *aZ)
;

/*
 Computes the asymptotic expansion of an expression.

 Takes a raw pointer to `Expr` (expression), a C-style string (variable),
 a raw pointer to `Expr` (point), and a `usize` (order).
 Returns a raw pointer to a new `Expr` representing the asymptotic expansion.
 */
rssn_
struct rssn_Expr *rssn_asymptotic_expansion_handle(const struct rssn_Expr *aExpr,
                                                   const char *aVar,
                                                   const struct rssn_Expr *aPoint,
                                                   size_t aOrder)
;

/*
 Computes the $L^p$ norm of a function in a Banach space.

 # Arguments
 * `space` - Handle to the Banach space.
 * `f` - Handle to the expression.

 # Returns
 A raw pointer to the symbolic expression representing the norm.
 */
rssn_
struct rssn_Expr *rssn_banach_norm(const struct rssn_BanachSpace *aSpace,
                                   const struct rssn_Expr *aF)
;

/*
 Creates a new Banach space $L^p$ over a specified interval.

 # Arguments
 * `var` - The name of the independent variable.
 * `lower_bound` - Symbolic expression for the lower bound.
 * `upper_bound` - Symbolic expression for the upper bound.
 * `p` - Symbolic expression representing the $p$ parameter of the $L^p$ norm.

 # Returns
 A raw pointer to the newly created `BanachSpace`.
 */
rssn_
struct rssn_BanachSpace *rssn_banach_space_create(const char *aVar,
                                                  const struct rssn_Expr *aLowerBound,
                                                  const struct rssn_Expr *aUpperBound,
                                                  const struct rssn_Expr *aP)
;

/*
 Frees a Banach space handle.

 # Arguments
 * `ptr` - Pointer to the `BanachSpace` to free.
 */
rssn_
void rssn_banach_space_free(struct rssn_BanachSpace *aPtr)
;

/*
 Computes the \(n\)-th Bell number symbolically and returns it as an `Expr` pointer.

 Bell numbers count the total number of set partitions of an \(n\)-element set.

 # Arguments

 * `n` - Index of the Bell number to compute.

 # Returns

 A newly allocated `Expr` pointer representing the \(n\)-th Bell number.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point and returns
 ownership of a heap-allocated `Expr` to the caller.
 */
rssn_
struct rssn_Expr *rssn_bell_number(size_t aN)
;

/*
 Constructs Bessel's differential equation: x²y'' + xy' + (x² - n²)y = 0.
 */
rssn_
struct rssn_Expr *rssn_bessel_differential_equation(const struct rssn_Expr *aY,
                                                    const struct rssn_Expr *aX,
                                                    const struct rssn_Expr *aN)
;

/*
 Computes the symbolic modified Bessel function of the first kind I_n(x).
 */
rssn_
struct rssn_Expr *rssn_bessel_i(const struct rssn_Expr *aOrder,
                                const struct rssn_Expr *aArg)
;

/*
 Computes the modified Bessel function of the first kind I₀(x).
 */
rssn_
double rssn_bessel_i0(double aX)
;

/*
 Computes the modified Bessel function of the first kind I₁(x).
 */
rssn_
double rssn_bessel_i1(double aX)
;

/*
 Computes the symbolic Bessel function of the first kind J_n(x).
 */
rssn_
struct rssn_Expr *rssn_bessel_j(const struct rssn_Expr *aOrder,
                                const struct rssn_Expr *aArg)
;

/*
 Computes the Bessel function of the first kind J₀(x).
 */
rssn_
double rssn_bessel_j0(double aX)
;

/*
 Computes the Bessel function of the first kind J₁(x).
 */
rssn_
double rssn_bessel_j1(double aX)
;

/*
 Computes the symbolic modified Bessel function of the second kind K_n(x).
 */
rssn_
struct rssn_Expr *rssn_bessel_k(const struct rssn_Expr *aOrder,
                                const struct rssn_Expr *aArg)
;

/*
 Computes the modified Bessel function of the second kind K₀(x).
 */
rssn_
double rssn_bessel_k0(double aX)
;

/*
 Computes the modified Bessel function of the second kind K₁(x).
 */
rssn_
double rssn_bessel_k1(double aX)
;

/*
 Computes the symbolic Bessel function of the second kind Y_n(x).
 */
rssn_
struct rssn_Expr *rssn_bessel_y(const struct rssn_Expr *aOrder,
                                const struct rssn_Expr *aArg)
;

/*
 Computes the Bessel function of the second kind Y₀(x).
 */
rssn_
double rssn_bessel_y0(double aX)
;

/*
 Computes the Bessel function of the second kind Y₁(x).
 */
rssn_
double rssn_bessel_y1(double aX)
;

/*
 Computes the symbolic Beta function B(a, b).
 */
rssn_
struct rssn_Expr *rssn_beta(const struct rssn_Expr *aA,
                            const struct rssn_Expr *aB)
;

/*
 Computes the beta function B(a, b).
 */
rssn_
double rssn_beta_numerical(double aA,
                           double aB)
;

/*
 Computes the derivative (tangent) of a Bezier curve at parameter t.
 */
rssn_
rssn_Vector *rssn_bezier_curve_derivative(const struct rssn_BezierCurve *aCurve,
                                          const struct rssn_Expr *aT)
;

/*
 Evaluates a Bezier curve at parameter t.
 */
rssn_
rssn_Vector *rssn_bezier_curve_evaluate(const struct rssn_BezierCurve *aCurve,
                                        const struct rssn_Expr *aT)
;

/*
 Frees a Bezier curve.
 */
rssn_
void rssn_bezier_curve_free(struct rssn_BezierCurve *aCurve)
;

/*
 Creates a new Bezier curve from control points.
 */
rssn_
struct rssn_BezierCurve *rssn_bezier_curve_new(const rssn_Vector *aPoints,
                                               size_t aCount)
;

/*
 Splits a Bezier curve at parameter t into two curves.
 Returns left curve. Use rssn_bezier_curve_split_right for the right curve.
 */
rssn_
struct rssn_BezierCurve *rssn_bezier_curve_split_left(const struct rssn_BezierCurve *aCurve,
                                                      const struct rssn_Expr *aT)
;

/*
 Splits a Bezier curve at parameter t into two curves.
 Returns right curve.
 */
rssn_
struct rssn_BezierCurve *rssn_bezier_curve_split_right(const struct rssn_BezierCurve *aCurve,
                                                       const struct rssn_Expr *aT)
;

/*
 Computes absolute value (magnitude) of complex number (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_abs(struct rssn_BincodeBuffer aZBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_adjoint_representation_algebra(struct rssn_BincodeBuffer aXBuf,
                                                                      struct rssn_BincodeBuffer aYBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_adjoint_representation_group(struct rssn_BincodeBuffer aGBuf,
                                                                    struct rssn_BincodeBuffer aXBuf)
;

/*
 Computes the analytic continuation of a series.

 Takes bincode-serialized `Expr` (expression), `String` (variable),
 `Expr` (original center), `Expr` (new center), and `usize` (order).
 Returns a bincode-serialized `Expr` representing the analytic continuation.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_analytic_continuation(struct rssn_BincodeBuffer aExprBuf,
                                                             struct rssn_BincodeBuffer aVarBuf,
                                                             struct rssn_BincodeBuffer aOrigCenterBuf,
                                                             struct rssn_BincodeBuffer aNewCenterBuf,
                                                             struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Analyzes the convergence of a series using bincode-serialized inputs.

 Takes a `BincodeBuffer` containing the series term (`Expr`) and another
 `BincodeBuffer` for the variable (`String`).
 Returns a `BincodeBuffer` containing the analysis result.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_analyze_convergence(struct rssn_BincodeBuffer aTermBuf,
                                                           struct rssn_BincodeBuffer aVarBuf)
;

/*
 Analyzes stability of a fixed point (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_analyze_stability(struct rssn_BincodeBuffer aMapBuf,
                                                         const char *aVar,
                                                         struct rssn_BincodeBuffer aFixedPointBuf)
;

/*
 Checks if two graphs are isomorphic.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_are_isomorphic_heuristic(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Computes argument (angle) of complex number (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_arg(struct rssn_BincodeBuffer aZBuf)
;

/*
 Computes the asymptotic expansion of an expression.

 Takes bincode-serialized `Expr` (expression), `String` (variable),
 `Expr` (point), and `usize` (order).
 Returns a bincode-serialized `Expr` representing the asymptotic expansion.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_asymptotic_expansion(struct rssn_BincodeBuffer aExprBuf,
                                                            struct rssn_BincodeBuffer aVarBuf,
                                                            struct rssn_BincodeBuffer aPointBuf,
                                                            struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Computes the \(n\)-th Bell number symbolically and returns it via bincode.

 Bell numbers count the total number of set partitions of an \(n\)-element set.

 # Arguments

 * `n` - Index of the Bell number to compute.

 # Returns

 A bincode buffer encoding an `Expr` for the \(n\)-th Bell number.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point, but it does
 not dereference raw pointers.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_bell_number(size_t aN)
;

/*
 Computes the Bessel differential equation.

 Takes bincode-serialized `Expr` representing `y`, `x`, and `n` as inputs,
 and returns a bincode-serialized `Expr` representing the equation.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_bessel_differential_equation(struct rssn_BincodeBuffer aYBuf,
                                                                    struct rssn_BincodeBuffer aXBuf,
                                                                    struct rssn_BincodeBuffer aNBuf)
;

/*
 Computes the modified Bessel function of the first kind I_n(x).

 Takes bincode-serialized `Expr` representing `n` and `x` as inputs,
 and returns a bincode-serialized `Expr` representing I_n(x).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_bessel_i(struct rssn_BincodeBuffer aOrderBuf,
                                                struct rssn_BincodeBuffer aArgBuf)
;

/*
 Computes I₀(x) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_bessel_i0(struct rssn_BincodeBuffer aValBuf)
;

/*
 Computes I₁(x) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_bessel_i1(struct rssn_BincodeBuffer aValBuf)
;

/*
 Computes the Bessel function of the first kind J_n(x).

 Takes bincode-serialized `Expr` representing `n` and `x` as inputs,
 and returns a bincode-serialized `Expr` representing J_n(x).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_bessel_j(struct rssn_BincodeBuffer aOrderBuf,
                                                struct rssn_BincodeBuffer aArgBuf)
;

/*
 Computes J₀(x) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_bessel_j0(struct rssn_BincodeBuffer aValBuf)
;

/*
 Computes J₁(x) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_bessel_j1(struct rssn_BincodeBuffer aValBuf)
;

/*
 Computes the modified Bessel function of the second kind K_n(x).

 Takes bincode-serialized `Expr` representing `n` and `x` as inputs,
 and returns a bincode-serialized `Expr` representing K_n(x).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_bessel_k(struct rssn_BincodeBuffer aOrderBuf,
                                                struct rssn_BincodeBuffer aArgBuf)
;

/*
 Computes K₀(x) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_bessel_k0(struct rssn_BincodeBuffer aValBuf)
;

/*
 Computes K₁(x) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_bessel_k1(struct rssn_BincodeBuffer aValBuf)
;

/*
 Computes the Bessel function of the second kind Y_n(x).

 Takes bincode-serialized `Expr` representing `n` and `x` as inputs,
 and returns a bincode-serialized `Expr` representing Y_n(x).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_bessel_y(struct rssn_BincodeBuffer aOrderBuf,
                                                struct rssn_BincodeBuffer aArgBuf)
;

/*
 Computes Y₀(x) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_bessel_y0(struct rssn_BincodeBuffer aValBuf)
;

/*
 Computes Y₁(x) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_bessel_y1(struct rssn_BincodeBuffer aValBuf)
;

/*
 Computes the beta function B(a, b).

 Takes bincode-serialized `Expr` representing `a` and `b` as inputs,
 and returns a bincode-serialized `Expr` representing B(a, b).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_beta(struct rssn_BincodeBuffer aABuf,
                                            struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes B(a, b) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_beta_numerical(struct rssn_BincodeBuffer aABuf,
                                                      struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes C(n, k) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_binomial(struct rssn_BincodeBuffer aNBuf,
                                                struct rssn_BincodeBuffer aKBuf)
;

/*
 Computes the boundary of a domain (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_boundary(struct rssn_BincodeBuffer aDomainBuf)
;

/*
 Computes the inner product <Bra|Ket> using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_bra_ket(struct rssn_BincodeBuffer aBraBuf,
                                               struct rssn_BincodeBuffer aKetBuf)
;

/*
 Computes a Gröbner basis using Buchberger's algorithm and returns it via bincode serialization.

 Given a basis of multivariate polynomials and a monomial order, this runs
 Buchberger's algorithm to produce a Gröbner basis for the ideal they generate.

 # Arguments

 * `basis_buf` - `BincodeBuffer` encoding `Vec<SparsePolynomial>` for the initial basis.
 * `order_buf` - `BincodeBuffer` encoding the [`MonomialOrder`] to use.

 # Returns

 A `BincodeBuffer` encoding `Vec<SparsePolynomial>` forming a Gröbner basis, or an
 empty buffer if deserialization fails or the computation encounters an error.

 # Safety

 This function is an FFI entry point; callers must treat the returned buffer as
 opaque and only pass it to compatible APIs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_buchberger(struct rssn_BincodeBuffer aBasisBuf,
                                                  struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Computes CAD for a set of polynomials via Bincode interface.

 Input buffer should contain a serialized `CadInput`: `{"polys": [Expr, ...], "vars": ["x", "y", ...]}`.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_cad(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Calculates residue using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_calculate_residue(struct rssn_BincodeBuffer aExprBuf,
                                                         const char *aVar,
                                                         struct rssn_BincodeBuffer aPoleBuf)
;

/*
 Computes the \(n\)-th Catalan number symbolically and returns it as a bincode-encoded `Expr`.

 Catalan numbers count many combinatorial structures, such as binary trees, Dyck paths,
 and non-crossing partitions.

 # Arguments

 * `n` - Index of the Catalan number to compute.

 # Returns

 A bincode buffer encoding an `Expr` for the \(n\)-th Catalan number.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point, but it does
 not dereference raw pointers.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_catalan_number(size_t aN)
;

/*
 Computes the character of a representation using bincode serialization.

 The character is the trace of each representation matrix over the group,
 viewed as a class function on the group.

 # Arguments

 * `rep_buf` - `BincodeBuffer` encoding a [`Representation`].

 # Returns

 A `BincodeBuffer` encoding the character values (e.g., as a vector indexed by
 group elements or conjugacy classes), or an empty buffer if deserialization fails.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point; callers
 must treat the returned buffer as opaque and only pass it to compatible APIs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_character(struct rssn_BincodeBuffer aRepBuf)
;

/*
 Computes the Chebyshev differential equation.

 Takes bincode-serialized `Expr` representing `y`, `x`, and `n` as inputs,
 and returns a bincode-serialized `Expr` representing the equation.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_chebyshev_differential_equation(struct rssn_BincodeBuffer aYBuf,
                                                                       struct rssn_BincodeBuffer aXBuf,
                                                                       struct rssn_BincodeBuffer aNBuf)
;

/*
 Computes the Chebyshev polynomial of the first kind T_n(x).

 Takes bincode-serialized `Expr` representing `n` and `x` as inputs,
 and returns a bincode-serialized `Expr` representing T_n(x).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_chebyshev_t(struct rssn_BincodeBuffer aNBuf,
                                                   struct rssn_BincodeBuffer aXBuf)
;

/*
 Computes the Chebyshev polynomial of the second kind U_n(x).

 Takes bincode-serialized `Expr` representing `n` and `x` as inputs,
 and returns a bincode-serialized `Expr` representing U_n(x).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_chebyshev_u(struct rssn_BincodeBuffer aNBuf,
                                                   struct rssn_BincodeBuffer aXBuf)
;

/*
 Checks analytic using Bincode.
 */
rssn_
bool rssn_bincode_check_analytic(struct rssn_BincodeBuffer aExprBuf,
                                 const char *aVar)
;

rssn_
bool rssn_bincode_check_jacobi_identity(struct rssn_BincodeBuffer aAlgebraBuf)
;

/*
 Solves the Chinese Remainder Theorem.

 Takes a bincode-serialized vector of congruences (`(remainder, modulus)`),
 and returns a bincode-serialized `Expr` representing the solution.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_chinese_remainder(struct rssn_BincodeBuffer aCongruencesBuf)
;

/*
 Exact chromatic number.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_chromatic_number_exact(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Classifies a PDE (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_classify_pde(struct rssn_BincodeBuffer aEquationBuf,
                                                    const char *aFunc,
                                                    struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Computes the number of combinations symbolically using bincode-encoded `Expr` arguments.

 This corresponds to the binomial coefficient \( C(n,k) = n! / (k!(n-k)!) \) when
 `n` and `k` are integers, but operates on general symbolic expressions.

 # Arguments

 * `n_buf` - Bincode buffer encoding an `Expr` representing the population size `n`.
 * `k_buf` - Bincode buffer encoding an `Expr` representing the selection size `k`.

 # Returns

 A bincode buffer encoding an `Expr` for the symbolic combination count.

 # Safety

 This function is unsafe because it dereferences raw bincode buffers that must
 contain valid serialized `Expr` values.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_combinations(struct rssn_BincodeBuffer aNBuf,
                                                    struct rssn_BincodeBuffer aKBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_commutator_table(struct rssn_BincodeBuffer aAlgebraBuf)
;

/*
 Finds fixed points (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_complex_system_fixed_points(struct rssn_BincodeBuffer aSystemBuf)
;

/*
 Iterates the system once (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_complex_system_iterate(struct rssn_BincodeBuffer aSystemBuf,
                                                              struct rssn_BincodeBuffer aZBuf)
;

/*
 Creates a new Mandelbrot family system (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_complex_system_new_mandelbrot(struct rssn_BincodeBuffer aCBuf)
;

/*
 Computes the conditional entropy of a joint probability distribution.

 Takes a bincode-serialized `Expr` representing the joint probability distribution.
 Returns a bincode-serialized `Expr` representing the conditional entropy.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_conditional_entropy(struct rssn_BincodeBuffer aJointProbsBuf)
;

/*
 Computes the convolution of two functions using the Fourier transform property.

 Takes bincode-serialized `Expr` representing two functions (`f` and `g`),
 and `String`s for input and output variables.
 Returns a bincode-serialized `Expr` representing the convolution.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_convolution_fourier(struct rssn_BincodeBuffer aFBuf,
                                                           struct rssn_BincodeBuffer aGBuf,
                                                           struct rssn_BincodeBuffer aInVarBuf,
                                                           struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Computes the convolution of two functions using the Laplace transform property.

 Takes bincode-serialized `Expr` representing two functions (`f` and `g`),
 and `String`s for input and output variables.
 Returns a bincode-serialized `Expr` representing the convolution.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_convolution_laplace(struct rssn_BincodeBuffer aFBuf,
                                                           struct rssn_BincodeBuffer aGBuf,
                                                           struct rssn_BincodeBuffer aInVarBuf,
                                                           struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Gets the metric tensor for a given coordinate system using bincode-serialized input.

 Takes a `BincodeBuffer` containing the `CoordinateSystem`.
 Returns a `BincodeBuffer` containing the metric tensor (`Vec<Vec<Expr>>`).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_coordinates_get_metric_tensor(struct rssn_BincodeBuffer aSystemBuf)
;

/*
 Computes the symbolic Pearson correlation coefficient using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_correlation(struct rssn_BincodeBuffer aData1Buf,
                                                   struct rssn_BincodeBuffer aData2Buf)
;

/*
 Counts the number of distinct real roots in an interval (Bincode)
 */
rssn_
int64_t rssn_bincode_count_real_roots_in_interval(struct rssn_BincodeBuffer aExprBuf,
                                                  const char *aVarPtr,
                                                  double aA,
                                                  double aB)
;

/*
 Computes the symbolic covariance of two sets of expressions using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_covariance(struct rssn_BincodeBuffer aData1Buf,
                                                  struct rssn_BincodeBuffer aData2Buf)
;

/*
 Computes CRC-32 checksum via Bincode interface.
 Input: Vec<u8>
 Returns: u32
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_crc32_compute(struct rssn_BincodeBuffer aDataBuf)
;

/*
 Finalizes CRC-32 computation via Bincode interface.
 Input: u32 (running crc)
 Returns: u32 (final crc)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_crc32_finalize(struct rssn_BincodeBuffer aCrcBuf)
;

/*
 Updates CRC-32 incrementally via Bincode interface.
 Input: (crc: u32, data: Vec<u8>)
 Returns: u32
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_crc32_update(struct rssn_BincodeBuffer aCrcBuf,
                                                    struct rssn_BincodeBuffer aDataBuf)
;

/*
 Verifies CRC-32 checksum via Bincode interface.
 Input: (data: Vec<u8>, expected_crc: u32)
 Returns: bool
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_crc32_verify(struct rssn_BincodeBuffer aDataBuf,
                                                    struct rssn_BincodeBuffer aExpectedCrcBuf)
;

/*
 Computes the cross-entropy between two probability distributions.

 Takes two bincode-serialized `Vec<Expr>` representing the probability distributions (`p` and `q`).
 Returns a bincode-serialized `Expr` representing the cross-entropy.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_cross_entropy(struct rssn_BincodeBuffer aPProbsBuf,
                                                     struct rssn_BincodeBuffer aQProbsBuf)
;

/*
 Adds two points.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_curve_add(struct rssn_BincodeBuffer aCurveBuf,
                                                 struct rssn_BincodeBuffer aP1Buf,
                                                 struct rssn_BincodeBuffer aP2Buf)
;

/*
 Doubles a point.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_curve_double(struct rssn_BincodeBuffer aCurveBuf,
                                                    struct rssn_BincodeBuffer aPointBuf)
;

/*
 Checks if a point is on the curve.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_curve_is_on_curve(struct rssn_BincodeBuffer aCurveBuf,
                                                         struct rssn_BincodeBuffer aPointBuf)
;

/*
 Negates a point.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_curve_negate(struct rssn_BincodeBuffer aCurveBuf,
                                                    struct rssn_BincodeBuffer aPointBuf)
;

/*
 Creates an affine curve point via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_curve_point_affine(struct rssn_BincodeBuffer aXBuf,
                                                          struct rssn_BincodeBuffer aYBuf,
                                                          struct rssn_BincodeBuffer aModulusBuf)
;

/*
 Creates a point at infinity via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_curve_point_infinity(void)
;

/*
 Scalar multiplication.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_curve_scalar_mult(struct rssn_BincodeBuffer aCurveBuf,
                                                         struct rssn_BincodeBuffer aKBuf,
                                                         struct rssn_BincodeBuffer aPBuf)
;

/*
 Creates a cyclic group of order `n` and returns it as a Bincode buffer.

 # Arguments
 * `n` - The order of the cyclic group.

 # Returns
 A `BincodeBuffer` containing the serialized representation of the group.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_cyclic_group_create(size_t aN)
;

/*
 Computes definite integral using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_definite_integrate(struct rssn_BincodeBuffer aExprBuf,
                                                          const char *aVar,
                                                          struct rssn_BincodeBuffer aLowerBuf,
                                                          struct rssn_BincodeBuffer aUpperBuf)
;

/*
 Denests a nested square root (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_denest_sqrt(struct rssn_BincodeBuffer aExprBuf)
;

/*
 Computes the density of states for a 3D electron gas using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_density_of_states_3d(struct rssn_BincodeBuffer aEnergyBuf,
                                                            struct rssn_BincodeBuffer aMassBuf,
                                                            struct rssn_BincodeBuffer aVolumeBuf)
;

/*
 Differentiates an expression using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_differentiate(struct rssn_BincodeBuffer aExprBuf,
                                                     const char *aVar)
;

/*
 Computes the digamma function ψ(z).

 Takes a bincode-serialized `Expr` representing `z` as input,
 and returns a bincode-serialized `Expr` representing ψ(z).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_digamma(struct rssn_BincodeBuffer aArgBuf)
;

/*
 Computes ψ(x) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_digamma_numerical(struct rssn_BincodeBuffer aValBuf)
;

/*
 Creates a dihedral group of order `2n` and returns it as a Bincode buffer.

 # Arguments
 * `n` - The parameter defining the dihedral group $D_n$.

 # Returns
 A `BincodeBuffer` containing the serialized representation of the group.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_dihedral_group_create(size_t aN)
;

/*
 Creates a Bernoulli distribution.

 Takes a bincode-serialized `Expr` representing `p` (probability of success).
 Returns a bincode-serialized `Expr` representing the Bernoulli distribution.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_bernoulli(struct rssn_BincodeBuffer aPBuf)
;

/*
 Creates a beta distribution.

 Takes bincode-serialized `Expr` representing the alpha and beta parameters.
 Returns a bincode-serialized `Expr` representing the beta distribution.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_beta(struct rssn_BincodeBuffer aAlphaBuf,
                                                 struct rssn_BincodeBuffer aBetaBuf)
;

/*
 Creates a binomial distribution.

 Takes bincode-serialized `Expr` representing `n` (number of trials) and `p` (probability of success).
 Returns a bincode-serialized `Expr` representing the binomial distribution.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_binomial(struct rssn_BincodeBuffer aNBuf,
                                                     struct rssn_BincodeBuffer aPBuf)
;

/*
 Computes the cumulative distribution function (CDF) of a distribution.

 Takes bincode-serialized `Expr` representing the distribution and the value `x`.
 Returns a bincode-serialized `Expr` representing the CDF at `x`.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_cdf(struct rssn_BincodeBuffer aDistBuf,
                                                struct rssn_BincodeBuffer aXBuf)
;

/*
 Computes the expectation (mean) of a distribution.

 Takes a bincode-serialized `Expr` representing the distribution.
 Returns a bincode-serialized `Expr` representing the expectation.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_expectation(struct rssn_BincodeBuffer aDistBuf)
;

/*
 Creates an exponential distribution.

 Takes a bincode-serialized `Expr` representing the rate parameter (λ).
 Returns a bincode-serialized `Expr` representing the exponential distribution.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_exponential(struct rssn_BincodeBuffer aRateBuf)
;

/*
 Creates a gamma distribution.

 Takes bincode-serialized `Expr` representing the shape and rate parameters.
 Returns a bincode-serialized `Expr` representing the gamma distribution.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_gamma(struct rssn_BincodeBuffer aShapeBuf,
                                                  struct rssn_BincodeBuffer aRateBuf)
;

/*
 Computes the moment generating function (MGF) of a distribution.

 Takes bincode-serialized `Expr` representing the distribution and the variable `t`.
 Returns a bincode-serialized `Expr` representing the MGF.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_mgf(struct rssn_BincodeBuffer aDistBuf,
                                                struct rssn_BincodeBuffer aTBuf)
;

/*
 Creates a normal distribution.

 Takes bincode-serialized `Expr` representing the mean and standard deviation.
 Returns a bincode-serialized `Expr` representing the normal distribution.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_normal(struct rssn_BincodeBuffer aMeanBuf,
                                                   struct rssn_BincodeBuffer aStdDevBuf)
;

/*
 Computes the probability density function (PDF) of a distribution.

 Takes bincode-serialized `Expr` representing the distribution and the value `x`.
 Returns a bincode-serialized `Expr` representing the PDF at `x`.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_pdf(struct rssn_BincodeBuffer aDistBuf,
                                                struct rssn_BincodeBuffer aXBuf)
;

/*
 Creates a Poisson distribution.

 Takes a bincode-serialized `Expr` representing the rate parameter (λ).
 Returns a bincode-serialized `Expr` representing the Poisson distribution.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_poisson(struct rssn_BincodeBuffer aRateBuf)
;

/*
 Creates a Student's t-distribution.

 Takes a bincode-serialized `Expr` representing the degrees of freedom (ν).
 Returns a bincode-serialized `Expr` representing the Student's t-distribution.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_student_t(struct rssn_BincodeBuffer aNuBuf)
;

/*
 Creates a uniform distribution.

 Takes bincode-serialized `Expr` representing the minimum and maximum values.
 Returns a bincode-serialized `Expr` representing the uniform distribution.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_uniform(struct rssn_BincodeBuffer aMinBuf,
                                                    struct rssn_BincodeBuffer aMaxBuf)
;

/*
 Computes the variance of a distribution.

 Takes a bincode-serialized `Expr` representing the distribution.
 Returns a bincode-serialized `Expr` representing the variance.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_variance(struct rssn_BincodeBuffer aDistBuf)
;

/*
 Computes n!! via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_double_factorial(struct rssn_BincodeBuffer aNBuf)
;

/*
 Computes Drude conductivity using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_drude_conductivity(struct rssn_BincodeBuffer aNBuf,
                                                          struct rssn_BincodeBuffer aEBuf,
                                                          struct rssn_BincodeBuffer aTauBuf,
                                                          struct rssn_BincodeBuffer aMassBuf)
;

/*
 Signs a message.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_ecdsa_sign(struct rssn_BincodeBuffer aMessageHashBuf,
                                                  struct rssn_BincodeBuffer aPrivateKeyBuf,
                                                  struct rssn_BincodeBuffer aCurveBuf,
                                                  struct rssn_BincodeBuffer aGeneratorBuf,
                                                  struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Verifies a signature.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_ecdsa_verify(struct rssn_BincodeBuffer aMessageHashBuf,
                                                    struct rssn_BincodeBuffer aSignatureBuf,
                                                    struct rssn_BincodeBuffer aPublicKeyBuf,
                                                    struct rssn_BincodeBuffer aCurveBuf,
                                                    struct rssn_BincodeBuffer aGeneratorBuf,
                                                    struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Calculates energy density using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_electromagnetic_energy_density(struct rssn_BincodeBuffer aEFieldBuf,
                                                                      struct rssn_BincodeBuffer aBFieldBuf)
;

/*
 Creates a new elliptic curve via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_elliptic_curve_new(struct rssn_BincodeBuffer aABuf,
                                                          struct rssn_BincodeBuffer aBBuf,
                                                          struct rssn_BincodeBuffer aModulusBuf)
;

/*
 Computes the error function erf(z).

 Takes a bincode-serialized `Expr` representing `z` as input,
 and returns a bincode-serialized `Expr` representing erf(z).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_erf(struct rssn_BincodeBuffer aArgBuf)
;

/*
 Computes erf(x) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_erf_numerical(struct rssn_BincodeBuffer aValBuf)
;

/*
 Computes the complementary error function erfc(z).

 Takes a bincode-serialized `Expr` representing `z` as input,
 and returns a bincode-serialized `Expr` representing erfc(z).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_erfc(struct rssn_BincodeBuffer aArgBuf)
;

/*
 Computes erfc(x) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_erfc_numerical(struct rssn_BincodeBuffer aValBuf)
;

/*
 Computes the imaginary error function erfi(z).

 Takes a bincode-serialized `Expr` representing `z` as input,
 and returns a bincode-serialized `Expr` representing erfi(z).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_erfi(struct rssn_BincodeBuffer aArgBuf)
;

/*
 Computes the Euler-Lagrange equation using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_euler_lagrange(struct rssn_BincodeBuffer aLagrangianBuf,
                                                      const char *aFunc,
                                                      const char *aVar)
;

/*
 Computes Euler-Lagrange equation using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_euler_lagrange_equation(struct rssn_BincodeBuffer aLagrangianBuf,
                                                               const char *aQ,
                                                               const char *aQDot,
                                                               const char *aTVar)
;

/*
 Evaluates at point using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_evaluate_at_point(struct rssn_BincodeBuffer aExprBuf,
                                                         const char *aVar,
                                                         struct rssn_BincodeBuffer aValueBuf)
;

/*
 Numerically evaluates a symbolic expression.

 Takes a bincode-serialized `Expr` as input,
 and returns a bincode-serialized numerical evaluation of that expression.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_evaluate_numerical(struct rssn_BincodeBuffer aExprBuf)
;

/*
 Computes the expectation value using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_expectation_value(struct rssn_BincodeBuffer aOpBuf,
                                                         struct rssn_BincodeBuffer aPsiBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_exponential_map(struct rssn_BincodeBuffer aXBuf,
                                                       size_t aOrder)
;

/*
 Computes the extended greatest common divisor (GCD).

 Takes bincode-serialized `Expr` representing two numbers (`a` and `b`),
 and returns a bincode-serialized tuple `(g, x, y)` where `g` is the GCD
 and `x`, `y` are coefficients such that `ax + by = g`.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_extended_gcd(struct rssn_BincodeBuffer aABuf,
                                                    struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes the exterior derivative of a differential form (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_exterior_derivative(struct rssn_BincodeBuffer aFormBuf,
                                                           struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Factors a polynomial over a finite field (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_factor_gf(struct rssn_BincodeBuffer aPolyBuf)
;

/*
 Computes n! via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_factorial(struct rssn_BincodeBuffer aNBuf)
;

/*
 Computes (x)₍ₙ₎ via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_falling_factorial(struct rssn_BincodeBuffer aXBuf,
                                                         struct rssn_BincodeBuffer aNBuf)
;

/*
 Computes Fermi energy for a 3D electron gas using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_fermi_energy_3d(struct rssn_BincodeBuffer aConcentrationBuf,
                                                       struct rssn_BincodeBuffer aMassBuf)
;

/*
 Finds constrained extrema (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_find_constrained_extrema(struct rssn_BincodeBuffer aExprBuf,
                                                                struct rssn_BincodeBuffer aConstraintsBuf,
                                                                struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Finds extrema of a function (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_find_extrema(struct rssn_BincodeBuffer aExprBuf,
                                                    struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Finds fixed points of a 1D map (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_find_fixed_points(struct rssn_BincodeBuffer aMapBuf,
                                                         const char *aVar)
;

/*
 Finds pole order using Bincode.
 */
rssn_
size_t rssn_bincode_find_pole_order(struct rssn_BincodeBuffer aExprBuf,
                                    const char *aVar,
                                    struct rssn_BincodeBuffer aPoleBuf)
;

/*
 Finds poles using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_find_poles(struct rssn_BincodeBuffer aExprBuf,
                                                  const char *aVar)
;

/*
 Gets the degree of a finite field polynomial (Bincode)
 */
rssn_
int64_t rssn_bincode_finite_field_polynomial_degree(struct rssn_BincodeBuffer aPolyBuf)
;

/*
 Performs polynomial long division (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_finite_field_polynomial_long_division(struct rssn_BincodeBuffer aDividendBuf,
                                                                             struct rssn_BincodeBuffer aDivisorBuf)
;

/*
 Creates a new finite field polynomial (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_finite_field_polynomial_new(struct rssn_BincodeBuffer aCoeffsBuf,
                                                                   struct rssn_BincodeBuffer aModulusBuf)
;

/*
 Applies the differentiation property of the Fourier transform.

 Takes bincode-serialized `Expr` (frequency domain expression) and `String` (output variable).
 Returns a bincode-serialized `Expr` representing the transformed expression.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_fourier_differentiation(struct rssn_BincodeBuffer aFOmegaBuf,
                                                               struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Applies the frequency shift property of the Fourier transform.

 Takes bincode-serialized `Expr` (frequency domain expression), `Expr` (frequency shift amount),
 and `String` (output variable).
 Returns a bincode-serialized `Expr` representing the transformed expression.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_fourier_frequency_shift(struct rssn_BincodeBuffer aFOmegaBuf,
                                                               struct rssn_BincodeBuffer aABuf,
                                                               struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Applies the scaling property of the Fourier transform.

 Takes bincode-serialized `Expr` (frequency domain expression), `Expr` (scaling factor `a`),
 and `String` (output variable).
 Returns a bincode-serialized `Expr` representing the transformed expression.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_fourier_scaling(struct rssn_BincodeBuffer aFOmegaBuf,
                                                       struct rssn_BincodeBuffer aABuf,
                                                       struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Computes the Fourier series expansion of an expression.

 Takes bincode-serialized `Expr` (expression), `String` (variable),
 `Expr` (period), and `usize` (order).
 Returns a bincode-serialized `Expr` representing the Fourier series.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_fourier_series(struct rssn_BincodeBuffer aExprBuf,
                                                      struct rssn_BincodeBuffer aVarBuf,
                                                      struct rssn_BincodeBuffer aPeriodBuf,
                                                      struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Applies the time shift property of the Fourier transform.

 Takes bincode-serialized `Expr` (frequency domain expression), `Expr` (time shift amount),
 and `String` (output variable).
 Returns a bincode-serialized `Expr` representing the transformed expression.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_fourier_time_shift(struct rssn_BincodeBuffer aFOmegaBuf,
                                                          struct rssn_BincodeBuffer aABuf,
                                                          struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Computes the Fourier transform of an expression.

 Takes bincode-serialized `Expr` (expression), `String` (input variable), and `String` (output variable).
 Returns a bincode-serialized `Expr` representing the Fourier transform.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_fourier_transform(struct rssn_BincodeBuffer aExprBuf,
                                                         struct rssn_BincodeBuffer aInVarBuf,
                                                         struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Computes the gamma function Γ(z).

 Takes a bincode-serialized `Expr` representing `z` as input,
 and returns a bincode-serialized `Expr` representing Γ(z).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_gamma(struct rssn_BincodeBuffer aArgBuf)
;

/*
 Computes Γ(x) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_gamma_numerical(struct rssn_BincodeBuffer aValBuf)
;

/*
 Represents Gauss's theorem (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_gauss_theorem(struct rssn_BincodeBuffer aVectorFieldBuf,
                                                     struct rssn_BincodeBuffer aVolumeBuf)
;

/*
 Computes general multi-valued arccos (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_arccos(struct rssn_BincodeBuffer aZBuf,
                                                      struct rssn_BincodeBuffer aKBuf,
                                                      struct rssn_BincodeBuffer aSBuf)
;

/*
 Computes general multi-valued arcsin (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_arcsin(struct rssn_BincodeBuffer aZBuf,
                                                      struct rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued arctan (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_arctan(struct rssn_BincodeBuffer aZBuf,
                                                      struct rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued logarithm (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_log(struct rssn_BincodeBuffer aZBuf,
                                                   struct rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued n-th root (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_nth_root(struct rssn_BincodeBuffer aZBuf,
                                                        struct rssn_BincodeBuffer aNBuf,
                                                        struct rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued power (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_power(struct rssn_BincodeBuffer aZBuf,
                                                     struct rssn_BincodeBuffer aWBuf,
                                                     struct rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued square root (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_sqrt(struct rssn_BincodeBuffer aZBuf,
                                                    struct rssn_BincodeBuffer aKBuf)
;

/*
 Computes the generalized Laguerre polynomial L_n^α(x).

 Takes bincode-serialized `Expr` representing `n`, `alpha`, and `x` as inputs,
 and returns a bincode-serialized `Expr` representing L_n^α(x).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_generalized_laguerre(struct rssn_BincodeBuffer aNBuf,
                                                            struct rssn_BincodeBuffer aAlphaBuf,
                                                            struct rssn_BincodeBuffer aXBuf)
;

/*
 Represents the generalized Stokes' theorem (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_generalized_stokes_theorem(struct rssn_BincodeBuffer aOmegaBuf,
                                                                  struct rssn_BincodeBuffer aManifoldBuf,
                                                                  struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Generates a key pair.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_generate_keypair(struct rssn_BincodeBuffer aCurveBuf,
                                                        struct rssn_BincodeBuffer aGeneratorBuf)
;

/*
 Generates a shared secret.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_generate_shared_secret(struct rssn_BincodeBuffer aCurveBuf,
                                                              struct rssn_BincodeBuffer aPrivateKeyBuf,
                                                              struct rssn_BincodeBuffer aOtherPublicKeyBuf)
;

/*
 Gets real and imaginary parts using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_get_real_imag_parts(struct rssn_BincodeBuffer aExprBuf)
;

/*
 Performs addition in GF(2^8) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_gf256_add(struct rssn_BincodeBuffer aABuf,
                                                 struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes inverse in GF(2^8) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_gf256_inv(struct rssn_BincodeBuffer aABuf)
;

/*
 Performs multiplication in GF(2^8) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_gf256_mul(struct rssn_BincodeBuffer aABuf,
                                                 struct rssn_BincodeBuffer aBBuf)
;

/*
 Calculates Gibbs Free Energy using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_gibbs_free_energy(struct rssn_BincodeBuffer aHBuf,
                                                         struct rssn_BincodeBuffer aTBuf,
                                                         struct rssn_BincodeBuffer aSBuf)
;

/*
 Computes the Gini impurity of a probability distribution.

 Takes a bincode-serialized `Vec<Expr>` representing the probabilities.
 Returns a bincode-serialized `Expr` representing the Gini impurity.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_gini_impurity(struct rssn_BincodeBuffer aProbsBuf)
;

/*
 Applies the Gram–Schmidt process to produce an orthonormal basis in a Hilbert space.

 Given a Hilbert space and a list of symbolic basis vectors, this performs the
 Gram–Schmidt orthonormalization procedure to obtain an orthonormal basis.

 # Arguments

 * `space_buf` - `BincodeBuffer` encoding a [`HilbertSpace`].
 * `basis_buf` - `BincodeBuffer` encoding a `Vec<Expr>` of basis vectors.

 # Returns

 A `BincodeBuffer` containing a `Vec<Expr>` for the orthonormal basis. Returns an
 empty buffer if any input fails to deserialize.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point; the caller
 must treat the returned buffer as opaque and only pass it to compatible APIs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_gram_schmidt(struct rssn_BincodeBuffer aSpaceBuf,
                                                    struct rssn_BincodeBuffer aBasisBuf)
;

/*
 Adds an edge to the graph.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_add_edge(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Adds a node to the graph.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_add_node(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Gets the adjacency matrix.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_adjacency_matrix(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Performs BFS traversal.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_bfs(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Performs BFS traversal.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_bfs_api(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Finds maximum matching in bipartite graph.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_bipartite_maximum_matching(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Finds bridges and articulation points.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_bridges_and_articulation_points(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes the Cartesian product of two graphs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_cartesian_product(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Computes the complement of a graph.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_complement(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Finds connected components.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_connected_components(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Finds connected components.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_connected_components_api(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Performs DFS traversal.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_dfs(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Performs DFS traversal.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_dfs_api(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Computes maximum flow using Dinic's algorithm.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_dinic_max_flow(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Computes the disjoint union of two graphs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_disjoint_union(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Computes maximum flow using Edmonds-Karp.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_edmonds_karp_max_flow(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Checks if graph has a cycle.
 */
rssn_
bool rssn_bincode_graph_has_cycle(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Checks if graph has a cycle.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_has_cycle_api(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Creates an induced subgraph.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_induced_subgraph(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Computes the intersection of two graphs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_intersection(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Checks if graph is bipartite.
 */
rssn_
bool rssn_bincode_graph_is_bipartite(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Checks if graph is bipartite.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_is_bipartite_api(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Checks if graph is connected.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_is_connected(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes the join of two graphs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_join(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Computes MST using Kruskal's algorithm.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_kruskal_mst(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes MST using Kruskal's algorithm.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_kruskal_mst_api(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Gets the Laplacian matrix.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_laplacian_matrix(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes maximum flow.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_max_flow(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Creates a new graph from bincode specification.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_new(struct rssn_BincodeBuffer aSpecBuf)
;

/*
 Finds strongly connected components.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_strongly_connected_components(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes the Tensor product of two graphs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_tensor_product(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Performs topological sort.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_topological_sort(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes the union of two graphs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_union(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Greedy coloring.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_greedy_coloring(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Represents Green's theorem (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_greens_theorem(struct rssn_BincodeBuffer aPBuf,
                                                      struct rssn_BincodeBuffer aQBuf,
                                                      struct rssn_BincodeBuffer aDomainBuf)
;

/*
 Computes the center of a bincode-encoded group.

 The center is the subset of elements that commute with every group element,
 i.e., \(Z(G) = \{z \in G \mid zg = gz, \forall g \in G\}\).

 # Arguments

 * `group_buf` - `BincodeBuffer` encoding a [`Group`].

 # Returns

 A `BincodeBuffer` encoding the center (typically as a collection of
 `GroupElement` values), or an empty buffer if deserialization fails.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point; callers
 must treat the returned buffer as opaque and only pass it to compatible APIs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_group_center(struct rssn_BincodeBuffer aGroupBuf)
;

/*
 Computes the conjugacy classes of a bincode-encoded group.

 Conjugacy classes partition the group into sets of elements related by
 conjugation \(gag^{-1}\).

 # Arguments

 * `group_buf` - `BincodeBuffer` encoding a [`Group`].

 # Returns

 A `BincodeBuffer` encoding the conjugacy classes (typically as a collection of
 `Vec<GroupElement>`), or an empty buffer if deserialization fails.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point; callers
 must treat the returned buffer as opaque and only pass it to compatible APIs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_group_conjugacy_classes(struct rssn_BincodeBuffer aGroupBuf)
;

/*
 Creates a group from a bincode-encoded description.

 The input buffer encodes a [`Group`] (e.g., its underlying set and operation),
 which is deserialized and returned in canonical internal form.

 # Arguments

 * `buf` - `BincodeBuffer` containing a serialized `Group` description.

 # Returns

 A `BincodeBuffer` containing the canonicalized `Group`, or an empty buffer if
 deserialization fails.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point; callers
 must treat the returned buffer as opaque and only pass it to compatible APIs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_group_create(struct rssn_BincodeBuffer aBuf)
;

/*
 Computes the order of a group element using a bincode-encoded group.

 The order of an element is the smallest positive integer \(n\) such that
 \(a^n = e\), where \(e\) is the identity element.

 # Arguments

 * `group_buf` - `BincodeBuffer` encoding a [`Group`].
 * `a_buf` - `BincodeBuffer` encoding a [`GroupElement`].

 # Returns

 The order of the element as a `usize`, or `0` if the order is undefined or
 deserialization fails.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point; callers
 must ensure the buffers encode a compatible group and element.
 */
rssn_
size_t rssn_bincode_group_element_order(struct rssn_BincodeBuffer aGroupBuf,
                                        struct rssn_BincodeBuffer aABuf)
;

/*
 Computes the inverse of a group element using a bincode-encoded group.

 # Arguments

 * `group_buf` - `BincodeBuffer` encoding a [`Group`].
 * `a_buf` - `BincodeBuffer` encoding a [`GroupElement`] whose inverse is sought.

 # Returns

 A `BincodeBuffer` encoding the inverse `GroupElement`, or an empty buffer if
 deserialization fails.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point; callers
 must treat the returned buffer as opaque and only pass it to compatible APIs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_group_inverse(struct rssn_BincodeBuffer aGroupBuf,
                                                     struct rssn_BincodeBuffer aABuf)
;

/*
 Tests whether a bincode-encoded group is Abelian.

 A group is Abelian if its operation is commutative, i.e., \(ab = ba\) for all
 elements \(a, b\).

 # Arguments

 * `group_buf` - `BincodeBuffer` encoding a [`Group`].

 # Returns

 `true` if the group is Abelian, `false` if it is non-Abelian or deserialization
 fails.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point; callers
 must ensure the buffer is a valid encoding of a `Group`.
 */
rssn_
bool rssn_bincode_group_is_abelian(struct rssn_BincodeBuffer aGroupBuf)
;

/*
 Multiplies two group elements using a bincode-encoded group.

 Given a `Group` and two `GroupElement` values, this applies the group
 operation to compute their product.

 # Arguments

 * `group_buf` - `BincodeBuffer` encoding a [`Group`].
 * `a_buf` - `BincodeBuffer` encoding a [`GroupElement`] for the left factor.
 * `b_buf` - `BincodeBuffer` encoding a [`GroupElement`] for the right factor.

 # Returns

 A `BincodeBuffer` encoding the resulting `GroupElement`, or an empty buffer if
 any input fails to deserialize.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point; callers
 must treat the returned buffer as opaque and only pass it to compatible APIs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_group_multiply(struct rssn_BincodeBuffer aGroupBuf,
                                                      struct rssn_BincodeBuffer aABuf,
                                                      struct rssn_BincodeBuffer aBBuf)
;

/*
 Applies Hamilton's Principle using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_hamiltons_principle(struct rssn_BincodeBuffer aLagrangianBuf,
                                                           const char *aFunc,
                                                           const char *aVar)
;

/*
 Checks if a Hamming(7,4) codeword is valid via Bincode interface.
 Input: Vec<u8> (7 bytes)
 Returns: bool
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_hamming_check(struct rssn_BincodeBuffer aCodewordBuf)
;

/*
 Decodes a 7-bit Hamming(7,4) codeword via Bincode interface.
 Returns tuple of (data, error_pos).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_hamming_decode(struct rssn_BincodeBuffer aCodewordBuf)
;

/*
 Computes Hamming distance between two byte slices via Bincode interface.
 Input: (a: Vec<u8>, b: Vec<u8>)
 Returns: Option<usize>
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_hamming_distance(struct rssn_BincodeBuffer aABuf,
                                                        struct rssn_BincodeBuffer aBBuf)
;

/*
 Encodes 4 data bits into a 7-bit Hamming(7,4) codeword via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_hamming_encode(struct rssn_BincodeBuffer aDataBuf)
;

/*
 Computes Hamming weight of a byte slice via Bincode interface.
 Input: Vec<u8>
 Returns: usize
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_hamming_weight(struct rssn_BincodeBuffer aDataBuf)
;

/*
 Computes the Hermite differential equation.

 Takes bincode-serialized `Expr` representing `y`, `x`, and `n` as inputs,
 and returns a bincode-serialized `Expr` representing the equation.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_hermite_differential_equation(struct rssn_BincodeBuffer aYBuf,
                                                                     struct rssn_BincodeBuffer aXBuf,
                                                                     struct rssn_BincodeBuffer aNBuf)
;

/*
 Computes the Hermite polynomial H_n(x).

 Takes bincode-serialized `Expr` representing `n` and `x` as inputs,
 and returns a bincode-serialized `Expr` representing H_n(x).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_hermite_h(struct rssn_BincodeBuffer aDegreeBuf,
                                                 struct rssn_BincodeBuffer aArgBuf)
;

/*
 Computes the Rodrigues' formula for Hermite polynomials.

 Takes bincode-serialized `Expr` representing `n` and `x` as inputs,
 and returns a bincode-serialized `Expr` representing the formula.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_hermite_rodrigues_formula(struct rssn_BincodeBuffer aNBuf,
                                                                 struct rssn_BincodeBuffer aXBuf)
;

/*
 Computes Hessian matrix (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_hessian_matrix(struct rssn_BincodeBuffer aExprBuf,
                                                      struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Simplifies an expression using the heuristic simplifier (Bincode input/output).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_heuristic_simplify(struct rssn_BincodeBuffer aExprBuf)
;

/*
 Constructs a Hilbert space from a bincode-encoded description.

 The input buffer encodes a [`HilbertSpace`] specification (e.g., underlying
 function space, inner product, and measure), which is deserialized and
 returned in canonical internal form.

 # Arguments

 * `buf` - `BincodeBuffer` containing a serialized `HilbertSpace` description.

 # Returns

 A `BincodeBuffer` containing the canonicalized `HilbertSpace`, or an empty
 buffer if deserialization fails.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point; the caller
 must treat the returned buffer as opaque and only pass it to compatible APIs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_hilbert_space_create(struct rssn_BincodeBuffer aBuf)
;

/*
 Calculates ideal gas Law using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_ideal_gas_law(struct rssn_BincodeBuffer aPBuf,
                                                     struct rssn_BincodeBuffer aVBuf,
                                                     struct rssn_BincodeBuffer aNBuf,
                                                     struct rssn_BincodeBuffer aRBuf,
                                                     struct rssn_BincodeBuffer aTBuf)
;

/*
 Creates a new IteratedFunctionSystem (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_ifs_create(struct rssn_BincodeBuffer aFunctionsBuf,
                                                  struct rssn_BincodeBuffer aProbabilitiesBuf,
                                                  struct rssn_BincodeBuffer aVariablesBuf)
;

/*
 Calculates similarity dimension (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_ifs_similarity_dimension(struct rssn_BincodeBuffer aScalingFactorsBuf)
;

/*
 Computes the inner product of two functions in a Hilbert space using bincode serialization.

 Given a Hilbert space and two symbolic functions \(f\) and \(g\), this evaluates
 the inner product \(\langle f, g \rangle\) according to the space's inner
 product structure.

 # Arguments

 * `space_buf` - `BincodeBuffer` encoding a [`HilbertSpace`].
 * `f_buf` - `BincodeBuffer` encoding an `Expr` for \(f\).
 * `g_buf` - `BincodeBuffer` encoding an `Expr` for \(g\).

 # Returns

 A `BincodeBuffer` containing the symbolic inner product value (typically an `Expr`).
 Returns an empty buffer if any input fails to deserialize.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point; the caller
 must treat the returned buffer as opaque and only pass it to compatible APIs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_inner_product(struct rssn_BincodeBuffer aSpaceBuf,
                                                     struct rssn_BincodeBuffer aFBuf,
                                                     struct rssn_BincodeBuffer aGBuf)
;

/*
 Integrates an expression using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_integrate(struct rssn_BincodeBuffer aExprBuf,
                                                 const char *aVar)
;

/*
 Integrates a rational function (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_integrate_rational_function(struct rssn_BincodeBuffer aExprBuf,
                                                                   struct rssn_BincodeBuffer aXBuf)
;

/*
 Computes erf⁻¹(x) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_inverse_erf(struct rssn_BincodeBuffer aValBuf)
;

/*
 Computes erfc⁻¹(x) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_inverse_erfc(struct rssn_BincodeBuffer aValBuf)
;

/*
 Computes the inverse Fourier transform of an expression.

 Takes bincode-serialized `Expr` (expression), `String` (input variable), and `String` (output variable).
 Returns a bincode-serialized `Expr` representing the inverse Fourier transform.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_inverse_fourier_transform(struct rssn_BincodeBuffer aExprBuf,
                                                                 struct rssn_BincodeBuffer aInVarBuf,
                                                                 struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Computes the inverse Laplace transform of an expression.

 Takes bincode-serialized `Expr` (expression), `String` (input variable), and `String` (output variable).
 Returns a bincode-serialized `Expr` representing the inverse Laplace transform.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_inverse_laplace_transform(struct rssn_BincodeBuffer aExprBuf,
                                                                 struct rssn_BincodeBuffer aInVarBuf,
                                                                 struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Computes the inverse Z-transform of an expression.

 Takes bincode-serialized `Expr` (expression), `String` (input variable), and `String` (output variable).
 Returns a bincode-serialized `Expr` representing the inverse Z-transform.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_inverse_z_transform(struct rssn_BincodeBuffer aExprBuf,
                                                           struct rssn_BincodeBuffer aInVarBuf,
                                                           struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Checks if a number is prime.

 Takes a bincode-serialized `Expr` representing a number,
 and returns a bincode-serialized boolean indicating whether the number is prime.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_is_prime(struct rssn_BincodeBuffer aNBuf)
;

/*
 Checks if a logical expression is satisfiable using bincode-based FFI.

 Returns a bincode buffer containing:
 - `Some(true)` if satisfiable
 - `Some(false)` if unsatisfiable
 - `None` if the expression contains quantifiers (undecidable)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_is_satisfiable(struct rssn_BincodeBuffer aExprBuf)
;

/*
 Isolates real roots in an interval (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_isolate_real_roots(struct rssn_BincodeBuffer aExprBuf,
                                                          const char *aVarPtr,
                                                          double aPrecision)
;

/*
 Computes the joint entropy of a joint probability distribution.

 Takes a bincode-serialized `Expr` representing the joint probability distribution.
 Returns a bincode-serialized `Expr` representing the joint entropy.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_joint_entropy(struct rssn_BincodeBuffer aJointProbsBuf)
;

/*
 Calculates kinetic energy using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_kinetic_energy(struct rssn_BincodeBuffer aMassBuf,
                                                      struct rssn_BincodeBuffer aVelocityBuf)
;

/*
 Computes the Kullback-Leibler divergence (relative entropy) between two probability distributions.

 Takes two bincode-serialized `Vec<Expr>` representing the probability distributions (`p` and `q`).
 Returns a bincode-serialized `Expr` representing the KL divergence.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_kl_divergence(struct rssn_BincodeBuffer aPProbsBuf,
                                                     struct rssn_BincodeBuffer aQProbsBuf)
;

/*
 Creates a Klein four-group and returns it as a Bincode buffer.

 # Returns
 A `BincodeBuffer` containing the serialized representation of the group.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_klein_four_group_create(void)
;

/*
 Computes the Laguerre differential equation.

 Takes bincode-serialized `Expr` representing `y`, `x`, and `n` as inputs,
 and returns a bincode-serialized `Expr` representing the equation.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_laguerre_differential_equation(struct rssn_BincodeBuffer aYBuf,
                                                                      struct rssn_BincodeBuffer aXBuf,
                                                                      struct rssn_BincodeBuffer aNBuf)
;

/*
 Computes the Laguerre polynomial L_n(x).

 Takes bincode-serialized `Expr` representing `n` and `x` as inputs,
 and returns a bincode-serialized `Expr` representing L_n(x).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_laguerre_l(struct rssn_BincodeBuffer aDegreeBuf,
                                                  struct rssn_BincodeBuffer aArgBuf)
;

/*
 Applies the differentiation property of the Laplace transform.

 Takes bincode-serialized `Expr` (s-domain expression), `String` (output variable),
 and `Expr` (`f(0)` - initial condition).
 Returns a bincode-serialized `Expr` representing the transformed expression.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_laplace_differentiation(struct rssn_BincodeBuffer aFSBuf,
                                                               struct rssn_BincodeBuffer aOutVarBuf,
                                                               struct rssn_BincodeBuffer aFZeroBuf)
;

/*
 Applies the frequency shift property of the Laplace transform.

 Takes bincode-serialized `Expr` (s-domain expression), `Expr` (frequency shift amount `a`),
 and `String` (output variable).
 Returns a bincode-serialized `Expr` representing the transformed expression.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_laplace_frequency_shift(struct rssn_BincodeBuffer aFSBuf,
                                                               struct rssn_BincodeBuffer aABuf,
                                                               struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Applies the integration property of the Laplace transform.

 Takes bincode-serialized `Expr` (s-domain expression) and `String` (output variable).
 Returns a bincode-serialized `Expr` representing the transformed expression.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_laplace_integration(struct rssn_BincodeBuffer aFSBuf,
                                                           struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Applies the scaling property of the Laplace transform.

 Takes bincode-serialized `Expr` (s-domain expression), `Expr` (scaling factor `a`),
 and `String` (output variable).
 Returns a bincode-serialized `Expr` representing the transformed expression.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_laplace_scaling(struct rssn_BincodeBuffer aFSBuf,
                                                       struct rssn_BincodeBuffer aABuf,
                                                       struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Applies the time shift property of the Laplace transform.

 Takes bincode-serialized `Expr` (s-domain expression), `Expr` (time shift amount `a`),
 and `String` (output variable).
 Returns a bincode-serialized `Expr` representing the transformed expression.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_laplace_time_shift(struct rssn_BincodeBuffer aFSBuf,
                                                          struct rssn_BincodeBuffer aABuf,
                                                          struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Computes the Laplace transform of an expression.

 Takes bincode-serialized `Expr` (expression), `String` (input variable), and `String` (output variable).
 Returns a bincode-serialized `Expr` representing the Laplace transform.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_laplace_transform(struct rssn_BincodeBuffer aExprBuf,
                                                         struct rssn_BincodeBuffer aInVarBuf,
                                                         struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Computes the Laurent series expansion of an expression.

 Takes bincode-serialized `Expr` (expression), `String` (variable),
 `Expr` (center), and `usize` (order).
 Returns a bincode-serialized `Expr` representing the Laurent series.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_laurent_series(struct rssn_BincodeBuffer aExprBuf,
                                                      struct rssn_BincodeBuffer aVarBuf,
                                                      struct rssn_BincodeBuffer aCenterBuf,
                                                      struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Computes the Legendre differential equation.

 Takes bincode-serialized `Expr` representing `y`, `x`, and `n` as inputs,
 and returns a bincode-serialized `Expr` representing the equation.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_legendre_differential_equation(struct rssn_BincodeBuffer aYBuf,
                                                                      struct rssn_BincodeBuffer aXBuf,
                                                                      struct rssn_BincodeBuffer aNBuf)
;

/*
 Computes the Legendre polynomial P_n(x).

 Takes bincode-serialized `Expr` representing `n` and `x` as inputs,
 and returns a bincode-serialized `Expr` representing P_n(x).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_legendre_p(struct rssn_BincodeBuffer aDegreeBuf,
                                                  struct rssn_BincodeBuffer aArgBuf)
;

/*
 Computes the Rodrigues' formula for Legendre polynomials.

 Takes bincode-serialized `Expr` representing `n` and `x` as inputs,
 and returns a bincode-serialized `Expr` representing the formula.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_legendre_rodrigues_formula(struct rssn_BincodeBuffer aNBuf,
                                                                  struct rssn_BincodeBuffer aXBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_lie_algebra_so3(void)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_lie_algebra_su2(void)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_lie_bracket(struct rssn_BincodeBuffer aXBuf,
                                                   struct rssn_BincodeBuffer aYBuf)
;

/*
 Computes limit using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_limit(struct rssn_BincodeBuffer aExprBuf,
                                             const char *aVar,
                                             struct rssn_BincodeBuffer aPointBuf)
;

/*
 Computes ln(B(a, b)) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_ln_beta_numerical(struct rssn_BincodeBuffer aABuf,
                                                         struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes ln(n!) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_ln_factorial(struct rssn_BincodeBuffer aNBuf)
;

/*
 Computes the log-gamma function ln(Γ(z)).

 Takes a bincode-serialized `Expr` representing `z` as input,
 and returns a bincode-serialized `Expr` representing ln(Γ(z)).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_ln_gamma(struct rssn_BincodeBuffer aArgBuf)
;

/*
 Computes ln(Γ(x)) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_ln_gamma_numerical(struct rssn_BincodeBuffer aValBuf)
;

/*
 Calculates Lorentz factor using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_lorentz_factor(struct rssn_BincodeBuffer aVelocityBuf)
;

/*
 Calculates Lorentz force using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_lorentz_force(struct rssn_BincodeBuffer aChargeBuf,
                                                     struct rssn_BincodeBuffer aEFieldBuf,
                                                     struct rssn_BincodeBuffer aVelocityBuf,
                                                     struct rssn_BincodeBuffer aBFieldBuf)
;

/*
 Returns Lorenz system equations (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_lorenz_system(void)
;

/*
 Calculates Lyapunov exponent (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_lyapunov_exponent(struct rssn_BincodeBuffer aMapBuf,
                                                         const char *aVar,
                                                         struct rssn_BincodeBuffer aInitialXBuf,
                                                         size_t aNIterations)
;

/*
 Calculates mass-energy equivalence using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_mass_energy_equivalence(struct rssn_BincodeBuffer aMassBuf)
;

/*
 Performs matrix addition.

 Takes two bincode-serialized `Expr` representing matrices,
 and returns a bincode-serialized `Expr` representing their sum.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_add(struct rssn_BincodeBuffer aM1Buf,
                                                  struct rssn_BincodeBuffer aM2Buf)
;

/*
 Computes the determinant of a matrix.

 Takes a bincode-serialized `Expr` representing a matrix,
 and returns a bincode-serialized `Expr` representing its determinant.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_determinant(struct rssn_BincodeBuffer aMatrixBuf)
;

/*
 Computes the inverse of a matrix.

 Takes a bincode-serialized `Expr` representing a matrix,
 and returns a bincode-serialized `Expr` representing its inverse.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_inverse(struct rssn_BincodeBuffer aMatrixBuf)
;

/*
 Performs matrix multiplication.

 Takes two bincode-serialized `Expr` representing matrices,
 and returns a bincode-serialized `Expr` representing their product.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_mul(struct rssn_BincodeBuffer aM1Buf,
                                                  struct rssn_BincodeBuffer aM2Buf)
;

/*
 Solves a linear system of equations AX = B.

 Takes two bincode-serialized `Expr` representing matrix A and vector B,
 and returns a bincode-serialized `Expr` representing the solution vector X.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_solve_linear_system(struct rssn_BincodeBuffer aABuf,
                                                                  struct rssn_BincodeBuffer aBBuf)
;

/*
 Performs matrix transposition.

 Takes a bincode-serialized `Expr` representing a matrix,
 and returns a bincode-serialized `Expr` representing its transpose.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_transpose(struct rssn_BincodeBuffer aMatrixBuf)
;

/*
 Computes the symbolic mean of a set of expressions using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_mean(struct rssn_BincodeBuffer aDataBuf)
;

/*
 Computes geometric product (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_geometric_product(struct rssn_BincodeBuffer aABuf,
                                                                     struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes grade projection (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_grade_projection(struct rssn_BincodeBuffer aMvBuf,
                                                                    uint32_t aGrade)
;

/*
 Computes inner product (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_inner_product(struct rssn_BincodeBuffer aABuf,
                                                                 struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes magnitude (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_magnitude(struct rssn_BincodeBuffer aMvBuf)
;

/*
 Computes outer product (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_outer_product(struct rssn_BincodeBuffer aABuf,
                                                                 struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes reverse (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_reverse(struct rssn_BincodeBuffer aMvBuf)
;

/*
 Creates a new scalar multivector (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_scalar(uint32_t aP,
                                                          uint32_t aQ,
                                                          uint32_t aR,
                                                          struct rssn_BincodeBuffer aValueBuf)
;

/*
 Computes the mutual information between two random variables from their joint probability distribution.

 Takes a bincode-serialized `Expr` representing the joint probability distribution.
 Returns a bincode-serialized `Expr` representing the mutual information.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_mutual_information(struct rssn_BincodeBuffer aJointProbsBuf)
;

/*
 Performs a nonlinear regression.

 Takes bincode-serialized `Vec<(Expr, Expr)>` (data points), `Expr` (model),
 `Vec<String>` (variables), and `Vec<String>` (parameters).
 Returns a bincode-serialized `Vec<Expr>` representing the optimized parameter values.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_nonlinear_regression(struct rssn_BincodeBuffer aDataBuf,
                                                            struct rssn_BincodeBuffer aModelBuf,
                                                            struct rssn_BincodeBuffer aVarsBuf,
                                                            struct rssn_BincodeBuffer aParamsBuf)
;

/*
 Computes the norm of a function in a Hilbert space using bincode serialization.

 Given a Hilbert space and a symbolic function \(f\), this evaluates the norm
 \(\|f\| = \sqrt{\langle f, f \rangle}\) induced by the inner product.

 # Arguments

 * `space_buf` - `BincodeBuffer` encoding a [`HilbertSpace`].
 * `f_buf` - `BincodeBuffer` encoding an `Expr` for \(f\).

 # Returns

 A `BincodeBuffer` containing the symbolic norm value (typically an `Expr`).
 Returns an empty buffer if any input fails to deserialize.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point; the caller
 must treat the returned buffer as opaque and only pass it to compatible APIs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_norm(struct rssn_BincodeBuffer aSpaceBuf,
                                            struct rssn_BincodeBuffer aFBuf)
;

/*
 Performs a one-sample t-test.

 Takes bincode-serialized `Vec<Expr>` (data) and `Expr` (target mean).
 Returns a bincode-serialized `HypothesisTest` representing the test result.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_one_sample_t_test(struct rssn_BincodeBuffer aDataBuf,
                                                         struct rssn_BincodeBuffer aTargetMeanBuf)
;

/*
 Computes the partial fraction decomposition of an expression.

 Takes bincode-serialized `Expr` (expression) and `String` (variable).
 Returns a bincode-serialized `Expr` representing the partial fraction decomposition.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_partial_fraction_decomposition(struct rssn_BincodeBuffer aExprBuf,
                                                                      struct rssn_BincodeBuffer aVarBuf)
;

/*
 Computes path integral using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_path_integrate(struct rssn_BincodeBuffer aExprBuf,
                                                      const char *aVar,
                                                      struct rssn_BincodeBuffer aContourBuf)
;

/*
 Computes the number of permutations symbolically using bincode-encoded `Expr` arguments.

 This corresponds to the falling factorial \( P(n,k) = n! / (n-k)! \) when `n` and `k`
 are specialized to integers, but operates on general symbolic expressions.

 # Arguments

 * `n_buf` - Bincode buffer encoding an `Expr` representing the population size `n`.
 * `k_buf` - Bincode buffer encoding an `Expr` representing the selection size `k`.

 # Returns

 A bincode buffer encoding an `Expr` for the symbolic permutation count.

 # Safety

 This function is unsafe because it dereferences raw bincode buffers that must
 contain valid serialized `Expr` values.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_permutations(struct rssn_BincodeBuffer aNBuf,
                                                    struct rssn_BincodeBuffer aKBuf)
;

/*
 Compresses a point.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_point_compress(struct rssn_BincodeBuffer aPointBuf)
;

/*
 Decompresses a point.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_point_decompress(struct rssn_BincodeBuffer aXBuf,
                                                        struct rssn_BincodeBuffer aIsOddBuf,
                                                        struct rssn_BincodeBuffer aCurveBuf)
;

/*
 Adds two polynomials over a general finite field via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_add_gf(struct rssn_BincodeBuffer aP1Buf,
                                                   struct rssn_BincodeBuffer aP2Buf,
                                                   struct rssn_BincodeBuffer aModulusBuf)
;

/*
 Adds two polynomials over GF(2^8) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_add_gf256(struct rssn_BincodeBuffer aP1Buf,
                                                      struct rssn_BincodeBuffer aP2Buf)
;

/*
 Computes polynomial derivative over finite field (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_derivative_gf(struct rssn_BincodeBuffer aPolyBuf)
;

/*
 Divides a multivariate polynomial by a list of divisors under a given monomial order,
 returning the quotients and remainder via bincode serialization.

 # Arguments

 * `dividend_buf` - `BincodeBuffer` encoding the dividend `SparsePolynomial`.
 * `divisors_buf` - `BincodeBuffer` encoding `Vec<SparsePolynomial>` of divisors.
 * `order_buf` - `BincodeBuffer` encoding the [`MonomialOrder`] to use.

 # Returns

 A `BincodeBuffer` encoding `(Vec<SparsePolynomial>, SparsePolynomial)` containing
 the quotient polynomials and the remainder, or an empty buffer if deserialization
 fails or the division fails.

 # Safety

 This function is an FFI entry point; callers must treat the returned buffer as
 opaque and only pass it to compatible APIs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_division_multivariate(struct rssn_BincodeBuffer aDividendBuf,
                                                                  struct rssn_BincodeBuffer aDivisorsBuf,
                                                                  struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Evaluates a polynomial over GF(2^8) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_eval_gf256(struct rssn_BincodeBuffer aPolyBuf,
                                                       struct rssn_BincodeBuffer aXBuf)
;

/*
 Computes polynomial GCD over finite field (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_gcd_gf(struct rssn_BincodeBuffer aABuf,
                                                   struct rssn_BincodeBuffer aBBuf)
;

/*
 Multiplies two polynomials over a general finite field via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_mul_gf(struct rssn_BincodeBuffer aP1Buf,
                                                   struct rssn_BincodeBuffer aP2Buf,
                                                   struct rssn_BincodeBuffer aModulusBuf)
;

/*
 Multiplies two polynomials over GF(2^8) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_mul_gf256(struct rssn_BincodeBuffer aP1Buf,
                                                      struct rssn_BincodeBuffer aP2Buf)
;

/*
 Computes the polygamma function ψ⁽ⁿ⁾(z).

 Takes bincode-serialized `Expr` representing `n` and `z` as inputs,
 and returns a bincode-serialized `Expr` representing ψ⁽ⁿ⁾(z).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_polygamma(struct rssn_BincodeBuffer aNBuf,
                                                 struct rssn_BincodeBuffer aZBuf)
;

/*
 Checks if an expression contains a variable (bincode)
 */
rssn_
bool rssn_bincode_polynomial_contains_var(struct rssn_BincodeBuffer aExprBuf,
                                          const char *aVar)
;

/*
 Computes the degree of a polynomial (bincode)
 */
rssn_
int64_t rssn_bincode_polynomial_degree(struct rssn_BincodeBuffer aExprBuf,
                                       const char *aVar)
;

/*
 Checks if an expression is a polynomial in the given variable (bincode)
 */
rssn_
bool rssn_bincode_polynomial_is_polynomial(struct rssn_BincodeBuffer aExprBuf,
                                           const char *aVar)
;

/*
 Finds the leading coefficient of a polynomial (bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_polynomial_leading_coefficient(struct rssn_BincodeBuffer aExprBuf,
                                                                      const char *aVar)
;

/*
 Performs polynomial long division (bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_polynomial_long_division(struct rssn_BincodeBuffer aDividendBuf,
                                                                struct rssn_BincodeBuffer aDivisorBuf,
                                                                const char *aVar)
;

/*
 Performs a polynomial regression.

 Takes a bincode-serialized `Vec<(Expr, Expr)>` representing the data points
 and a `usize` for the degree of the polynomial.
 Returns a bincode-serialized `Vec<Expr>` containing the coefficients of the polynomial.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_polynomial_regression(struct rssn_BincodeBuffer aDataBuf,
                                                             size_t aDegree)
;

/*
 Converts polynomial to coefficient vector (bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_polynomial_to_coeffs_vec(struct rssn_BincodeBuffer aExprBuf,
                                                                const char *aVar)
;

/*
 Adds two prime field elements (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_prime_field_element_add(struct rssn_BincodeBuffer aABuf,
                                                               struct rssn_BincodeBuffer aBBuf)
;

/*
 Divides two prime field elements (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_prime_field_element_div(struct rssn_BincodeBuffer aABuf,
                                                               struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes the inverse of a prime field element (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_prime_field_element_inverse(struct rssn_BincodeBuffer aElemBuf)
;

/*
 Multiplies two prime field elements (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_prime_field_element_mul(struct rssn_BincodeBuffer aABuf,
                                                               struct rssn_BincodeBuffer aBBuf)
;

/*
 Creates a new prime field element (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_prime_field_element_new(struct rssn_BincodeBuffer aValueBuf,
                                                               struct rssn_BincodeBuffer aModulusBuf)
;

/*
 Subtracts two prime field elements (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_prime_field_element_sub(struct rssn_BincodeBuffer aABuf,
                                                               struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes the product of an expression.

 Takes bincode-serialized `Expr` (expression), `String` (variable),
 `Expr` (lower bound), and `Expr` (upper bound).
 Returns a bincode-serialized `Expr` representing the product.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_product(struct rssn_BincodeBuffer aExprBuf,
                                               struct rssn_BincodeBuffer aVarBuf,
                                               struct rssn_BincodeBuffer aLowerBuf,
                                               struct rssn_BincodeBuffer aUpperBuf)
;

/*
 Computes a propagator using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_qft_propagator(struct rssn_BincodeBuffer aPBuf,
                                                      struct rssn_BincodeBuffer aMBuf,
                                                      bool aIsFermion)
;

/*
 Generates a 3x3 2D reflection matrix via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_reflection_2d(struct rssn_BincodeBuffer aAngleBuf)
;

/*
 Generates a 4x4 3D reflection matrix via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_reflection_3d(struct rssn_BincodeBuffer aNxBuf,
                                                     struct rssn_BincodeBuffer aNyBuf,
                                                     struct rssn_BincodeBuffer aNzBuf)
;

/*
 Computes P(a, x) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_regularized_gamma_p(struct rssn_BincodeBuffer aABuf,
                                                           struct rssn_BincodeBuffer aXBuf)
;

/*
 Computes Q(a, x) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_regularized_gamma_q(struct rssn_BincodeBuffer aABuf,
                                                           struct rssn_BincodeBuffer aXBuf)
;

/*
 Computes Iₓ(a, b) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_regularized_incomplete_beta(struct rssn_BincodeBuffer aABuf,
                                                                   struct rssn_BincodeBuffer aBBuf,
                                                                   struct rssn_BincodeBuffer aXBuf)
;

/*
 Creates a group representation from a bincode-encoded description.

 A representation assigns linear operators to each group element, typically as
 matrices acting on a vector space.

 # Arguments

 * `buf` - `BincodeBuffer` containing a serialized [`Representation`].

 # Returns

 A `BincodeBuffer` containing the canonicalized `Representation`, or an empty
 buffer if deserialization fails.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point; callers
 must treat the returned buffer as opaque and only pass it to compatible APIs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_representation_create(struct rssn_BincodeBuffer aBuf)
;

/*
 Checks whether a representation is valid for a given group using bincode serialization.

 A representation is valid if it respects the group operation, i.e., the image
 of the group under the representation is a homomorphism.

 # Arguments

 * `rep_buf` - `BincodeBuffer` encoding a [`Representation`].
 * `group_buf` - `BincodeBuffer` encoding a [`Group`].

 # Returns

 `true` if the representation is valid for the group, `false` otherwise or if
 deserialization fails.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point; callers
 must ensure the buffers encode compatible objects.
 */
rssn_
bool rssn_bincode_representation_is_valid(struct rssn_BincodeBuffer aRepBuf,
                                          struct rssn_BincodeBuffer aGroupBuf)
;

/*
 Integrates an expression using the Risch-Norman algorithm (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_risch_norman_integrate(struct rssn_BincodeBuffer aExprBuf,
                                                              struct rssn_BincodeBuffer aXBuf)
;

/*
 Computes (x)ₙ via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_rising_factorial(struct rssn_BincodeBuffer aXBuf,
                                                        struct rssn_BincodeBuffer aNBuf)
;

/*
 Generates a 3x3 2D rotation matrix via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_rotation_2d(struct rssn_BincodeBuffer aAngleBuf)
;

/*
 Generates a 4x4 3D rotation matrix around X-axis via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_rotation_3d_x(struct rssn_BincodeBuffer aAngleBuf)
;

/*
 Generates a 4x4 3D rotation matrix around Y-axis via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_rotation_3d_y(struct rssn_BincodeBuffer aAngleBuf)
;

/*
 Generates a 4x4 3D rotation matrix around Z-axis via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_rotation_3d_z(struct rssn_BincodeBuffer aAngleBuf)
;

/*
 Generates a 4x4 3D rotation around arbitrary axis via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_rotation_axis_angle(struct rssn_BincodeBuffer aAxisXBuf,
                                                           struct rssn_BincodeBuffer aAxisYBuf,
                                                           struct rssn_BincodeBuffer aAxisZBuf,
                                                           struct rssn_BincodeBuffer aAngleBuf)
;

/*
 Checks if a Reed-Solomon codeword is valid via Bincode interface.
 Input: (codeword: Vec<u8>, n_sym: usize)
 Returns: bool
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_rs_check(struct rssn_BincodeBuffer aCodewordBuf,
                                                struct rssn_BincodeBuffer aNSymBuf)
;

/*
 Decodes a Reed-Solomon codeword via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_rs_decode(struct rssn_BincodeBuffer aCodewordBuf,
                                                 struct rssn_BincodeBuffer aNSymBuf)
;

/*
 Encodes data using Reed-Solomon code via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_rs_encode(struct rssn_BincodeBuffer aDataBuf,
                                                 struct rssn_BincodeBuffer aNSymBuf)
;

/*
 Estimates error count in a Reed-Solomon codeword via Bincode interface.
 Input: (codeword: Vec<u8>, n_sym: usize)
 Returns: usize
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_rs_error_count(struct rssn_BincodeBuffer aCodewordBuf,
                                                      struct rssn_BincodeBuffer aNSymBuf)
;

/*
 Lagrangian density for a scalar field using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_scalar_field_lagrangian(struct rssn_BincodeBuffer aPhiBuf,
                                                               struct rssn_BincodeBuffer aMBuf)
;

/*
 Generates a 3x3 2D scaling matrix via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_scaling_2d(struct rssn_BincodeBuffer aSxBuf,
                                                  struct rssn_BincodeBuffer aSyBuf)
;

/*
 Generates a 4x4 3D scaling matrix via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_scaling_3d(struct rssn_BincodeBuffer aSxBuf,
                                                  struct rssn_BincodeBuffer aSyBuf,
                                                  struct rssn_BincodeBuffer aSzBuf)
;

/*
 Calculates Schwarzschild radius using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_schwarzschild_radius(struct rssn_BincodeBuffer aMassBuf)
;

/*
 Computes the Shannon entropy of a probability distribution.

 Takes a bincode-serialized `Vec<Expr>` representing the probabilities.
 Returns a bincode-serialized `Expr` representing the entropy.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_shannon_entropy(struct rssn_BincodeBuffer aProbsBuf)
;

/*
 Generates a 3x3 2D shear matrix via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_shear_2d(struct rssn_BincodeBuffer aShxBuf,
                                                struct rssn_BincodeBuffer aShyBuf)
;

/*
 Performs a simple linear regression.

 Takes a bincode-serialized `Vec<(Expr, Expr)>` representing the data points.
 Returns a bincode-serialized `Vec<Expr>` containing the intercept and slope coefficients.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_simple_linear_regression(struct rssn_BincodeBuffer aDataBuf)
;

/*
 Creates a new Simplex (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_simplex_create(struct rssn_BincodeBuffer aVerticesBuf)
;

/*
 Gets the dimension of a Simplex (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_simplex_dimension(struct rssn_BincodeBuffer aSimplexBuf)
;

/*
 Adds a simplex to a SimplicialComplex (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_simplicial_complex_add_simplex(struct rssn_BincodeBuffer aComplexBuf,
                                                                      struct rssn_BincodeBuffer aVerticesBuf)
;

/*
 Applies the symbolic boundary operator to a SymbolicChain (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_simplicial_complex_apply_symbolic_boundary_operator(struct rssn_BincodeBuffer aComplexBuf,
                                                                                           struct rssn_BincodeBuffer aChainBuf)
;

/*
 Creates a new SimplicialComplex (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_simplicial_complex_create(void)
;

/*
 Gets the symbolic boundary matrix for dimension k (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_simplicial_complex_get_symbolic_boundary_matrix(struct rssn_BincodeBuffer aComplexBuf,
                                                                                       size_t aK)
;

/*
 Simplifies an expression using the legacy simplifier (Bincode input/output).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_simplify(struct rssn_BincodeBuffer aExprBuf)
;

/*
 Simplifies an expression using the DAG-based simplifier (Bincode input/output).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_simplify_dag(struct rssn_BincodeBuffer aExprBuf)
;

/*
 Simplifies a logical expression using bincode-based FFI.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_simplify_logic(struct rssn_BincodeBuffer aExprBuf)
;

/*
 Simplifies radical expressions (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_simplify_radicals(struct rssn_BincodeBuffer aExprBuf)
;

/*
 Computes sinc(x) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_sinc(struct rssn_BincodeBuffer aValBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_so3_generators(void)
;

/*
 Solves an equation for a given variable.

 Takes bincode-serialized `Expr` (equation) and `String` (variable).
 Returns a bincode-serialized `Expr` representing the solution.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve(struct rssn_BincodeBuffer aExprBuf,
                                             struct rssn_BincodeBuffer aVarBuf)
;

/*
 Solves a Bernoulli ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_bernoulli_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                           const char *aFunc,
                                                           const char *aVar)
;

/*
 Solves by reduction of order using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_by_reduction_of_order(struct rssn_BincodeBuffer aEquationBuf,
                                                                   const char *aFunc,
                                                                   const char *aVar,
                                                                   struct rssn_BincodeBuffer aY1Buf)
;

/*
 Solves a Cauchy-Euler ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_cauchy_euler_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                              const char *aFunc,
                                                              const char *aVar)
;

/*
 Solves a Diophantine equation.

 Takes bincode-serialized `Expr` representing the equation and `Vec<String>`
 representing variables. Returns a bincode-serialized `Vec<Expr>` of solutions.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_diophantine(struct rssn_BincodeBuffer aEquationBuf,
                                                         struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Generates and attempts to solve the Euler-Lagrange equation using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_euler_lagrange(struct rssn_BincodeBuffer aLagrangianBuf,
                                                            const char *aFunc,
                                                            const char *aVar)
;

/*
 Solves an exact ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_exact_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                       const char *aFunc,
                                                       const char *aVar)
;

/*
 Solves a first-order linear ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_first_order_linear_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                                    const char *aFunc,
                                                                    const char *aVar)
;

/*
 Solves the 1D heat equation (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_heat_equation_1d(struct rssn_BincodeBuffer aEquationBuf,
                                                              const char *aFunc,
                                                              struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves the 2D Laplace equation (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_laplace_equation_2d(struct rssn_BincodeBuffer aEquationBuf,
                                                                 const char *aFunc,
                                                                 struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves a linear system of equations.

 Takes bincode-serialized `Expr` (system) and `Vec<String>` (variables).
 Returns a bincode-serialized `Expr` representing the solution.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_linear_system(struct rssn_BincodeBuffer aSystemBuf,
                                                           struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves an ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_ode(struct rssn_BincodeBuffer aOdeBuf,
                                                 const char *aFunc,
                                                 const char *aVar)
;

/*
 Solves a PDE using Bincode with automatic method selection.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_pde(struct rssn_BincodeBuffer aPdeBuf,
                                                 const char *aFunc,
                                                 struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves a PDE using the method of characteristics (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_pde_by_characteristics(struct rssn_BincodeBuffer aEquationBuf,
                                                                    const char *aFunc,
                                                                    struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves a Riccati ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_riccati_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                         const char *aFunc,
                                                         const char *aVar,
                                                         struct rssn_BincodeBuffer aY1Buf)
;

/*
 Solves a separable ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_separable_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                           const char *aFunc,
                                                           const char *aVar)
;

/*
 Solves a system of equations for given variables.

 Takes bincode-serialized `Vec<Expr>` (equations) and `Vec<String>` (variables).
 Returns a bincode-serialized `Expr` representing the solution.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_system(struct rssn_BincodeBuffer aEquationsBuf,
                                                    struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves the 1D wave equation (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_wave_equation_1d(struct rssn_BincodeBuffer aEquationBuf,
                                                              const char *aFunc,
                                                              struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Computes square-free factorization (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_square_free_factorization_gf(struct rssn_BincodeBuffer aPolyBuf)
;

/*
 Computes the symbolic standard deviation of a set of expressions using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_std_dev(struct rssn_BincodeBuffer aDataBuf)
;

/*
 Computes a Stirling number of the second kind symbolically and returns it via bincode.

 Stirling numbers of the second kind \( S(n,k) \) count partitions of an \(n\)-element
 set into \(k\) non-empty unlabeled blocks.

 # Arguments

 * `n` - Total number of elements.
 * `k` - Number of non-empty blocks.

 # Returns

 A bincode buffer encoding an `Expr` for \( S(n,k) \).

 # Safety

 This function is unsafe because it is exposed as an FFI entry point, but it does
 not dereference raw pointers.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_stirling_number_second_kind(size_t aN,
                                                                   size_t aK)
;

/*
 Represents Stokes' theorem (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_stokes_theorem(struct rssn_BincodeBuffer aVectorFieldBuf,
                                                      struct rssn_BincodeBuffer aSurfaceBuf)
;

/*
 Generates the Sturm sequence for a given polynomial (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_sturm_sequence(struct rssn_BincodeBuffer aExprBuf,
                                                      const char *aVarPtr)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_su2_generators(void)
;

/*
 Substitutes using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_substitute(struct rssn_BincodeBuffer aExprBuf,
                                                  const char *aVar,
                                                  struct rssn_BincodeBuffer aReplacementBuf)
;

/*
 Computes the summation of an expression.

 Takes bincode-serialized `Expr` (expression), `String` (variable),
 `Expr` (lower bound), and `Expr` (upper bound).
 Returns a bincode-serialized `Expr` representing the summation.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_summation(struct rssn_BincodeBuffer aExprBuf,
                                                 struct rssn_BincodeBuffer aVarBuf,
                                                 struct rssn_BincodeBuffer aLowerBuf,
                                                 struct rssn_BincodeBuffer aUpperBuf)
;

/*
 Adds a term to a SymbolicChain (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_symbolic_chain_add_term(struct rssn_BincodeBuffer aChainBuf,
                                                               struct rssn_BincodeBuffer aSimplexBuf,
                                                               struct rssn_BincodeBuffer aCoeffBuf)
;

/*
 Creates a new SymbolicChain (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_symbolic_chain_create(size_t aDimension)
;

/*
 Creates a symmetric group of degree `n` and returns it as a Bincode buffer.

 # Arguments
 * `n` - The number of symbols the group acts on.

 # Returns
 A `BincodeBuffer` containing the serialized representation of the group, or an empty buffer if `n` is invalid.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_symmetric_group_create(size_t aN)
;

/*
 Computes the Taylor series expansion of an expression.

 Takes bincode-serialized `Expr` (expression), `String` (variable),
 `Expr` (center), and `usize` (order).
 Returns a bincode-serialized `Expr` representing the Taylor series.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_taylor_series(struct rssn_BincodeBuffer aExprBuf,
                                                     struct rssn_BincodeBuffer aVarBuf,
                                                     struct rssn_BincodeBuffer aCenterBuf,
                                                     struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Performs tensor addition.

 Takes two bincode-serialized `Tensor` objects as input,
 and returns a bincode-serialized `Tensor` representing their sum.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_tensor_add(struct rssn_BincodeBuffer aT1Buf,
                                                  struct rssn_BincodeBuffer aT2Buf)
;

/*
 Computes the outer product of two tensors.

 Takes two bincode-serialized `Tensor` objects as input,
 and returns a bincode-serialized `Tensor` representing their outer product.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_tensor_outer_product(struct rssn_BincodeBuffer aT1Buf,
                                                            struct rssn_BincodeBuffer aT2Buf)
;

/*
 Performs scalar multiplication on a tensor.

 Takes a bincode-serialized `Tensor` and a bincode-serialized `Expr` (scalar).
 Returns a bincode-serialized `Tensor` representing the result.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_tensor_scalar_mul(struct rssn_BincodeBuffer aTBuf,
                                                         struct rssn_BincodeBuffer aScalarBuf)
;

/*
 Converts a logical expression to Conjunctive Normal Form (CNF) using bincode-based FFI.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_to_cnf(struct rssn_BincodeBuffer aExprBuf)
;

/*
 Converts a logical expression to Disjunctive Normal Form (DNF) using bincode-based FFI.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_to_dnf(struct rssn_BincodeBuffer aExprBuf)
;

/*
 Transforms a contravariant vector from one coordinate system to another using bincode-serialized inputs.

 Takes `BincodeBuffer`s for the vector components (`Vec<Expr>`), the source `CoordinateSystem`,
 and the target `CoordinateSystem`.
 Returns a `BincodeBuffer` containing the transformed contravariant vector components (`Vec<Expr>`).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_contravariant_vector(struct rssn_BincodeBuffer aCompsBuf,
                                                                      struct rssn_BincodeBuffer aFromBuf,
                                                                      struct rssn_BincodeBuffer aToBuf)
;

/*
 Transforms a covariant vector from one coordinate system to another using bincode-serialized inputs.

 Takes `BincodeBuffer`s for the vector components (`Vec<Expr>`), the source `CoordinateSystem`,
 and the target `CoordinateSystem`.
 Returns a `BincodeBuffer` containing the transformed covariant vector components (`Vec<Expr>`).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_covariant_vector(struct rssn_BincodeBuffer aCompsBuf,
                                                                  struct rssn_BincodeBuffer aFromBuf,
                                                                  struct rssn_BincodeBuffer aToBuf)
;

/*
 Transforms the curl of a vector field from one coordinate system to another using bincode-serialized inputs.

 Takes `BincodeBuffer`s for the vector components (`Vec<Expr>`) and the source `CoordinateSystem`.
 Returns a `BincodeBuffer` containing the transformed curl (`Vec<Expr>`).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_curl(struct rssn_BincodeBuffer aCompsBuf,
                                                      struct rssn_BincodeBuffer aFromBuf)
;

/*
 Transforms the divergence of a vector field from one coordinate system to another using bincode-serialized inputs.

 Takes `BincodeBuffer`s for the vector components (`Vec<Expr>`) and the source `CoordinateSystem`.
 Returns a `BincodeBuffer` containing the transformed divergence (`Expr`).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_divergence(struct rssn_BincodeBuffer aCompsBuf,
                                                            struct rssn_BincodeBuffer aFromBuf)
;

/*
 Transforms an expression from one coordinate system to another using bincode-serialized inputs.

 Takes `BincodeBuffer`s for the expression (`Expr`), the source `CoordinateSystem`,
 and the target `CoordinateSystem`.
 Returns a `BincodeBuffer` containing the transformed expression (`Expr`).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_expression(struct rssn_BincodeBuffer aExprBuf,
                                                            struct rssn_BincodeBuffer aFromBuf,
                                                            struct rssn_BincodeBuffer aToBuf)
;

/*
 Transforms the gradient of a scalar function from one coordinate system to another using bincode-serialized inputs.

 Takes `BincodeBuffer`s for the scalar function (`Expr`), the variables (`Vec<String>`),
 the source `CoordinateSystem`, and the target `CoordinateSystem`.
 Returns a `BincodeBuffer` containing the transformed gradient (`Vec<Expr>`).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_gradient(struct rssn_BincodeBuffer aScalarBuf,
                                                          struct rssn_BincodeBuffer aVarsBuf,
                                                          struct rssn_BincodeBuffer aFromBuf,
                                                          struct rssn_BincodeBuffer aToBuf)
;

/*
 Transforms a point from one coordinate system to another using bincode-serialized inputs.

 Takes `BincodeBuffer`s for the point (`Vec<Expr>`), the source `CoordinateSystem`,
 and the target `CoordinateSystem`.
 Returns a `BincodeBuffer` containing the transformed point (`Vec<Expr>`).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_point(struct rssn_BincodeBuffer aPointBuf,
                                                       struct rssn_BincodeBuffer aFromBuf,
                                                       struct rssn_BincodeBuffer aToBuf)
;

/*
 Generates a 3x3 2D translation matrix via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_translation_2d(struct rssn_BincodeBuffer aTxBuf,
                                                      struct rssn_BincodeBuffer aTyBuf)
;

/*
 Generates a 4x4 3D translation matrix via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_translation_3d(struct rssn_BincodeBuffer aTxBuf,
                                                      struct rssn_BincodeBuffer aTyBuf,
                                                      struct rssn_BincodeBuffer aTzBuf)
;

/*
 Performs a two-sample t-test.

 Takes bincode-serialized `Vec<Expr>` (two data sets) and `Expr` (hypothesized difference in means).
 Returns a bincode-serialized `HypothesisTest` representing the test result.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_two_sample_t_test(struct rssn_BincodeBuffer aData1Buf,
                                                         struct rssn_BincodeBuffer aData2Buf,
                                                         struct rssn_BincodeBuffer aMuDiffBuf)
;

/*
 Computes the uncertainty using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_uncertainty(struct rssn_BincodeBuffer aOpBuf,
                                                   struct rssn_BincodeBuffer aPsiBuf)
;

/*
 Unifies the units in a symbolic expression.

 Takes a bincode-serialized `Expr` as input,
 and returns a bincode-serialized `Expr` representing the expression with unified units.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_unify_expression(struct rssn_BincodeBuffer aExprBuf)
;

/*
 Computes the symbolic variance of a set of expressions using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_variance(struct rssn_BincodeBuffer aDataBuf)
;

/*
 Computes the cross product of two vectors.

 Takes two bincode-serialized `Vector` objects as input.
 Returns a bincode-serialized `Vector` representing their cross product.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_vector_cross(struct rssn_BincodeBuffer aV1Buf,
                                                    struct rssn_BincodeBuffer aV2Buf)
;

/*
 Computes the dot product of two vectors.

 Takes two bincode-serialized `Vector` objects as input.
 Returns a bincode-serialized `Expr` representing their dot product.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_vector_dot(struct rssn_BincodeBuffer aV1Buf,
                                                  struct rssn_BincodeBuffer aV2Buf)
;

/*
 Computes the magnitude of a vector.

 Takes a bincode-serialized `Vector` as input.
 Returns a bincode-serialized `Expr` representing its magnitude.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_vector_magnitude(struct rssn_BincodeBuffer aVBuf)
;

/*
 Normalizes a vector.

 Takes a bincode-serialized `Vector` as input.
 Returns a bincode-serialized `Vector` representing the normalized vector.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_vector_normalize(struct rssn_BincodeBuffer aVBuf)
;

/*
 Verifies an equation solution using Bincode.
 */
rssn_
bool rssn_bincode_verify_equation_solution(struct rssn_BincodeBuffer aEquationsBuf,
                                           struct rssn_BincodeBuffer aSolutionBuf,
                                           struct rssn_BincodeBuffer aFreeVarsBuf)
;

/*
 Verifies an indefinite integral using Bincode.
 */
rssn_
bool rssn_bincode_verify_indefinite_integral(struct rssn_BincodeBuffer aIntegrandBuf,
                                             struct rssn_BincodeBuffer aIntegralResultBuf,
                                             struct rssn_BincodeBuffer aVarBuf)
;

/*
 Computes the wedge product of two differential forms (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_wedge_product(struct rssn_BincodeBuffer aForm1Buf,
                                                     struct rssn_BincodeBuffer aForm2Buf)
;

/*
 Applies the differentiation property of the Z-transform.

 Takes bincode-serialized `Expr` (z-domain expression) and `String` (output variable).
 Returns a bincode-serialized `Expr` representing the transformed expression.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_z_differentiation(struct rssn_BincodeBuffer aFZBuf,
                                                         struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Applies the scaling property of the Z-transform.

 Takes bincode-serialized `Expr` (z-domain expression), `Expr` (scaling factor `a`),
 and `String` (output variable).
 Returns a bincode-serialized `Expr` representing the transformed expression.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_z_scaling(struct rssn_BincodeBuffer aFZBuf,
                                                 struct rssn_BincodeBuffer aABuf,
                                                 struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Performs a z-test.

 Takes bincode-serialized `Vec<Expr>` (data), `Expr` (target mean), and `Expr` (population standard deviation).
 Returns a bincode-serialized `HypothesisTest` representing the test result.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_z_test(struct rssn_BincodeBuffer aDataBuf,
                                              struct rssn_BincodeBuffer aTargetMeanBuf,
                                              struct rssn_BincodeBuffer aPopStdDevBuf)
;

/*
 Applies the time shift property of the Z-transform.

 Takes bincode-serialized `Expr` (z-domain expression), `Expr` (time shift amount `k`),
 and `String` (output variable).
 Returns a bincode-serialized `Expr` representing the transformed expression.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_z_time_shift(struct rssn_BincodeBuffer aFZBuf,
                                                    struct rssn_BincodeBuffer aKBuf,
                                                    struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Computes the Z-transform of an expression.

 Takes bincode-serialized `Expr` (expression), `String` (input variable), and `String` (output variable).
 Returns a bincode-serialized `Expr` representing the Z-transform.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_z_transform(struct rssn_BincodeBuffer aExprBuf,
                                                   struct rssn_BincodeBuffer aInVarBuf,
                                                   struct rssn_BincodeBuffer aOutVarBuf)
;

/*
 Computes the Riemann zeta function ζ(s).

 Takes a bincode-serialized `Expr` representing `s` as input,
 and returns a bincode-serialized `Expr` representing ζ(s).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_zeta(struct rssn_BincodeBuffer aArgBuf)
;

/*
 Computes ζ(s) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_zeta_numerical(struct rssn_BincodeBuffer aValBuf)
;

/*
 Computes the binomial coefficient C(n, k).
 */
rssn_
uint64_t rssn_binomial(uint64_t aN,
                       uint64_t aK)
;

/*
 Computes binomial coefficient C(n, k).
 */
rssn_
char *rssn_binomial_coefficient(size_t aN,
                                size_t aK)
;

/*
 Computes binomial coefficient C(n, k) and returns as JSON string.
 */
rssn_
char *rssn_binomial_coefficient_json(size_t aN,
                                     size_t aK)
;

/*
 Calculates Boltzmann Distribution.
 */
rssn_
struct rssn_Expr *rssn_boltzmann_distribution(const struct rssn_Expr *aEnergy,
                                              const struct rssn_Expr *aTemperature,
                                              const struct rssn_Expr *aPartitionFunction)
;

/*
 Computes the boundary of a domain (Handle)
 */
rssn_
struct rssn_Expr *rssn_boundary_handle(const struct rssn_Expr *aDomainPtr)
;

/*
 Frees a Bra.
 */
rssn_
void rssn_bra_free(struct rssn_Bra *aBra)
;

/*
 Computes the inner product <Bra|Ket>.
 */
rssn_
struct rssn_Expr *rssn_bra_ket(const struct rssn_Bra *aBra,
                               const struct rssn_Ket *aKet)
;

/*
 Creates a new Bra from a state expression.
 */
rssn_
struct rssn_Bra *rssn_bra_new(const struct rssn_Expr *aState)
;

/*
 Computes a Gröbner basis using Buchberger's algorithm and returns it as a heap-allocated vector handle.

 # Arguments

 * `basis` - Pointer to a `Vec<SparsePolynomial>` representing the initial basis.
 * `order` - [`MonomialOrder`] specifying the term ordering.

 # Returns

 A pointer to a heap-allocated `Vec<SparsePolynomial>` representing a Gröbner
 basis, or null if the computation fails.

 # Safety

 This function is unsafe because it dereferences a raw pointer and returns
 ownership of a heap-allocated vector that must be freed by the caller.
 */
rssn_
struct rssn_Vec_SparsePolynomial *rssn_buchberger_handle(const struct rssn_Vec_SparsePolynomial *aBasis,
                                                         enum rssn_MonomialOrder aOrder)
;

/*
 Gets the number of cells in a CAD.
 */
rssn_
size_t rssn_cad_get_cell_count(const struct rssn_Cad *aPtr)
;

/*
 Computes CAD for a set of polynomials (Handle).

 Expects an array of Expr handles (which must be SparsePolynomial variants)
 and an array of variable name strings.
 */
rssn_
struct rssn_Cad *rssn_cad_handle(const struct rssn_Expr *const *aPolys,
                                 size_t aPolysCount,
                                 const char *const *aVars,
                                 size_t aVarsCount)
;

/*
 Calculates the residue of a complex function at a given pole.
 */
rssn_
struct rssn_Expr *rssn_calculate_residue(const struct rssn_Expr *aExpr,
                                         const char *aVar,
                                         const struct rssn_Expr *aPole)
;

/*
 Computes the definite integral of an expression using handles.

 # Safety
 * `var` must be a valid null-terminated C string.
 * `result_h` must be a valid pointer to store the resulting handle.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_calculus_definite_integrate(size_t aExprH,
                                         const char *aVar,
                                         size_t aLowerH,
                                         size_t aUpperH,
                                         size_t *aResultH)
;

/*
 Differentiates an expression with respect to a variable using handles.

 # Safety
 * `var` must be a valid null-terminated C string.
 * `result_h` must be a valid pointer to store the resulting handle.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_calculus_differentiate(size_t aExprH,
                                    const char *aVar,
                                    size_t *aResultH)
;

/*
 Integrates an expression with respect to a variable using handles (indefinite).

 # Safety
 * `var` must be a valid null-terminated C string.
 * `result_h` must be a valid pointer to store the resulting handle.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_calculus_integrate(size_t aExprH,
                                const char *aVar,
                                size_t *aResultH)
;

/*
 Computes the limit of an expression as a variable approaches a value using handles.

 # Safety
 * `var` must be a valid null-terminated C string.
 * `result_h` must be a valid pointer to store the resulting handle.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_calculus_limit(size_t aExprH,
                            const char *aVar,
                            size_t aToH,
                            size_t *aResultH)
;

/*
 Substitutes a variable with another expression in an expression using handles.

 # Safety
 * `var` must be a valid null-terminated C string.
 * `result_h` must be a valid pointer to store the resulting handle.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_calculus_substitute(size_t aExprH,
                                 const char *aVar,
                                 size_t aReplacementH,
                                 size_t *aResultH)
;

/*
 Calculates Carnot Efficiency: 1 - Tc/Th.
 */
rssn_
struct rssn_Expr *rssn_carnot_efficiency(const struct rssn_Expr *aTc,
                                         const struct rssn_Expr *aTh)
;

/*
 Expands an expression using algebraic rules.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_
struct rssn_Expr *rssn_cas_expand(const struct rssn_Expr *aExpr)
;

/*
 Expands an expression using algebraic rules (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_cas_expand_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Expands an expression using algebraic rules (JSON).
 */
rssn_
char *rssn_cas_expand_json(const char *aJsonStr)
;

/*
 Factorizes an expression.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_
struct rssn_Expr *rssn_cas_factorize(const struct rssn_Expr *aExpr)
;

/*
 Factorizes an expression (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_cas_factorize_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Factorizes an expression (JSON).
 */
rssn_
char *rssn_cas_factorize_json(const char *aJsonStr)
;

/*
 Normalizes an expression to a canonical form.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_
struct rssn_Expr *rssn_cas_normalize(const struct rssn_Expr *aExpr)
;

/*
 Normalizes an expression to a canonical form (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_cas_normalize_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Normalizes an expression to a canonical form (JSON).
 */
rssn_
char *rssn_cas_normalize_json(const char *aJsonStr)
;

/*
 Simplifies an expression using a set of polynomial side-relations.

 # Arguments
 * `expr` - The expression to simplify.
 * `relations` - Array of pointers to relation expressions (e.g., `x^2 + y^2 - 1`).
 * `relations_len` - Number of relations.
 * `vars` - Array of C strings representing variable ordering.
 * `vars_len` - Number of variables.
 * `order_int` - Monomial ordering: 0=Lex, 1=GradedLex, 2=GradedReverseLex.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_cas_simplify_with_relations(const struct rssn_Expr *aExpr,
                                                   const struct rssn_Expr *const *aRelations,
                                                   size_t aRelationsLen,
                                                   const char *const *aVars,
                                                   size_t aVarsLen,
                                                   int32_t aOrderInt)
;

/*
 Simplifies an expression using a set of polynomial side-relations (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_cas_simplify_with_relations_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Simplifies an expression using a set of polynomial side-relations (JSON).
 */
rssn_
char *rssn_cas_simplify_with_relations_json(const char *aJsonStr)
;

/*
 Computes the \(n\)-th Catalan number symbolically and returns it as an `Expr` pointer.

 Catalan numbers count many combinatorial structures, such as full binary trees,
 Dyck paths, and non-crossing partitions.

 # Arguments

 * `n` - Index of the Catalan number to compute.

 # Returns

 A newly allocated `Expr` pointer representing the \(n\)-th Catalan number.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point and returns
 ownership of a heap-allocated `Expr` to the caller.
 */
rssn_
struct rssn_Expr *rssn_catalan_number(size_t aN)
;

rssn_
void rssn_character(const struct rssn_Representation *aRep,
                    size_t *aOutLen,
                    struct rssn_Expr ***aOutKeys,
                    struct rssn_Expr ***aOutValues)
;

/*
 Constructs Chebyshev's differential equation: (1-x²)y'' - xy' + n²y = 0.
 */
rssn_
struct rssn_Expr *rssn_chebyshev_differential_equation(const struct rssn_Expr *aY,
                                                       const struct rssn_Expr *aX,
                                                       const struct rssn_Expr *aN)
;

/*
 Computes the symbolic Chebyshev polynomial of the first kind T_n(x).
 */
rssn_
struct rssn_Expr *rssn_chebyshev_t(const struct rssn_Expr *aN,
                                   const struct rssn_Expr *aX)
;

/*
 Computes the symbolic Chebyshev polynomial of the second kind U_n(x).
 */
rssn_
struct rssn_Expr *rssn_chebyshev_u(const struct rssn_Expr *aN,
                                   const struct rssn_Expr *aX)
;

/*
 Checks if an expression is analytic with respect to a variable.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `var` is a valid C string.
 */
rssn_
bool rssn_check_analytic(const struct rssn_Expr *aExpr,
                         const char *aVar)
;

rssn_
bool rssn_check_jacobi_identity(const struct rssn_LieAlgebra *aAlgebra)
;

/*
 Solves a system of congruences using the Chinese Remainder Theorem.

 # Safety
 `remainders` and `moduli` must be valid pointers to arrays of `Expr` pointers of length `len`.
 */
rssn_
struct rssn_Expr *rssn_chinese_remainder_handle(const struct rssn_Expr *const *aRemainders,
                                                const struct rssn_Expr *const *aModuli,
                                                int aLen)
;

/*
 Finds the chromatic number exactly (NP-hard).
 */
rssn_
size_t rssn_chromatic_number_exact(const struct rssn_RssnGraph *aGraph)
;

/*
 Computes the number of combinations (nCk).

 # Arguments
 * `n` - The total number of items.
 * `k` - The number of items to choose.
 * `result` - A pointer to store the computed number of combinations.

 # Returns
 0 on success, -1 on error (e.g., null pointer).

 # Safety
 The `result` pointer must point to a valid f64 location.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_comb_combinations(uint64_t aN,
                               uint64_t aK,
                               double *aResult)
;

/*
 Computes the factorial of a number `n`.

 # Arguments
 * `n` - The number to compute the factorial of.
 * `result` - A pointer to store the computed factorial.

 # Returns
 0 on success, -1 on error (e.g., null pointer).

 # Safety
 The `result` pointer must point to a valid f64 location.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_comb_factorial(uint64_t aN,
                            double *aResult)
;

/*
 Computes the number of permutations (nPk).

 # Arguments
 * `n` - The total number of items.
 * `k` - The number of items to choose.
 * `result` - A pointer to store the computed number of permutations.

 # Returns
 0 on success, -1 on error (e.g., null pointer).

 # Safety
 The `result` pointer must point to a valid f64 location.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_comb_permutations(uint64_t aN,
                               uint64_t aK,
                               double *aResult)
;

/*
 Computes the number of combinations symbolically as an `Expr`.

 This corresponds to the binomial coefficient \( C(n,k) = n! / (k!(n-k)!) \) for
 integer `n` and `k`, but also supports symbolic `Expr` arguments.

 # Arguments

 * `n` - Pointer to an `Expr` representing the population size.
 * `k` - Pointer to an `Expr` representing the selection size.

 # Returns

 A newly allocated `Expr` pointer representing the symbolic combination count.

 # Safety

 This function is unsafe because it dereferences raw `Expr` pointers and returns
 ownership of a heap-allocated `Expr` to the caller.
 */
rssn_
struct rssn_Expr *rssn_combinations(const struct rssn_Expr *aN,
                                    const struct rssn_Expr *aK)
;

/*
 Computes the commutator [A, B] acting on a Ket.
 */
rssn_
struct rssn_Expr *rssn_commutator(const struct rssn_Operator *aA,
                                  const struct rssn_Operator *aB,
                                  const struct rssn_Ket *aKet)
;

rssn_
struct rssn_Expr **rssn_commutator_table(const struct rssn_LieAlgebra *aAlgebra,
                                         size_t *aOutRows,
                                         size_t *aOutCols)
;

/*
 Finds fixed points (Handle)
 */
rssn_
struct rssn_Expr **rssn_complex_system_fixed_points(const struct rssn_ComplexDynamicalSystem *aSystemPtr,
                                                    size_t *aOutLen)
;

/*
 Frees a ComplexDynamicalSystem handle
 */
rssn_
void rssn_complex_system_free(struct rssn_ComplexDynamicalSystem *aPtr)
;

/*
 Iterates the system once (Handle)
 */
rssn_
struct rssn_Expr *rssn_complex_system_iterate(const struct rssn_ComplexDynamicalSystem *aSystemPtr,
                                              const struct rssn_Expr *aZPtr)
;

/*
 Creates a new Mandelbrot family system (Handle)
 */
rssn_
struct rssn_ComplexDynamicalSystem *rssn_complex_system_new_mandelbrot(const struct rssn_Expr *aCPtr)
;

/*
 Clears a ComputationResultCache.
 */
rssn_
void rssn_computation_result_cache_clear(struct rssn_ComputationResultCache *aCache)
;

/*
 Frees a ComputationResultCache.
 */
rssn_
void rssn_computation_result_cache_free(struct rssn_ComputationResultCache *aCache)
;

/*
 Retrieves a value from the ComputationResultCache.
 Returns a C string (char*) which must be freed by the caller using rssn_free_string.
 Returns null if not found.
 */
rssn_
char *rssn_computation_result_cache_get(struct rssn_ComputationResultCache *aCache,
                                        const struct rssn_Expr *aExpr)
;

/*
 Retrieves a value from the ComputationResultCache using a bincode expression key.
 */
rssn_
struct rssn_BincodeBuffer rssn_computation_result_cache_get_bincode(struct rssn_ComputationResultCache *aCache,
                                                                    struct rssn_BincodeBuffer aExprBuffer)
;

/*
 Retrieves a value from the ComputationResultCache using a JSON expression key.
 Returns the value as a JSON string (e.g. "\"result\"").
 */
rssn_
char *rssn_computation_result_cache_get_json(struct rssn_ComputationResultCache *aCache,
                                             const char *aJsonExpr)
;

/*
 Creates a new ComputationResultCache.
 The caller is responsible for freeing the memory using rssn_computation_result_cache_free.
 */
rssn_
struct rssn_ComputationResultCache *rssn_computation_result_cache_new(void)
;

/*
 Stores a value in the ComputationResultCache.
 */
rssn_
void rssn_computation_result_cache_set(struct rssn_ComputationResultCache *aCache,
                                       const struct rssn_Expr *aExpr,
                                       const char *aValue)
;

/*
 Stores a value in the ComputationResultCache using bincode buffers.
 */
rssn_
void rssn_computation_result_cache_set_bincode(struct rssn_ComputationResultCache *aCache,
                                               struct rssn_BincodeBuffer aExprBuffer,
                                               struct rssn_BincodeBuffer aValueBuffer)
;

/*
 Stores a value in the ComputationResultCache using JSON strings.
 */
rssn_
void rssn_computation_result_cache_set_json(struct rssn_ComputationResultCache *aCache,
                                            const char *aJsonExpr,
                                            const char *aJsonValue)
;

/*
 Computes the conditional entropy of a joint probability distribution.

 Takes a raw pointer to an `Expr` representing the joint probability distribution.
 Returns a raw pointer to an `Expr` representing the conditional entropy.
 */
rssn_
struct rssn_Expr *rssn_conditional_entropy(const struct rssn_Expr *aJointProbs)
;

/*
 Applies Aitken's acceleration to the input sequence.

 # Arguments
 * `data` - Pointer to the input sequence array.
 * `len` - Length of the input sequence.

 # Returns
 A pointer to a new `Vec<f64>` containing the accelerated sequence, or null on error.
 */
rssn_
struct rssn_Vec_f64 *rssn_convergence_aitken(const double *aData,
                                             size_t aLen)
;

/*
 Bincode FFI for Aitken acceleration.
 */
rssn_
struct rssn_BincodeBuffer rssn_convergence_aitken_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for Aitken acceleration.
 */
rssn_
char *rssn_convergence_aitken_json(const char *aJsonPtr)
;

/*
 Frees a generic `Vec<f64>` pointer created by convergence functions.
 */
rssn_
void rssn_convergence_free_vec(struct rssn_Vec_f64 *aVec)
;

/*
 Copies the vector data into a provided buffer.
 buffer must have size at least `len * sizeof(f64)`.
 */
rssn_
void rssn_convergence_get_vec_data(const struct rssn_Vec_f64 *aVec,
                                   double *aBuffer)
;

/*
 Returns the length of the vector.
 */
rssn_
size_t rssn_convergence_get_vec_len(const struct rssn_Vec_f64 *aVec)
;

/*
 Applies Richardson extrapolation to the input sequence.

 # Arguments
 * `data` - Pointer to the input sequence array (assumed approximations with halving steps).
 * `len` - Length of the input sequence.

 # Returns
 A pointer to a new `Vec<f64>` containing the extrapolated sequence, or null on error.
 */
rssn_
struct rssn_Vec_f64 *rssn_convergence_richardson(const double *aData,
                                                 size_t aLen)
;

/*
 Bincode FFI for Richardson extrapolation.
 */
rssn_
struct rssn_BincodeBuffer rssn_convergence_richardson_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for Richardson extrapolation.
 */
rssn_
char *rssn_convergence_richardson_json(const char *aJsonPtr)
;

/*
 Applies Wynn's epsilon algorithm to the input sequence.

 # Arguments
 * `data` - Pointer to the input sequence array.
 * `len` - Length of the input sequence.

 # Returns
 A pointer to a new `Vec<f64>` containing the accelerated sequence, or null on error.
 */
rssn_
struct rssn_Vec_f64 *rssn_convergence_wynn(const double *aData,
                                           size_t aLen)
;

/*
 Bincode FFI for Wynn's epsilon algorithm.
 */
rssn_
struct rssn_BincodeBuffer rssn_convergence_wynn_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for Wynn's epsilon algorithm.
 */
rssn_
char *rssn_convergence_wynn_json(const char *aJsonPtr)
;

/*
 Computes the convolution of two expressions in the Fourier domain.

 # Safety
 Caller must ensure `f` and `g` are valid pointers to an `Expr`.
 `in_var` and `out_var` must be valid C strings or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_convolution_fourier(const struct rssn_Expr *aF,
                                           const struct rssn_Expr *aG,
                                           const char *aInVar,
                                           const char *aOutVar)
;

/*
 Computes the convolution of two expressions in the Laplace domain.

 # Safety
 Caller must ensure `f` and `g` are valid pointers to an `Expr`.
 `in_var` and `out_var` must be valid C strings or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_convolution_laplace(const struct rssn_Expr *aF,
                                           const struct rssn_Expr *aG,
                                           const char *aInVar,
                                           const char *aOutVar)
;

/*
 Returns the metric tensor for a given coordinate system as a symbolic expression.

 The metric tensor encodes the inner product and volume element for the coordinate
 system, and is typically represented as a matrix-valued `Expr`.

 # Arguments

 * `system` - [`CoordinateSystem`] for which to compute the metric tensor.

 # Returns

 A newly allocated `Expr` pointer representing the metric tensor, or null on failure.

 # Safety

 This function is unsafe at the FFI boundary; the returned pointer must be eventually
 freed by the caller using the appropriate deallocation routine.
 */
rssn_
struct rssn_Expr *rssn_coordinates_get_metric_tensor_handle(enum rssn_CoordinateSystem aSystem)
;

/*
 Computes the symbolic Pearson correlation coefficient.

 # Safety
 The caller must ensure `data1` and `data2` are valid pointers to arrays of `Expr` pointers.
 */
rssn_
struct rssn_Expr *rssn_correlation(const struct rssn_Expr *const *aData1,
                                   size_t aLen1,
                                   const struct rssn_Expr *const *aData2,
                                   size_t aLen2)
;

/*
 Creates a cosine expression: cos(expr).
 */
rssn_
struct rssn_Expr *rssn_cos(const struct rssn_Expr *aExpr)
;

/*
 Creates a cosine expression from bincode: cos(expr).
 */
rssn_
struct rssn_BincodeBuffer rssn_cos_bincode(struct rssn_BincodeBuffer aExprBuffer)
;

/*
 Creates a cosine expression from JSON: cos(expr).
 */
rssn_
char *rssn_cos_json(const char *aJsonExpr)
;

/*
 Calculates Coulomb's Law field.
 */
rssn_
rssn_Vector *rssn_coulombs_law(const struct rssn_Expr *aCharge,
                               const rssn_Vector *aR)
;

/*
 Counts the number of distinct real roots in an interval (Handle)
 */
rssn_
int64_t rssn_count_real_roots_in_interval_handle(const struct rssn_Expr *aExprPtr,
                                                 const char *aVarPtr,
                                                 double aA,
                                                 double aB)
;

/*
 Computes the symbolic covariance of two sets of expressions.

 # Safety
 The caller must ensure `data1` and `data2` are valid pointers to arrays of `Expr` pointers.
 */
rssn_
struct rssn_Expr *rssn_covariance(const struct rssn_Expr *const *aData1,
                                  size_t aLen1,
                                  const struct rssn_Expr *const *aData2,
                                  size_t aLen2)
;

/*
 Computes CRC-32 checksum of data.

 # Safety
 Caller must ensure `data` points to `len` bytes.
 */
rssn_
uint32_t rssn_crc32_compute(const uint8_t *aData,
                            size_t aLen)
;

/*
 Finalizes a CRC-32 computation started with crc32_update.
 */
rssn_
uint32_t rssn_crc32_finalize(uint32_t aCrc)
;

/*
 Updates an existing CRC-32 with additional data (for incremental computation).

 # Safety
 Caller must ensure `data` points to `len` bytes.
 Use 0xFFFFFFFF as initial crc for first call.
 */
rssn_
uint32_t rssn_crc32_update(uint32_t aCrc,
                           const uint8_t *aData,
                           size_t aLen)
;

/*
 Verifies CRC-32 checksum of data.

 # Safety
 Caller must ensure `data` points to `len` bytes.
 Returns 1 if valid, 0 if invalid.
 */
rssn_
int32_t rssn_crc32_verify(const uint8_t *aData,
                          size_t aLen,
                          uint32_t aExpectedCrc)
;

/*
 Creates a grid complex
 */
rssn_
struct rssn_SimplicialComplex *rssn_create_grid_complex(size_t aWidth,
                                                        size_t aHeight)
;

/*
 Creates a torus complex
 */
rssn_
struct rssn_SimplicialComplex *rssn_create_torus_complex(size_t aM,
                                                         size_t aN)
;

/*
 Computes the cross-entropy between two probability distributions.

 Takes raw pointers to two arrays of `Expr` (probabilities) and their lengths.
 Returns a raw pointer to an `Expr` representing the cross-entropy.
 */
rssn_
struct rssn_Expr *rssn_cross_entropy(const struct rssn_Expr *const *aPProbs,
                                     size_t aPLen,
                                     const struct rssn_Expr *const *aQProbs,
                                     size_t aQLen)
;

/*
 Frees a CrystalLattice.
 */
rssn_
void rssn_crystal_lattice_free(struct rssn_CrystalLattice *aPtr)
;

/*
 Creates a new CrystalLattice.
 */
rssn_
struct rssn_CrystalLattice *rssn_crystal_lattice_new(const rssn_Vector *aA1,
                                                     const rssn_Vector *aA2,
                                                     const rssn_Vector *aA3)
;

/*
 Computes reciprocal lattice vectors.
 */
rssn_
void rssn_crystal_lattice_reciprocal_vectors(const struct rssn_CrystalLattice *aPtr,
                                             rssn_Vector **aB1,
                                             rssn_Vector **aB2,
                                             rssn_Vector **aB3)
;

/*
 Computes the volume of the unit cell.
 */
rssn_
struct rssn_Expr *rssn_crystal_lattice_volume(const struct rssn_CrystalLattice *aPtr)
;

/*
 Adds two points on the elliptic curve (P1 + P2).

 # Arguments
 * `curve` - Handle to the elliptic curve.
 * `p1` - Handle to the first point.
 * `p2` - Handle to the second point.

 # Returns
 A handle to the resulting point, or NULL on error.
 */
rssn_
struct rssn_CurvePoint *rssn_curve_add(const struct rssn_EllipticCurve *aCurve,
                                       const struct rssn_CurvePoint *aP1,
                                       const struct rssn_CurvePoint *aP2)
;

/*
 Doubles a point on the elliptic curve (P -> 2P).

 # Arguments
 * `curve` - Handle to the elliptic curve.
 * `point` - Handle to the point to double.

 # Returns
 A handle to the doubled point, or NULL on error.
 */
rssn_
struct rssn_CurvePoint *rssn_curve_double(const struct rssn_EllipticCurve *aCurve,
                                          const struct rssn_CurvePoint *aPoint)
;

/*
 Checks if a point lies on the given elliptic curve.

 # Arguments
 * `curve` - Handle to the elliptic curve.
 * `point` - Handle to the curve point to check.

 # Returns
 `true` if the point is on the curve, `false` otherwise.
 */
rssn_
bool rssn_curve_is_on_curve(const struct rssn_EllipticCurve *aCurve,
                            const struct rssn_CurvePoint *aPoint)
;

/*
 Negates a point on the elliptic curve (P -> -P).

 # Arguments
 * `curve` - Handle to the elliptic curve.
 * `point` - Handle to the point to negate.

 # Returns
 A handle to the negated point, or NULL on error.
 */
rssn_
struct rssn_CurvePoint *rssn_curve_negate(const struct rssn_EllipticCurve *aCurve,
                                          const struct rssn_CurvePoint *aPoint)
;

/*
 Creates an affine curve point from decimal strings.
 */
rssn_
struct rssn_CurvePoint *rssn_curve_point_affine(const char *aXStr,
                                                const char *aYStr,
                                                const char *aModulusStr)
;

/*
 Frees a curve point handle.
 */
rssn_
void rssn_curve_point_free(struct rssn_CurvePoint *aPoint)
;

/*
 Gets the x-coordinate of an affine point as a string. Returns NULL if infinity.
 */
rssn_
char *rssn_curve_point_get_x(const struct rssn_CurvePoint *aPoint)
;

/*
 Gets the y-coordinate of an affine point as a string. Returns NULL if infinity.
 */
rssn_
char *rssn_curve_point_get_y(const struct rssn_CurvePoint *aPoint)
;

/*
 Creates the point at infinity.
 */
rssn_
struct rssn_CurvePoint *rssn_curve_point_infinity(void)
;

/*
 Checks if a point is the point at infinity.
 */
rssn_
bool rssn_curve_point_is_infinity(const struct rssn_CurvePoint *aPoint)
;

/*
 Scalar multiplication. k is a string.
 */
rssn_
struct rssn_CurvePoint *rssn_curve_scalar_mult(const struct rssn_EllipticCurve *aCurve,
                                               const char *aKStr,
                                               const struct rssn_CurvePoint *aP)
;

/*
 Creates a cyclic group of order `n` and returns a raw pointer to it.

 # Arguments
 * `n` - The order of the cyclic group.

 # Returns
 A raw pointer (`*mut Group`) to the newly created group.
 */
rssn_
struct rssn_Group *rssn_cyclic_group_create(size_t aN)
;

/*
 Computes the definite integral of an expression.
 */
rssn_
struct rssn_Expr *rssn_definite_integrate(const struct rssn_Expr *aExpr,
                                          const char *aVar,
                                          const struct rssn_Expr *aLower,
                                          const struct rssn_Expr *aUpper)
;

/*
 Denests a nested square root (Handle)
 */
rssn_
struct rssn_Expr *rssn_denest_sqrt_handle(const struct rssn_Expr *aExpr)
;

/*
 Computes the density of states for a 3D electron gas.
 */
rssn_
struct rssn_Expr *rssn_density_of_states_3d(const struct rssn_Expr *aEnergy,
                                            const struct rssn_Expr *aEffectiveMass,
                                            const struct rssn_Expr *aVolume)
;

/*
 Differentiates an expression: d/d(var) expr.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `var` is a valid C string.
 */
rssn_
struct rssn_Expr *rssn_differentiate(const struct rssn_Expr *aExpr,
                                     const char *aVar)
;

/*
 Computes the symbolic Digamma function ψ(z).
 */
rssn_
struct rssn_Expr *rssn_digamma(const struct rssn_Expr *aArg)
;

/*
 Computes the digamma function ψ(x) = d/dx ln(Γ(x)).
 */
rssn_
double rssn_digamma_numerical(double aX)
;

/*
 Creates a dihedral group of order `2n` and returns a raw pointer to it.

 # Arguments
 * `n` - The parameter defining the dihedral group $D_n$.

 # Returns
 A raw pointer (`*mut Group`) to the newly created group.
 */
rssn_
struct rssn_Group *rssn_dihedral_group_create(size_t aN)
;

/*
 Computes the Dirac adjoint of a fermion field.
 */
rssn_
struct rssn_Expr *rssn_dirac_adjoint(const struct rssn_Expr *aPsi)
;

/*
 Dirac equation for a free particle.
 */
rssn_
struct rssn_Expr *rssn_dirac_equation(const struct rssn_Expr *aPsi,
                                      const struct rssn_Expr *aM)
;

/*
 Creates a Bernoulli distribution.

 Takes a raw pointer to an `Expr` representing `p` (probability of success).
 Returns a raw pointer to an `Expr` representing the Bernoulli distribution.
 */
rssn_
struct rssn_Expr *rssn_dist_bernoulli(const struct rssn_Expr *aP)
;

/*
 Creates a beta distribution.

 Takes raw pointers to `Expr` representing the alpha and beta parameters.
 Returns a raw pointer to an `Expr` representing the beta distribution.
 */
rssn_
struct rssn_Expr *rssn_dist_beta(const struct rssn_Expr *aAlpha,
                                 const struct rssn_Expr *aBeta)
;

/*
 Creates a binomial distribution.

 Takes raw pointers to `Expr` representing `n` (number of trials) and `p` (probability of success).
 Returns a raw pointer to an `Expr` representing the binomial distribution.
 */
rssn_
struct rssn_Expr *rssn_dist_binomial(const struct rssn_Expr *aN,
                                     const struct rssn_Expr *aP)
;

/*
 Computes the cumulative distribution function (CDF) of a distribution.

 Takes raw pointers to `Expr` representing the distribution and the value `x`.
 Returns a raw pointer to an `Expr` representing the CDF at `x`.
 */
rssn_
struct rssn_Expr *rssn_dist_cdf(const struct rssn_Expr *aDist,
                                const struct rssn_Expr *aX)
;

/*
 Computes the expectation (mean) of a distribution.

 Takes a raw pointer to an `Expr` representing the distribution.
 Returns a raw pointer to an `Expr` representing the expectation.
 */
rssn_
struct rssn_Expr *rssn_dist_expectation(const struct rssn_Expr *aDist)
;

/*
 Creates an exponential distribution.

 Takes a raw pointer to an `Expr` representing the rate parameter (λ).
 Returns a raw pointer to an `Expr` representing the exponential distribution.
 */
rssn_
struct rssn_Expr *rssn_dist_exponential(const struct rssn_Expr *aRate)
;

/*
 Creates a gamma distribution.

 Takes raw pointers to `Expr` representing the shape and rate parameters.
 Returns a raw pointer to an `Expr` representing the gamma distribution.
 */
rssn_
struct rssn_Expr *rssn_dist_gamma(const struct rssn_Expr *aShape,
                                  const struct rssn_Expr *aRate)
;

/*
 Computes the moment generating function (MGF) of a distribution.

 Takes raw pointers to `Expr` representing the distribution and the variable `t`.
 Returns a raw pointer to an `Expr` representing the MGF.
 */
rssn_
struct rssn_Expr *rssn_dist_mgf(const struct rssn_Expr *aDist,
                                const struct rssn_Expr *aT)
;

/*
 Creates a normal distribution.

 Takes raw pointers to `Expr` representing the mean and standard deviation.
 Returns a raw pointer to an `Expr` representing the normal distribution.
 */
rssn_
struct rssn_Expr *rssn_dist_normal(const struct rssn_Expr *aMean,
                                   const struct rssn_Expr *aStdDev)
;

/*
 Computes the probability density function (PDF) of a distribution.

 Takes raw pointers to `Expr` representing the distribution and the value `x`.
 Returns a raw pointer to an `Expr` representing the PDF at `x`.
 */
rssn_
struct rssn_Expr *rssn_dist_pdf(const struct rssn_Expr *aDist,
                                const struct rssn_Expr *aX)
;

/*
 Creates a Poisson distribution.

 Takes a raw pointer to an `Expr` representing the rate parameter (λ).
 Returns a raw pointer to an `Expr` representing the Poisson distribution.
 */
rssn_
struct rssn_Expr *rssn_dist_poisson(const struct rssn_Expr *aRate)
;

/*
 Creates a Student's t-distribution.

 Takes a raw pointer to an `Expr` representing the degrees of freedom (ν).
 Returns a raw pointer to an `Expr` representing the Student's t-distribution.
 */
rssn_
struct rssn_Expr *rssn_dist_student_t(const struct rssn_Expr *aNu)
;

/*
 Creates a uniform distribution.

 Takes raw pointers to `Expr` representing the minimum and maximum values.
 Returns a raw pointer to an `Expr` representing the uniform distribution.
 */
rssn_
struct rssn_Expr *rssn_dist_uniform(const struct rssn_Expr *aMin,
                                    const struct rssn_Expr *aMax)
;

/*
 Computes the variance of a distribution.

 Takes a raw pointer to an `Expr` representing the distribution.
 Returns a raw pointer to an `Expr` representing the variance.
 */
rssn_
struct rssn_Expr *rssn_dist_variance(const struct rssn_Expr *aDist)
;

/*
 Computes the double factorial n!!.
 */
rssn_
uint64_t rssn_double_factorial(uint64_t aN)
;

/*
 Computes Drude conductivity.
 */
rssn_
struct rssn_Expr *rssn_drude_conductivity(const struct rssn_Expr *aN,
                                          const struct rssn_Expr *aECharge,
                                          const struct rssn_Expr *aTau,
                                          const struct rssn_Expr *aMStar)
;

/*
 Returns the symbolic representation of Euler's number (e).
 */
rssn_
struct rssn_Expr *rssn_e(void)
;

/*
 Returns Euler's number (e) as bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_e_bincode(void)
;

/*
 Returns Euler's number (e) as JSON.
 */
rssn_ char *rssn_e_json(void) ;

/*
 Signs a message hash using the Elliptic Curve Digital Signature Algorithm (ECDSA).

 # Arguments
 * `message_hash_str` - The message hash as a decimal string.
 * `private_key_str` - The private key as a decimal string.
 * `curve` - Handle to the elliptic curve.
 * `generator` - Handle to the base point.
 * `order_str` - The order of the generator as a decimal string.

 # Returns
 A handle to the ECDSA signature, or NULL on error.
 */
rssn_
struct rssn_EcdsaSignature *rssn_ecdsa_sign(const char *aMessageHashStr,
                                            const char *aPrivateKeyStr,
                                            const struct rssn_EllipticCurve *aCurve,
                                            const struct rssn_CurvePoint *aGenerator,
                                            const char *aOrderStr)
;

/*
 Frees an ECDSA signature handle.

 # Arguments
 * `sig` - Handle to the signature to free.
 */
rssn_
void rssn_ecdsa_signature_free(struct rssn_EcdsaSignature *aSig)
;

/*
 Gets the 'r' component of an ECDSA signature as a decimal string.

 # Arguments
 * `sig` - Handle to the ECDSA signature.

 # Returns
 A decimal string representing 'r', or NULL on error.
 */
rssn_
char *rssn_ecdsa_signature_get_r(const struct rssn_EcdsaSignature *aSig)
;

/*
 Gets the 's' component of an ECDSA signature as a decimal string.

 # Arguments
 * `sig` - Handle to the ECDSA signature.

 # Returns
 A decimal string representing 's', or NULL on error.
 */
rssn_
char *rssn_ecdsa_signature_get_s(const struct rssn_EcdsaSignature *aSig)
;

/*
 Verifies an ECDSA signature.

 # Arguments
 * `message_hash_str` - The message hash as a decimal string.
 * `signature` - Handle to the ECDSA signature.
 * `public_key` - Handle to the signer's public key point.
 * `curve` - Handle to the elliptic curve.
 * `generator` - Handle to the base point.
 * `order_str` - The order of the generator as a decimal string.

 # Returns
 `true` if the signature is valid, `false` otherwise.
 */
rssn_
bool rssn_ecdsa_verify(const char *aMessageHashStr,
                       const struct rssn_EcdsaSignature *aSignature,
                       const struct rssn_CurvePoint *aPublicKey,
                       const struct rssn_EllipticCurve *aCurve,
                       const struct rssn_CurvePoint *aGenerator,
                       const char *aOrderStr)
;

/*
 Computes electric field from scalar and vector potentials.
 */
rssn_
rssn_Vector *rssn_electric_field_from_potentials(const struct rssn_Expr *aV,
                                                 const rssn_Vector *aA,
                                                 const char *aX,
                                                 const char *aY,
                                                 const char *aZ,
                                                 const char *aT)
;

/*
 Calculates energy density.
 */
rssn_
struct rssn_Expr *rssn_electromagnetic_energy_density(const rssn_Vector *aEField,
                                                      const rssn_Vector *aBField)
;

/*
 Frees an elliptic curve handle.
 */
rssn_
void rssn_elliptic_curve_free(struct rssn_EllipticCurve *aCurve)
;

/*
 Creates a new elliptic curve from decimal strings.
 */
rssn_
struct rssn_EllipticCurve *rssn_elliptic_curve_new(const char *aAStr,
                                                   const char *aBStr,
                                                   const char *aModulusStr)
;

/*
 Calculates enthalpy: U + PV.
 */
rssn_
struct rssn_Expr *rssn_enthalpy(const struct rssn_Expr *aU,
                                const struct rssn_Expr *aP,
                                const struct rssn_Expr *aV)
;

/*
 Computes the symbolic error function erf(z).
 */
rssn_
struct rssn_Expr *rssn_erf(const struct rssn_Expr *aArg)
;

/*
 Computes the error function erf(x).
 */
rssn_
double rssn_erf_numerical(double aX)
;

/*
 Computes the symbolic complementary error function erfc(z).
 */
rssn_
struct rssn_Expr *rssn_erfc(const struct rssn_Expr *aArg)
;

/*
 Computes the complementary error function erfc(x).
 */
rssn_
double rssn_erfc_numerical(double aX)
;

/*
 Computes the symbolic imaginary error function erfi(z).
 */
rssn_
struct rssn_Expr *rssn_erfi(const struct rssn_Expr *aArg)
;

/*
 Computes the Euler-Lagrange equation for a given Lagrangian.

 # Safety
 The caller must ensure `lagrangian` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_euler_lagrange(const struct rssn_Expr *aLagrangian,
                                      const char *aFunc,
                                      const char *aVar)
;

/*
 Computes Euler-Lagrange equation.
 */
rssn_
struct rssn_Expr *rssn_euler_lagrange_equation(const struct rssn_Expr *aLagrangian,
                                               const char *aQ,
                                               const char *aQDot,
                                               const char *aTVar)
;

/*
 Evaluates an expression at a given point.
 */
rssn_
struct rssn_Expr *rssn_evaluate_at_point(const struct rssn_Expr *aExpr,
                                         const char *aVar,
                                         const struct rssn_Expr *aValue)
;

/*
 Numerically evaluates a symbolic expression.

 Takes a raw pointer to an `Expr` as input,
 and returns an `f64` representing the numerical evaluation of that expression.
 */
rssn_
double rssn_evaluate_numerical_handle(const struct rssn_Expr *aExpr)
;

/*
 Creates an exponential expression: e^(expr).
 */
rssn_
struct rssn_Expr *rssn_exp(const struct rssn_Expr *aExpr)
;

/*
 Creates an exponential expression from bincode: e^(expr).
 */
rssn_
struct rssn_BincodeBuffer rssn_exp_bincode(struct rssn_BincodeBuffer aExprBuffer)
;

/*
 Creates an exponential expression from JSON: e^(expr).
 */
rssn_
char *rssn_exp_json(const char *aJsonExpr)
;

/*
 Expands a symbolic expression.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_
struct rssn_Expr *rssn_expand(const struct rssn_Expr *aExpr)
;

/*
 Expands a symbolic expression from bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_expand_bincode(struct rssn_BincodeBuffer aExprBuffer)
;

/*
 Expands a symbolic expression from JSON.
 */
rssn_
char *rssn_expand_json(const char *aJsonExpr)
;

/*
 Computes the expectation value <A>.
 */
rssn_
struct rssn_Expr *rssn_expectation_value(const struct rssn_Operator *aOp,
                                         const struct rssn_Ket *aPsi)
;

rssn_
struct rssn_Expr *rssn_exponential_map(const struct rssn_Expr *aX,
                                       size_t aOrder)
;

/*
 Creates an expression from a JSON string and returns a thread-safe handle.

 Returns 0 if the JSON is invalid.
 */
rssn_
DEPRECATED_WITH_NOTE
size_t rssn_expr_create(const char *aJsonPtr)
;

/*
 Frees the memory associated with an expression handle.
 */
rssn_
DEPRECATED_WITH_NOTE
void rssn_expr_free(size_t aHandle)
;

/*
 Frees the memory allocated for an `ExprList`.

 Takes a raw mutable pointer to an `ExprList`.
 */
rssn_
void rssn_expr_list_free(struct rssn_ExprList *aList)
;

/*
 Returns a specific element from an `ExprList`.

 Takes a raw pointer to an `ExprList` and a `usize` index.
 Returns a raw pointer to an `Expr` at that index.
 */
rssn_
struct rssn_Expr *rssn_expr_list_get(const struct rssn_ExprList *aList,
                                     size_t aIndex)
;

/*
 Returns the length of an `ExprList`.

 Takes a raw pointer to an `ExprList`.
 Returns a `usize` representing its length.
 */
rssn_
size_t rssn_expr_list_len(const struct rssn_ExprList *aList)
;

/*
 Simplifies an expression handle and returns a handle to the new, simplified expression.

 Returns 0 on error (e.g., invalid handle).
 */
rssn_
DEPRECATED_WITH_NOTE
size_t rssn_expr_simplify(const size_t *aHandle)
;

/*
 Computes the Extended GCD of two expressions.

 # Safety
 `a` and `b` must be valid pointers to `Expr`.
 */
rssn_
struct rssn_Expr *rssn_extended_gcd_handle(const struct rssn_Expr *aA,
                                           const struct rssn_Expr *aB)
;

/*
 Computes the exterior derivative of a differential form (Handle)
 */
rssn_
struct rssn_DifferentialForm *rssn_exterior_derivative_handle(const struct rssn_DifferentialForm *aFormPtr,
                                                              const char *const *aVarsPtr,
                                                              int aVarsLen)
;

/*
 Factors a polynomial over a finite field (Handle)
 */
rssn_
struct rssn_Vec_FiniteFieldPolynomial *rssn_factor_gf_handle(const struct rssn_FiniteFieldPolynomial *aPoly)
;

/*
 Computes the factorial n!.
 */
rssn_
uint64_t rssn_factorial(uint64_t aN)
;

/*
 Computes the falling factorial (x)₍ₙ₎.
 */
rssn_
double rssn_falling_factorial(double aX,
                              uint32_t aN)
;

/*
 Computes Fermi energy for a 3D electron gas.
 */
rssn_
struct rssn_Expr *rssn_fermi_energy_3d(const struct rssn_Expr *aConcentration,
                                       const struct rssn_Expr *aEffectiveMass)
;

/*
 Feynman propagator in position space.
 */
rssn_
struct rssn_Expr *rssn_feynman_propagator_position_space(const struct rssn_Expr *aX,
                                                         const struct rssn_Expr *aY,
                                                         const struct rssn_Expr *aM)
;

/*
 Computes the Feynman slash notation.
 */
rssn_
struct rssn_Expr *rssn_feynman_slash(const struct rssn_Expr *aVMu)
;

/*
 Computes the Fast Fourier Transform (FFT) of a sequence of complex numbers in-place.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_fft(rssn_Complex<double> *aData,
                 size_t aLen)
;

/*
 Finds constrained extrema (Handle)
 */
rssn_
struct rssn_Vec_HashMap_Expr__Expr *rssn_find_constrained_extrema_handle(const struct rssn_Expr *aExprPtr,
                                                                         const struct rssn_Vec_Expr *aConstraintsPtr,
                                                                         const char *const *aVarsPtr,
                                                                         int aVarsLen)
;

/*
 Finds extrema of a function (Handle)
 */
rssn_
struct rssn_Vec_CriticalPoint *rssn_find_extrema_handle(const struct rssn_Expr *aExprPtr,
                                                        const char *const *aVarsPtr,
                                                        int aVarsLen)
;

/*
 Finds fixed points of a 1D map (Handle)
 */
rssn_
struct rssn_Expr **rssn_find_fixed_points(const struct rssn_Expr *aMapPtr,
                                          const char *aVar,
                                          size_t *aOutLen)
;

/*
 Finds the order of a pole.
 */
rssn_
size_t rssn_find_pole_order(const struct rssn_Expr *aExpr,
                            const char *aVar,
                            const struct rssn_Expr *aPole)
;

/*
 Finds poles of an expression.
 */
rssn_
struct rssn_Vec_Expr *rssn_find_poles(const struct rssn_Expr *aExpr,
                                      const char *aVar)
;

/*
 Frees a finite field handle.

 # Safety
 Caller must ensure `field` is a valid pointer returned by `rssn_finite_field_new`.
 */
rssn_
void rssn_finite_field_free(struct rssn_Arc_FiniteField *aField)
;

/*
 Creates a new finite field GF(modulus).

 Returns an opaque handle to the field.
 */
rssn_
struct rssn_Arc_FiniteField *rssn_finite_field_new(int64_t aModulus)
;

/*
 First-order energy correction.
 */
rssn_
struct rssn_Expr *rssn_first_order_energy_correction(const struct rssn_Operator *aPerturbation,
                                                     const struct rssn_Ket *aUnperturbedState)
;

/*
 Applies the differentiation property of the Fourier transform.

 # Safety
 Caller must ensure `f_omega` is a valid pointer to an `Expr`.
 `out_var` must be a valid C string or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_fourier_differentiation(const struct rssn_Expr *aFOmega,
                                               const char *aOutVar)
;

/*
 Applies the frequency shift property of the Fourier transform.

 # Safety
 Caller must ensure `f_omega` and `a` are valid pointers to an `Expr`.
 `out_var` must be a valid C string or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_fourier_frequency_shift(const struct rssn_Expr *aFOmega,
                                               const struct rssn_Expr *aA,
                                               const char *aOutVar)
;

/*
 Applies the scaling property of the Fourier transform.

 # Safety
 Caller must ensure `f_omega` and `a` are valid pointers to an `Expr`.
 `out_var` must be a valid C string or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_fourier_scaling(const struct rssn_Expr *aFOmega,
                                       const struct rssn_Expr *aA,
                                       const char *aOutVar)
;

/*
 Computes the Fourier series expansion of an expression.

 Takes a raw pointer to `Expr` (expression), a C-style string (variable),
 a raw pointer to `Expr` (period), and a `usize` (order).
 Returns a raw pointer to a new `Expr` representing the Fourier series.
 */
rssn_
struct rssn_Expr *rssn_fourier_series_handle(const struct rssn_Expr *aExpr,
                                             const char *aVar,
                                             const struct rssn_Expr *aPeriod,
                                             size_t aOrder)
;

/*
 Applies the time shift property of the Fourier transform.

 # Safety
 Caller must ensure `f_omega` and `a` are valid pointers to an `Expr`.
 `out_var` must be a valid C string or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_fourier_time_shift(const struct rssn_Expr *aFOmega,
                                          const struct rssn_Expr *aA,
                                          const char *aOutVar)
;

/*
 Computes the symbolic Fourier transform of an expression.

 # Safety
 Caller must ensure `expr` is a valid pointer to an `Expr`.
 `in_var` and `out_var` must be valid C strings or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_fourier_transform(const struct rssn_Expr *aExpr,
                                         const char *aInVar,
                                         const char *aOutVar)
;

/*
 Frees a Fredholm integral equation.
 */
rssn_
void rssn_fredholm_free(struct rssn_FredholmEquation *aPtr)
;

/*
 Creates a new Fredholm integral equation.
 */
rssn_
struct rssn_FredholmEquation *rssn_fredholm_new(const struct rssn_Expr *aYX,
                                                const struct rssn_Expr *aFX,
                                                const struct rssn_Expr *aLambda,
                                                const struct rssn_Expr *aKernel,
                                                const struct rssn_Expr *aLowerBound,
                                                const struct rssn_Expr *aUpperBound,
                                                const char *aVarX,
                                                const char *aVarT)
;

/*
 Solves a Fredholm equation using the Neumann series method.
 */
rssn_
struct rssn_Expr *rssn_fredholm_solve_neumann(const struct rssn_FredholmEquation *aEq,
                                              size_t aIterations)
;

/*
 Solves a Fredholm equation using the Neumann series method (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_fredholm_solve_neumann_bincode(const uint8_t *aInputPtr,
                                                              size_t aInputLen)
;

/*
 Solves a Fredholm equation using the Neumann series method (JSON).
 */
rssn_
char *rssn_fredholm_solve_neumann_json(const char *aInputJson)
;

/*
 Solves a Fredholm equation with a separable kernel.
 */
rssn_
struct rssn_Expr *rssn_fredholm_solve_separable(const struct rssn_FredholmEquation *aEq,
                                                const struct rssn_Expr *const *aAFuncs,
                                                size_t aALen,
                                                const struct rssn_Expr *const *aBFuncs,
                                                size_t aBLen)
;

/*
 Solves a Fredholm equation with a separable kernel (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_fredholm_solve_separable_bincode(const uint8_t *aInputPtr,
                                                                size_t aInputLen)
;

/*
 Solves a Fredholm equation with a separable kernel (JSON).
 */
rssn_
char *rssn_fredholm_solve_separable_json(const char *aInputJson)
;

/*
 Frees a bincode buffer allocated by an FFI function.

 # Safety
 The buffer must have been allocated by an FFI function that returns `BincodeBuffer`.
 This function should only be called once per buffer.
 */
rssn_
void rssn_free_bincode_buffer(struct rssn_BincodeBuffer aBuffer)
;

/*
 Frees a CAD handle.
 */
rssn_
void rssn_free_cad_handle(struct rssn_Cad *aPtr)
;

/*
 Frees a Vec<CriticalPoint> handle
 */
rssn_
void rssn_free_critical_point_vec_handle(struct rssn_Vec_CriticalPoint *aPtr)
;

/*
 Frees a DifferentialForm handle
 */
rssn_
void rssn_free_differential_form_handle(struct rssn_DifferentialForm *aPtr)
;

/*
 Frees an Expr pointer created by this module.

 # Safety
 The caller must ensure `expr` was created by this module and hasn't been freed yet.
 */
rssn_
void rssn_free_expr(struct rssn_Expr *aExpr)
;

/*
 Frees a Vec<Expr> handle
 */
rssn_
void rssn_free_expr_vec_handle(struct rssn_Vec_Expr *aPtr)
;

/*
 Frees a float64 array allocated by the FEM FFI.
 */
rssn_
void rssn_free_f64_array(double *aPtr,
                         size_t aSize)
;

/*
 Frees a float64 array allocated by the CNM FFI.
 */
rssn_
void rssn_free_f64_cnm_array(double *aPtr,
                             size_t aSize)
;

/*
 Frees a float64 array allocated by the MTM FFI.
 */
rssn_
void rssn_free_f64_mtm_array(double *aPtr,
                             size_t aSize)
;

/*
 Frees a multivector (Handle)
 */
rssn_
void rssn_free_multivector_handle(struct rssn_Multivector *aPtr)
;

/*
 Frees a vector of pole expressions previously returned by `rssn_find_poles`.

 # Arguments

 * `poles` - Mutable pointer to a heap-allocated `Vec<Expr>`.

 # Returns

 This function does not return a value.

 # Safety

 This function is unsafe because it takes ownership of a raw pointer and frees the
 underlying allocation. The pointer must have been created by this library and must
 not be used after this call.
 */
rssn_
void rssn_free_poles(struct rssn_Vec_Expr *aPoles)
;

/*
 Frees a vector of polynomials (Handle)
 */
rssn_
void rssn_free_poly_vec_handle(struct rssn_Vec_FiniteFieldPolynomial *aPtr)
;

/*
 Frees a Vec<HashMap<Expr, Expr>> handle
 */
rssn_
void rssn_free_solution_vec_handle(struct rssn_Vec_HashMap_Expr__Expr *aPtr)
;

/*
 Frees a string allocated by an FFI function.

 # Safety
 The string must have been allocated by an FFI function that returns `*mut c_char`.
 This function should only be called once per string.
 */
rssn_
void rssn_free_string(char *aS)
;

/*
 Frees a C string returned by other functions.
 */
rssn_
void rssn_free_string_api(char *aPtr)
;

/*
 Frees a C string that was allocated by the `rssn_get_*` functions in this module.

 # Safety
 The `ptr` must be a valid C string pointer allocated by this module.
 */
rssn_
void rssn_free_string_constant(char *aPtr)
;

/*
 Computes the symbolic Gamma function Γ(z).
 */
rssn_
struct rssn_Expr *rssn_gamma(const struct rssn_Expr *aArg)
;

/*
 Computes the gamma function Γ(x).
 */
rssn_
double rssn_gamma_numerical(double aX)
;

/*
 Represents Gauss's theorem (Handle)
 */
rssn_
struct rssn_Expr *rssn_gauss_theorem_handle(const rssn_Vector *aVectorFieldPtr,
                                            const struct rssn_Expr *aVolumePtr)
;

/*
 Computes general multi-valued arccos (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_arccos_handle(const struct rssn_Expr *aZ,
                                             const struct rssn_Expr *aK,
                                             const struct rssn_Expr *aS)
;

/*
 Computes general multi-valued arcsin (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_arcsin_handle(const struct rssn_Expr *aZ,
                                             const struct rssn_Expr *aK)
;

/*
 Computes general multi-valued arctan (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_arctan_handle(const struct rssn_Expr *aZ,
                                             const struct rssn_Expr *aK)
;

/*
 Computes general multi-valued logarithm (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_log_handle(const struct rssn_Expr *aZ,
                                          const struct rssn_Expr *aK)
;

/*
 Computes general multi-valued n-th root (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_nth_root_handle(const struct rssn_Expr *aZ,
                                               const struct rssn_Expr *aN,
                                               const struct rssn_Expr *aK)
;

/*
 Computes general multi-valued power (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_power_handle(const struct rssn_Expr *aZ,
                                            const struct rssn_Expr *aW,
                                            const struct rssn_Expr *aK)
;

/*
 Computes general multi-valued square root (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_sqrt_handle(const struct rssn_Expr *aZ,
                                           const struct rssn_Expr *aK)
;

/*
 Computes the symbolic Generalized Laguerre polynomial L_n^α(x).
 */
rssn_
struct rssn_Expr *rssn_generalized_laguerre(const struct rssn_Expr *aN,
                                            const struct rssn_Expr *aAlpha,
                                            const struct rssn_Expr *aX)
;

/*
 Represents the generalized Stokes' theorem (Handle)
 */
rssn_
struct rssn_Expr *rssn_generalized_stokes_theorem_handle(const struct rssn_DifferentialForm *aOmegaPtr,
                                                         const struct rssn_Expr *aManifoldPtr,
                                                         const char *const *aVarsPtr,
                                                         int aVarsLen)
;

/*
 Generates an ECDH key pair for the given curve and generator.

 # Arguments
 * `curve` - Handle to the elliptic curve.
 * `generator` - Handle to the curve's base point (generator).

 # Returns
 A handle to the generated key pair, or NULL on error.
 */
rssn_
struct rssn_EcdhKeyPair *rssn_generate_keypair(const struct rssn_EllipticCurve *aCurve,
                                               const struct rssn_CurvePoint *aGenerator)
;

/*
 Generates a shared secret point using elliptic curve Diffie-Hellman (ECDH).

 # Arguments
 * `curve` - Handle to the elliptic curve.
 * `private_key_str` - The private key as a decimal string.
 * `other_public_key` - Handle to the other party's public key point.

 # Returns
 A handle to the shared secret point, or NULL on error.
 */
rssn_
struct rssn_CurvePoint *rssn_generate_shared_secret(const struct rssn_EllipticCurve *aCurve,
                                                    const char *aPrivateKeyStr,
                                                    const struct rssn_CurvePoint *aOtherPublicKey)
;

/*
 Returns the build date as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_get_build_date(void)
;

/*
 Returns the build date as a bincode_next buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
struct rssn_BincodeBuffer rssn_get_build_date_bincode(void)
;

/*
 Returns the build date as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_get_build_date_json(void)
;

/*
 Returns all build information as a bincode_next buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
struct rssn_BincodeBuffer rssn_get_build_info_bincode(void)
;

/*
 Returns all build information as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_get_build_info_json(void)
;

/*
 Returns the cargo target triple as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_get_cargo_target_triple(void)
;

/*
 Returns the commit SHA as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_get_commit_sha(void)
;

/*
 Returns the commit SHA as a bincode_next buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
struct rssn_BincodeBuffer rssn_get_commit_sha_bincode(void)
;

/*
 Returns the commit SHA as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_get_commit_sha_json(void)
;

/*
 Retrieves the last error message set by an FFI function on the current thread.

 The returned pointer is valid until the next call to an FFI function on the same thread.
 The caller should not free this pointer.
 */
rssn_
const char *rssn_get_last_error(void)
;

/*
 Gets real and imaginary parts of an expression.
 Returns a pointer to a tuple (Expr, Expr) - represented as Vec<Expr> of size 2 for simplicity?
 Or return two out pointers?
 I'll return a Vec<Expr> of size 2.
 */
rssn_
struct rssn_Vec_Expr *rssn_get_real_imag_parts(const struct rssn_Expr *aExpr)
;

/*
 Returns the rustc version as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_get_rustc_version(void)
;

/*
 Returns the system info as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_get_system_info(void)
;

/*
 Performs addition in GF(2^8) (XOR operation).
 */
rssn_
uint8_t rssn_gf256_add(uint8_t aA,
                       uint8_t aB)
;

/*
 Performs division in GF(2^8).
 Returns 0 if divisor is 0 (error case).
 */
rssn_
uint8_t rssn_gf256_div(uint8_t aA,
                       uint8_t aB)
;

/*
 Computes the exponentiation (anti-logarithm) in GF(2^8).
 */
rssn_
uint8_t rssn_gf256_exp(uint8_t aLogVal)
;

/*
 Computes the multiplicative inverse in GF(2^8).
 Returns 0 if input is 0 (error case).
 */
rssn_
uint8_t rssn_gf256_inv(uint8_t aA)
;

/*
 Computes the discrete logarithm in GF(2^8).
 Returns 0 if input is 0 (error case, as log(0) is undefined).
 */
rssn_
uint8_t rssn_gf256_log(uint8_t aA)
;

/*
 Performs multiplication in GF(2^8).
 */
rssn_
uint8_t rssn_gf256_mul(uint8_t aA,
                       uint8_t aB)
;

/*
 Computes a^exp in GF(2^8).
 */
rssn_
uint8_t rssn_gf256_pow(uint8_t aA,
                       uint8_t aExp)
;

/*
 Calculates Gibbs Free Energy: H - TS.
 */
rssn_
struct rssn_Expr *rssn_gibbs_free_energy(const struct rssn_Expr *aH,
                                         const struct rssn_Expr *aT,
                                         const struct rssn_Expr *aS)
;

/*
 Computes the Gini impurity of a probability distribution.

 Takes a raw pointer to an array of `Expr` (probabilities) and its length.
 Returns a raw pointer to an `Expr` representing the Gini impurity.
 */
rssn_
struct rssn_Expr *rssn_gini_impurity(const struct rssn_Expr *const *aProbs,
                                     size_t aLen)
;

/*
 Performs the Gram-Schmidt process to produce an orthogonal basis.

 # Arguments
 * `space` - Handle to the Hilbert space.
 * `basis_ptr` - Array of handles to the input basis expressions.
 * `basis_len` - Number of input expressions.
 * `out_len` - Pointer to store the number of orthogonal expressions produced.

 # Returns
 A raw pointer to an array of handles to the orthogonalized basis expressions.
 */
rssn_
struct rssn_Expr **rssn_gram_schmidt(const struct rssn_HilbertSpace *aSpace,
                                     const struct rssn_Expr *const *aBasisPtr,
                                     size_t aBasisLen,
                                     size_t *aOutLen)
;

/*
 Adds an edge to the graph.
 */
rssn_
void rssn_graph_add_edge(struct rssn_RssnGraph *aPtr,
                         const char *aFromLabel,
                         const char *aToLabel,
                         const struct rssn_Expr *aWeight)
;

/*
 Adds a node to the graph.
 */
rssn_
size_t rssn_graph_add_node(struct rssn_RssnGraph *aPtr,
                           const char *aLabel)
;

/*
 Gets the adjacency matrix of the graph.
 */
rssn_
struct rssn_Expr *rssn_graph_adjacency_matrix(const struct rssn_RssnGraph *aPtr)
;

/*
 Performs BFS traversal from a start node.
 Returns a JSON string containing the node IDs in visit order.
 */
rssn_
char *rssn_graph_bfs(const struct rssn_RssnGraph *aPtr,
                     size_t aStartNode)
;

/*
 Performs BFS traversal starting from a given node.
 Returns a JSON array of node indices in visit order.
 */
rssn_
char *rssn_graph_bfs_api(const struct rssn_RssnGraph *aGraph,
                         size_t aStartNode)
;

/*
 Finds maximum matching in a bipartite graph.
 partition_json should be a JSON array of 0s and 1s indicating the partition.
 Returns a JSON array of [u, v] pairs representing the matching.
 */
rssn_
char *rssn_graph_bipartite_maximum_matching(const struct rssn_RssnGraph *aGraph,
                                            const char *aPartitionJson)
;

/*
 Finds bridges and articulation points.
 Returns a JSON object with "bridges" and "articulation_points" fields.
 */
rssn_
char *rssn_graph_bridges_and_articulation_points_api(const struct rssn_RssnGraph *aGraph)
;

/*
 Computes the Cartesian product of two graphs.
 */
rssn_
struct rssn_RssnGraph *rssn_graph_cartesian_product(const struct rssn_RssnGraph *aPtr1,
                                                    const struct rssn_RssnGraph *aPtr2)
;

/*
 Computes the complement of a graph.
 */
rssn_
struct rssn_RssnGraph *rssn_graph_complement(const struct rssn_RssnGraph *aPtr)
;

/*
 Finds connected components.
 Returns a JSON string containing the components.
 */
rssn_
char *rssn_graph_connected_components(const struct rssn_RssnGraph *aPtr)
;

/*
 Finds all connected components in an undirected graph.
 Returns a JSON array of arrays, where each inner array is a component.
 */
rssn_
char *rssn_graph_connected_components_api(const struct rssn_RssnGraph *aGraph)
;

/*
 Performs DFS traversal from a start node.
 Returns a JSON string containing the node IDs in visit order.
 */
rssn_
char *rssn_graph_dfs(const struct rssn_RssnGraph *aPtr,
                     size_t aStartNode)
;

/*
 Performs DFS traversal starting from a given node.
 Returns a JSON array of node indices in visit order.
 */
rssn_
char *rssn_graph_dfs_api(const struct rssn_RssnGraph *aGraph,
                         size_t aStartNode)
;

/*
 Computes maximum flow using Dinic's algorithm.
 */
rssn_
double rssn_graph_dinic_max_flow(const struct rssn_RssnGraph *aGraph,
                                 size_t aSource,
                                 size_t aSink)
;

/*
 Computes the disjoint union of two graphs.
 */
rssn_
struct rssn_RssnGraph *rssn_graph_disjoint_union(const struct rssn_RssnGraph *aPtr1,
                                                 const struct rssn_RssnGraph *aPtr2)
;

/*
 Computes maximum flow using Edmonds-Karp algorithm.
 */
rssn_
double rssn_graph_edmonds_karp_max_flow(const struct rssn_RssnGraph *aGraph,
                                        size_t aSource,
                                        size_t aSink)
;

/*
 Frees a graph.
 */
rssn_
void rssn_graph_free(struct rssn_RssnGraph *aPtr)
;

/*
 Checks if the graph has a cycle.
 */
rssn_
int rssn_graph_has_cycle(const struct rssn_RssnGraph *aPtr)
;

/*
 Checks if the graph has a cycle.
 */
rssn_
int rssn_graph_has_cycle_api(const struct rssn_RssnGraph *aGraph)
;

/*
 Gets the incidence matrix of the graph.
 */
rssn_
struct rssn_Expr *rssn_graph_incidence_matrix(const struct rssn_RssnGraph *aPtr)
;

/*
 Creates an induced subgraph.
 */
rssn_
struct rssn_RssnGraph *rssn_graph_induced_subgraph(const struct rssn_RssnGraph *aPtr,
                                                   const char *const *aNodeLabels,
                                                   size_t aCount)
;

/*
 Computes the intersection of two graphs.
 */
rssn_
struct rssn_RssnGraph *rssn_graph_intersection(const struct rssn_RssnGraph *aPtr1,
                                               const struct rssn_RssnGraph *aPtr2)
;

/*
 Checks if the graph is bipartite.
 Returns 1 if bipartite, 0 otherwise.
 */
rssn_
int rssn_graph_is_bipartite(const struct rssn_RssnGraph *aPtr)
;

/*
 Checks if a graph is bipartite.
 Returns a JSON array of partition assignments (0 or 1 for each node), or null if not bipartite.
 */
rssn_
char *rssn_graph_is_bipartite_api(const struct rssn_RssnGraph *aGraph)
;

/*
 Checks if the graph is connected.
 */
rssn_
int rssn_graph_is_connected(const struct rssn_RssnGraph *aGraph)
;

/*
 Computes the join of two graphs.
 */
rssn_
struct rssn_RssnGraph *rssn_graph_join(const struct rssn_RssnGraph *aPtr1,
                                       const struct rssn_RssnGraph *aPtr2)
;

/*
 Computes minimum spanning tree using Kruskal's algorithm.
 Returns a JSON string containing the MST edges.
 */
rssn_
char *rssn_graph_kruskal_mst(const struct rssn_RssnGraph *aPtr)
;

/*
 Computes the minimum spanning tree using Kruskal's algorithm.
 Returns a new graph containing only the MST edges.
 */
rssn_
struct rssn_RssnGraph *rssn_graph_kruskal_mst_api(const struct rssn_RssnGraph *aGraph)
;

/*
 Gets the Laplacian matrix of the graph.
 */
rssn_
struct rssn_Expr *rssn_graph_laplacian_matrix(const struct rssn_RssnGraph *aPtr)
;

/*
 Computes maximum flow using Edmonds-Karp algorithm.
 */
rssn_
double rssn_graph_max_flow(const struct rssn_RssnGraph *aPtr,
                           size_t aSource,
                           size_t aSink)
;

/*
 Creates a new graph.
 */
rssn_
struct rssn_RssnGraph *rssn_graph_new(int aIsDirected)
;

/*
 Gets the number of nodes in the graph.
 */
rssn_
size_t rssn_graph_node_count(const struct rssn_RssnGraph *aPtr)
;

/*
 Finds all strongly connected components in a directed graph.
 Returns a JSON array of arrays.
 */
rssn_
char *rssn_graph_strongly_connected_components(const struct rssn_RssnGraph *aGraph)
;

/*
 Computes the Tensor product of two graphs.
 */
rssn_
struct rssn_RssnGraph *rssn_graph_tensor_product(const struct rssn_RssnGraph *aPtr1,
                                                 const struct rssn_RssnGraph *aPtr2)
;

/*
 Performs topological sort on a DAG.
 Returns a JSON array of node indices in topological order, or null if the graph has a cycle.
 */
rssn_
char *rssn_graph_topological_sort(const struct rssn_RssnGraph *aGraph)
;

/*
 Computes the union of two graphs.
 */
rssn_
struct rssn_RssnGraph *rssn_graph_union(const struct rssn_RssnGraph *aPtr1,
                                        const struct rssn_RssnGraph *aPtr2)
;

/*
 Finds a valid vertex coloring using greedy heuristic.
 Returns a JSON object mapping node IDs to colors.
 */
rssn_
char *rssn_greedy_coloring(const struct rssn_RssnGraph *aGraph)
;

/*
 Represents Green's theorem (Handle)
 */
rssn_
struct rssn_Expr *rssn_greens_theorem_handle(const struct rssn_Expr *aPPtr,
                                             const struct rssn_Expr *aQPtr,
                                             const struct rssn_Expr *aDomainPtr)
;

rssn_
struct rssn_Expr **rssn_group_center(const struct rssn_Group *aGroup,
                                     size_t *aOutLen)
;

rssn_
struct rssn_Group *rssn_group_create(const struct rssn_Expr *const *aElementsPtr,
                                     size_t aElementsLen,
                                     const struct rssn_Expr *const *aKeysAPtr,
                                     const struct rssn_Expr *const *aKeysBPtr,
                                     const struct rssn_Expr *const *aValuesPtr,
                                     size_t aTableLen,
                                     const struct rssn_Expr *aIdentityPtr)
;

rssn_
size_t rssn_group_element_order(const struct rssn_Group *aGroup,
                                const struct rssn_Expr *aA)
;

rssn_
void rssn_group_free(struct rssn_Group *aPtr)
;

rssn_
struct rssn_Expr *rssn_group_inverse(const struct rssn_Group *aGroup,
                                     const struct rssn_Expr *aA)
;

rssn_
bool rssn_group_is_abelian(const struct rssn_Group *aGroup)
;

rssn_
struct rssn_Expr *rssn_group_multiply(const struct rssn_Group *aGroup,
                                      const struct rssn_Expr *aA,
                                      const struct rssn_Expr *aB)
;

/*
 Computes Hall coefficient.
 */
rssn_
struct rssn_Expr *rssn_hall_coefficient(const struct rssn_Expr *aN,
                                        const struct rssn_Expr *aQ)
;

/*
 Calculates Hamiltonian: T + V.
 */
rssn_
struct rssn_Expr *rssn_hamiltonian(const struct rssn_Expr *aT,
                                   const struct rssn_Expr *aV)
;

/*
 Hamiltonian for a free particle.
 */
rssn_
struct rssn_Operator *rssn_hamiltonian_free_particle(const struct rssn_Expr *aM)
;

/*
 Hamiltonian for a harmonic oscillator.
 */
rssn_
struct rssn_Operator *rssn_hamiltonian_harmonic_oscillator(const struct rssn_Expr *aM,
                                                           const struct rssn_Expr *aOmega)
;

/*
 Applies Hamilton's Principle to derive the equations of motion.

 # Safety
 The caller must ensure `lagrangian` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_hamiltons_principle(const struct rssn_Expr *aLagrangian,
                                           const char *aFunc,
                                           const char *aVar)
;

/*
 Checks if a Hamming(7,4) codeword is valid without correcting.

 # Safety
 Caller must ensure `codeword` points to 7 bytes.
 Returns 1 if valid, 0 if invalid, -1 on error.
 */
rssn_
int32_t rssn_hamming_check(const uint8_t *aCodeword)
;

/*
 Decodes a 7-bit Hamming(7,4) codeword, correcting single-bit errors.

 # Safety
 Caller must ensure `codeword` points to 7 bytes and `data_out` points to 4 bytes.
 `error_pos` will receive the 1-based error position or 0 if no error.
 */
rssn_
int32_t rssn_hamming_decode(const uint8_t *aCodeword,
                            uint8_t *aDataOut,
                            uint8_t *aErrorPos)
;

/*
 Computes Hamming distance between two byte slices.

 # Safety
 Caller must ensure `a` and `b` point to `len` bytes each.
 Returns -1 on error (null pointers or different lengths).
 */
rssn_
int32_t rssn_hamming_distance(const uint8_t *aA,
                              size_t aALen,
                              const uint8_t *aB,
                              size_t aBLen)
;

/*
 Encodes 4 data bits into a 7-bit Hamming(7,4) codeword.

 # Safety
 Caller must ensure `data` points to 4 bytes and `out` points to 7 bytes of allocated memory.
 */
rssn_
int32_t rssn_hamming_encode(const uint8_t *aData,
                            uint8_t *aOut)
;

/*
 Computes Hamming weight (number of 1s) of a byte slice.

 # Safety
 Caller must ensure `data` points to `len` bytes.
 */
rssn_
int32_t rssn_hamming_weight(const uint8_t *aData,
                            size_t aLen)
;

/*
 Clears all expressions from the handle manager.

 **Warning**: This invalidates all existing handles.

 # Safety
 This function is always safe to call, but will invalidate all handles.
 */
rssn_
void rssn_handle_clear(void)
;

/*
 Clears all handles (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_handle_clear_bincode(void)
;

/*
 Clears all handles (JSON).

 Output: JSON object with "cleared" boolean field
 */
rssn_
char *rssn_handle_clear_json(void)
;

/*
 Clones an expression handle, creating a new handle pointing to the same expression.

 Returns 0 if the source handle doesn't exist.

 # Safety
 This function is safe to call with any handle value.
 */
rssn_
size_t rssn_handle_clone(size_t aHandle)
;

/*
 Clones a handle (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_handle_clone_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Clones a handle (JSON).

 Input: JSON object with "handle" field
 Output: JSON object with "new_handle" field
 */
rssn_
char *rssn_handle_clone_json(const char *aJsonStr)
;

/*
 Returns the number of expressions currently managed.

 # Safety
 This function is always safe to call.
 */
rssn_
size_t rssn_handle_count(void)
;

/*
 Checks if a handle exists in the manager.

 # Safety
 This function is safe to call with any handle value.
 */
rssn_
bool rssn_handle_exists(size_t aHandle)
;

/*
 Checks if a handle exists (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_handle_exists_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Checks if a handle exists (JSON).

 Input: JSON object with "handle" field
 Output: JSON object with "exists" boolean field
 */
rssn_
char *rssn_handle_exists_json(const char *aJsonStr)
;

/*
 Frees a handle from the manager.

 Returns true if the handle was found and freed, false otherwise.

 # Safety
 This function is safe to call with any handle value.
 */
rssn_
bool rssn_handle_free(size_t aHandle)
;

/*
 Frees a handle (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_handle_free_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Frees a handle (JSON).

 Input: JSON object with "handle" field
 Output: JSON object with "freed" boolean field
 */
rssn_
char *rssn_handle_free_json(const char *aJsonStr)
;

/*
 Retrieves an expression from the handle manager.

 Returns a new owned Expr pointer that must be freed by the caller.

 # Safety
 The caller must ensure the returned pointer is freed using `rssn_free_expr`.
 */
rssn_
struct rssn_Expr *rssn_handle_get(size_t aHandle)
;

/*
 Returns a list of all active handles as a JSON array string.

 The returned string must be freed using `rssn_free_string`.

 # Safety
 The caller must free the returned string.
 */
rssn_
char *rssn_handle_get_all(void)
;

/*
 Returns all active handles (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_handle_get_all_bincode(void)
;

/*
 Retrieves an expression by handle (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_handle_get_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Retrieves an expression by handle (JSON).

 Input: JSON object with "handle" field
 Output: JSON-serialized Expr
 */
rssn_
char *rssn_handle_get_json(const char *aJsonStr)
;

/*
 Inserts an expression into the handle manager and returns a unique handle.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_
size_t rssn_handle_insert(const struct rssn_Expr *aExpr)
;

/*
 Inserts an expression (Bincode) into the handle manager.
 */
rssn_
struct rssn_BincodeBuffer rssn_handle_insert_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Inserts an expression (JSON) into the handle manager.

 Input: JSON-serialized Expr
 Output: JSON object with "handle" field
 */
rssn_
char *rssn_handle_insert_json(const char *aJsonStr)
;

/*
 Returns handle manager statistics (JSON).

 Output: JSON object with "count" and "handles" fields
 */
rssn_
char *rssn_handle_stats_json(void)
;

/*
 Converts an expression handle to a string representation.

 The returned string must be freed using `rssn_free_string`.

 # Safety
 The caller must free the returned string.
 */
rssn_
char *rssn_handle_to_string(size_t aHandle)
;

/*
 Constructs Hermite's differential equation: y'' - 2xy' + 2ny = 0.
 */
rssn_
struct rssn_Expr *rssn_hermite_differential_equation(const struct rssn_Expr *aY,
                                                     const struct rssn_Expr *aX,
                                                     const struct rssn_Expr *aN)
;

/*
 Computes the symbolic Hermite polynomial H_n(x).
 */
rssn_
struct rssn_Expr *rssn_hermite_h(const struct rssn_Expr *aDegree,
                                 const struct rssn_Expr *aArg)
;

/*
 Constructs Rodrigues' formula for Hermite polynomials.
 */
rssn_
struct rssn_Expr *rssn_hermite_rodrigues_formula(const struct rssn_Expr *aN,
                                                 const struct rssn_Expr *aX)
;

/*
 Computes Hessian matrix (Handle)
 */
rssn_
struct rssn_Expr *rssn_hessian_matrix_handle(const struct rssn_Expr *aExprPtr,
                                             const char *const *aVarsPtr,
                                             int aVarsLen)
;

/*
 Simplifies an expression using the heuristic simplifier.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_
struct rssn_Expr *rssn_heuristic_simplify(const struct rssn_Expr *aExpr)
;

/*
 Creates a new Hilbert space over a specified interval.

 # Arguments
 * `var` - The name of the independent variable defining the space.
 * `lower_bound` - Symbolic expression for the lower bound of the interval.
 * `upper_bound` - Symbolic expression for the upper bound of the interval.

 # Returns
 A raw pointer to the newly created `HilbertSpace`.
 */
rssn_
struct rssn_HilbertSpace *rssn_hilbert_space_create(const char *aVar,
                                                    const struct rssn_Expr *aLowerBound,
                                                    const struct rssn_Expr *aUpperBound)
;

/*
 Frees a Hilbert space handle.

 # Arguments
 * `ptr` - Pointer to the `HilbertSpace` to free.
 */
rssn_
void rssn_hilbert_space_free(struct rssn_HilbertSpace *aPtr)
;

/*
 Calculates ideal gas Law expression: PV - nRT.
 */
rssn_
struct rssn_Expr *rssn_ideal_gas_law(const struct rssn_Expr *aP,
                                     const struct rssn_Expr *aV,
                                     const struct rssn_Expr *aN,
                                     const struct rssn_Expr *aR,
                                     const struct rssn_Expr *aT)
;

/*
 Computes the Inverse Fast Fourier Transform (IFFT) of a sequence of complex numbers in-place.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_ifft(rssn_Complex<double> *aData,
                  size_t aLen)
;

/*
 Creates a new IteratedFunctionSystem (Handle)
 */
rssn_
struct rssn_IteratedFunctionSystem *rssn_ifs_create(struct rssn_Expr *const *aFunctionsPtr,
                                                    size_t aFunctionsLen,
                                                    struct rssn_Expr *const *aProbabilitiesPtr,
                                                    size_t aProbabilitiesLen,
                                                    const char *const *aVariablesPtr,
                                                    size_t aVariablesLen)
;

/*
 Frees an IteratedFunctionSystem handle
 */
rssn_
void rssn_ifs_free(struct rssn_IteratedFunctionSystem *aPtr)
;

/*
 Calculates similarity dimension (Handle)
 */
rssn_
struct rssn_Expr *rssn_ifs_similarity_dimension(struct rssn_Expr *const *aScalingFactorsPtr,
                                                size_t aLen)
;

/*
 Initializes the plugin manager with a specified plugin directory.

 This function must be called before any plugin operations are performed.

 # Arguments
 * `plugin_dir_ptr` - A null-terminated UTF-8 string for the plugin directory path.

 # Returns
 0 on success, -1 on failure. On failure, an error message can be retrieved
 with `rssn_get_last_error`.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_init_plugin_manager(const char *aPluginDirPtr)
;

/*
 Computes the inner product of two functions in a Hilbert space.

 # Arguments
 * `space` - Handle to the Hilbert space.
 * `f` - Handle to the first expression.
 * `g` - Handle to the second expression.

 # Returns
 A raw pointer to the symbolic expression representing the inner product.
 */
rssn_
struct rssn_Expr *rssn_inner_product(const struct rssn_HilbertSpace *aSpace,
                                     const struct rssn_Expr *aF,
                                     const struct rssn_Expr *aG)
;

/*
 Integrates an expression: int(expr) d(var).

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `var` is a valid C string.
 */
rssn_
struct rssn_Expr *rssn_integrate(const struct rssn_Expr *aExpr,
                                 const char *aVar)
;

/*
 Integrates a rational function (Handle)
 */
rssn_
struct rssn_Expr *rssn_integrate_rational_function_handle(const struct rssn_Expr *aExpr,
                                                          const char *aX)
;

/*
 Evaluates a point on a Bezier curve defined by control points.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_interp_bezier_curve(const struct rssn_FfiPoint *aPointsPtr,
                                 size_t aNumPoints,
                                 double aT,
                                 struct rssn_FfiPoint *aResultPtr)
;

/*
 Computes a Lagrange interpolating polynomial from a set of points.
 Returns a handle to the resulting polynomial expression.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_interp_lagrange(const struct rssn_FfiPoint *aPointsPtr,
                             size_t aNumPoints,
                             size_t *aResultHandle)
;

/*
 Computes the inverse error function erf⁻¹(x).
 */
rssn_
double rssn_inverse_erf(double aX)
;

/*
 Computes the inverse complementary error function erfc⁻¹(x).
 */
rssn_
double rssn_inverse_erfc(double aX)
;

/*
 Computes the symbolic inverse Fourier transform of an expression.

 # Safety
 Caller must ensure `expr` is a valid pointer to an `Expr`.
 `in_var` and `out_var` must be valid C strings or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_inverse_fourier_transform(const struct rssn_Expr *aExpr,
                                                 const char *aInVar,
                                                 const char *aOutVar)
;

/*
 Computes the symbolic inverse Laplace transform of an expression.

 # Safety
 Caller must ensure `expr` is a valid pointer to an `Expr`.
 `in_var` and `out_var` must be valid C strings or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_inverse_laplace_transform(const struct rssn_Expr *aExpr,
                                                 const char *aInVar,
                                                 const char *aOutVar)
;

/*
 Computes the symbolic inverse Z-transform of an expression.

 # Safety
 Caller must ensure `expr` is a valid pointer to an `Expr`.
 `in_var` and `out_var` must be valid C strings or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_inverse_z_transform(const struct rssn_Expr *aExpr,
                                           const char *aInVar,
                                           const char *aOutVar)
;

/*
 Checks if an expression is prime.

 # Safety
 `n` must be a valid pointer to an `Expr`.
 */
rssn_
struct rssn_Expr *rssn_is_prime_handle(const struct rssn_Expr *aN)
;

/*
 Checks if a logical expression is satisfiable using handle-based FFI.

 Returns:
 - 1 if satisfiable
 - 0 if unsatisfiable
 - -1 if the expression contains quantifiers (undecidable)

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_
int32_t rssn_is_satisfiable_handle(const struct rssn_Expr *aExpr)
;

/*
 Compiles a sequence of instructions provided as JSON.
 Returns a JSON result containing the address (as usize) of the compiled function.
 */
rssn_
char *rssn_jit_compile_json(struct rssn_JitEngine *aEngine,
                            const char *aJsonPtr)
;

/*
 Creates a new JIT Engine instance.
 */
rssn_
struct rssn_JitEngine *rssn_jit_create(void)
;

/*
 Executes a JIT-compiled function pointer.

 # Safety
 The function pointer must be a valid pointer returned by `rssn_jit_compile_*`.
 It assumes the function signature is `fn() -> f64`.
 */
rssn_
double rssn_jit_execute(const uint8_t *aFuncPtr)
;

/*
 Frees a JIT Engine instance.
 */
rssn_
void rssn_jit_free(struct rssn_JitEngine *aEngine)
;

/*
 Registers a custom instruction handler.

 `opcode`: The exact u32 opcode found in `Instruction::Custom`.
 `func_ptr`: Pointer to the C function to call. Signature must be `fn(i64, ...) -> i64` where `i64` represents a stack value.
 `arg_count`: Number of arguments the function expects (popped from stack).
 */
rssn_
void rssn_jit_register_custom_op(struct rssn_JitEngine *aEngine,
                                 uint32_t aOpcode,
                                 const uint8_t *aFuncPtr,
                                 size_t aArgCount)
;

/*
 Computes the joint entropy of a joint probability distribution.

 Takes a raw pointer to an `Expr` representing the joint probability distribution.
 Returns a raw pointer to an `Expr` representing the joint entropy.
 */
rssn_
struct rssn_Expr *rssn_joint_entropy(const struct rssn_Expr *aJointProbs)
;

/*
 Computes absolute value (magnitude) of complex number (JSON)
 */
rssn_
char *rssn_json_abs(const char *aZJson)
;

rssn_
char *rssn_json_adjoint_representation_algebra(const char *aXJson,
                                               const char *aYJson)
;

rssn_
char *rssn_json_adjoint_representation_group(const char *aGJson,
                                             const char *aXJson)
;

/*
 Computes the analytic continuation of a series.

 Takes JSON strings representing `Expr` (expression), `String` (variable),
 `Expr` (original center), `Expr` (new center), and `usize` (order).
 Returns a JSON string representing the `Expr` of the analytic continuation.
 */
rssn_
char *rssn_json_analytic_continuation(const char *aExprJson,
                                      const char *aVarJson,
                                      const char *aOrigCenterJson,
                                      const char *aNewCenterJson,
                                      const char *aOrderJson)
;

/*
 Analyzes the convergence of a series using JSON-serialized inputs.

 Takes C-style strings containing JSON-serialized `Expr` for the series term
 and `String` for the variable.
 Returns a C-style string containing the JSON-serialized analysis result.
 */
rssn_
char *rssn_json_analyze_convergence(const char *aTermJson,
                                    const char *aVarJson)
;

/*
 Analyzes stability of a fixed point (JSON)
 */
rssn_
char *rssn_json_analyze_stability(const char *aMapJson,
                                  const char *aVar,
                                  const char *aFixedPointJson)
;

/*
 Checks if two graphs are isomorphic.
 Input: {"g1": Graph, "g2": Graph}
 Output: bool
 */
rssn_
char *rssn_json_are_isomorphic_heuristic(const char *aJson)
;

/*
 Computes argument (angle) of complex number (JSON)
 */
rssn_
char *rssn_json_arg(const char *aZJson)
;

/*
 Computes the asymptotic expansion of an expression.

 Takes JSON strings representing `Expr` (expression), `String` (variable),
 `Expr` (point), and `usize` (order).
 Returns a JSON string representing the `Expr` of the asymptotic expansion.
 */
rssn_
char *rssn_json_asymptotic_expansion(const char *aExprJson,
                                     const char *aVarJson,
                                     const char *aPointJson,
                                     const char *aOrderJson)
;

/*
 Computes the \(n\)-th Bell number symbolically and returns it as JSON-encoded `Expr`.

 Bell numbers count the total number of set partitions of an \(n\)-element set.

 # Arguments

 * `n` - Index of the Bell number to compute.

 # Returns

 A C string pointer containing JSON-encoded `Expr` for the \(n\)-th Bell number.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point and returns
 ownership of a heap-allocated C string.
 */
rssn_
char *rssn_json_bell_number(size_t aN)
;

/*
 Constructs Bessel's differential equation via JSON interface.
 */
rssn_
char *rssn_json_bessel_differential_equation(const char *aYJson,
                                             const char *aXJson,
                                             const char *aNJson)
;

/*
 Computes the symbolic modified Bessel function I_n(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_i(const char *aOrderJson,
                         const char *aArgJson)
;

/*
 Computes I₀(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_i0(const char *aXJson)
;

/*
 Computes I₁(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_i1(const char *aXJson)
;

/*
 Computes the symbolic Bessel function J_n(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_j(const char *aOrderJson,
                         const char *aArgJson)
;

/*
 Computes J₀(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_j0(const char *aXJson)
;

/*
 Computes J₁(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_j1(const char *aXJson)
;

/*
 Computes the symbolic modified Bessel function K_n(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_k(const char *aOrderJson,
                         const char *aArgJson)
;

/*
 Computes K₀(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_k0(const char *aXJson)
;

/*
 Computes K₁(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_k1(const char *aXJson)
;

/*
 Computes the symbolic Bessel function Y_n(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_y(const char *aOrderJson,
                         const char *aArgJson)
;

/*
 Computes Y₀(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_y0(const char *aXJson)
;

/*
 Computes Y₁(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_y1(const char *aXJson)
;

/*
 Computes the symbolic Beta function B(a, b) via JSON interface.
 */
rssn_
char *rssn_json_beta(const char *aAJson,
                     const char *aBJson)
;

/*
 Computes B(a, b) via JSON interface.
 */
rssn_
char *rssn_json_beta_numerical(const char *aAJson,
                               const char *aBJson)
;

/*
 Computes C(n, k) via JSON interface.
 */
rssn_
char *rssn_json_binomial(const char *aNJson,
                         const char *aKJson)
;

/*
 Computes the boundary of a domain (JSON)
 */
rssn_
char *rssn_json_boundary(const char *aDomainJson)
;

/*
 Computes the inner product <Bra|Ket> using JSON.
 */
rssn_
char *rssn_json_bra_ket(const char *aBraJson,
                        const char *aKetJson)
;

/*
 Computes a Gröbner basis using Buchberger's algorithm and returns it as JSON-encoded polynomials.

 # Arguments

 * `basis_json` - C string pointer with JSON-encoded `Vec<SparsePolynomial>` for the initial basis.
 * `order_json` - C string pointer with JSON-encoded [`MonomialOrder`].

 # Returns

 A C string pointer containing JSON-encoded `Vec<SparsePolynomial>` representing a
 Gröbner basis, or null if deserialization fails or the computation encounters an error.

 # Safety

 This function is unsafe because it dereferences raw C string pointers and returns
 ownership of a heap-allocated C string that must be freed by the caller.
 */
rssn_
char *rssn_json_buchberger(const char *aBasisJson,
                           const char *aOrderJson)
;

/*
 Computes CAD for a set of polynomials via JSON interface.

 Input JSON should be an object: `{"polys": [Expr, ...], "vars": ["x", "y", ...]}`.
 */
rssn_
char *rssn_json_cad(const char *aInputJson)
;

/*
 Calculates residue using JSON.
 */
rssn_
char *rssn_json_calculate_residue(const char *aExprJson,
                                  const char *aVar,
                                  const char *aPoleJson)
;

/*
 Computes the \(n\)-th Catalan number symbolically and returns it as JSON-encoded `Expr`.

 Catalan numbers count many combinatorial structures, such as binary trees, Dyck paths,
 and non-crossing partitions.

 # Arguments

 * `n` - Index of the Catalan number to compute.

 # Returns

 A C string pointer containing JSON-encoded `Expr` for the \(n\)-th Catalan number.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point and returns
 ownership of a heap-allocated C string.
 */
rssn_
char *rssn_json_catalan_number(size_t aN)
;

rssn_
char *rssn_json_character(const char *aRepJson)
;

/*
 Constructs Chebyshev's differential equation via JSON interface.
 */
rssn_
char *rssn_json_chebyshev_differential_equation(const char *aYJson,
                                                const char *aXJson,
                                                const char *aNJson)
;

/*
 Computes the symbolic Chebyshev polynomial T_n(x) via JSON interface.
 */
rssn_
char *rssn_json_chebyshev_t(const char *aNJson,
                            const char *aXJson)
;

/*
 Computes the symbolic Chebyshev polynomial U_n(x) via JSON interface.
 */
rssn_
char *rssn_json_chebyshev_u(const char *aNJson,
                            const char *aXJson)
;

/*
 Checks analytic using JSON.
 */
rssn_
bool rssn_json_check_analytic(const char *aExprJson,
                              const char *aVar)
;

rssn_
bool rssn_json_check_jacobi_identity(const char *aAlgebraJson)
;

/*
 Solves the Chinese Remainder Theorem.

 Takes a JSON string representing a vector of congruences (`(remainder, modulus)`),
 and returns a JSON string representing the `Expr` solution.
 */
rssn_
char *rssn_json_chinese_remainder(const char *aCongruencesJson)
;

/*
 Exact chromatic number.
 Input: Graph
 Output: usize
 */
rssn_
char *rssn_json_chromatic_number_exact(const char *aJson)
;

/*
 Classifies a PDE and suggests solution methods (JSON).
 */
rssn_
char *rssn_json_classify_pde(const char *aEquationJson,
                             const char *aFunc,
                             const char *aVarsJson)
;

/*
 Computes the number of combinations symbolically using JSON-encoded `Expr` arguments.

 This corresponds to the binomial coefficient \( C(n,k) = n! / (k!(n-k)!) \) when
 `n` and `k` are integers, but operates on general symbolic expressions.

 # Arguments

 * `n_json` - C string pointer to JSON encoding an `Expr` for the population size `n`.
 * `k_json` - C string pointer to JSON encoding an `Expr` for the selection size `k`.

 # Returns

 A C string pointer containing JSON-encoded `Expr` for the symbolic combination count,
 or null on deserialization failure.

 # Safety

 This function is unsafe because it dereferences raw C string pointers and returns
 ownership of a heap-allocated C string.
 */
rssn_
char *rssn_json_combinations(const char *aNJson,
                             const char *aKJson)
;

rssn_
char *rssn_json_commutator_table(const char *aAlgebraJson)
;

/*
 Finds fixed points (JSON)
 */
rssn_
char *rssn_json_complex_system_fixed_points(const char *aSystemJson)
;

/*
 Iterates the system once (JSON)
 */
rssn_
char *rssn_json_complex_system_iterate(const char *aSystemJson,
                                       const char *aZJson)
;

/*
 Creates a new Mandelbrot family system (JSON)
 */
rssn_
char *rssn_json_complex_system_new_mandelbrot(const char *aCJson)
;

/*
 Computes the conditional entropy of a joint probability distribution.

 Takes a JSON string representing an `Expr` (joint probability distribution).
 Returns a JSON string representing the `Expr` of the conditional entropy.
 */
rssn_
char *rssn_json_conditional_entropy(const char *aJointProbsJson)
;

/*
 Computes the convolution of two functions using the Fourier transform property.

 Takes JSON strings representing `Expr` (two functions `f` and `g`),
 and `String` (input variable), `String` (output variable).
 Returns a JSON string representing the `Expr` of the convolution.
 */
rssn_
char *rssn_json_convolution_fourier(const char *aFJson,
                                    const char *aGJson,
                                    const char *aInVarJson,
                                    const char *aOutVarJson)
;

/*
 Computes the convolution of two functions using the Laplace transform property.

 Takes JSON strings representing `Expr` (two functions `f` and `g`),
 and `String` (input variable), `String` (output variable).
 Returns a JSON string representing the `Expr` of the convolution.
 */
rssn_
char *rssn_json_convolution_laplace(const char *aFJson,
                                    const char *aGJson,
                                    const char *aInVarJson,
                                    const char *aOutVarJson)
;

/*
 Returns the metric tensor for a given coordinate system as JSON-encoded `Expr`.

 # Arguments

 * `system` - [`CoordinateSystem`] for which to compute the metric tensor.

 # Returns

 A C string pointer containing JSON-encoded `Expr` for the metric tensor, or null on error.

 # Safety

 This function is unsafe because it is exposed as an FFI entry point and returns
 ownership of a heap-allocated C string.
 */
rssn_
char *rssn_json_coordinates_get_metric_tensor(enum rssn_CoordinateSystem aSystem)
;

/*
 Computes the symbolic Pearson correlation coefficient using JSON.
 */
rssn_
char *rssn_json_correlation(const char *aData1Json,
                            const char *aData2Json)
;

/*
 Counts the number of distinct real roots in an interval (JSON)
 */
rssn_
int64_t rssn_json_count_real_roots_in_interval(const char *aExprJson,
                                               const char *aVarPtr,
                                               double aA,
                                               double aB)
;

/*
 Computes the symbolic covariance of two sets of expressions using JSON.
 */
rssn_
char *rssn_json_covariance(const char *aData1Json,
                           const char *aData2Json)
;

/*
 Computes CRC-32 checksum via JSON interface.
 Input: [bytes]
 Returns: u32 checksum
 */
rssn_
char *rssn_json_crc32_compute(const char *aDataJson)
;

/*
 Finalizes CRC-32 computation via JSON interface.
 Input: running crc as u32
 Returns: final crc as u32
 */
rssn_
char *rssn_json_crc32_finalize(const char *aCrcJson)
;

/*
 Updates CRC-32 incrementally via JSON interface.
 Input: current crc as u32, data as [bytes]
 Returns: updated crc as u32
 */
rssn_
char *rssn_json_crc32_update(const char *aCrcJson,
                             const char *aDataJson)
;

/*
 Verifies CRC-32 checksum via JSON interface.
 Input: data as [bytes], expected_crc as u32
 Returns: boolean
 */
rssn_
char *rssn_json_crc32_verify(const char *aDataJson,
                             const char *aExpectedCrcJson)
;

/*
 Computes the cross-entropy between two probability distributions.

 Takes two JSON strings representing `Vec<Expr>` (probability distributions `p` and `q`).
 Returns a JSON string representing the `Expr` of the cross-entropy.
 */
rssn_
char *rssn_json_cross_entropy(const char *aPProbsJson,
                              const char *aQProbsJson)
;

/*
 Adds two points.
 */
rssn_
char *rssn_json_curve_add(const char *aCurveJson,
                          const char *aP1Json,
                          const char *aP2Json)
;

/*
 Doubles a point.
 */
rssn_
char *rssn_json_curve_double(const char *aCurveJson,
                             const char *aPointJson)
;

/*
 Checks if a point is on the curve.
 */
rssn_
char *rssn_json_curve_is_on_curve(const char *aCurveJson,
                                  const char *aPointJson)
;

/*
 Negates a point.
 */
rssn_
char *rssn_json_curve_negate(const char *aCurveJson,
                             const char *aPointJson)
;

/*
 Creates an affine curve point.
 Arguments: x (str), y (str), modulus (str)
 */
rssn_
char *rssn_json_curve_point_affine(const char *aXJson,
                                   const char *aYJson,
                                   const char *aModulusJson)
;

/*
 Creates a point at infinity.
 */
rssn_
char *rssn_json_curve_point_infinity(void)
;

/*
 Scalar multiplication.
 */
rssn_
char *rssn_json_curve_scalar_mult(const char *aCurveJson,
                                  const char *aKJson,
                                  const char *aPJson)
;

/*
 Creates a cyclic group of order `n` and returns it as a JSON string.

 # Arguments
 * `n` - The order of the cyclic group.

 # Returns
 A raw pointer to a JSON string representing the group.
 */
rssn_
char *rssn_json_cyclic_group_create(size_t aN)
;

/*
 Computes definite integral using JSON.
 */
rssn_
char *rssn_json_definite_integrate(const char *aExprJson,
                                   const char *aVar,
                                   const char *aLowerJson,
                                   const char *aUpperJson)
;

/*
 Denests a nested square root (JSON)
 */
rssn_
char *rssn_json_denest_sqrt(const char *aExprJson)
;

/*
 Computes the density of states for a 3D electron gas using JSON.
 */
rssn_
char *rssn_json_density_of_states_3d(const char *aEnergyJson,
                                     const char *aMassJson,
                                     const char *aVolumeJson)
;

/*
 Differentiates an expression using JSON.
 */
rssn_
char *rssn_json_differentiate(const char *aExprJson,
                              const char *aVar)
;

/*
 Computes the symbolic Digamma function ψ(z) via JSON interface.
 */
rssn_
char *rssn_json_digamma(const char *aArgJson)
;

/*
 Computes the digamma function ψ(x) via JSON interface.
 */
rssn_
char *rssn_json_digamma_numerical(const char *aXJson)
;

/*
 Creates a dihedral group of order `2n` and returns it as a JSON string.

 # Arguments
 * `n` - The parameter defining the dihedral group $D_n$.

 # Returns
 A raw pointer to a JSON string representing the group.
 */
rssn_
char *rssn_json_dihedral_group_create(size_t aN)
;

/*
 Computes the Dirac adjoint using JSON.
 */
rssn_
char *rssn_json_dirac_adjoint(const char *aPsiJson)
;

/*
 Creates a Bernoulli distribution.

 Takes a JSON string representing `Expr` (probability of success).
 Returns a JSON string representing the `Expr` of the Bernoulli distribution.
 */
rssn_
char *rssn_json_dist_bernoulli(const char *aPJson)
;

/*
 Creates a beta distribution.

 Takes JSON strings representing `Expr` (alpha parameter) and `Expr` (beta parameter).
 Returns a JSON string representing the `Expr` of the beta distribution.
 */
rssn_
char *rssn_json_dist_beta(const char *aAlphaJson,
                          const char *aBetaJson)
;

/*
 Creates a binomial distribution.

 Takes JSON strings representing `Expr` (number of trials) and `Expr` (probability of success).
 Returns a JSON string representing the `Expr` of the binomial distribution.
 */
rssn_
char *rssn_json_dist_binomial(const char *aNJson,
                              const char *aPJson)
;

/*
 Computes the cumulative distribution function (CDF) of a distribution.

 Takes JSON strings representing `Expr` (distribution) and `Expr` (value `x`).
 Returns a JSON string representing the `Expr` of the CDF at `x`.
 */
rssn_
char *rssn_json_dist_cdf(const char *aDistJson,
                         const char *aXJson)
;

/*
 Computes the expectation (mean) of a distribution.

 Takes a JSON string representing `Expr` (distribution).
 Returns a JSON string representing the `Expr` of the expectation.
 */
rssn_
char *rssn_json_dist_expectation(const char *aDistJson)
;

/*
 Creates an exponential distribution.

 Takes a JSON string representing `Expr` (rate parameter λ).
 Returns a JSON string representing the `Expr` of the exponential distribution.
 */
rssn_
char *rssn_json_dist_exponential(const char *aRateJson)
;

/*
 Creates a gamma distribution.

 Takes JSON strings representing `Expr` (shape parameter) and `Expr` (rate parameter).
 Returns a JSON string representing the `Expr` of the gamma distribution.
 */
rssn_
char *rssn_json_dist_gamma(const char *aShapeJson,
                           const char *aRateJson)
;

/*
 Computes the moment generating function (MGF) of a distribution.

 Takes JSON strings representing `Expr` (distribution) and `Expr` (variable `t`).
 Returns a JSON string representing the `Expr` of the MGF.
 */
rssn_
char *rssn_json_dist_mgf(const char *aDistJson,
                         const char *aTJson)
;

/*
 Creates a normal distribution.

 Takes JSON strings representing `Expr` (mean) and `Expr` (standard deviation).
 Returns a JSON string representing the `Expr` of the normal distribution.
 */
rssn_
char *rssn_json_dist_normal(const char *aMeanJson,
                            const char *aStdDevJson)
;

/*
 Computes the probability density function (PDF) of a distribution.

 Takes JSON strings representing `Expr` (distribution) and `Expr` (value `x`).
 Returns a JSON string representing the `Expr` of the PDF at `x`.
 */
rssn_
char *rssn_json_dist_pdf(const char *aDistJson,
                         const char *aXJson)
;

/*
 Creates a Poisson distribution.

 Takes a JSON string representing `Expr` (rate parameter λ).
 Returns a JSON string representing the `Expr` of the Poisson distribution.
 */
rssn_
char *rssn_json_dist_poisson(const char *aRateJson)
;

/*
 Creates a Student's t-distribution.

 Takes a JSON string representing `Expr` (degrees of freedom ν).
 Returns a JSON string representing the `Expr` of the Student's t-distribution.
 */
rssn_
char *rssn_json_dist_student_t(const char *aNuJson)
;

/*
 Creates a uniform distribution.

 Takes JSON strings representing `Expr` (minimum value) and `Expr` (maximum value).
 Returns a JSON string representing the `Expr` of the uniform distribution.
 */
rssn_
char *rssn_json_dist_uniform(const char *aMinJson,
                             const char *aMaxJson)
;

/*
 Computes the variance of a distribution.

 Takes a JSON string representing `Expr` (distribution).
 Returns a JSON string representing the `Expr` of the variance.
 */
rssn_
char *rssn_json_dist_variance(const char *aDistJson)
;

/*
 Computes n!! via JSON interface.
 */
rssn_
char *rssn_json_double_factorial(const char *aNJson)
;

/*
 Computes Drude conductivity using JSON.
 */
rssn_
char *rssn_json_drude_conductivity(const char *aNJson,
                                   const char *aEJson,
                                   const char *aTauJson,
                                   const char *aMassJson)
;

/*
 Signs a message.
 */
rssn_
char *rssn_json_ecdsa_sign(const char *aMessageHashJson,
                           const char *aPrivateKeyJson,
                           const char *aCurveJson,
                           const char *aGeneratorJson,
                           const char *aOrderJson)
;

/*
 Verifies a signature.
 */
rssn_
char *rssn_json_ecdsa_verify(const char *aMessageHashJson,
                             const char *aSignatureJson,
                             const char *aPublicKeyJson,
                             const char *aCurveJson,
                             const char *aGeneratorJson,
                             const char *aOrderJson)
;

/*
 Calculates energy density using JSON.
 */
rssn_
char *rssn_json_electromagnetic_energy_density(const char *aEFieldJson,
                                               const char *aBFieldJson)
;

/*
 Creates a new elliptic curve.
 Arguments: a (str), b (str), modulus (str)
 */
rssn_
char *rssn_json_elliptic_curve_new(const char *aAJson,
                                   const char *aBJson,
                                   const char *aModulusJson)
;

/*
 Computes the symbolic error function erf(z) via JSON interface.
 */
rssn_
char *rssn_json_erf(const char *aArgJson)
;

/*
 Computes erf(x) via JSON interface.
 */
rssn_
char *rssn_json_erf_numerical(const char *aXJson)
;

/*
 Computes the symbolic complementary error function erfc(z) via JSON interface.
 */
rssn_
char *rssn_json_erfc(const char *aArgJson)
;

/*
 Computes erfc(x) via JSON interface.
 */
rssn_
char *rssn_json_erfc_numerical(const char *aXJson)
;

/*
 Computes the symbolic imaginary error function erfi(z) via JSON interface.
 */
rssn_
char *rssn_json_erfi(const char *aArgJson)
;

/*
 Computes the Euler-Lagrange equation using JSON.
 */
rssn_
char *rssn_json_euler_lagrange(const char *aLagrangianJson,
                               const char *aFunc,
                               const char *aVar)
;

/*
 Computes Euler-Lagrange equation using JSON.
 */
rssn_
char *rssn_json_euler_lagrange_equation(const char *aLagrangianJson,
                                        const char *aQ,
                                        const char *aQDot,
                                        const char *aTVar)
;

/*
 Evaluates at point using JSON.
 */
rssn_
char *rssn_json_evaluate_at_point(const char *aExprJson,
                                  const char *aVar,
                                  const char *aValueJson)
;

/*
 Numerically evaluates a symbolic expression.

 Takes a JSON string representing an `Expr` as input,
 and returns a JSON string representing the numerical evaluation of that expression.
 */
rssn_
char *rssn_json_evaluate_numerical(const char *aExprJson)
;

/*
 Computes the expectation value using JSON.
 */
rssn_
char *rssn_json_expectation_value(const char *aOpJson,
                                  const char *aPsiJson)
;

rssn_
char *rssn_json_exponential_map(const char *aXJson,
                                size_t aOrder)
;

/*
 Computes the extended greatest common divisor (GCD).

 Takes JSON strings representing two numbers (`a` and `b`),
 and returns a JSON string representing a tuple `(g, x, y)` where `g` is the GCD
 and `x`, `y` are coefficients such that `ax + by = g`.
 */
rssn_
char *rssn_json_extended_gcd(const char *aAJson,
                             const char *aBJson)
;

/*
 Computes the exterior derivative of a differential form (JSON)
 */
rssn_
char *rssn_json_exterior_derivative(const char *aFormJson,
                                    const char *aVarsJson)
;

/*
 Factors a polynomial over a finite field (JSON)
 */
rssn_
char *rssn_json_factor_gf(const char *aPolyJson)
;

/*
 Computes n! via JSON interface.
 */
rssn_
char *rssn_json_factorial(const char *aNJson)
;

/*
 Computes the falling factorial (x)₍ₙ₎ via JSON interface.
 */
rssn_
char *rssn_json_falling_factorial(const char *aXJson,
                                  const char *aNJson)
;

/*
 Computes Fermi energy for a 3D electron gas using JSON.
 */
rssn_
char *rssn_json_fermi_energy_3d(const char *aConcentrationJson,
                                const char *aMassJson)
;

/*
 Computes the Feynman slash using JSON.
 */
rssn_
char *rssn_json_feynman_slash(const char *aVMuJson)
;

/*
 Finds constrained extrema (JSON)
 */
rssn_
char *rssn_json_find_constrained_extrema(const char *aExprJson,
                                         const char *aConstraintsJson,
                                         const char *aVarsJson)
;

/*
 Finds extrema of a function (JSON)
 */
rssn_
char *rssn_json_find_extrema(const char *aExprJson,
                             const char *aVarsJson)
;

/*
 Finds fixed points of a 1D map (JSON)
 */
rssn_
char *rssn_json_find_fixed_points(const char *aMapJson,
                                  const char *aVar)
;

/*
 Finds pole order using JSON.
 */
rssn_
size_t rssn_json_find_pole_order(const char *aExprJson,
                                 const char *aVar,
                                 const char *aPoleJson)
;

/*
 Finds poles using JSON.
 */
rssn_
char *rssn_json_find_poles(const char *aExprJson,
                           const char *aVar)
;

/*
 Gets the degree of a finite field polynomial (JSON)
 */
rssn_
int64_t rssn_json_finite_field_polynomial_degree(const char *aPolyJson)
;

/*
 Performs polynomial long division (JSON)
 */
rssn_
char *rssn_json_finite_field_polynomial_long_division(const char *aDividendJson,
                                                      const char *aDivisorJson)
;

/*
 Creates a new finite field polynomial (JSON)
 */
rssn_
char *rssn_json_finite_field_polynomial_new(const char *aCoeffsJson,
                                            const char *aModulusJson)
;

/*
 Applies the differentiation property of the Fourier transform.

 Takes JSON strings representing `Expr` (frequency domain expression) and `String` (output variable).
 Returns a JSON string representing the `Expr` of the transformed expression.
 */
rssn_
char *rssn_json_fourier_differentiation(const char *aFOmegaJson,
                                        const char *aOutVarJson)
;

/*
 Applies the frequency shift property of the Fourier transform.

 Takes JSON strings representing `Expr` (frequency domain expression), `Expr` (frequency shift amount `a`),
 and `String` (output variable).
 Returns a JSON string representing the `Expr` of the transformed expression.
 */
rssn_
char *rssn_json_fourier_frequency_shift(const char *aFOmegaJson,
                                        const char *aAJson,
                                        const char *aOutVarJson)
;

/*
 Applies the scaling property of the Fourier transform.

 Takes JSON strings representing `Expr` (frequency domain expression), `Expr` (scaling factor `a`),
 and `String` (output variable).
 Returns a JSON string representing the `Expr` of the transformed expression.
 */
rssn_
char *rssn_json_fourier_scaling(const char *aFOmegaJson,
                                const char *aAJson,
                                const char *aOutVarJson)
;

/*
 Computes the Fourier series expansion of an expression.

 Takes JSON strings representing `Expr` (expression), `String` (variable),
 `Expr` (period), and `usize` (order).
 Returns a JSON string representing the `Expr` of the Fourier series.
 */
rssn_
char *rssn_json_fourier_series(const char *aExprJson,
                               const char *aVarJson,
                               const char *aPeriodJson,
                               const char *aOrderJson)
;

/*
 Applies the time shift property of the Fourier transform.

 Takes JSON strings representing `Expr` (frequency domain expression), `Expr` (time shift amount `a`),
 and `String` (output variable).
 Returns a JSON string representing the `Expr` of the transformed expression.
 */
rssn_
char *rssn_json_fourier_time_shift(const char *aFOmegaJson,
                                   const char *aAJson,
                                   const char *aOutVarJson)
;

/*
 Computes the Fourier transform of an expression.

 Takes JSON strings representing `Expr` (expression), `String` (input variable), and `String` (output variable).
 Returns a JSON string representing the `Expr` of the Fourier transform.
 */
rssn_
char *rssn_json_fourier_transform(const char *aExprJson,
                                  const char *aInVarJson,
                                  const char *aOutVarJson)
;

/*
 Computes the symbolic Gamma function Γ(z) via JSON interface.
 */
rssn_
char *rssn_json_gamma(const char *aArgJson)
;

/*
 Computes the gamma function Γ(x) via JSON interface.
 */
rssn_
char *rssn_json_gamma_numerical(const char *aXJson)
;

/*
 Represents Gauss's theorem (JSON)
 */
rssn_
char *rssn_json_gauss_theorem(const char *aVectorFieldJson,
                              const char *aVolumeJson)
;

/*
 Computes general multi-valued arccos (JSON)
 */
rssn_
char *rssn_json_general_arccos(const char *aZJson,
                               const char *aKJson,
                               const char *aSJson)
;

/*
 Computes general multi-valued arcsin (JSON)
 */
rssn_
char *rssn_json_general_arcsin(const char *aZJson,
                               const char *aKJson)
;

/*
 Computes general multi-valued arctan (JSON)
 */
rssn_
char *rssn_json_general_arctan(const char *aZJson,
                               const char *aKJson)
;

/*
 Computes general multi-valued logarithm (JSON)
 */
rssn_
char *rssn_json_general_log(const char *aZJson,
                            const char *aKJson)
;

/*
 Computes general multi-valued n-th root (JSON)
 */
rssn_
char *rssn_json_general_nth_root(const char *aZJson,
                                 const char *aNJson,
                                 const char *aKJson)
;

/*
 Computes general multi-valued power (JSON)
 */
rssn_
char *rssn_json_general_power(const char *aZJson,
                              const char *aWJson,
                              const char *aKJson)
;

/*
 Computes general multi-valued square root (JSON)
 */
rssn_
char *rssn_json_general_sqrt(const char *aZJson,
                             const char *aKJson)
;

/*
 Computes the symbolic Generalized Laguerre polynomial L_n^α(x) via JSON interface.
 */
rssn_
char *rssn_json_generalized_laguerre(const char *aNJson,
                                     const char *aAlphaJson,
                                     const char *aXJson)
;

/*
 Represents the generalized Stokes' theorem (JSON)
 */
rssn_
char *rssn_json_generalized_stokes_theorem(const char *aOmegaJson,
                                           const char *aManifoldJson,
                                           const char *aVarsJson)
;

/*
 Generates a key pair.
 */
rssn_
char *rssn_json_generate_keypair(const char *aCurveJson,
                                 const char *aGeneratorJson)
;

/*
 Generates a shared secret.
 */
rssn_
char *rssn_json_generate_shared_secret(const char *aCurveJson,
                                       const char *aPrivateKeyJson,
                                       const char *aOtherPublicKeyJson)
;

/*
 Gets real and imaginary parts using JSON.
 */
rssn_
char *rssn_json_get_real_imag_parts(const char *aExprJson)
;

/*
 Performs addition in GF(2^8) via JSON interface.
 */
rssn_
char *rssn_json_gf256_add(const char *aAJson,
                          const char *aBJson)
;

/*
 Computes inverse in GF(2^8) via JSON interface.
 */
rssn_
char *rssn_json_gf256_inv(const char *aAJson)
;

/*
 Performs multiplication in GF(2^8) via JSON interface.
 */
rssn_
char *rssn_json_gf256_mul(const char *aAJson,
                          const char *aBJson)
;

/*
 Calculates Gibbs Free Energy using JSON.
 */
rssn_
char *rssn_json_gibbs_free_energy(const char *aHJson,
                                  const char *aTJson,
                                  const char *aSJson)
;

/*
 Computes the Gini impurity of a probability distribution.

 Takes a JSON string representing a `Vec<Expr>` (probabilities).
 Returns a JSON string representing the `Expr` of the Gini impurity.
 */
rssn_
char *rssn_json_gini_impurity(const char *aProbsJson)
;

/*
 Applies the Gram–Schmidt process to produce an orthonormal basis in a Hilbert space using JSON serialization.

 Given a Hilbert space and a list of symbolic basis vectors, this performs the
 Gram–Schmidt orthonormalization procedure to obtain an orthonormal basis.

 # Arguments

 * `space_json` - C string pointer with JSON-encoded [`HilbertSpace`].
 * `basis_json` - C string pointer with JSON-encoded `Vec<Expr>` of basis vectors.

 # Returns

 A C string pointer containing JSON-encoded `Vec<Expr>` for the orthonormal
 basis, or null if any input cannot be deserialized or the computation fails.

 # Safety

 This function is unsafe because it dereferences raw C string pointers and
 returns ownership of a heap-allocated C string that must be freed by the caller.
 */
rssn_
char *rssn_json_gram_schmidt(const char *aSpaceJson,
                             const char *aBasisJson)
;

/*
 Adds an edge to the graph.
 Input JSON: {"graph": <graph>, "from": "label1", "to": "label2", "weight": <expr>}
 */
rssn_
char *rssn_json_graph_add_edge(const char *aJson)
;

/*
 Adds a node to the graph.
 Input JSON: {"graph": <graph>, "label": "node_label"}
 Returns updated graph as JSON.
 */
rssn_
char *rssn_json_graph_add_node(const char *aJson)
;

/*
 Gets the adjacency matrix of the graph.
 Input JSON: <graph>
 Returns Expr (matrix) as JSON.
 */
rssn_
char *rssn_json_graph_adjacency_matrix(const char *aJson)
;

/*
 Performs BFS traversal.
 Input JSON: {"graph": <graph>, "start_node": <index>}
 */
rssn_
char *rssn_json_graph_bfs(const char *aJson)
;

/*
 Performs BFS traversal.
 Input: {"graph": Graph, "start_node": usize}
 Output: [usize]
 */
rssn_
char *rssn_json_graph_bfs_api(const char *aJson)
;

/*
 Finds maximum matching in bipartite graph.
 Input: {"graph": Graph, "partition": [i8]}
 Output: [(usize, usize)]
 */
rssn_
char *rssn_json_graph_bipartite_maximum_matching(const char *aJson)
;

/*
 Finds bridges and articulation points.
 Input: Graph
 Output: {"bridges": [(usize, usize)], "articulation_points": [usize]}
 */
rssn_
char *rssn_json_graph_bridges_and_articulation_points(const char *aJson)
;

/*
 Computes the Cartesian product of two graphs.
 */
rssn_
char *rssn_json_graph_cartesian_product(const char *aJson)
;

/*
 Computes the complement of a graph.
 */
rssn_
char *rssn_json_graph_complement(const char *aJson)
;

/*
 Finds connected components.
 */
rssn_
char *rssn_json_graph_connected_components(const char *aJson)
;

/*
 Finds connected components.
 Input: Graph
 Output: [[usize]] (array of arrays)
 */
rssn_
char *rssn_json_graph_connected_components_api(const char *aJson)
;

/*
 Performs DFS traversal.
 */
rssn_
char *rssn_json_graph_dfs(const char *aJson)
;

/*
 Performs DFS traversal.
 Input: {"graph": Graph, "start_node": usize}
 Output: [usize] (array of node indices)
 */
rssn_
char *rssn_json_graph_dfs_api(const char *aJson)
;

/*
 Computes maximum flow using Dinic's algorithm.
 Input: {"graph": Graph, "source": usize, "sink": usize}
 Output: f64
 */
rssn_
char *rssn_json_graph_dinic_max_flow(const char *aJson)
;

/*
 Computes the disjoint union of two graphs.
 */
rssn_
char *rssn_json_graph_disjoint_union(const char *aJson)
;

/*
 Computes maximum flow using Edmonds-Karp.
 Input: {"graph": Graph, "source": usize, "sink": usize}
 Output: f64
 */
rssn_
char *rssn_json_graph_edmonds_karp_max_flow(const char *aJson)
;

/*
 Checks if graph has a cycle.
 */
rssn_
char *rssn_json_graph_has_cycle(const char *aJson)
;

/*
 Checks if graph has a cycle.
 Input: Graph
 Output: bool
 */
rssn_
char *rssn_json_graph_has_cycle_api(const char *aJson)
;

/*
 Creates an induced subgraph.
 Input JSON: {"graph": <graph>, "nodes": ["label1", "label2"]}
 */
rssn_
char *rssn_json_graph_induced_subgraph(const char *aJson)
;

/*
 Computes the intersection of two graphs.
 */
rssn_
char *rssn_json_graph_intersection(const char *aJson)
;

/*
 Checks if graph is bipartite.
 */
rssn_
char *rssn_json_graph_is_bipartite(const char *aJson)
;

/*
 Checks if graph is bipartite.
 Input: Graph
 Output: [i8] or null
 */
rssn_
char *rssn_json_graph_is_bipartite_api(const char *aJson)
;

/*
 Checks if graph is connected.
 Input: Graph
 Output: bool
 */
rssn_
char *rssn_json_graph_is_connected(const char *aJson)
;

/*
 Computes the join of two graphs.
 */
rssn_
char *rssn_json_graph_join(const char *aJson)
;

/*
 Computes MST using Kruskal's algorithm.
 */
rssn_
char *rssn_json_graph_kruskal_mst(const char *aJson)
;

/*
 Computes MST using Kruskal's algorithm.
 Input: Graph
 Output: Graph (MST)
 */
rssn_
char *rssn_json_graph_kruskal_mst_api(const char *aJson)
;

/*
 Gets the Laplacian matrix of the graph.
 */
rssn_
char *rssn_json_graph_laplacian_matrix(const char *aJson)
;

/*
 Computes maximum flow.
 Input JSON: {"graph": <graph>, "source": <index>, "sink": <index>}
 */
rssn_
char *rssn_json_graph_max_flow(const char *aJson)
;

/*
 Creates a new graph from JSON specification.
 JSON format: {"is_directed": true/false}
 */
rssn_
char *rssn_json_graph_new(const char *aJson)
;

/*
 Finds strongly connected components.
 Input: Graph
 Output: [[usize]]
 */
rssn_
char *rssn_json_graph_strongly_connected_components(const char *aJson)
;

/*
 Computes the Tensor product of two graphs.
 */
rssn_
char *rssn_json_graph_tensor_product(const char *aJson)
;

/*
 Performs topological sort.
 Input: Graph
 Output: [usize] or null
 */
rssn_
char *rssn_json_graph_topological_sort(const char *aJson)
;

/*
 Computes the union of two graphs.
 Input JSON: {"g1": <graph>, "g2": <graph>}
 */
rssn_
char *rssn_json_graph_union(const char *aJson)
;

/*
 Greedy coloring.
 Input: Graph
 Output: {node_id: color_id}
 */
rssn_
char *rssn_json_greedy_coloring(const char *aJson)
;

/*
 Represents Green's theorem (JSON)
 */
rssn_
char *rssn_json_greens_theorem(const char *aPJson,
                               const char *aQJson,
                               const char *aDomainJson)
;

rssn_
char *rssn_json_group_center(const char *aGroupJson)
;

rssn_
char *rssn_json_group_conjugacy_classes(const char *aGroupJson)
;

rssn_
char *rssn_json_group_create(const char *aJsonStr)
;

rssn_
size_t rssn_json_group_element_order(const char *aGroupJson,
                                     const char *aAJson)
;

rssn_
char *rssn_json_group_inverse(const char *aGroupJson,
                              const char *aAJson)
;

rssn_
bool rssn_json_group_is_abelian(const char *aGroupJson)
;

rssn_
char *rssn_json_group_multiply(const char *aGroupJson,
                               const char *aAJson,
                               const char *aBJson)
;

/*
 Applies Hamilton's Principle using JSON.
 */
rssn_
char *rssn_json_hamiltons_principle(const char *aLagrangianJson,
                                    const char *aFunc,
                                    const char *aVar)
;

/*
 Checks if a Hamming(7,4) codeword is valid via JSON interface.
 Input: [7 bytes]
 Returns: boolean
 */
rssn_
char *rssn_json_hamming_check(const char *aCodewordJson)
;

/*
 Decodes a 7-bit Hamming(7,4) codeword via JSON interface.
 Returns JSON object with "data" and "error_pos" fields.
 */
rssn_
char *rssn_json_hamming_decode(const char *aCodewordJson)
;

/*
 Computes Hamming distance between two byte slices via JSON interface.
 Input: {"a": [bytes], "b": [bytes]}
 Returns: distance as integer, or null on error
 */
rssn_
char *rssn_json_hamming_distance(const char *aAJson,
                                 const char *aBJson)
;

/*
 Encodes 4 data bits into a 7-bit Hamming(7,4) codeword via JSON interface.
 */
rssn_
char *rssn_json_hamming_encode(const char *aDataJson)
;

/*
 Computes Hamming weight of a byte slice via JSON interface.
 Input: [bytes]
 Returns: weight as integer
 */
rssn_
char *rssn_json_hamming_weight(const char *aDataJson)
;

/*
 Constructs Hermite's differential equation via JSON interface.
 */
rssn_
char *rssn_json_hermite_differential_equation(const char *aYJson,
                                              const char *aXJson,
                                              const char *aNJson)
;

/*
 Computes the symbolic Hermite polynomial H_n(x) via JSON interface.
 */
rssn_
char *rssn_json_hermite_h(const char *aDegreeJson,
                          const char *aArgJson)
;

/*
 Constructs Rodrigues' formula for Hermite polynomials via JSON interface.
 */
rssn_
char *rssn_json_hermite_rodrigues_formula(const char *aNJson,
                                          const char *aXJson)
;

/*
 Computes Hessian matrix (JSON)
 */
rssn_
char *rssn_json_hessian_matrix(const char *aExprJson,
                               const char *aVarsJson)
;

/*
 Simplifies an expression using the heuristic simplifier (JSON input/output).
 */
rssn_
char *rssn_json_heuristic_simplify(const char *aExprJson)
;

/*
 Constructs a Hilbert space from a JSON-encoded description.

 The input string encodes a [`HilbertSpace`] specification (e.g., underlying
 function space, inner product, and measure), which is deserialized and
 returned in canonical internal form.

 # Arguments

 * `json_str` - C string pointer containing JSON for a `HilbertSpace` description.

 # Returns

 A C string pointer containing JSON-encoded `HilbertSpace`, or null if the
 input cannot be deserialized.

 # Safety

 This function is unsafe because it dereferences a raw C string pointer and
 returns ownership of a heap-allocated C string that must be freed by the caller.
 */
rssn_
char *rssn_json_hilbert_space_create(const char *aJsonStr)
;

/*
 Calculates ideal gas Law using JSON.
 */
rssn_
char *rssn_json_ideal_gas_law(const char *aPJson,
                              const char *aVJson,
                              const char *aNJson,
                              const char *aRJson,
                              const char *aTJson)
;

/*
 Creates a new IteratedFunctionSystem (JSON)
 */
rssn_
char *rssn_json_ifs_create(const char *aFunctionsJson,
                           const char *aProbabilitiesJson,
                           const char *aVariablesJson)
;

/*
 Calculates similarity dimension (JSON)
 */
rssn_
char *rssn_json_ifs_similarity_dimension(const char *aScalingFactorsJson)
;

/*
 Computes the inner product of two functions in a Hilbert space using JSON serialization.

 Given a Hilbert space and two symbolic functions \(f\) and \(g\), this evaluates
 the inner product \(\langle f, g \rangle\) according to the space's inner
 product structure.

 # Arguments

 * `space_json` - C string pointer with JSON-encoded [`HilbertSpace`].
 * `f_json` - C string pointer with JSON-encoded `Expr` for \(f\).
 * `g_json` - C string pointer with JSON-encoded `Expr` for \(g\).

 # Returns

 A C string pointer containing JSON-encoded symbolic inner product (typically
 an `Expr`), or null if any input cannot be deserialized or the computation fails.

 # Safety

 This function is unsafe because it dereferences raw C string pointers and
 returns ownership of a heap-allocated C string that must be freed by the caller.
 */
rssn_
char *rssn_json_inner_product(const char *aSpaceJson,
                              const char *aFJson,
                              const char *aGJson)
;

/*
 Integrates an expression using JSON.
 */
rssn_
char *rssn_json_integrate(const char *aExprJson,
                          const char *aVar)
;

/*
 Integrates a rational function (JSON)
 */
rssn_
char *rssn_json_integrate_rational_function(const char *aExprJson,
                                            const char *aXJson)
;

/*
 Computes erf⁻¹(x) via JSON interface.
 */
rssn_
char *rssn_json_inverse_erf(const char *aXJson)
;

/*
 Computes erfc⁻¹(x) via JSON interface.
 */
rssn_
char *rssn_json_inverse_erfc(const char *aXJson)
;

/*
 Computes the inverse Fourier transform of an expression.

 Takes JSON strings representing `Expr` (expression), `String` (input variable), and `String` (output variable).
 Returns a JSON string representing the `Expr` of the inverse Fourier transform.
 */
rssn_
char *rssn_json_inverse_fourier_transform(const char *aExprJson,
                                          const char *aInVarJson,
                                          const char *aOutVarJson)
;

/*
 Computes the inverse Laplace transform of an expression.

 Takes JSON strings representing `Expr` (expression), `String` (input variable), and `String` (output variable).
 Returns a JSON string representing the `Expr` of the inverse Laplace transform.
 */
rssn_
char *rssn_json_inverse_laplace_transform(const char *aExprJson,
                                          const char *aInVarJson,
                                          const char *aOutVarJson)
;

/*
 Computes the inverse Z-transform of an expression.

 Takes JSON strings representing `Expr` (expression), `String` (input variable), and `String` (output variable).
 Returns a JSON string representing the `Expr` of the inverse Z-transform.
 */
rssn_
char *rssn_json_inverse_z_transform(const char *aExprJson,
                                    const char *aInVarJson,
                                    const char *aOutVarJson)
;

/*
 Checks if a number is prime.

 Takes a JSON string representing an `Expr` (number),
 and returns a JSON string representing a boolean indicating whether the number is prime.
 */
rssn_
char *rssn_json_is_prime(const char *aNJson)
;

/*
 Checks if a logical expression is satisfiable using JSON-based FFI.

 Returns a JSON string containing:
 - `{"result": "satisfiable"}` if satisfiable
 - `{"result": "unsatisfiable"}` if unsatisfiable
 - `{"result": "undecidable"}` if the expression contains quantifiers
 */
rssn_
char *rssn_json_is_satisfiable(const char *aExprJson)
;

/*
 Isolates real roots in an interval (JSON)
 */
rssn_
char *rssn_json_isolate_real_roots(const char *aExprJson,
                                   const char *aVarPtr,
                                   double aPrecision)
;

/*
 Computes the joint entropy of a joint probability distribution.

 Takes a JSON string representing an `Expr` (joint probability distribution).
 Returns a JSON string representing the `Expr` of the joint entropy.
 */
rssn_
char *rssn_json_joint_entropy(const char *aJointProbsJson)
;

/*
 Calculates kinetic energy using JSON.
 */
rssn_
char *rssn_json_kinetic_energy(const char *aMassJson,
                               const char *aVelocityJson)
;

/*
 Computes the Kullback-Leibler divergence between two probability distributions.

 Takes JSON strings representing two `Vec<Expr>` (probability distributions `p` and `q`).
 Returns a JSON string representing the `Expr` of the KL divergence.
 */
rssn_
char *rssn_json_kl_divergence(const char *aPProbsJson,
                              const char *aQProbsJson)
;

/*
 Creates a Klein four-group and returns it as a JSON string.

 # Returns
 A raw pointer to a JSON string representing the group.
 */
rssn_
char *rssn_json_klein_four_group_create(void)
;

/*
 Constructs Laguerre's differential equation via JSON interface.
 */
rssn_
char *rssn_json_laguerre_differential_equation(const char *aYJson,
                                               const char *aXJson,
                                               const char *aNJson)
;

/*
 Computes the symbolic Laguerre polynomial L_n(x) via JSON interface.
 */
rssn_
char *rssn_json_laguerre_l(const char *aDegreeJson,
                           const char *aArgJson)
;

/*
 Applies the differentiation property of the Laplace transform.

 Takes JSON strings representing `Expr` (s-domain expression), `String` (output variable),
 and `Expr` (`f(0)` - initial condition).
 Returns a JSON string representing the `Expr` of the transformed expression.
 */
rssn_
char *rssn_json_laplace_differentiation(const char *aFSJson,
                                        const char *aOutVarJson,
                                        const char *aFZeroJson)
;

/*
 Applies the frequency shift property of the Laplace transform.

 Takes JSON strings representing `Expr` (s-domain expression), `Expr` (frequency shift amount `a`),
 and `String` (output variable).
 Returns a JSON string representing the `Expr` of the transformed expression.
 */
rssn_
char *rssn_json_laplace_frequency_shift(const char *aFSJson,
                                        const char *aAJson,
                                        const char *aOutVarJson)
;

/*
 Applies the integration property of the Laplace transform.

 Takes JSON strings representing `Expr` (s-domain expression) and `String` (output variable).
 Returns a JSON string representing the `Expr` of the transformed expression.
 */
rssn_
char *rssn_json_laplace_integration(const char *aFSJson,
                                    const char *aOutVarJson)
;

/*
 Applies the scaling property of the Laplace transform.

 Takes JSON strings representing `Expr` (s-domain expression), `Expr` (scaling factor `a`),
 and `String` (output variable).
 Returns a JSON string representing the `Expr` of the transformed expression.
 */
rssn_
char *rssn_json_laplace_scaling(const char *aFSJson,
                                const char *aAJson,
                                const char *aOutVarJson)
;

/*
 Applies the time shift property of the Laplace transform.

 Takes JSON strings representing `Expr` (s-domain expression), `Expr` (time shift amount `a`),
 and `String` (output variable).
 Returns a JSON string representing the `Expr` of the transformed expression.
 */
rssn_
char *rssn_json_laplace_time_shift(const char *aFSJson,
                                   const char *aAJson,
                                   const char *aOutVarJson)
;

/*
 Computes the Laplace transform of an expression.

 Takes JSON strings representing `Expr` (expression), `String` (input variable), and `String` (output variable).
 Returns a JSON string representing the `Expr` of the Laplace transform.
 */
rssn_
char *rssn_json_laplace_transform(const char *aExprJson,
                                  const char *aInVarJson,
                                  const char *aOutVarJson)
;

/*
 Computes the Laurent series expansion of an expression.

 Takes JSON strings representing `Expr` (expression), `String` (variable),
 `Expr` (center), and `usize` (order).
 Returns a JSON string representing the `Expr` of the Laurent series.
 */
rssn_
char *rssn_json_laurent_series(const char *aExprJson,
                               const char *aVarJson,
                               const char *aCenterJson,
                               const char *aOrderJson)
;

/*
 Constructs Legendre's differential equation via JSON interface.
 */
rssn_
char *rssn_json_legendre_differential_equation(const char *aYJson,
                                               const char *aXJson,
                                               const char *aNJson)
;

/*
 Computes the symbolic Legendre polynomial P_n(x) via JSON interface.
 */
rssn_
char *rssn_json_legendre_p(const char *aDegreeJson,
                           const char *aArgJson)
;

/*
 Constructs Rodrigues' formula for Legendre polynomials via JSON interface.
 */
rssn_
char *rssn_json_legendre_rodrigues_formula(const char *aNJson,
                                           const char *aXJson)
;

rssn_
char *rssn_json_lie_algebra_so3(void)
;

rssn_
char *rssn_json_lie_algebra_su2(void)
;

rssn_
char *rssn_json_lie_bracket(const char *aXJson,
                            const char *aYJson)
;

/*
 Computes limit using JSON.
 */
rssn_
char *rssn_json_limit(const char *aExprJson,
                      const char *aVar,
                      const char *aPointJson)
;

/*
 Computes ln(B(a, b)) via JSON interface.
 */
rssn_
char *rssn_json_ln_beta_numerical(const char *aAJson,
                                  const char *aBJson)
;

/*
 Computes ln(n!) via JSON interface.
 */
rssn_
char *rssn_json_ln_factorial(const char *aNJson)
;

/*
 Computes the symbolic log-gamma function ln(Γ(z)) via JSON interface.
 */
rssn_
char *rssn_json_ln_gamma(const char *aArgJson)
;

/*
 Computes ln(Γ(x)) via JSON interface.
 */
rssn_
char *rssn_json_ln_gamma_numerical(const char *aXJson)
;

/*
 Calculates Lorentz factor using JSON.
 */
rssn_
char *rssn_json_lorentz_factor(const char *aVelocityJson)
;

/*
 Calculates Lorentz force using JSON.
 */
rssn_
char *rssn_json_lorentz_force(const char *aChargeJson,
                              const char *aEFieldJson,
                              const char *aVelocityJson,
                              const char *aBFieldJson)
;

/*
 Returns Lorenz system equations (JSON)
 */
rssn_
char *rssn_json_lorenz_system(void)
;

/*
 Calculates Lyapunov exponent (JSON)
 */
rssn_
char *rssn_json_lyapunov_exponent(const char *aMapJson,
                                  const char *aVar,
                                  const char *aInitialXJson,
                                  size_t aNIterations)
;

/*
 Calculates mass-energy equivalence using JSON.
 */
rssn_
char *rssn_json_mass_energy_equivalence(const char *aMassJson)
;

/*
 Performs matrix addition.

 Takes two JSON strings representing `Expr` (matrices) as input,
 and returns a JSON string representing their sum.
 */
rssn_
char *rssn_json_matrix_add(const char *aM1Json,
                           const char *aM2Json)
;

/*
 Computes the determinant of a matrix.

 Takes a JSON string representing an `Expr` (matrix) as input,
 and returns a JSON string representing its determinant.
 */
rssn_
char *rssn_json_matrix_determinant(const char *aMatrixJson)
;

/*
 Computes the inverse of a matrix.

 Takes a JSON string representing an `Expr` (matrix) as input,
 and returns a JSON string representing its inverse.
 */
rssn_
char *rssn_json_matrix_inverse(const char *aMatrixJson)
;

/*
 Performs matrix multiplication.

 Takes two JSON strings representing `Expr` (matrices) as input,
 and returns a JSON string representing their product.
 */
rssn_
char *rssn_json_matrix_mul(const char *aM1Json,
                           const char *aM2Json)
;

/*
 Solves a linear system of equations AX = B.

 Takes two JSON strings representing `Expr` (matrix A and vector B) as input,
 and returns a JSON string representing the solution vector X.
 */
rssn_
char *rssn_json_matrix_solve_linear_system(const char *aAJson,
                                           const char *aBJson)
;

/*
 Performs matrix transposition.

 Takes a JSON string representing an `Expr` (matrix) as input,
 and returns a JSON string representing its transpose.
 */
rssn_
char *rssn_json_matrix_transpose(const char *aMatrixJson)
;

/*
 Computes the symbolic mean of a set of expressions using JSON.
 */
rssn_
char *rssn_json_mean(const char *aDataJson)
;

/*
 Computes geometric product (JSON)
 */
rssn_
char *rssn_json_multivector_geometric_product(const char *aAJson,
                                              const char *aBJson)
;

/*
 Computes grade projection (JSON)
 */
rssn_
char *rssn_json_multivector_grade_projection(const char *aMvJson,
                                             uint32_t aGrade)
;

/*
 Computes inner product (JSON)
 */
rssn_
char *rssn_json_multivector_inner_product(const char *aAJson,
                                          const char *aBJson)
;

/*
 Computes magnitude (JSON)
 */
rssn_
char *rssn_json_multivector_magnitude(const char *aMvJson)
;

/*
 Computes outer product (JSON)
 */
rssn_
char *rssn_json_multivector_outer_product(const char *aAJson,
                                          const char *aBJson)
;

/*
 Computes reverse (JSON)
 */
rssn_
char *rssn_json_multivector_reverse(const char *aMvJson)
;

/*
 Creates a new scalar multivector (JSON)
 */
rssn_
char *rssn_json_multivector_scalar(uint32_t aP,
                                   uint32_t aQ,
                                   uint32_t aR,
                                   const char *aValueJson)
;

/*
 Computes the mutual information between two random variables from their joint probability distribution.

 Takes a JSON string representing an `Expr` (joint probability distribution).
 Returns a JSON string representing the `Expr` of the mutual information.
 */
rssn_
char *rssn_json_mutual_information(const char *aJointProbsJson)
;

/*
 Performs a nonlinear regression.

 Takes JSON strings representing `Vec<(Expr, Expr)>` (data points), `Expr` (model),
 `Vec<String>` (variables), and `Vec<String>` (parameters).
 Returns a JSON string representing `Vec<(Expr, Expr)>` (optimized parameter values).
 */
rssn_
char *rssn_json_nonlinear_regression(const char *aDataJson,
                                     const char *aModelJson,
                                     const char *aVarsJson,
                                     const char *aParamsJson)
;

/*
 Computes the norm of a function in a Hilbert space using JSON serialization.

 Given a Hilbert space and a symbolic function \(f\), this evaluates the norm
 \(\|f\| = \sqrt{\langle f, f \rangle}\) induced by the inner product.

 # Arguments

 * `space_json` - C string pointer with JSON-encoded [`HilbertSpace`].
 * `f_json` - C string pointer with JSON-encoded `Expr` for \(f\).

 # Returns

 A C string pointer containing JSON-encoded symbolic norm (typically an `Expr`),
 or null if any input cannot be deserialized or the computation fails.

 # Safety

 This function is unsafe because it dereferences raw C string pointers and
 returns ownership of a heap-allocated C string that must be freed by the caller.
 */
rssn_
char *rssn_json_norm(const char *aSpaceJson,
                     const char *aFJson)
;

/*
 Performs a one-sample t-test.

 Takes JSON strings representing `Vec<Expr>` (data) and `Expr` (target mean).
 Returns a JSON string representing the `HypothesisTest` result.
 */
rssn_
char *rssn_json_one_sample_t_test(const char *aDataJson,
                                  const char *aTargetMeanJson)
;

/*
 Computes the partial fraction decomposition of an expression.

 Takes JSON strings representing `Expr` (expression) and `String` (variable).
 Returns a JSON string representing `Vec<Expr>` (partial fraction decomposition).
 */
rssn_
char *rssn_json_partial_fraction_decomposition(const char *aExprJson,
                                               const char *aVarJson)
;

/*
 Computes path integral using JSON.
 */
rssn_
char *rssn_json_path_integrate(const char *aExprJson,
                               const char *aVar,
                               const char *aContourJson)
;

/*
 Computes the number of permutations symbolically using JSON-encoded `Expr` arguments.

 This corresponds to the falling factorial \( P(n,k) = n! / (n-k)! \) when `n` and `k`
 are integers, but operates on general symbolic expressions.

 # Arguments

 * `n_json` - C string pointer to JSON encoding an `Expr` for the population size `n`.
 * `k_json` - C string pointer to JSON encoding an `Expr` for the selection size `k`.

 # Returns

 A C string pointer containing JSON-encoded `Expr` for the symbolic permutation count,
 or null on deserialization failure.

 # Safety

 This function is unsafe because it dereferences raw C string pointers and returns
 ownership of a heap-allocated C string.
 */
rssn_
char *rssn_json_permutations(const char *aNJson,
                             const char *aKJson)
;

/*
 Compresses a point.
 */
rssn_
char *rssn_json_point_compress(const char *aPointJson)
;

/*
 Decompresses a point.
 */
rssn_
char *rssn_json_point_decompress(const char *aXJson,
                                 const char *aIsOddJson,
                                 const char *aCurveJson)
;

/*
 Adds two polynomials over a general finite field via JSON interface.
 */
rssn_
char *rssn_json_poly_add_gf(const char *aP1Json,
                            const char *aP2Json,
                            const char *aModulusJson)
;

/*
 Adds two polynomials over GF(2^8) via JSON interface.
 */
rssn_
char *rssn_json_poly_add_gf256(const char *aP1Json,
                               const char *aP2Json)
;

/*
 Computes polynomial derivative over finite field (JSON)
 */
rssn_
char *rssn_json_poly_derivative_gf(const char *aPolyJson)
;

/*
 Divides a multivariate polynomial by a list of divisors under a given monomial order
 and returns quotients and remainder as JSON-encoded polynomials.

 # Arguments

 * `dividend_json` - C string pointer with JSON-encoded dividend `SparsePolynomial`.
 * `divisors_json` - C string pointer with JSON-encoded `Vec<SparsePolynomial>` of divisors.
 * `order_json` - C string pointer with JSON-encoded [`MonomialOrder`].

 # Returns

 A C string pointer containing JSON-encoded `(Vec<SparsePolynomial>, SparsePolynomial)`
 with quotient polynomials and remainder, or null if deserialization fails or the
 computation encounters an error.

 # Safety

 This function is unsafe because it dereferences raw C string pointers and returns
 ownership of a heap-allocated C string that must be freed by the caller.
 */
rssn_
char *rssn_json_poly_division_multivariate(const char *aDividendJson,
                                           const char *aDivisorsJson,
                                           const char *aOrderJson)
;

/*
 Evaluates a polynomial over GF(2^8) via JSON interface.
 */
rssn_
char *rssn_json_poly_eval_gf256(const char *aPolyJson,
                                const char *aXJson)
;

/*
 Computes polynomial GCD over finite field (JSON)
 */
rssn_
char *rssn_json_poly_gcd_gf(const char *aAJson,
                            const char *aBJson)
;

/*
 Multiplies two polynomials over a general finite field via JSON interface.
 */
rssn_
char *rssn_json_poly_mul_gf(const char *aP1Json,
                            const char *aP2Json,
                            const char *aModulusJson)
;

/*
 Multiplies two polynomials over GF(2^8) via JSON interface.
 */
rssn_
char *rssn_json_poly_mul_gf256(const char *aP1Json,
                               const char *aP2Json)
;

/*
 Computes the symbolic Polygamma function ψ⁽ⁿ⁾(z) via JSON interface.
 */
rssn_
char *rssn_json_polygamma(const char *aNJson,
                          const char *aZJson)
;

/*
 Checks if an expression contains a variable (JSON)
 */
rssn_
bool rssn_json_polynomial_contains_var(const char *aExprJson,
                                       const char *aVar)
;

/*
 Computes the degree of a polynomial (JSON)
 */
rssn_
int64_t rssn_json_polynomial_degree(const char *aExprJson,
                                    const char *aVar)
;

/*
 Checks if an expression is a polynomial in the given variable (JSON)
 */
rssn_
bool rssn_json_polynomial_is_polynomial(const char *aExprJson,
                                        const char *aVar)
;

/*
 Finds the leading coefficient of a polynomial (JSON)
 */
rssn_
char *rssn_json_polynomial_leading_coefficient(const char *aExprJson,
                                               const char *aVar)
;

/*
 Performs polynomial long division (JSON)
 */
rssn_
char *rssn_json_polynomial_long_division(const char *aDividendJson,
                                         const char *aDivisorJson,
                                         const char *aVar)
;

/*
 Performs a polynomial regression.

 Takes a JSON string representing `Vec<(Expr, Expr)>` (data points) and a `usize` (degree).
 Returns a JSON string representing a `Vec<Expr>` containing the coefficients of the polynomial.
 */
rssn_
char *rssn_json_polynomial_regression(const char *aDataJson,
                                      size_t aDegree)
;

/*
 Converts polynomial to coefficient vector (JSON)
 */
rssn_
char *rssn_json_polynomial_to_coeffs_vec(const char *aExprJson,
                                         const char *aVar)
;

/*
 Adds two prime field elements (JSON)
 */
rssn_
char *rssn_json_prime_field_element_add(const char *aAJson,
                                        const char *aBJson)
;

/*
 Divides two prime field elements (JSON)
 */
rssn_
char *rssn_json_prime_field_element_div(const char *aAJson,
                                        const char *aBJson)
;

/*
 Computes the inverse of a prime field element (JSON)
 */
rssn_
char *rssn_json_prime_field_element_inverse(const char *aElemJson)
;

/*
 Multiplies two prime field elements (JSON)
 */
rssn_
char *rssn_json_prime_field_element_mul(const char *aAJson,
                                        const char *aBJson)
;

/*
 Creates a new prime field element (JSON)
 */
rssn_
char *rssn_json_prime_field_element_new(const char *aValueJson,
                                        const char *aModulusJson)
;

/*
 Subtracts two prime field elements (JSON)
 */
rssn_
char *rssn_json_prime_field_element_sub(const char *aAJson,
                                        const char *aBJson)
;

/*
 Computes the product of an expression.

 Takes JSON strings representing `Expr` (expression), `String` (variable),
 `Expr` (lower bound), and `Expr` (upper bound).
 Returns a JSON string representing the `Expr` of the product.
 */
rssn_
char *rssn_json_product(const char *aExprJson,
                        const char *aVarJson,
                        const char *aLowerJson,
                        const char *aUpperJson)
;

/*
 Lagrangian density for QCD using JSON.
 */
rssn_
char *rssn_json_qcd_lagrangian(const char *aPsiBarJson,
                               const char *aPsiJson,
                               const char *aGMuJson,
                               const char *aMJson,
                               const char *aGsJson)
;

/*
 Lagrangian density for QED using JSON.
 */
rssn_
char *rssn_json_qed_lagrangian(const char *aPsiBarJson,
                               const char *aPsiJson,
                               const char *aAMuJson,
                               const char *aMJson,
                               const char *aEJson)
;

/*
 Computes a propagator using JSON.
 */
rssn_
char *rssn_json_qft_propagator(const char *aPJson,
                               const char *aMJson,
                               bool aIsFermion)
;

/*
 Generates a 3x3 2D reflection matrix via JSON interface.
 */
rssn_
char *rssn_json_reflection_2d(const char *aAngleJson)
;

/*
 Generates a 4x4 3D reflection matrix via JSON interface.
 */
rssn_
char *rssn_json_reflection_3d(const char *aNxJson,
                              const char *aNyJson,
                              const char *aNzJson)
;

/*
 Computes P(a, x) via JSON interface.
 */
rssn_
char *rssn_json_regularized_gamma_p(const char *aAJson,
                                    const char *aXJson)
;

/*
 Computes Q(a, x) via JSON interface.
 */
rssn_
char *rssn_json_regularized_gamma_q(const char *aAJson,
                                    const char *aXJson)
;

/*
 Computes the regularized incomplete beta Iₓ(a, b) via JSON interface.
 */
rssn_
char *rssn_json_regularized_incomplete_beta(const char *aAJson,
                                            const char *aBJson,
                                            const char *aXJson)
;

rssn_
char *rssn_json_representation_create(const char *aJsonStr)
;

rssn_
bool rssn_json_representation_is_valid(const char *aRepJson,
                                       const char *aGroupJson)
;

/*
 Integrates an expression using the Risch-Norman algorithm (JSON)
 */
rssn_
char *rssn_json_risch_norman_integrate(const char *aExprJson,
                                       const char *aXJson)
;

/*
 Computes the rising factorial (x)ₙ via JSON interface.
 */
rssn_
char *rssn_json_rising_factorial(const char *aXJson,
                                 const char *aNJson)
;

/*
 Generates a 3x3 2D rotation matrix via JSON interface.
 */
rssn_
char *rssn_json_rotation_2d(const char *aAngleJson)
;

/*
 Generates a 4x4 3D rotation matrix around X-axis via JSON interface.
 */
rssn_
char *rssn_json_rotation_3d_x(const char *aAngleJson)
;

/*
 Generates a 4x4 3D rotation matrix around Y-axis via JSON interface.
 */
rssn_
char *rssn_json_rotation_3d_y(const char *aAngleJson)
;

/*
 Generates a 4x4 3D rotation matrix around Z-axis via JSON interface.
 */
rssn_
char *rssn_json_rotation_3d_z(const char *aAngleJson)
;

/*
 Generates a 4x4 3D rotation around arbitrary axis via JSON interface.
 */
rssn_
char *rssn_json_rotation_axis_angle(const char *aAxisXJson,
                                    const char *aAxisYJson,
                                    const char *aAxisZJson,
                                    const char *aAngleJson)
;

/*
 Checks if a Reed-Solomon codeword is valid via JSON interface.
 Returns: boolean
 */
rssn_
char *rssn_json_rs_check(const char *aCodewordJson,
                         const char *aNSymJson)
;

/*
 Decodes a Reed-Solomon codeword via JSON interface.
 */
rssn_
char *rssn_json_rs_decode(const char *aCodewordJson,
                          const char *aNSymJson)
;

/*
 Encodes data using Reed-Solomon code via JSON interface.
 Input: {"data": [bytes], "n_sym": number}
 */
rssn_
char *rssn_json_rs_encode(const char *aDataJson,
                          const char *aNSymJson)
;

/*
 Estimates error count in a Reed-Solomon codeword via JSON interface.
 Returns: error count as integer
 */
rssn_
char *rssn_json_rs_error_count(const char *aCodewordJson,
                               const char *aNSymJson)
;

/*
 Lagrangian density for a scalar field using JSON.
 */
rssn_
char *rssn_json_scalar_field_lagrangian(const char *aPhiJson,
                                        const char *aMJson)
;

/*
 Generates a 3x3 2D scaling matrix via JSON interface.
 */
rssn_
char *rssn_json_scaling_2d(const char *aSxJson,
                           const char *aSyJson)
;

/*
 Generates a 4x4 3D scaling matrix via JSON interface.
 */
rssn_
char *rssn_json_scaling_3d(const char *aSxJson,
                           const char *aSyJson,
                           const char *aSzJson)
;

/*
 Calculates Schwarzschild radius using JSON.
 */
rssn_
char *rssn_json_schwarzschild_radius(const char *aMassJson)
;

/*
 Computes the Shannon entropy of a probability distribution.

 Takes a JSON string representing a `Vec<Expr>` (probabilities).
 Returns a JSON string representing the `Expr` of the entropy.
 */
rssn_
char *rssn_json_shannon_entropy(const char *aProbsJson)
;

/*
 Generates a 3x3 2D shear matrix via JSON interface.
 */
rssn_
char *rssn_json_shear_2d(const char *aShxJson,
                         const char *aShyJson)
;

/*
 Performs a simple linear regression.

 Takes a JSON string representing `Vec<(Expr, Expr)>` (data points).
 Returns a JSON string representing a `Vec<Expr>` containing the intercept and slope coefficients.
 */
rssn_
char *rssn_json_simple_linear_regression(const char *aDataJson)
;

/*
 Creates a new Simplex (JSON)
 */
rssn_
char *rssn_json_simplex_create(const char *aVerticesJson)
;

/*
 Gets the dimension of a Simplex (JSON)
 */
rssn_
char *rssn_json_simplex_dimension(const char *aSimplexJson)
;

/*
 Adds a simplex to a SimplicialComplex (JSON)
 */
rssn_
char *rssn_json_simplicial_complex_add_simplex(const char *aComplexJson,
                                               const char *aVerticesJson)
;

/*
 Applies the symbolic boundary operator to a SymbolicChain (JSON)
 */
rssn_
char *rssn_json_simplicial_complex_apply_symbolic_boundary_operator(const char *aComplexJson,
                                                                    const char *aChainJson)
;

/*
 Creates a new SimplicialComplex (JSON)
 */
rssn_
char *rssn_json_simplicial_complex_create(void)
;

/*
 Gets the symbolic boundary matrix for dimension k (JSON)
 */
rssn_
char *rssn_json_simplicial_complex_get_symbolic_boundary_matrix(const char *aComplexJson,
                                                                size_t aK)
;

/*
 Simplifies an expression using the legacy simplifier (JSON input/output).
 */
rssn_
char *rssn_json_simplify(const char *aExprJson)
;

/*
 Simplifies an expression using the DAG-based simplifier (JSON input/output).
 */
rssn_
char *rssn_json_simplify_dag(const char *aExprJson)
;

/*
 Simplifies a logical expression using JSON-based FFI.
 */
rssn_
char *rssn_json_simplify_logic(const char *aExprJson)
;

/*
 Simplifies radical expressions (JSON)
 */
rssn_
char *rssn_json_simplify_radicals(const char *aExprJson)
;

/*
 Computes sinc(x) via JSON interface.
 */
rssn_
char *rssn_json_sinc(const char *aXJson)
;

rssn_
char *rssn_json_so3_generators(void)
;

/*
 Solves an equation for a given variable.

 Takes JSON strings representing `Expr` (equation) and `String` (variable).
 Returns a JSON string representing the `Expr` of the solution.
 */
rssn_
char *rssn_json_solve(const char *aExprJson,
                      const char *aVarJson)
;

/*
 Solves a Bernoulli ODE using JSON.
 */
rssn_
char *rssn_json_solve_bernoulli_ode(const char *aEquationJson,
                                    const char *aFunc,
                                    const char *aVar)
;

/*
 Solves by reduction of order using JSON.
 */
rssn_
char *rssn_json_solve_by_reduction_of_order(const char *aEquationJson,
                                            const char *aFunc,
                                            const char *aVar,
                                            const char *aY1Json)
;

/*
 Solves a Cauchy-Euler ODE using JSON.
 */
rssn_
char *rssn_json_solve_cauchy_euler_ode(const char *aEquationJson,
                                       const char *aFunc,
                                       const char *aVar)
;

/*
 Solves a Diophantine equation.

 Takes JSON strings representing the equation (`Expr`) and variables (`Vec<String>`),
 and returns a JSON string representing the `Vec<Expr>` of solutions.
 */
rssn_
char *rssn_json_solve_diophantine(const char *aEquationJson,
                                  const char *aVarsJson)
;

/*
 Generates and attempts to solve the Euler-Lagrange equation using JSON.
 */
rssn_
char *rssn_json_solve_euler_lagrange(const char *aLagrangianJson,
                                     const char *aFunc,
                                     const char *aVar)
;

/*
 Solves an exact ODE using JSON.
 */
rssn_
char *rssn_json_solve_exact_ode(const char *aEquationJson,
                                const char *aFunc,
                                const char *aVar)
;

/*
 Solves a first-order linear ODE using JSON.
 */
rssn_
char *rssn_json_solve_first_order_linear_ode(const char *aEquationJson,
                                             const char *aFunc,
                                             const char *aVar)
;

/*
 Solves the 1D heat equation (JSON).
 */
rssn_
char *rssn_json_solve_heat_equation_1d(const char *aEquationJson,
                                       const char *aFunc,
                                       const char *aVarsJson)
;

/*
 Solves the 2D Laplace equation (JSON).
 */
rssn_
char *rssn_json_solve_laplace_equation_2d(const char *aEquationJson,
                                          const char *aFunc,
                                          const char *aVarsJson)
;

/*
 Solves a linear system of equations.

 Takes JSON strings representing `Expr` (system) and `Vec<String>` (variables).
 Returns a JSON string representing the `Expr` of the solution.
 */
rssn_
char *rssn_json_solve_linear_system(const char *aSystemJson,
                                    const char *aVarsJson)
;

/*
 Solves an ODE using JSON.
 */
rssn_
char *rssn_json_solve_ode(const char *aOdeJson,
                          const char *aFunc,
                          const char *aVar)
;

/*
 Solves a PDE using JSON with automatic method selection.
 */
rssn_
char *rssn_json_solve_pde(const char *aPdeJson,
                          const char *aFunc,
                          const char *aVarsJson)
;

/*
 Solves a PDE using the method of characteristics (JSON).
 */
rssn_
char *rssn_json_solve_pde_by_characteristics(const char *aEquationJson,
                                             const char *aFunc,
                                             const char *aVarsJson)
;

/*
 Solves the 2D Poisson equation (JSON).
 */
rssn_
char *rssn_json_solve_poisson_equation_2d(const char *aEquationJson,
                                          const char *aFunc,
                                          const char *aVarsJson)
;

/*
 Solves a Riccati ODE using JSON.
 */
rssn_
char *rssn_json_solve_riccati_ode(const char *aEquationJson,
                                  const char *aFunc,
                                  const char *aVar,
                                  const char *aY1Json)
;

/*
 Solves a separable ODE using JSON.
 */
rssn_
char *rssn_json_solve_separable_ode(const char *aEquationJson,
                                    const char *aFunc,
                                    const char *aVar)
;

/*
 Solves a system of equations for given variables.

 Takes JSON strings representing `Vec<Expr>` (equations) and `Vec<String>` (variables).
 Returns a JSON string representing the `Expr` of the solution.
 */
rssn_
char *rssn_json_solve_system(const char *aEquationsJson,
                             const char *aVarsJson)
;

/*
 Solves the 1D wave equation using D'Alembert's formula (JSON).
 */
rssn_
char *rssn_json_solve_wave_equation_1d(const char *aEquationJson,
                                       const char *aFunc,
                                       const char *aVarsJson)
;

/*
 Computes square-free factorization (JSON)
 */
rssn_
char *rssn_json_square_free_factorization_gf(const char *aPolyJson)
;

/*
 Computes the symbolic standard deviation of a set of expressions using JSON.
 */
rssn_
char *rssn_json_std_dev(const char *aDataJson)
;

/*
 Computes a Stirling number of the second kind symbolically and returns it as JSON-encoded `Expr`.

 Stirling numbers of the second kind \( S(n,k) \) count partitions of an \(n\)-element
 set into \(k\) non-empty unlabeled blocks.

 # Arguments

 * `n` - Total number of elements.
 * `k` - Number of non-empty blocks.

 # Returns

 A C string pointer containing JSON-encoded `Expr` for \( S(n,k) \).

 # Safety

 This function is unsafe because it is exposed as an FFI entry point and returns
 ownership of a heap-allocated C string.
 */
rssn_
char *rssn_json_stirling_number_second_kind(size_t aN,
                                            size_t aK)
;

/*
 Represents Stokes' theorem (JSON)
 */
rssn_
char *rssn_json_stokes_theorem(const char *aVectorFieldJson,
                               const char *aSurfaceJson)
;

/*
 Generates the Sturm sequence for a given polynomial (JSON)
 */
rssn_
char *rssn_json_sturm_sequence(const char *aExprJson,
                               const char *aVarPtr)
;

/*
 Returns the SU(2) Lie algebra generators as a JSON string.
 */
rssn_
char *rssn_json_su2_generators(void)
;

/*
 Substitutes using JSON.
 */
rssn_
char *rssn_json_substitute(const char *aExprJson,
                           const char *aVar,
                           const char *aReplacementJson)
;

/*
 Computes the summation of an expression.

 Takes JSON strings representing `Expr` (expression), `String` (variable),
 `Expr` (lower bound), and `Expr` (upper bound).
 Returns a JSON string representing the `Expr` of the summation.
 */
rssn_
char *rssn_json_summation(const char *aExprJson,
                          const char *aVarJson,
                          const char *aLowerJson,
                          const char *aUpperJson)
;

/*
 Adds a term to a SymbolicChain (JSON)
 */
rssn_
char *rssn_json_symbolic_chain_add_term(const char *aChainJson,
                                        const char *aSimplexJson,
                                        const char *aCoeffJson)
;

/*
 Creates a new SymbolicChain (JSON)
 */
rssn_
char *rssn_json_symbolic_chain_create(size_t aDimension)
;

/*
 Creates a symmetric group of degree `n` and returns it as a JSON string.

 # Arguments
 * `n` - The number of symbols the group acts on.

 # Returns
 A raw pointer to a JSON string representing the group, or NULL if `n` is invalid.
 */
rssn_
char *rssn_json_symmetric_group_create(size_t aN)
;

/*
 Computes the Taylor series expansion of an expression.

 Takes JSON strings representing `Expr` (expression), `String` (variable),
 `Expr` (center), and `usize` (order).
 Returns a JSON string representing the `Expr` of the Taylor series.
 */
rssn_
char *rssn_json_taylor_series(const char *aExprJson,
                              const char *aVarJson,
                              const char *aCenterJson,
                              const char *aOrderJson)
;

/*
 Performs tensor addition.

 Takes two JSON strings representing `Tensor` objects as input,
 and returns a JSON string representing their sum.
 */
rssn_
char *rssn_json_tensor_add(const char *aT1Json,
                           const char *aT2Json)
;

/*
 Performs tensor contraction.

 Takes a JSON string representing a `Tensor`, and two `usize` values representing the axes to contract.
 Returns a JSON string representing the contracted `Tensor`.
 */
rssn_
char *rssn_json_tensor_contract(const char *aTJson,
                                size_t aAxis1,
                                size_t aAxis2)
;

/*
 Computes the outer product of two tensors.

 Takes two JSON strings representing `Tensor` objects as input,
 and returns a JSON string representing their outer product.
 */
rssn_
char *rssn_json_tensor_outer_product(const char *aT1Json,
                                     const char *aT2Json)
;

/*
 Performs scalar multiplication on a tensor.

 Takes a JSON string representing a `Tensor` and a JSON string representing an `Expr` (scalar).
 Returns a JSON string representing the resulting `Tensor`.
 */
rssn_
char *rssn_json_tensor_scalar_mul(const char *aTJson,
                                  const char *aScalarJson)
;

/*
 Converts a logical expression to Conjunctive Normal Form (CNF) using JSON-based FFI.
 */
rssn_
char *rssn_json_to_cnf(const char *aExprJson)
;

/*
 Converts a logical expression to Disjunctive Normal Form (DNF) using JSON-based FFI.
 */
rssn_
char *rssn_json_to_dnf(const char *aExprJson)
;

/*
 Transforms contravariant vector components between coordinate systems using JSON serialization.

 # Arguments

 * `comps_json` - C string pointer to JSON encoding a `Vec<Expr>` of contravariant components
   in the `from` system.
 * `from` - Source [`CoordinateSystem`].
 * `to` - Target [`CoordinateSystem`].

 # Returns

 A C string pointer containing JSON-encoded `Vec<Expr>` with components in the `to` system,
 or null on deserialization or transformation failure.

 # Safety

 This function is unsafe because it dereferences a raw C string pointer and returns
 ownership of a heap-allocated C string.
 */
rssn_
char *rssn_json_transform_contravariant_vector(const char *aCompsJson,
                                               enum rssn_CoordinateSystem aFrom,
                                               enum rssn_CoordinateSystem aTo)
;

/*
 Transforms covariant vector components between coordinate systems using JSON serialization.

 # Arguments

 * `comps_json` - C string pointer to JSON encoding a `Vec<Expr>` of covariant components
   in the `from` system.
 * `from` - Source [`CoordinateSystem`].
 * `to` - Target [`CoordinateSystem`].

 # Returns

 A C string pointer containing JSON-encoded `Vec<Expr>` with components in the `to` system,
 or null on deserialization or transformation failure.

 # Safety

 This function is unsafe because it dereferences a raw C string pointer and returns
 ownership of a heap-allocated C string.
 */
rssn_
char *rssn_json_transform_covariant_vector(const char *aCompsJson,
                                           enum rssn_CoordinateSystem aFrom,
                                           enum rssn_CoordinateSystem aTo)
;

/*
 Computes the curl of a vector field in a given coordinate system using JSON serialization.

 # Arguments

 * `comps_json` - C string pointer to JSON encoding a `Vec<Expr>` of vector components.
 * `from` - [`CoordinateSystem`] with respect to which the curl is taken.

 # Returns

 A C string pointer containing JSON-encoded `Vec<Expr>` for the curl, or null on failure.

 # Safety

 This function is unsafe because it dereferences a raw C string pointer and returns
 ownership of a heap-allocated C string.
 */
rssn_
char *rssn_json_transform_curl(const char *aCompsJson,
                               enum rssn_CoordinateSystem aFrom)
;

/*
 Computes the divergence of a vector field in a given coordinate system using JSON serialization.

 # Arguments

 * `comps_json` - C string pointer to JSON encoding a `Vec<Expr>` of vector components.
 * `from` - [`CoordinateSystem`] with respect to which the divergence is taken.

 # Returns

 A C string pointer containing JSON-encoded `Expr` for the divergence, or null on failure.

 # Safety

 This function is unsafe because it dereferences a raw C string pointer and returns
 ownership of a heap-allocated C string.
 */
rssn_
char *rssn_json_transform_divergence(const char *aCompsJson,
                                     enum rssn_CoordinateSystem aFrom)
;

/*
 Transforms a scalar expression between coordinate systems using JSON serialization.

 # Arguments

 * `expr_json` - C string pointer to JSON encoding an `Expr` in the `from` system.
 * `from` - Source [`CoordinateSystem`].
 * `to` - Target [`CoordinateSystem`].

 # Returns

 A C string pointer containing JSON-encoded `Expr` for the transformed expression in
 the `to` system, or null on deserialization or transformation failure.

 # Safety

 This function is unsafe because it dereferences a raw C string pointer and returns
 ownership of a heap-allocated C string.
 */
rssn_
char *rssn_json_transform_expression(const char *aExprJson,
                                     enum rssn_CoordinateSystem aFrom,
                                     enum rssn_CoordinateSystem aTo)
;

/*
 Computes the gradient of a scalar field and transforms it between coordinate systems
 using JSON serialization.

 # Arguments

 * `scalar_json` - C string pointer to JSON encoding an `Expr` for the scalar field.
 * `vars_json` - C string pointer to JSON encoding a `Vec<String>` of coordinate variables.
 * `from` - Source [`CoordinateSystem`].
 * `to` - Target [`CoordinateSystem`].

 # Returns

 A C string pointer containing JSON-encoded `Vec<Expr>` for the gradient components in
 the `to` system, or null on deserialization or transformation failure.

 # Safety

 This function is unsafe because it dereferences raw C string pointers and returns
 ownership of a heap-allocated C string.
 */
rssn_
char *rssn_json_transform_gradient(const char *aScalarJson,
                                   const char *aVarsJson,
                                   enum rssn_CoordinateSystem aFrom,
                                   enum rssn_CoordinateSystem aTo)
;

/*
 Transforms a point between coordinate systems using JSON-encoded coordinates.

 The point is represented as a JSON-encoded `Vec<Expr>` (e.g., \([x,y,z]\)), and the
 transformation applies the appropriate coordinate mapping.

 # Arguments

 * `point_json` - C string pointer to JSON encoding a `Vec<Expr>` for the point in the `from` system.
 * `from` - Source [`CoordinateSystem`].
 * `to` - Target [`CoordinateSystem`].

 # Returns

 A C string pointer containing JSON-encoded `Vec<Expr>` for the point in the `to` system,
 or null on deserialization or transformation failure.

 # Safety

 This function is unsafe because it dereferences a raw C string pointer and returns
 ownership of a heap-allocated C string.
 */
rssn_
char *rssn_json_transform_point(const char *aPointJson,
                                enum rssn_CoordinateSystem aFrom,
                                enum rssn_CoordinateSystem aTo)
;

/*
 Generates a 3x3 2D translation matrix via JSON interface.
 */
rssn_
char *rssn_json_translation_2d(const char *aTxJson,
                               const char *aTyJson)
;

/*
 Generates a 4x4 3D translation matrix via JSON interface.
 */
rssn_
char *rssn_json_translation_3d(const char *aTxJson,
                               const char *aTyJson,
                               const char *aTzJson)
;

/*
 Performs a two-sample t-test.

 Takes JSON strings representing `Vec<Expr>` (two data sets) and `Expr` (hypothesized difference in means).
 Returns a JSON string representing the `HypothesisTest` result.
 */
rssn_
char *rssn_json_two_sample_t_test(const char *aData1Json,
                                  const char *aData2Json,
                                  const char *aMuDiffJson)
;

/*
 Computes the uncertainty using JSON.
 */
rssn_
char *rssn_json_uncertainty(const char *aOpJson,
                            const char *aPsiJson)
;

/*
 Unifies the units in a symbolic expression.

 Takes a JSON string representing an `Expr` as input,
 and returns a JSON string representing the expression with unified units.
 */
rssn_
char *rssn_json_unify_expression(const char *aExprJson)
;

/*
 Computes the symbolic variance of a set of expressions using JSON.
 */
rssn_
char *rssn_json_variance(const char *aDataJson)
;

/*
 Computes the cross product of two vectors.

 Takes two JSON strings representing `Vector` objects.
 Returns a JSON string representing the `Vector` of their cross product.
 */
rssn_
char *rssn_json_vector_cross(const char *aV1Json,
                             const char *aV2Json)
;

/*
 Computes the curl of a 3D vector field.

 Takes a JSON string representing a `Vector` and three C-style strings for the variable names (x, y, z).
 Returns a JSON string representing the `Vector` of the curl.
 */
rssn_
char *rssn_json_vector_curl(const char *aVJson,
                            const char *aXVar,
                            const char *aYVar,
                            const char *aZVar)
;

/*
 Computes the divergence of a vector field.

 Takes a JSON string representing a `Vector` and three C-style strings for the variable names (x, y, z).
 Returns a JSON string representing the `Expr` of the divergence.
 */
rssn_
char *rssn_json_vector_divergence(const char *aVJson,
                                  const char *aXVar,
                                  const char *aYVar,
                                  const char *aZVar)
;

/*
 Computes the dot product of two vectors.

 Takes two JSON strings representing `Vector` objects.
 Returns a JSON string representing the `Expr` of their dot product.
 */
rssn_
char *rssn_json_vector_dot(const char *aV1Json,
                           const char *aV2Json)
;

/*
 Computes the gradient of a scalar field.

 Takes a JSON string representing an `Expr` (scalar field) and three C-style strings for the variable names (x, y, z).
 Returns a JSON string representing the `Vector` of the gradient.
 Computes the gradient of a scalar field.

 Takes a JSON string representing an `Expr` (scalar field) and three C-style strings for the variable names (x, y, z).
 Returns a JSON string representing the `Vector` of the gradient.
 */
rssn_
char *rssn_json_vector_gradient(const char *aScalarFieldJson,
                                const char *aXVar,
                                const char *aYVar,
                                const char *aZVar)
;

/*
 Computes the magnitude of a vector.

 Takes a JSON string representing a `Vector`.
 Returns a JSON string representing the `Expr` of its magnitude.
 */
rssn_
char *rssn_json_vector_magnitude(const char *aVJson)
;

/*
 Normalizes a vector.

 Takes a JSON string representing a `Vector`.
 Returns a JSON string representing the normalized `Vector`.
 */
rssn_
char *rssn_json_vector_normalize(const char *aVJson)
;

/*
 Verifies an equation solution using JSON.
 */
rssn_
bool rssn_json_verify_equation_solution(const char *aEquationsJson,
                                        const char *aSolutionJson,
                                        const char *aFreeVarsJson)
;

/*
 Verifies an indefinite integral using JSON.
 */
rssn_
bool rssn_json_verify_indefinite_integral(const char *aIntegrandJson,
                                          const char *aIntegralResultJson,
                                          const char *aVarJson)
;

/*
 Verifies a matrix inverse using JSON.
 */
rssn_
bool rssn_json_verify_matrix_inverse(const char *aOriginalJson,
                                     const char *aInverseJson)
;

/*
 Computes the wedge product of two differential forms (JSON)
 */
rssn_
char *rssn_json_wedge_product(const char *aForm1Json,
                              const char *aForm2Json)
;

/*
 Applies the differentiation property of the Z-transform.

 Takes JSON strings representing `Expr` (z-domain expression) and `String` (output variable).
 Returns a JSON string representing the `Expr` of the transformed expression.
 */
rssn_
char *rssn_json_z_differentiation(const char *aFZJson,
                                  const char *aOutVarJson)
;

/*
 Applies the scaling property of the Z-transform.

 Takes JSON strings representing `Expr` (z-domain expression), `Expr` (scaling factor `a`),
 and `String` (output variable).
 Returns a JSON string representing the `Expr` of the transformed expression.
 */
rssn_
char *rssn_json_z_scaling(const char *aFZJson,
                          const char *aAJson,
                          const char *aOutVarJson)
;

/*
 Performs a z-test.

 Takes JSON strings representing `Vec<Expr>` (data), `Expr` (target mean), and `Expr` (population standard deviation).
 Returns a JSON string representing the `HypothesisTest` result.
 */
rssn_
char *rssn_json_z_test(const char *aDataJson,
                       const char *aTargetMeanJson,
                       const char *aPopStdDevJson)
;

/*
 Applies the time shift property of the Z-transform.

 Takes JSON strings representing `Expr` (z-domain expression), `Expr` (time shift amount `k`),
 and `String` (output variable).
 Returns a JSON string representing the `Expr` of the transformed expression.
 */
rssn_
char *rssn_json_z_time_shift(const char *aFZJson,
                             const char *aKJson,
                             const char *aOutVarJson)
;

/*
 Computes the Z-transform of an expression.

 Takes JSON strings representing `Expr` (expression), `String` (input variable), and `String` (output variable).
 Returns a JSON string representing the `Expr` of the Z-transform.
 */
rssn_
char *rssn_json_z_transform(const char *aExprJson,
                            const char *aInVarJson,
                            const char *aOutVarJson)
;

/*
 Computes the symbolic Riemann zeta function ζ(s) via JSON interface.
 */
rssn_
char *rssn_json_zeta(const char *aArgJson)
;

/*
 Computes ζ(s) via JSON interface.
 */
rssn_
char *rssn_json_zeta_numerical(const char *aSJson)
;

/*
 Frees a Ket.
 */
rssn_
void rssn_ket_free(struct rssn_Ket *aKet)
;

/*
 Creates a new Ket from a state expression.
 */
rssn_
struct rssn_Ket *rssn_ket_new(const struct rssn_Expr *aState)
;

/*
 Frees an ECDH key pair handle.

 # Arguments
 * `keypair` - Handle to the key pair to free.
 */
rssn_
void rssn_keypair_free(struct rssn_EcdhKeyPair *aKeypair)
;

/*
 Gets the private key from an ECDH key pair as a decimal string.

 # Arguments
 * `kp` - Handle to the key pair.

 # Returns
 A decimal string representing the private key, or NULL on error.
 */
rssn_
char *rssn_keypair_get_private_key(const struct rssn_EcdhKeyPair *aKp)
;

/*
 Returns a NEW handle to the public key point (must be freed).
 */
rssn_
struct rssn_CurvePoint *rssn_keypair_get_public_key(const struct rssn_EcdhKeyPair *aKp)
;

/*
 Calculates kinetic energy: 1/2 * m * v^2.
 */
rssn_
struct rssn_Expr *rssn_kinetic_energy(const struct rssn_Expr *aMass,
                                      const struct rssn_Expr *aVelocity)
;

/*
 Computes the Kullback-Leibler divergence between two probability distributions.

 Takes raw pointers to two arrays of `Expr` (probabilities) and their lengths.
 Returns a raw pointer to an `Expr` representing the KL divergence.
 */
rssn_
struct rssn_Expr *rssn_kl_divergence(const struct rssn_Expr *const *aPProbs,
                                     size_t aPLen,
                                     const struct rssn_Expr *const *aQProbs,
                                     size_t aQLen)
;

/*
 Creates a Klein four-group and returns a raw pointer to it.

 # Returns
 A raw pointer (`*mut Group`) to the newly created group.
 */
rssn_
struct rssn_Group *rssn_klein_four_group_create(void)
;

/*
 Klein-Gordon equation.
 */
rssn_
struct rssn_Expr *rssn_klein_gordon_equation(const struct rssn_Expr *aPsi,
                                             const struct rssn_Expr *aM)
;

/*
 Applies the Knuth-Bendix completion algorithm to a set of equations.

 Returns a pointer to a Vec<RewriteRule> on success, or null on failure.

 # Safety
 The caller must ensure `equations` is a valid array of Expr pointers.
 */
rssn_
struct rssn_Vec_RewriteRule *rssn_knuth_bendix(const struct rssn_Expr *const *aEquations,
                                               size_t aEquationsLen)
;

/*
 Applies the Knuth-Bendix completion algorithm (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_knuth_bendix_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Applies the Knuth-Bendix completion algorithm (JSON).

 Input: JSON array of equations (Expr::Eq)
 Output: JSON array of RewriteRule objects
 */
rssn_
char *rssn_knuth_bendix_json(const char *aJsonStr)
;

/*
 Calculates Lagrangian: T - V.
 */
rssn_
struct rssn_Expr *rssn_lagrangian(const struct rssn_Expr *aT,
                                  const struct rssn_Expr *aV)
;

/*
 Constructs Laguerre's differential equation: xy'' + (1-x)y' + ny = 0.
 */
rssn_
struct rssn_Expr *rssn_laguerre_differential_equation(const struct rssn_Expr *aY,
                                                      const struct rssn_Expr *aX,
                                                      const struct rssn_Expr *aN)
;

/*
 Computes the symbolic Laguerre polynomial L_n(x).
 */
rssn_
struct rssn_Expr *rssn_laguerre_l(const struct rssn_Expr *aDegree,
                                  const struct rssn_Expr *aArg)
;

/*
 Applies the differentiation property of the Laplace transform.

 # Safety
 Caller must ensure `f_s` and `f_zero` are valid pointers to an `Expr`.
 `out_var` must be a valid C string or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_laplace_differentiation(const struct rssn_Expr *aFS,
                                               const char *aOutVar,
                                               const struct rssn_Expr *aFZero)
;

/*
 Applies the frequency shift property of the Laplace transform.

 # Safety
 Caller must ensure `f_s` and `a` are valid pointers to an `Expr`.
 `out_var` must be a valid C string or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_laplace_frequency_shift(const struct rssn_Expr *aFS,
                                               const struct rssn_Expr *aA,
                                               const char *aOutVar)
;

/*
 Applies the integration property of the Laplace transform.

 # Safety
 Caller must ensure `f_s` is a valid pointer to an `Expr`.
 `out_var` must be a valid C string or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_laplace_integration(const struct rssn_Expr *aFS,
                                           const char *aOutVar)
;

/*
 Applies the scaling property of the Laplace transform.

 # Safety
 Caller must ensure `f_s` and `a` are valid pointers to an `Expr`.
 `out_var` must be a valid C string or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_laplace_scaling(const struct rssn_Expr *aFS,
                                       const struct rssn_Expr *aA,
                                       const char *aOutVar)
;

/*
 Applies the time shift property of the Laplace transform.

 # Safety
 Caller must ensure `f_s` and `a` are valid pointers to an `Expr`.
 `out_var` must be a valid C string or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_laplace_time_shift(const struct rssn_Expr *aFS,
                                          const struct rssn_Expr *aA,
                                          const char *aOutVar)
;

/*
 Computes the symbolic Laplace transform of an expression.

 # Safety
 Caller must ensure `expr` is a valid pointer to an `Expr`.
 `in_var` and `out_var` must be valid C strings or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_laplace_transform(const struct rssn_Expr *aExpr,
                                         const char *aInVar,
                                         const char *aOutVar)
;

/*
 Computes the Laurent series expansion of an expression.

 Takes a raw pointer to `Expr` (expression), a C-style string (variable),
 a raw pointer to `Expr` (center), and a `usize` (order).
 Returns a raw pointer to a new `Expr` representing the Laurent series.
 */
rssn_
struct rssn_Expr *rssn_laurent_series_handle(const struct rssn_Expr *aExpr,
                                             const char *aVar,
                                             const struct rssn_Expr *aCenter,
                                             size_t aOrder)
;

/*
 Constructs Legendre's differential equation: (1-x²)y'' - 2xy' + n(n+1)y = 0.
 */
rssn_
struct rssn_Expr *rssn_legendre_differential_equation(const struct rssn_Expr *aY,
                                                      const struct rssn_Expr *aX,
                                                      const struct rssn_Expr *aN)
;

/*
 Computes the symbolic Legendre polynomial P_n(x).
 */
rssn_
struct rssn_Expr *rssn_legendre_p(const struct rssn_Expr *aDegree,
                                  const struct rssn_Expr *aArg)
;

/*
 Constructs Rodrigues' formula for Legendre polynomials.
 */
rssn_
struct rssn_Expr *rssn_legendre_rodrigues_formula(const struct rssn_Expr *aN,
                                                  const struct rssn_Expr *aX)
;

rssn_
void rssn_lie_algebra_free(struct rssn_LieAlgebra *aPtr)
;

rssn_
struct rssn_Expr *rssn_lie_algebra_get_basis_element(const struct rssn_LieAlgebra *aPtr,
                                                     size_t aIndex)
;

rssn_
size_t rssn_lie_algebra_get_dimension(const struct rssn_LieAlgebra *aPtr)
;

rssn_
char *rssn_lie_algebra_get_name(const struct rssn_LieAlgebra *aPtr)
;

rssn_
struct rssn_LieAlgebra *rssn_lie_algebra_so3_create(void)
;

rssn_
struct rssn_LieAlgebra *rssn_lie_algebra_su2_create(void)
;

rssn_
struct rssn_Expr *rssn_lie_bracket(const struct rssn_Expr *aX,
                                   const struct rssn_Expr *aY)
;

/*
 Computes the limit of an expression: limit(expr, var -> point).

 # Safety
 The caller must ensure `expr` and `point` are valid Expr pointers and `var` is a valid C string.
 */
rssn_
struct rssn_Expr *rssn_limit(const struct rssn_Expr *aExpr,
                             const char *aVar,
                             const struct rssn_Expr *aPoint)
;

/*
 Computes the line integral of a scalar field along a curve.
 */
rssn_
char *rssn_line_integral_scalar(const char *aScalarField,
                                const struct rssn_ParametricCurve *aCurve)
;

/*
 Computes the line integral of a scalar field (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_line_integral_scalar_bincode(const uint8_t *aInputPtr,
                                                            size_t aInputLen)
;

/*
 Computes the line integral of a scalar field (JSON).
 */
rssn_
char *rssn_line_integral_scalar_json(const char *aInputJson)
;

/*
 Computes the line integral of a vector field along a curve.
 */
rssn_
char *rssn_line_integral_vector(const char *aFieldX,
                                const char *aFieldY,
                                const char *aFieldZ,
                                const struct rssn_ParametricCurve *aCurve)
;

/*
 Computes the line integral of a vector field (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_line_integral_vector_bincode(const uint8_t *aInputPtr,
                                                            size_t aInputLen)
;

/*
 Computes the line integral of a vector field (JSON).
 */
rssn_
char *rssn_line_integral_vector_json(const char *aInputJson)
;

/*
 Applies a linear operator to a symbolic expression.

 # Arguments
 * `op` - Handle to the linear operator.
 * `expr` - Handle to the expression to operate on.

 # Returns
 A raw pointer to the resulting symbolic expression.
 */
rssn_
struct rssn_Expr *rssn_linear_operator_apply(const struct rssn_LinearOperator *aOp,
                                             const struct rssn_Expr *aExpr)
;

/*
 Creates a linear derivative operator handle.

 # Arguments
 * `var` - The name of the variable with respect to which differentiation is performed.

 # Returns
 A raw pointer to the `LinearOperator`.
 */
rssn_
struct rssn_LinearOperator *rssn_linear_operator_derivative_create(const char *aVar)
;

/*
 Frees a linear operator handle.

 # Arguments
 * `ptr` - Pointer to the `LinearOperator` to free.
 */
rssn_
void rssn_linear_operator_free(struct rssn_LinearOperator *aPtr)
;

/*
 Creates a linear integral operator handle.

 # Arguments
 * `lower_bound` - Symbolic expression for the lower integration limit.
 * `var` - The integration variable.

 # Returns
 A raw pointer to the `LinearOperator`.
 */
rssn_
struct rssn_LinearOperator *rssn_linear_operator_integral_create(const struct rssn_Expr *aLowerBound,
                                                                 const char *aVar)
;

/*
 Creates a natural logarithm expression: ln(expr).
 */
rssn_
struct rssn_Expr *rssn_ln(const struct rssn_Expr *aExpr)
;

/*
 Computes the natural logarithm of the beta function ln(B(a, b)).
 */
rssn_
double rssn_ln_beta_numerical(double aA,
                              double aB)
;

/*
 Creates a natural logarithm expression from bincode: ln(expr).
 */
rssn_
struct rssn_BincodeBuffer rssn_ln_bincode(struct rssn_BincodeBuffer aExprBuffer)
;

/*
 Computes the natural logarithm of the factorial ln(n!).
 */
rssn_
double rssn_ln_factorial(uint64_t aN)
;

/*
 Computes the symbolic log-gamma function ln(Γ(z)).
 */
rssn_
struct rssn_Expr *rssn_ln_gamma(const struct rssn_Expr *aArg)
;

/*
 Computes the natural logarithm of the gamma function ln(Γ(x)).
 */
rssn_
double rssn_ln_gamma_numerical(double aX)
;

/*
 Creates a natural logarithm expression from JSON: ln(expr).
 */
rssn_
char *rssn_ln_json(const char *aJsonExpr)
;

/*
 Calculates the Lorentz factor.
 */
rssn_
struct rssn_Expr *rssn_lorentz_factor(const struct rssn_Expr *aVelocity)
;

/*
 Calculates the Lorentz force.
 */
rssn_
rssn_Vector *rssn_lorentz_force(const struct rssn_Expr *aCharge,
                                const rssn_Vector *aEField,
                                const rssn_Vector *aVelocity,
                                const rssn_Vector *aBField)
;

/*
 Performs a Lorentz transformation in the x-direction.
 */
rssn_
struct rssn_ExprPair rssn_lorentz_transformation_x(const struct rssn_Expr *aX,
                                                   const struct rssn_Expr *aT,
                                                   const struct rssn_Expr *aV)
;

/*
 Returns Lorenz system equations (Handle)
 */
rssn_
bool rssn_lorenz_system(struct rssn_Expr **aDxOut,
                        struct rssn_Expr **aDyOut,
                        struct rssn_Expr **aDzOut)
;

/*
 Calculates Lyapunov exponent (Handle)
 */
rssn_
struct rssn_Expr *rssn_lyapunov_exponent(const struct rssn_Expr *aMapPtr,
                                         const char *aVar,
                                         const struct rssn_Expr *aInitialXPtr,
                                         size_t aNIterations)
;

/*
 Computes magnetic field from vector potential.
 */
rssn_
rssn_Vector *rssn_magnetic_field_from_vector_potential(const rssn_Vector *aA,
                                                       const char *aX,
                                                       const char *aY,
                                                       const char *aZ)
;

/*
 Calculates mass-energy equivalence.
 */
rssn_
struct rssn_Expr *rssn_mass_energy_equivalence(const struct rssn_Expr *aMass)
;

/*
 Adds two matrices using handles.

 # Safety
 * `result_h` must be a valid pointer to store the resulting handle.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_matrix_add(size_t aH1,
                        size_t aH2,
                        size_t *aResultH)
;

/*
 Performs matrix addition using raw pointers to `Expr` objects.

 Takes two raw pointers to `Expr` (representing matrices) as input,
 and returns a raw pointer to a new `Expr` representing their sum.
 */
rssn_
struct rssn_Expr *rssn_matrix_add_handle(const struct rssn_Expr *aM1,
                                         const struct rssn_Expr *aM2)
;

/*
 Computes the determinant of a matrix using a handle.

 # Safety
 * `result_h` must be a valid pointer to store the resulting handle to the determinant expression.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_matrix_determinant(size_t aH,
                                size_t *aResultH)
;

/*
 Computes the determinant of a matrix using a raw pointer to an `Expr` object.

 Takes a raw pointer to an `Expr` (representing a matrix) as input,
 and returns a raw pointer to a new `Expr` representing its determinant.
 */
rssn_
struct rssn_Expr *rssn_matrix_determinant_handle(const struct rssn_Expr *aMatrix)
;

/*
 Creates an identity matrix of the specified size.

 # Safety
 * `result_h` must be a valid pointer to store the resulting handle.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_matrix_identity(size_t aSize,
                             size_t *aResultH)
;

/*
 Computes the inverse of a matrix using a handle.

 # Safety
 * `result_h` must be a valid pointer to store the resulting handle.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_matrix_inverse(size_t aH,
                            size_t *aResultH)
;

/*
 Computes the inverse of a matrix using a raw pointer to an `Expr` object.

 Takes a raw pointer to an `Expr` (representing a matrix) as input,
 and returns a raw pointer to a new `Expr` representing its inverse.
 */
rssn_
struct rssn_Expr *rssn_matrix_inverse_handle(const struct rssn_Expr *aMatrix)
;

/*
 Multiplies two matrices using handles.

 # Safety
 * `result_h` must be a valid pointer to store the resulting handle.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_matrix_mul(size_t aH1,
                        size_t aH2,
                        size_t *aResultH)
;

/*
 Performs matrix multiplication using raw pointers to `Expr` objects.

 Takes two raw pointers to `Expr` (representing matrices) as input,
 and returns a raw pointer to a new `Expr` representing their product.
 */
rssn_
struct rssn_Expr *rssn_matrix_mul_handle(const struct rssn_Expr *aM1,
                                         const struct rssn_Expr *aM2)
;

/*
 Multiplies a matrix by a scalar expression using handles.

 # Safety
 * `result_h` must be a valid pointer to store the resulting handle.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_matrix_scalar_mul(size_t aScalarH,
                               size_t aMatrixH,
                               size_t *aResultH)
;

/*
 Solves a linear system of equations AX = B using raw pointers to `Expr` objects.

 Takes two raw pointers to `Expr` (representing matrix A and vector B) as input,
 and returns a raw pointer to a new `Expr` representing the solution vector X.
 */
rssn_
struct rssn_Expr *rssn_matrix_solve_linear_system_handle(const struct rssn_Expr *aA,
                                                         const struct rssn_Expr *aB)
;

/*
 Subtracts two matrices using handles.

 # Safety
 * `result_h` must be a valid pointer to store the resulting handle.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_matrix_sub(size_t aH1,
                        size_t aH2,
                        size_t *aResultH)
;

/*
 Transposes a matrix using a handle.

 # Safety
 * `result_h` must be a valid pointer to store the resulting handle.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_matrix_transpose(size_t aH,
                              size_t *aResultH)
;

/*
 Performs matrix transposition using a raw pointer to an `Expr` object.

 Takes a raw pointer to an `Expr` (representing a matrix) as input,
 and returns a raw pointer to a new `Expr` representing its transpose.
 */
rssn_
struct rssn_Expr *rssn_matrix_transpose_handle(const struct rssn_Expr *aMatrix)
;

/*
 Computes the symbolic mean of a set of expressions.

 # Safety
 The caller must ensure `data` is a valid pointer to an array of `Expr` pointers of size `len`.
 */
rssn_
struct rssn_Expr *rssn_mean(const struct rssn_Expr *const *aData,
                            size_t aLen)
;

/*
 Computes geometric product (Handle)
 */
rssn_
struct rssn_Multivector *rssn_multivector_geometric_product_handle(const struct rssn_Multivector *aA,
                                                                   const struct rssn_Multivector *aB)
;

/*
 Computes grade projection (Handle)
 */
rssn_
struct rssn_Multivector *rssn_multivector_grade_projection_handle(const struct rssn_Multivector *aMv,
                                                                  uint32_t aGrade)
;

/*
 Computes inner product (Handle)
 */
rssn_
struct rssn_Multivector *rssn_multivector_inner_product_handle(const struct rssn_Multivector *aA,
                                                               const struct rssn_Multivector *aB)
;

/*
 Computes magnitude (Handle)
 */
rssn_
struct rssn_Expr *rssn_multivector_magnitude_handle(const struct rssn_Multivector *aMv)
;

/*
 Computes outer product (Handle)
 */
rssn_
struct rssn_Multivector *rssn_multivector_outer_product_handle(const struct rssn_Multivector *aA,
                                                               const struct rssn_Multivector *aB)
;

/*
 Computes reverse (Handle)
 */
rssn_
struct rssn_Multivector *rssn_multivector_reverse_handle(const struct rssn_Multivector *aMv)
;

/*
 Creates a new scalar multivector (Handle)
 */
rssn_
struct rssn_Multivector *rssn_multivector_scalar_handle(uint32_t aP,
                                                        uint32_t aQ,
                                                        uint32_t aR,
                                                        const struct rssn_Expr *aValue)
;

/*
 Computes the mutual information between two random variables from their joint probability distribution.

 Takes a raw pointer to an `Expr` representing the joint probability distribution.
 Returns a raw pointer to an `Expr` representing the mutual information.
 */
rssn_
struct rssn_Expr *rssn_mutual_information(const struct rssn_Expr *aJointProbs)
;

/*
 Performs a nonlinear regression.

 Takes raw pointers to arrays of `Expr` (x and y data), the length of the data,
 a raw pointer to an `Expr` (model), raw pointers to arrays of C-style strings (variables and parameters),
 and their respective lengths.
 Returns a raw pointer to an `Expr` representing the solutions (optimized parameter values).
 */
rssn_
struct rssn_Expr *rssn_nonlinear_regression(const struct rssn_Expr *const *aXData,
                                            const struct rssn_Expr *const *aYData,
                                            size_t aLen,
                                            const struct rssn_Expr *aModel,
                                            const char *const *aVars,
                                            size_t aVarsLen,
                                            const char *const *aParams,
                                            size_t aParamsLen)
;

/*
 Computes the $L^2$ norm of a function in a Hilbert space.

 # Arguments
 * `space` - Handle to the Hilbert space.
 * `f` - Handle to the expression.

 # Returns
 A raw pointer to the symbolic expression representing the norm.
 */
rssn_
struct rssn_Expr *rssn_norm(const struct rssn_HilbertSpace *aSpace,
                            const struct rssn_Expr *aF)
;

/*
 Computes the greatest common divisor (GCD) of two numbers.

 Returns 0 on success, -1 on error.
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_nt_gcd(uint64_t aA,
                    uint64_t aB,
                    uint64_t *aResult)
;

/*
 Checks if a number is prime using the Miller-Rabin test.

 Returns 0 on success, -1 on error.
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_nt_is_prime(uint64_t aN,
                         bool *aResult)
;

/*
 Computes the modular multiplicative inverse.

 Returns 0 on success, -1 on error (e.g., if no inverse exists).
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_nt_mod_inverse(int64_t aA,
                            int64_t aB,
                            int64_t *aResult)
;

/*
 Computes modular exponentiation (base^exp % modulus).

 Returns 0 on success, -1 on error.
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_nt_mod_pow(uint64_t aBase,
                        uint64_t aExp,
                        uint64_t aModulus,
                        uint64_t *aResult)
;

/*
 Evaluates a B-spline curve at parameter t.
 */
rssn_
int32_t rssn_num_b_spline(const double *aControlPoints,
                          size_t aNPoints,
                          size_t aDim,
                          size_t aDegree,
                          const double *aKnots,
                          size_t aNKnots,
                          double aT,
                          double *aOutPoint)
;

/*
 Computes a point on a B-spline curve given control points, degree, knots, and a parameter t, using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_b_spline_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes a point on a B-spline curve given control points, degree, knots, and a parameter t, using JSON for serialization.
 */
rssn_
char *rssn_num_b_spline_json(const char *aInputPtr)
;

/*
 Evaluates a Bézier curve at parameter t.
 control_points is a flattened array of size n_points * dim.
 */
rssn_
int32_t rssn_num_bezier_curve(const double *aControlPoints,
                              size_t aNPoints,
                              size_t aDim,
                              double aT,
                              double *aOutPoint)
;

/*
 Computes a point on a Bezier curve given control points and a parameter t, using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_bezier_curve_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes a point on a Bezier curve given control points and a parameter t, using JSON for serialization.
 */
rssn_
char *rssn_num_bezier_curve_json(const char *aInputPtr)
;

/*
 Computes the numerical gradient of a function at a point.
 Returns a pointer to a Vec<f64> containing the gradient.
 */
rssn_
struct rssn_Vec_f64 *rssn_num_calculus_gradient(const struct rssn_Expr *aF,
                                                const char *const *aVars,
                                                const double *aPoint,
                                                size_t aNVars)
;

/*
 Computes the numerical Hessian matrix of a scalar function at a point.
 Returns a pointer to a Matrix<f64>.
 */
rssn_
struct rssn_Matrix_f64 *rssn_num_calculus_hessian(const struct rssn_Expr *aF,
                                                  const char *const *aVars,
                                                  const double *aPoint,
                                                  size_t aNVars)
;

/*
 Computes the numerical Jacobian matrix of a vector-valued function at a point.
 Returns a pointer to a Matrix<f64>.
 */
rssn_
struct rssn_Matrix_f64 *rssn_num_calculus_jacobian(const struct rssn_Expr *const *aFuncs,
                                                   size_t aNFuncs,
                                                   const char *const *aVars,
                                                   const double *aPoint,
                                                   size_t aNVars)
;

/*
 Computes the numerical partial derivative of a function with respect to a variable at a point.
 */
rssn_
int32_t rssn_num_calculus_partial_derivative(const struct rssn_Expr *aF,
                                             const char *aVar,
                                             double aX,
                                             double *aResult)
;

/*
 Returns kinematic viscosity of air at 20°C.
 */
rssn_
double rssn_num_cfd_air_kinematic_viscosity(void)
;

/*
 Returns Prandtl number of air.
 */
rssn_
double rssn_num_cfd_air_prandtl_number(void)
;

/*
 Returns standard air properties at sea level and 15°C using JSON serialization.

 Provides reference fluid properties for air (ρ ≈ 1.225 kg/m³, μ ≈ 1.81×10⁻⁵ Pa·s).

 # Arguments

 * `_input` - Unused parameter for API consistency (can be null)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult` with standard air properties:
 - `kinematic_viscosity`: ν (m²/s)
 - `thermal_diffusivity`: α (m²/s)
 - `prandtl_number`: Pr (dimensionless, ≈ 0.71 for air)

 # Safety

 This function is unsafe because it returns a raw pointer that the caller must free.
 */
rssn_
char *rssn_num_cfd_air_properties_json(const char *aInput)
;

/*
 Calculates CFL number.
 */
rssn_
double rssn_num_cfd_cfl_number(double aVelocity,
                               double aDt,
                               double aDx)
;

/*
 Computes the Courant-Friedrichs-Lewy (CFL) number for numerical stability using bincode serialization.

 The CFL number is a stability criterion for explicit time-stepping schemes:
 CFL = (velocity × dt) / dx

 For numerical stability in explicit schemes, CFL ≤ 1 is typically required.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `CflInput` with:
   - `velocity`: Flow velocity or wave speed (m/s)
   - `dt`: Time step size (s)
   - `dx`: Spatial grid spacing (m)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The computed CFL number (dimensionless)
 - `err`: Error message if deserialization failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_cfd_cfl_number_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Courant-Friedrichs-Lewy (CFL) number using JSON serialization.

 The CFL condition ensures numerical stability in explicit time-stepping schemes:
 CFL = (velocity × dt) / dx. For stability, CFL ≤ 1 is typically required.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `velocity`: Flow velocity or wave speed (m/s)
   - `dt`: Time step size (s)
   - `dx`: Spatial grid spacing (m)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the computed CFL number (dimensionless).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_cfd_cfl_number_json(const char *aInput)
;

/*
 Checks CFL stability.
 */
rssn_
bool rssn_num_cfd_check_cfl_stability(double aVelocity,
                                      double aDt,
                                      double aDx,
                                      double aMaxCfl)
;

/*
 Calculates diffusion number.
 */
rssn_
double rssn_num_cfd_diffusion_number(double aAlpha,
                                     double aDt,
                                     double aDx)
;

/*
 Computes derived fluid properties from fundamental properties using JSON serialization.

 This function calculates kinematic viscosity (ν = μ/ρ), thermal diffusivity (α = k/(ρc_p)),
 and Prandtl number (Pr = ν/α) from input material properties.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `density`: Fluid density ρ (kg/m³)
   - `dynamic_viscosity`: Dynamic viscosity μ (Pa·s)
   - `thermal_conductivity`: Thermal conductivity k (W/(m·K))
   - `specific_heat`: Specific heat capacity c_p (J/(kg·K))

 # Returns

 A C string pointer containing JSON-encoded `FfiResult` with:
 - `kinematic_viscosity`: ν (m²/s)
 - `thermal_diffusivity`: α (m²/s)
 - `prandtl_number`: Pr (dimensionless)

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_cfd_fluid_properties_json(const char *aInput)
;

/*
 Calculates Froude number.
 */
rssn_
double rssn_num_cfd_froude_number(double aVelocity,
                                  double aLength,
                                  double aGravity)
;

/*
 Calculates Mach number.
 */
rssn_
double rssn_num_cfd_mach_number(double aVelocity,
                                double aSpeedOfSound)
;

/*
 Calculates Reynolds number.
 */
rssn_
double rssn_num_cfd_reynolds_number(double aVelocity,
                                    double aLength,
                                    double aKinematicViscosity)
;

/*
 Computes the Reynolds number for fluid flow using bincode serialization.

 The Reynolds number is a dimensionless quantity characterizing the flow regime:
 Re = (velocity × length) / kinematic_viscosity

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `ReynoldsInput` with:
   - `velocity`: Flow velocity (m/s)
   - `length`: Characteristic length scale (m)
   - `kinematic_viscosity`: Kinematic viscosity (ν = μ/ρ, m²/s)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The computed Reynolds number (dimensionless)
 - `err`: Error message if deserialization failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_cfd_reynolds_number_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Reynolds number for fluid flow using JSON serialization.

 The Reynolds number characterizes the flow regime (laminar vs. turbulent):
 Re = (velocity × length) / kinematic_viscosity

 # Arguments

 * `input` - A JSON string pointer containing:
   - `velocity`: Flow velocity (m/s)
   - `length`: Characteristic length scale (m)
   - `kinematic_viscosity`: Kinematic viscosity ν (m²/s)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the computed Reynolds number (dimensionless).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_cfd_reynolds_number_json(const char *aInput)
;

/*
 Solves the 1D advection equation using a finite difference scheme and bincode serialization.

 The advection equation describes the transport of a scalar quantity by a velocity field:
 ∂u/∂t + c ∂u/∂x = 0

 This function uses an explicit finite difference method to time-step the solution.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `Advection1DInput` with:
   - `u0`: Initial condition as a spatial array of values
   - `c`: Advection velocity (constant)
   - `dx`: Spatial grid spacing
   - `dt`: Time step size
   - `num_steps`: Number of time steps to compute

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<Vec<f64>>, String>` with either:
 - `ok`: Solution history where each inner vector is the solution at one time step
 - `err`: Error message if deserialization failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_cfd_solve_advection_1d_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Solves the 1D advection equation using JSON serialization.

 The advection equation describes transport by a velocity field: ∂u/∂t + c ∂u/∂x = 0.
 Uses an explicit finite difference scheme to time-step the solution.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `u0`: Initial condition array (spatial distribution)
   - `c`: Advection velocity (constant, m/s)
   - `dx`: Spatial grid spacing (m)
   - `dt`: Time step size (s)
   - `num_steps`: Number of time steps to compute

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<Vec<f64>>, String>` with
 the solution history, where each inner vector represents the spatial distribution at one time step.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_cfd_solve_advection_1d_json(const char *aInput)
;

/*
 Solves the 1D advection-diffusion equation using JSON serialization.

 The advection-diffusion equation combines transport and diffusion:
 ∂u/∂t + c ∂u/∂x = α ∂²u/∂x².
 This models phenomena like pollutant dispersion in a moving fluid.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `u0`: Initial condition array (spatial distribution)
   - `c`: Advection velocity (m/s)
   - `alpha`: Diffusivity coefficient α (m²/s)
   - `dx`: Spatial grid spacing (m)
   - `dt`: Time step size (s)
   - `num_steps`: Number of time steps to compute

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<Vec<f64>>, String>` with
 the solution history, where each inner vector represents the spatial distribution at one time step.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_cfd_solve_advection_diffusion_1d_json(const char *aInput)
;

/*
 Solves the 1D Burgers equation using JSON serialization.

 The Burgers equation is a nonlinear PDE combining convection and diffusion:
 ∂u/∂t + u ∂u/∂x = ν ∂²u/∂x².
 It models shock wave formation and is often used as a simplified model for fluid turbulence.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `u0`: Initial condition array (spatial distribution)
   - `nu`: Kinematic viscosity ν (m²/s)
   - `dx`: Spatial grid spacing (m)
   - `dt`: Time step size (s)
   - `num_steps`: Number of time steps to compute

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<Vec<f64>>, String>` with
 the solution history, where each inner vector represents the spatial distribution at one time step.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_cfd_solve_burgers_1d_json(const char *aInput)
;

/*
 Solves the 1D diffusion equation using JSON serialization.

 The diffusion equation models heat conduction or mass diffusion: ∂u/∂t = α ∂²u/∂x².
 Uses an explicit finite difference scheme for time integration.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `u0`: Initial condition array (spatial distribution)
   - `alpha`: Diffusivity coefficient α (m²/s)
   - `dx`: Spatial grid spacing (m)
   - `dt`: Time step size (s)
   - `num_steps`: Number of time steps to compute

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<Vec<f64>>, String>` with
 the solution history, where each inner vector represents the spatial distribution at one time step.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_cfd_solve_diffusion_1d_json(const char *aInput)
;

/*
 Returns kinematic viscosity of water at 20°C.
 */
rssn_
double rssn_num_cfd_water_kinematic_viscosity(void)
;

/*
 Returns Prandtl number of water.
 */
rssn_
double rssn_num_cfd_water_prandtl_number(void)
;

/*
 Returns standard water properties at 20°C using JSON serialization.

 Provides reference fluid properties for water (ρ ≈ 998 kg/m³, μ ≈ 1.0×10⁻³ Pa·s).

 # Arguments

 * `_input` - Unused parameter for API consistency (can be null)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult` with standard water properties:
 - `kinematic_viscosity`: ν (m²/s)
 - `thermal_diffusivity`: α (m²/s)
 - `prandtl_number`: Pr (dimensionless, ≈ 7 for water)

 # Safety

 This function is unsafe because it returns a raw pointer that the caller must free.
 */
rssn_
char *rssn_num_cfd_water_properties_json(const char *aInput)
;

/*
 Computes the Bell number B(n).
 */
rssn_
int32_t rssn_num_comb_bell(uint64_t aN,
                           double *aResult)
;

/*
 Computes the Bell number using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_comb_bell_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Bell number using JSON for serialization.
 */
rssn_
char *rssn_num_comb_bell_json(const char *aInputJson)
;

/*
 Computes the Catalan number C_n.
 */
rssn_
int32_t rssn_num_comb_catalan(uint64_t aN,
                              double *aResult)
;

/*
 Computes the Catalan number using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_comb_catalan_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Catalan number using JSON for serialization.
 */
rssn_
char *rssn_num_comb_catalan_json(const char *aInputJson)
;

/*
 Computes the number of combinations C(n, k).
 */
rssn_
int32_t rssn_num_comb_combinations(uint64_t aN,
                                   uint64_t aK,
                                   double *aResult)
;

/*
 Computes the number of combinations using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_comb_combinations_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the number of combinations using JSON for serialization.
 */
rssn_
char *rssn_num_comb_combinations_json(const char *aInputJson)
;

/*
 Computes the factorial of n.
 */
rssn_
int32_t rssn_num_comb_factorial(uint64_t aN,
                                double *aResult)
;

/*
 Computes the factorial of a number using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_comb_factorial_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the factorial of a number using JSON for serialization.
 */
rssn_
char *rssn_num_comb_factorial_json(const char *aInputJson)
;

/*
 Computes the falling factorial.
 */
rssn_
int32_t rssn_num_comb_falling_factorial(double aX,
                                        uint64_t aN,
                                        double *aResult)
;

/*
 Computes the falling factorial using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_comb_falling_factorial_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the falling factorial using JSON for serialization.
 */
rssn_
char *rssn_num_comb_falling_factorial_json(const char *aInputJson)
;

/*
 Computes the number of permutations P(n, k).
 */
rssn_
int32_t rssn_num_comb_permutations(uint64_t aN,
                                   uint64_t aK,
                                   double *aResult)
;

/*
 Computes the number of permutations using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_comb_permutations_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the number of permutations using JSON for serialization.
 */
rssn_
char *rssn_num_comb_permutations_json(const char *aInputJson)
;

/*
 Computes the rising factorial.
 */
rssn_
int32_t rssn_num_comb_rising_factorial(double aX,
                                       uint64_t aN,
                                       double *aResult)
;

/*
 Computes the rising factorial using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_comb_rising_factorial_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the rising factorial using JSON for serialization.
 */
rssn_
char *rssn_num_comb_rising_factorial_json(const char *aInputJson)
;

/*
 Solves a linear recurrence relation numerically.
 */
rssn_
int32_t rssn_num_comb_solve_recurrence(const double *aCoeffs,
                                       size_t aCoeffsLen,
                                       const double *aInitialConditions,
                                       size_t aInitialLen,
                                       size_t aTargetN,
                                       double *aResult)
;

/*
 Solves a linear recurrence relation using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_comb_solve_recurrence_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Solves a linear recurrence relation using JSON for serialization.
 */
rssn_
char *rssn_num_comb_solve_recurrence_json(const char *aInputJson)
;

/*
 Computes the Stirling numbers of the second kind S(n, k).
 */
rssn_
int32_t rssn_num_comb_stirling_second(uint64_t aN,
                                      uint64_t aK,
                                      double *aResult)
;

/*
 Computes the Stirling number of the second kind using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_comb_stirling_second_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Stirling number of the second kind using JSON for serialization.
 */
rssn_
char *rssn_num_comb_stirling_second_json(const char *aInputJson)
;

/*
 Computes a contour integral of a symbolic expression.
 */
rssn_
int32_t rssn_num_complex_contour_integral(const struct rssn_Expr *aExprPtr,
                                          const char *aVarPtr,
                                          const double *aPathRe,
                                          const double *aPathIm,
                                          size_t aPathLen,
                                          double *aResRe,
                                          double *aResIm)
;

/*
 Computes the contour integral of a complex expression using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_complex_contour_integral_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the contour integral of a complex expression using JSON for serialization.
 */
rssn_
char *rssn_num_complex_contour_integral_json(const char *aInputJson)
;

/*
 Evaluates a symbolic expression to a complex number.
 */
rssn_
int32_t rssn_num_complex_eval(const struct rssn_Expr *aExprPtr,
                              const char *const *aVarNames,
                              const double *aVarRe,
                              const double *aVarIm,
                              size_t aNVars,
                              double *aResRe,
                              double *aResIm)
;

/*
 Evaluates a complex expression using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_complex_eval_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Evaluates a complex expression using JSON for serialization.
 */
rssn_
char *rssn_num_complex_eval_json(const char *aInputJson)
;

/*
 Computes the residue of a symbolic expression.
 */
rssn_
int32_t rssn_num_complex_residue(const struct rssn_Expr *aExprPtr,
                                 const char *aVarPtr,
                                 double aZ0Re,
                                 double aZ0Im,
                                 double aRadius,
                                 size_t aNPoints,
                                 double *aResRe,
                                 double *aResIm)
;

/*
 Frees a pointer allocated by the coordinate transformation functions.
 */
rssn_
void rssn_num_coord_free(double *aPtr,
                         size_t aLen)
;

/*
 Computes the numerical Jacobian matrix.
 Returns a pointer to a flat array of doubles (row-major).
 */
rssn_
double *rssn_num_coord_jacobian(enum rssn_CoordinateSystem aFrom,
                                enum rssn_CoordinateSystem aTo,
                                const double *aAtPointPtr,
                                size_t aPointLen,
                                size_t *aOutRows,
                                size_t *aOutCols)
;

/*
 Transforms a point via Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_coord_transform_bincode(const uint8_t *aData,
                                                           size_t aLen)
;

/*
 Transforms a point using JSON.
 */
rssn_
char *rssn_num_coord_transform_json(const char *aJsonPtr)
;

/*
 Transforms a point from one coordinate system to another.

 # Arguments
 * `point_ptr` - Pointer to an array of doubles.
 * `point_len` - Number of elements in the point.
 * `from` - Source coordinate system.
 * `to` - Target coordinate system.
 * `out_len` - Pointer to store the number of elements in the resulting vector.

 # Returns
 A pointer to the transformed point (array of doubles), or null on error.
 */
rssn_
double *rssn_num_coord_transform_point(const double *aPointPtr,
                                       size_t aPointLen,
                                       enum rssn_CoordinateSystem aFrom,
                                       enum rssn_CoordinateSystem aTo,
                                       size_t *aOutLen)
;

/*
 Transforms a point from one coordinate system to another (pure numerical).
 */
rssn_
double *rssn_num_coord_transform_point_pure(const double *aPointPtr,
                                            size_t aPointLen,
                                            enum rssn_CoordinateSystem aFrom,
                                            enum rssn_CoordinateSystem aTo,
                                            size_t *aOutLen)
;

/*
 Transforms a point (pure numerical) via Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_coord_transform_pure_bincode(const uint8_t *aData,
                                                                size_t aLen)
;

/*
 Transforms a point (pure numerical) using JSON.
 */
rssn_
char *rssn_num_coord_transform_pure_json(const char *aJsonPtr)
;

/*
 Computes the Euler-Lagrange expression.
 Returns a pointer to a new Expr.
 */
rssn_
struct rssn_Expr *rssn_num_cov_euler_lagrange(const struct rssn_Expr *aLagrangian,
                                              const char *aTVar,
                                              const char *aPathVar,
                                              const char *aPathDotVar)
;

/*
 Evaluates the action for a given path.
 */
rssn_
int32_t rssn_num_cov_evaluate_action(const struct rssn_Expr *aLagrangian,
                                     const struct rssn_Expr *aPath,
                                     const char *aTVar,
                                     const char *aPathVar,
                                     const char *aPathDotVar,
                                     double aTStart,
                                     double aTEnd,
                                     double *aResult)
;

/*
 Evaluates the action for a given Lagrangian and path using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_cov_evaluate_action_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Evaluates the action for a given Lagrangian and path using JSON for serialization.
 */
rssn_
char *rssn_num_cov_evaluate_action_json(const char *aInputJson)
;

/*
 Evaluates a cubic spline at a given x coordinate.
 */
rssn_
double rssn_num_cubic_spline_evaluate(const struct rssn_CubicSplineHandle *aHandle,
                                      double aX)
;

/*
 Frees a cubic spline handle.
 */
rssn_
void rssn_num_cubic_spline_free(struct rssn_CubicSplineHandle *aHandle)
;

/*
 Creates a cubic spline interpolator handle.
 */
rssn_
struct rssn_CubicSplineHandle *rssn_num_cubic_spline_interpolation(const double *aXCoords,
                                                                   const double *aYCoords,
                                                                   size_t aLen)
;

/*
 Computes the cubic spline interpolation for a given set of points using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_cubic_spline_interpolation_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the cubic spline interpolation for a given set of points using JSON for serialization.
 */
rssn_
char *rssn_num_cubic_spline_interpolation_json(const char *aInputPtr)
;

/*
 Computes the Christoffel symbols at a given point.
 Returns a flattened vector of size dim^3.
 */
rssn_
struct rssn_Vec_f64 *rssn_num_dg_christoffel_symbols(enum rssn_CoordinateSystem aSystem,
                                                     const double *aPoint,
                                                     size_t aNVars)
;

/*
 Computes the Christoffel symbols at a given point using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_dg_christoffel_symbols_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Christoffel symbols at a given point using JSON for serialization.
 */
rssn_
char *rssn_num_dg_christoffel_symbols_json(const char *aInputJson)
;

/*
 Computes the metric tensor at a given point.
 */
rssn_
struct rssn_Matrix_f64 *rssn_num_dg_metric_tensor(enum rssn_CoordinateSystem aSystem,
                                                  const double *aPoint,
                                                  size_t aNVars)
;

/*
 Computes the metric tensor at a given point using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_dg_metric_tensor_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the metric tensor at a given point using JSON for serialization.
 */
rssn_
char *rssn_num_dg_metric_tensor_json(const char *aInputJson)
;

/*
 Computes the Ricci scalar at a given point.
 */
rssn_
int32_t rssn_num_dg_ricci_scalar(enum rssn_CoordinateSystem aSystem,
                                 const double *aPoint,
                                 size_t aNVars,
                                 double *aResult)
;

/*
 Computes the Ricci scalar at a given point using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_dg_ricci_scalar_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Ricci scalar at a given point using JSON for serialization.
 */
rssn_
char *rssn_num_dg_ricci_scalar_json(const char *aInputJson)
;

/*
 Computes the Ricci tensor at a given point.
 */
rssn_
struct rssn_Matrix_f64 *rssn_num_dg_ricci_tensor(enum rssn_CoordinateSystem aSystem,
                                                 const double *aPoint,
                                                 size_t aNVars)
;

/*
 Computes the Ricci tensor at a given point using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_dg_ricci_tensor_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Ricci tensor at a given point using JSON for serialization.
 */
rssn_
char *rssn_num_dg_ricci_tensor_json(const char *aInputJson)
;

/*
 Compute error correction capability from minimum distance.
 */
rssn_
size_t rssn_num_error_correction_capability(size_t aMinDistance)
;

/*
 Computes the error correction capability of a code given its minimum distance, using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_error_correction_capability_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the error correction capability of a code given its minimum distance, using JSON for serialization.
 */
rssn_
char *rssn_num_error_correction_capability_json(const char *aInput)
;

/*
 Compute code rate.
 */
rssn_
double rssn_num_error_correction_code_rate(size_t aK,
                                           size_t aN)
;

/*
 Computes the code rate (k/n) of a code with bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_error_correction_code_rate_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the code rate (k/n) of a code with JSON for serialization.
 */
rssn_
char *rssn_num_error_correction_code_rate_json(const char *aInput)
;

/*
 Compute CRC-16 checksum.

 # Safety
 `data_ptr` must be a valid pointer to `len` bytes.
 */
rssn_
uint16_t rssn_num_error_correction_crc16(const uint8_t *aDataPtr,
                                         size_t aLen)
;

/*
 Computes the CRC16 checksum of a byte vector with bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_error_correction_crc16_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the CRC16 checksum of a byte vector with JSON for serialization.
 */
rssn_
char *rssn_num_error_correction_crc16_json(const char *aInput)
;

/*
 Compute CRC-32 checksum.

 # Safety
 `data_ptr` must be a valid pointer to `len` bytes.
 */
rssn_
uint32_t rssn_num_error_correction_crc32(const uint8_t *aDataPtr,
                                         size_t aLen)
;

/*
 Computes the CRC32 checksum of a byte vector with bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_error_correction_crc32_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the CRC32 checksum of a byte vector with JSON for serialization.
 */
rssn_
char *rssn_num_error_correction_crc32_json(const char *aInput)
;

/*
 Verify CRC-32 checksum.

 # Safety
 `data_ptr` must be a valid pointer to `len` bytes.
 */
rssn_
int32_t rssn_num_error_correction_crc32_verify(const uint8_t *aDataPtr,
                                               size_t aLen,
                                               uint32_t aExpectedCrc)
;

/*
 Verifies the CRC32 checksum of a byte vector with bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_error_correction_crc32_verify_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Verifies the CRC32 checksum of a byte vector with JSON for serialization.
 */
rssn_
char *rssn_num_error_correction_crc32_verify_json(const char *aInput)
;

/*
 Compute CRC-8 checksum.

 # Safety
 `data_ptr` must be a valid pointer to `len` bytes.
 */
rssn_
uint8_t rssn_num_error_correction_crc8(const uint8_t *aDataPtr,
                                       size_t aLen)
;

/*
 Computes the CRC8 checksum of a byte vector with bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_error_correction_crc8_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the CRC8 checksum of a byte vector with JSON for serialization.
 */
rssn_
char *rssn_num_error_correction_crc8_json(const char *aInput)
;

/*
 De-interleave data.

 # Safety
 `data_ptr` must be a valid pointer to `len` bytes.
 `out_ptr` must be a valid pointer to at least `len` bytes.
 */
rssn_
int32_t rssn_num_error_correction_deinterleave(const uint8_t *aDataPtr,
                                               size_t aLen,
                                               size_t aDepth,
                                               uint8_t *aOutPtr)
;

/*
 Deinterleaves a byte vector with a given depth using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_error_correction_deinterleave_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Deinterleaves a byte vector with a given depth using JSON for serialization.
 */
rssn_
char *rssn_num_error_correction_deinterleave_json(const char *aInput)
;

/*
 Check if a Hamming codeword is valid.

 # Safety
 `codeword_ptr` must be a valid pointer to 7 bytes.
 */
rssn_
int32_t rssn_num_error_correction_hamming_check(const uint8_t *aCodewordPtr)
;

/*
 Checks a Hamming codeword for errors with bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_error_correction_hamming_check_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Checks a Hamming codeword for errors with JSON for serialization.
 */
rssn_
char *rssn_num_error_correction_hamming_check_json(const char *aInput)
;

/*
 Hamming decode a 7-bit codeword.

 # Safety
 `codeword_ptr` must be a valid pointer to 7 bytes.
 `out_ptr` must be a valid pointer to at least 4 bytes.
 `error_pos_ptr` must be a valid pointer.
 */
rssn_
int32_t rssn_num_error_correction_hamming_decode(const uint8_t *aCodewordPtr,
                                                 uint8_t *aOutPtr,
                                                 int32_t *aErrorPosPtr)
;

/*
 Decodes a Hamming codeword and corrects errors with bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_error_correction_hamming_decode_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Decodes a Hamming codeword and corrects errors with JSON for serialization.
 */
rssn_
char *rssn_num_error_correction_hamming_decode_json(const char *aInput)
;

/*
 Compute Hamming distance between two byte arrays.

 # Safety
 `a_ptr` and `b_ptr` must be valid pointers to `len` bytes each.
 */
rssn_
int32_t rssn_num_error_correction_hamming_distance(const uint8_t *aAPtr,
                                                   const uint8_t *aBPtr,
                                                   size_t aLen)
;

/*
 Computes the Hamming distance between two byte vectors with bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_error_correction_hamming_distance_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Hamming distance between two byte vectors with JSON for serialization.
 */
rssn_
char *rssn_num_error_correction_hamming_distance_json(const char *aInput)
;

/*
 Hamming encode a 4-bit data block.

 # Safety
 `data_ptr` must be a valid pointer to 4 bytes.
 `out_ptr` must be a valid pointer to at least 7 bytes.
 */
rssn_
int32_t rssn_num_error_correction_hamming_encode(const uint8_t *aDataPtr,
                                                 uint8_t *aOutPtr)
;

/*
 Encodes a message using Hamming codes with bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_error_correction_hamming_encode_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Encodes a message using Hamming codes with JSON for serialization.
 */
rssn_
char *rssn_num_error_correction_hamming_encode_json(const char *aInput)
;

/*
 Compute Hamming weight of a byte array.

 # Safety
 `data_ptr` must be a valid pointer to `len` bytes.
 */
rssn_
int32_t rssn_num_error_correction_hamming_weight(const uint8_t *aDataPtr,
                                                 size_t aLen)
;

/*
 Computes the Hamming weight of a byte vector with bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_error_correction_hamming_weight_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Hamming weight of a byte vector with JSON for serialization.
 */
rssn_
char *rssn_num_error_correction_hamming_weight_json(const char *aInput)
;

/*
 Interleave data.

 # Safety
 `data_ptr` must be a valid pointer to `len` bytes.
 `out_ptr` must be a valid pointer to at least `len` bytes.
 */
rssn_
int32_t rssn_num_error_correction_interleave(const uint8_t *aDataPtr,
                                             size_t aLen,
                                             size_t aDepth,
                                             uint8_t *aOutPtr)
;

/*
 Interleaves a byte vector with a given depth using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_error_correction_interleave_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Interleaves a byte vector with a given depth using JSON for serialization.
 */
rssn_
char *rssn_num_error_correction_interleave_json(const char *aInput)
;

/*
 Check if a Reed-Solomon codeword is valid.

 # Safety
 `codeword_ptr` must be a valid pointer to `codeword_len` bytes.
 */
rssn_
int32_t rssn_num_error_correction_rs_check(const uint8_t *aCodewordPtr,
                                           size_t aCodewordLen,
                                           size_t aNParity)
;

/*
 Checks if a Reed-Solomon codeword is valid with bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_error_correction_rs_check_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Checks if a Reed-Solomon codeword is valid with JSON for serialization.
 */
rssn_
char *rssn_num_error_correction_rs_check_json(const char *aInput)
;

/*
 Reed-Solomon decode a codeword in place.

 # Safety
 `codeword_ptr` must be a valid pointer to `codeword_len` bytes.
 */
rssn_
int32_t rssn_num_error_correction_rs_decode(uint8_t *aCodewordPtr,
                                            size_t aCodewordLen,
                                            size_t aNParity)
;

/*
 Decodes a Reed-Solomon codeword with bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_error_correction_rs_decode_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Decodes a Reed-Solomon codeword with JSON for serialization.
 */
rssn_
char *rssn_num_error_correction_rs_decode_json(const char *aInput)
;

/*
 Reed-Solomon encode a message.

 # Safety
 `message_ptr` must be a valid pointer to `message_len` bytes.
 */
rssn_
int32_t rssn_num_error_correction_rs_encode(const uint8_t *aMessagePtr,
                                            size_t aMessageLen,
                                            size_t aNParity,
                                            uint8_t *aOutPtr,
                                            size_t *aOutLen)
;

/*
 Encodes a message using Reed-Solomon codes with bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_error_correction_rs_encode_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Encodes a message using Reed-Solomon codes with JSON for serialization.
 */
rssn_
char *rssn_num_error_correction_rs_encode_json(const char *aInput)
;

/*
 Compute error detection capability from minimum distance.
 */
rssn_
size_t rssn_num_error_detection_capability(size_t aMinDistance)
;

/*
 Evaluates an expression from a Bincode buffer.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_eval_bincode(const uint8_t *aData,
                                                size_t aLen)
;

/*
 Evaluates an expression handle given variable values.

 # Arguments
 * `expr_ptr` - Pointer to the Expr object.
 * `vars` - Array of C-strings for variable names.
 * `vals` - Array of doubles for variable values.
 * `num_vars` - Number of variables.
 * `result` - Pointer to store the result.

 # Returns
 0 on success, -1 on failure.
 */
rssn_
int32_t rssn_num_eval_expr(const struct rssn_Expr *aExprPtr,
                           const char *const *aVars,
                           const double *aVals,
                           size_t aNumVars,
                           double *aResult)
;

/*
 Evaluates an expression from a JSON string.

 Input JSON format: `{"expr": <Expr>, "vars": {"x": 1.0, "y": 2.0}}`
 */
rssn_
char *rssn_num_eval_json(const char *aJsonPtr)
;

/*
 Applies the Gram-Schmidt orthonormalization process to a set of basis functions using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_fa_gram_schmidt_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Applies the Gram-Schmidt orthonormalization process to a set of basis functions using JSON for serialization.
 */
rssn_
char *rssn_num_fa_gram_schmidt_json(const char *aInputJson)
;

/*
 Calculates the L-infinity norm.
 */
rssn_
double rssn_num_fa_infinity_norm(const double *aX,
                                 const double *aY,
                                 size_t aLen)
;

/*
 Calculates the inner product.
 */
rssn_
int32_t rssn_num_fa_inner_product(const double *aX1,
                                  const double *aY1,
                                  size_t aLen1,
                                  const double *aX2,
                                  const double *aY2,
                                  size_t aLen2,
                                  double *aResult)
;

/*
 Computes the inner product of two functions (represented by series of points) using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_fa_inner_product_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the inner product of two functions (represented by series of points) using JSON for serialization.
 */
rssn_
char *rssn_num_fa_inner_product_json(const char *aInputJson)
;

/*
 Calculates the L1 norm.
 */
rssn_
double rssn_num_fa_l1_norm(const double *aX,
                           const double *aY,
                           size_t aLen)
;

/*
 Calculates the L2 norm.
 */
rssn_
double rssn_num_fa_l2_norm(const double *aX,
                           const double *aY,
                           size_t aLen)
;

/*
 Computes the L2 norm of a function (represented by a series of points) using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_fa_l2_norm_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the L2 norm of a function (represented by a series of points) using JSON for serialization.
 */
rssn_
char *rssn_num_fa_l2_norm_json(const char *aInputJson)
;

/*
 Computes the global stiffness matrix for a 2D beam element using JSON serialization.

 The beam element includes both axial and bending behavior. The stiffness matrix
 is transformed from local to global coordinates using the specified angle.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `length`: Element length L (m)
   - `youngs_modulus`: Young's modulus E (Pa)
   - `area`: Cross-sectional area A (m²)
   - `moment_of_inertia`: Second moment of area I (m⁴)
   - `angle`: Element orientation angle θ (radians)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the 6×6 global stiffness matrix in row-major format.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_fea_beam_element_2d_stiffness_json(const char *aInput)
;

/*
 Computes bulk modulus from Young's modulus and Poisson's ratio.
 */
rssn_
double rssn_num_fea_bulk_modulus(double aYoungsModulus,
                                 double aPoissonsRatio)
;

/*
 Generates a structured triangular mesh for a rectangular domain using JSON serialization.

 Creates a finite element mesh by subdividing a rectangle into triangular elements.
 The mesh is structured with regular spacing in both x and y directions.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `width`: Domain width (m)
   - `height`: Domain height (m)
   - `nx`: Number of divisions in x-direction
   - `ny`: Number of divisions in y-direction

 # Returns

 A C string pointer containing JSON-encoded `FfiResult` with:
 - `num_nodes`: Total number of mesh nodes
 - `num_elements`: Total number of triangular elements
 - `nodes`: Array of (x, y) node coordinates
 - `elements`: Array of triangular element connectivity (3 node indices per element)

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_fea_create_rectangular_mesh_json(const char *aInput)
;

/*
 Computes and returns the stiffness value for a 1D linear element.
 k = E * A / L
 */
rssn_
double rssn_num_fea_linear_element_1d_stiffness(double aLength,
                                                double aYoungsModulus,
                                                double aArea)
;

/*
 Computes the axial stiffness of a 1D linear finite element using bincode serialization.

 The axial stiffness represents the force-displacement relationship for a bar element:
 k = (E × A) / L, where E is Young's modulus, A is cross-sectional area, and L is length.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `LinearElement1DInput` with:
   - `length`: Element length L (m)
   - `youngs_modulus`: Young's modulus E (Pa)
   - `area`: Cross-sectional area A (m²)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The computed axial stiffness k (N/m)
 - `err`: Error message if deserialization failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_fea_linear_element_1d_stiffness_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the axial stiffness of a 1D linear finite element using JSON serialization.

 The axial stiffness represents the force-displacement relationship for a bar element:
 k = (E × A) / L, where E is Young's modulus, A is cross-sectional area, and L is length.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `length`: Element length L (m)
   - `youngs_modulus`: Young's modulus E (Pa)
   - `area`: Cross-sectional area A (m²)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the computed axial stiffness k (N/m).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_fea_linear_element_1d_stiffness_json(const char *aInput)
;

/*
 Creates aluminum material and returns shear modulus.
 */
rssn_
double rssn_num_fea_material_aluminum_shear_modulus(void)
;

/*
 Creates copper material and returns shear modulus.
 */
rssn_
double rssn_num_fea_material_copper_shear_modulus(void)
;

/*
 Computes derived material properties from fundamental elastic constants using JSON serialization.

 This function calculates shear modulus G = E/(2(1+ν)) and bulk modulus K = E/(3(1-2ν))
 from Young's modulus and Poisson's ratio.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `youngs_modulus`: Young's modulus E (Pa)
   - `poissons_ratio`: Poisson's ratio ν (dimensionless)
   - `density`: Material density ρ (kg/m³)
   - `thermal_conductivity`: Thermal conductivity k (W/(m·K))
   - `thermal_expansion`: Thermal expansion coefficient α (1/K)
   - `yield_strength`: Yield strength σ_y (Pa)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult` with:
 - `shear_modulus`: G (Pa)
 - `bulk_modulus`: K (Pa)

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_fea_material_properties_json(const char *aInput)
;

/*
 Returns standard material properties for structural steel using JSON serialization.

 Provides reference properties for mild steel (E ≈ 200 GPa, ν ≈ 0.3, ρ ≈ 7850 kg/m³).

 # Arguments

 * `_input` - Unused parameter for API consistency (can be null)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult` with steel properties:
 - `shear_modulus`: G (Pa)
 - `bulk_modulus`: K (Pa)

 # Safety

 This function is unsafe because it returns a raw pointer that the caller must free.
 */
rssn_
char *rssn_num_fea_material_steel_json(const char *aInput)
;

/*
 Creates steel material and returns shear modulus.
 */
rssn_
double rssn_num_fea_material_steel_shear_modulus(void)
;

/*
 Computes maximum shear stress from principal stresses.
 */
rssn_
double rssn_num_fea_max_shear_stress(double aSigma1,
                                     double aSigma2)
;

/*
 Computes principal stresses from stress components.
 Returns sigma1 in out_sigma1, sigma2 in out_sigma2, angle in out_angle.

 # Safety
 Pointers must be valid.
 */
rssn_
int32_t rssn_num_fea_principal_stresses(double aSx,
                                        double aSy,
                                        double aTxy,
                                        double *aOutSigma1,
                                        double *aOutSigma2,
                                        double *aOutAngle)
;

/*
 Computes the principal stresses and orientation from a 2D stress state using bincode serialization.

 Principal stresses are the eigenvalues of the stress tensor, representing maximum and minimum
 normal stresses. The angle indicates the orientation of the principal stress axes.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `StressInput` with:
   - `sx`: Normal stress in x-direction σ_x (Pa)
   - `sy`: Normal stress in y-direction σ_y (Pa)
   - `txy`: Shear stress τ_xy (Pa)

 # Returns

 A bincode-encoded buffer containing `FfiResult<PrincipalStressOutput, String>` with either:
 - `ok`: Object containing:
   - `sigma1`: Maximum principal stress σ₁ (Pa)
   - `sigma2`: Minimum principal stress σ₂ (Pa)
   - `angle`: Orientation angle θ (radians)
 - `err`: Error message if deserialization failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_fea_principal_stresses_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the principal stresses and orientation from a 2D stress state using JSON serialization.

 Principal stresses are the eigenvalues of the stress tensor, representing maximum and minimum
 normal stresses. The angle indicates the orientation of the principal stress axes.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `sx`: Normal stress in x-direction σ_x (Pa)
   - `sy`: Normal stress in y-direction σ_y (Pa)
   - `txy`: Shear stress τ_xy (Pa)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult` with:
 - `sigma1`: Maximum principal stress σ₁ (Pa)
 - `sigma2`: Minimum principal stress σ₂ (Pa)
 - `angle`: Orientation angle θ (radians)

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_fea_principal_stresses_json(const char *aInput)
;

/*
 Computes the factor of safety against yielding using the von Mises criterion and JSON serialization.

 The safety factor is the ratio of yield strength to equivalent stress:
 SF = σ_yield / σ_vm. A value > 1 indicates the material will not yield.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `sx`: Normal stress in x-direction σ_x (Pa)
   - `sy`: Normal stress in y-direction σ_y (Pa)
   - `txy`: Shear stress τ_xy (Pa)
   - `yield_strength`: Material yield strength σ_y (Pa)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the computed safety factor (dimensionless).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_fea_safety_factor_json(const char *aInput)
;

/*
 Computes safety factor based on von Mises criterion.
 */
rssn_
double rssn_num_fea_safety_factor_von_mises(double aSx,
                                            double aSy,
                                            double aTxy,
                                            double aYieldStrength)
;

/*
 Computes shear modulus from Young's modulus and Poisson's ratio.
 */
rssn_
double rssn_num_fea_shear_modulus(double aYoungsModulus,
                                  double aPoissonsRatio)
;

/*
 Computes the conductivity value for a 1D thermal element.
 k = κ * A / L
 */
rssn_
double rssn_num_fea_thermal_element_1d_conductivity(double aLength,
                                                    double aConductivity,
                                                    double aArea)
;

/*
 Computes the thermal conductivity coefficient for a 1D thermal element using JSON serialization.

 The thermal conductivity represents the heat flow-temperature relationship:
 k_thermal = (k × A) / L, where k is thermal conductivity, A is area, and L is length.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `length`: Element length L (m)
   - `conductivity`: Material thermal conductivity k (W/(m·K))
   - `area`: Cross-sectional area A (m²)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the computed thermal conductivity coefficient (W/K).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_fea_thermal_element_1d_conductivity_json(const char *aInput)
;

/*
 Computes von Mises stress from plane stress components.
 */
rssn_
double rssn_num_fea_von_mises_stress(double aSx,
                                     double aSy,
                                     double aTxy)
;

/*
 Computes the von Mises equivalent stress from a 2D stress state using bincode serialization.

 The von Mises stress is a scalar measure of stress intensity used in yield criteria:
 σ_vm = √(σ_x² - σ_xσ_y + σ_y² + 3τ_xy²)

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `StressInput` with:
   - `sx`: Normal stress in x-direction σ_x (Pa)
   - `sy`: Normal stress in y-direction σ_y (Pa)
   - `txy`: Shear stress τ_xy (Pa)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The von Mises stress σ_vm (Pa)
 - `err`: Error message if deserialization failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_fea_von_mises_stress_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the von Mises equivalent stress from a 2D stress state using JSON serialization.

 The von Mises stress is a scalar measure of stress intensity used in yield criteria:
 σ_vm = √(σ_x² - σ_xσ_y + σ_y² + 3τ_xy²)

 # Arguments

 * `input` - A JSON string pointer containing:
   - `sx`: Normal stress in x-direction σ_x (Pa)
   - `sy`: Normal stress in y-direction σ_y (Pa)
   - `txy`: Shear stress τ_xy (Pa)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the von Mises stress σ_vm (Pa).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_fea_von_mises_stress_json(const char *aInput)
;

/*
 GF(2^8) addition.
 */
rssn_
uint8_t rssn_num_ff_gf256_add(uint8_t aA,
                              uint8_t aB)
;

/*
 GF(2^8) division.
 Returns 0 and sets error if divisor is 0.
 */
rssn_
uint8_t rssn_num_ff_gf256_div(uint8_t aA,
                              uint8_t aB)
;

/*
 GF(2^8) multiplication.
 */
rssn_
uint8_t rssn_num_ff_gf256_mul(uint8_t aA,
                              uint8_t aB)
;

/*
 GF(2^8) multiplication from JSON.
 */
rssn_
char *rssn_num_ff_gf256_mul_json(const char *aJsonPtr)
;

/*
 Performs addition in GF(p).
 */
rssn_
struct rssn_PrimeFieldElement *rssn_num_ff_pfe_add(const struct rssn_PrimeFieldElement *aA,
                                                   const struct rssn_PrimeFieldElement *aB)
;

/*
 GF(p) addition via Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_ff_pfe_add_bincode(const uint8_t *aData,
                                                      size_t aLen)
;

/*
 GF(p) addition from JSON.
 */
rssn_
char *rssn_num_ff_pfe_add_json(const char *aJsonPtr)
;

/*
 Frees a PrimeFieldElement.
 */
rssn_
void rssn_num_ff_pfe_free(struct rssn_PrimeFieldElement *aPfe)
;

/*
 Computes the inverse of a PrimeFieldElement.
 */
rssn_
struct rssn_PrimeFieldElement *rssn_num_ff_pfe_inverse(const struct rssn_PrimeFieldElement *aPfe)
;

/*
 Performs multiplication in GF(p).
 */
rssn_
struct rssn_PrimeFieldElement *rssn_num_ff_pfe_mul(const struct rssn_PrimeFieldElement *aA,
                                                   const struct rssn_PrimeFieldElement *aB)
;

/*
 GF(p) multiplication via Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_ff_pfe_mul_bincode(const uint8_t *aData,
                                                      size_t aLen)
;

/*
 GF(p) multiplication from JSON.
 */
rssn_
char *rssn_num_ff_pfe_mul_json(const char *aJsonPtr)
;

/*
 Creates a new PrimeFieldElement.
 */
rssn_
struct rssn_PrimeFieldElement *rssn_num_ff_pfe_new(uint64_t aValue,
                                                   uint64_t aModulus)
;

/*
 Computes (pfe^exp) mod modulus.
 */
rssn_
struct rssn_PrimeFieldElement *rssn_num_ff_pfe_pow(const struct rssn_PrimeFieldElement *aPfe,
                                                   uint64_t aExp)
;

/*
 Computes the Fast Fourier Transform (FFT) in-place using bincode serialization.

 The FFT converts a sequence from the time/space domain to the frequency domain,
 computing X(k) = Σx(n)e^(-2πikn/N) for k = 0, ..., N-1.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `TransformInput` with:
   - `data`: Vector of complex numbers to transform

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<Complex<f64>>, String>` with either:
 - `ok`: FFT-transformed data in frequency domain
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_fft_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Fast Fourier Transform (FFT) in-place.

 # Arguments
 * `real` - Pointer to the real parts of the input/output sequence.
 * `imag` - Pointer to the imaginary parts of the input/output sequence.
 * `len` - Length of the sequence. Must be a power of two for optimal performance.

 # Returns
 0 on success, -1 on error.
 */
rssn_
int32_t rssn_num_fft_inplace(double *aReal,
                             double *aImag,
                             size_t aLen)
;

/*
 Computes the Fast Fourier Transform (FFT) in-place via JSON serialization.

 The FFT converts a sequence from the time/space domain to the frequency domain,
 computing X(k) = Σx(n)e^(-2πikn/N) for k = 0, ..., N-1.

 # Arguments

 * `input_json` - A JSON string pointer containing:
   - `data`: Array of complex numbers to transform

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<Complex<f64>>, String>` with
 FFT-transformed data in frequency domain.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_fft_json(const char *aInputJson)
;

/*
 Generates data for a bifurcation diagram of the logistic map using JSON for serialization.
 */
rssn_
char *rssn_num_fractal_bifurcation_json(const char *aInput)
;

/*
 Computes box-counting dimension.

 # Safety
 `points_ptr` must be a valid pointer to `num_points * 2` f64 values.
 */
rssn_
double rssn_num_fractal_box_counting_dim(const double *aPointsPtr,
                                         size_t aNumPoints,
                                         size_t aNumScales)
;

/*
 Computes the box-counting dimension of a set of points using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_fractal_box_counting_dim_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the box-counting dimension of a set of points using JSON for serialization.
 */
rssn_
char *rssn_num_fractal_box_counting_dim_json(const char *aInput)
;

/*
 Computes correlation dimension.

 # Safety
 `points_ptr` must be a valid pointer to `num_points * 2` f64 values.
 */
rssn_
double rssn_num_fractal_correlation_dim(const double *aPointsPtr,
                                        size_t aNumPoints,
                                        size_t aNumRadii)
;

/*
 Computes the correlation dimension of a set of points using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_fractal_correlation_dim_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the correlation dimension of a set of points using JSON for serialization.
 */
rssn_
char *rssn_num_fractal_correlation_dim_json(const char *aInput)
;

/*
 Generates Henon map points.

 # Safety
 `out_ptr` must be a valid pointer to at least `num_steps * 2` f64 values.
 */
rssn_
int32_t rssn_num_fractal_henon_map(double aX0,
                                   double aY0,
                                   size_t aNumSteps,
                                   double aA,
                                   double aB,
                                   double *aOutPtr)
;

/*
 Generates data points for the Henon map using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_fractal_henon_map_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Generates data points for the Henon map using JSON for serialization.
 */
rssn_
char *rssn_num_fractal_henon_map_json(const char *aInput)
;

/*
 Computes the escape time for a single point in a Julia set.
 */
rssn_
uint32_t rssn_num_fractal_julia_escape_time(double aZReal,
                                            double aZImag,
                                            double aCReal,
                                            double aCImag,
                                            uint32_t aMaxIter)
;

/*
 Computes the escape time for a single point in the Julia set using JSON for serialization.
 */
rssn_
char *rssn_num_fractal_julia_escape_time_json(const char *aInput)
;

/*
 Generates the Julia set as an image (iterations per pixel) using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_fractal_julia_set_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Generates the Julia set as an image (iterations per pixel) using JSON for serialization.
 */
rssn_
char *rssn_num_fractal_julia_set_json(const char *aInput)
;

/*
 Iterates the logistic map.

 # Safety
 `out_ptr` must be a valid pointer to at least `num_steps + 1` f64 values.
 */
rssn_
int32_t rssn_num_fractal_logistic_map(double aX0,
                                      double aR,
                                      size_t aNumSteps,
                                      double *aOutPtr)
;

/*
 Computes iterations of the logistic map using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_fractal_logistic_map_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes iterations of the logistic map using JSON for serialization.
 */
rssn_
char *rssn_num_fractal_logistic_map_json(const char *aInput)
;

/*
 Generates Lorenz attractor points.

 # Safety
 `out_ptr` must be a valid pointer to at least `num_steps * 3` f64 values.
 */
rssn_
int32_t rssn_num_fractal_lorenz_attractor(double aX0,
                                          double aY0,
                                          double aZ0,
                                          double aDt,
                                          size_t aNumSteps,
                                          double *aOutPtr)
;

/*
 Generates data points for the Lorenz attractor using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_fractal_lorenz_attractor_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Generates data points for the Lorenz attractor with custom parameters using JSON for serialization.
 */
rssn_
char *rssn_num_fractal_lorenz_attractor_custom_json(const char *aInput)
;

/*
 Generates data points for the Lorenz attractor using JSON for serialization.
 */
rssn_
char *rssn_num_fractal_lorenz_attractor_json(const char *aInput)
;

/*
 Computes the Lyapunov exponent for the logistic map.
 */
rssn_
double rssn_num_fractal_lyapunov_logistic(double aR,
                                          double aX0,
                                          size_t aTransient,
                                          size_t aNumIterations)
;

/*
 Computes the Lyapunov exponent for the logistic map using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_fractal_lyapunov_logistic_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Lyapunov exponent for the logistic map using JSON for serialization.
 */
rssn_
char *rssn_num_fractal_lyapunov_logistic_json(const char *aInput)
;

/*
 Computes the Lyapunov exponent for the Lorenz system.
 */
rssn_
double rssn_num_fractal_lyapunov_lorenz(double aX0,
                                        double aY0,
                                        double aZ0,
                                        double aDt,
                                        size_t aNumSteps,
                                        double aSigma,
                                        double aRho,
                                        double aBeta)
;

/*
 Computes the Lyapunov exponent for the Lorenz attractor using JSON for serialization.
 */
rssn_
char *rssn_num_fractal_lyapunov_lorenz_json(const char *aInput)
;

/*
 Computes the escape time for a single point in the Mandelbrot set.
 */
rssn_
uint32_t rssn_num_fractal_mandelbrot_escape_time(double aCReal,
                                                 double aCImag,
                                                 uint32_t aMaxIter)
;

/*
 Computes the escape time for a single point in the Mandelbrot set using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_fractal_mandelbrot_escape_time_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the escape time for a single point in the Mandelbrot set using JSON for serialization.
 */
rssn_
char *rssn_num_fractal_mandelbrot_escape_time_json(const char *aInput)
;

/*
 Generates the Mandelbrot set as an image (iterations per pixel) using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_fractal_mandelbrot_set_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Generates the Mandelbrot set as an image (iterations per pixel) using JSON for serialization.
 */
rssn_
char *rssn_num_fractal_mandelbrot_set_json(const char *aInput)
;

/*
 Generates data points for the Rossler attractor using JSON for serialization.
 */
rssn_
char *rssn_num_fractal_rossler_attractor_json(const char *aInput)
;

/*
 Generates data points for the Tinkerbell map using JSON for serialization.
 */
rssn_
char *rssn_num_fractal_tinkerbell_map_json(const char *aInput)
;

/*
 Performs multivector addition.
 */
rssn_
struct rssn_Multivector3D *rssn_num_ga_add(const struct rssn_Multivector3D *aMv1,
                                           const struct rssn_Multivector3D *aMv2)
;

/*
 Bincode FFI for ga_add.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_ga_add_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for ga_add.
 */
rssn_
char *rssn_num_ga_add_json(const char *aJsonPtr)
;

/*
 Creates a new Multivector3D.
 */
rssn_
struct rssn_Multivector3D *rssn_num_ga_create(double aS,
                                              double aV1,
                                              double aV2,
                                              double aV3,
                                              double aB12,
                                              double aB23,
                                              double aB31,
                                              double aPss)
;

/*
 Performs inner product.
 */
rssn_
struct rssn_Multivector3D *rssn_num_ga_dot(const struct rssn_Multivector3D *aMv1,
                                           const struct rssn_Multivector3D *aMv2)
;

/*
 Bincode FFI for ga_dot.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_ga_dot_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for ga_dot.
 */
rssn_
char *rssn_num_ga_dot_json(const char *aJsonPtr)
;

/*
 Frees a Multivector3D.
 */
rssn_
void rssn_num_ga_free(struct rssn_Multivector3D *aMv)
;

/*
 Gets components of a Multivector3D.
 */
rssn_
int32_t rssn_num_ga_get_components(const struct rssn_Multivector3D *aMv,
                                   double *aS,
                                   double *aV1,
                                   double *aV2,
                                   double *aV3,
                                   double *aB12,
                                   double *aB23,
                                   double *aB31,
                                   double *aPss)
;

/*
 Returns the inverse of a Multivector3D.
 */
rssn_
struct rssn_Multivector3D *rssn_num_ga_inv(const struct rssn_Multivector3D *aMv)
;

/*
 Bincode FFI for ga_inv.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_ga_inv_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for ga_inv.
 */
rssn_
char *rssn_num_ga_inv_json(const char *aJsonPtr)
;

/*
 Performs geometric product.
 */
rssn_
struct rssn_Multivector3D *rssn_num_ga_mul(const struct rssn_Multivector3D *aMv1,
                                           const struct rssn_Multivector3D *aMv2)
;

/*
 Bincode FFI for ga_mul.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_ga_mul_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for ga_mul.
 */
rssn_
char *rssn_num_ga_mul_json(const char *aJsonPtr)
;

/*
 Returns the norm of a Multivector3D.
 */
rssn_
double rssn_num_ga_norm(const struct rssn_Multivector3D *aMv)
;

/*
 Bincode FFI for ga_norm.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_ga_norm_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for ga_norm.
 */
rssn_
char *rssn_num_ga_norm_json(const char *aJsonPtr)
;

/*
 Returns the reverse of a Multivector3D.
 */
rssn_
struct rssn_Multivector3D *rssn_num_ga_reverse(const struct rssn_Multivector3D *aMv)
;

/*
 Bincode FFI for ga_reverse.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_ga_reverse_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for ga_reverse.
 */
rssn_
char *rssn_num_ga_reverse_json(const char *aJsonPtr)
;

/*
 Performs multivector subtraction.
 */
rssn_
struct rssn_Multivector3D *rssn_num_ga_sub(const struct rssn_Multivector3D *aMv1,
                                           const struct rssn_Multivector3D *aMv2)
;

/*
 Bincode FFI for ga_sub.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_ga_sub_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for ga_sub.
 */
rssn_
char *rssn_num_ga_sub_json(const char *aJsonPtr)
;

/*
 Performs outer product.
 */
rssn_
struct rssn_Multivector3D *rssn_num_ga_wedge(const struct rssn_Multivector3D *aMv1,
                                             const struct rssn_Multivector3D *aMv2)
;

/*
 Bincode FFI for ga_wedge.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_ga_wedge_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for ga_wedge.
 */
rssn_
char *rssn_num_ga_wedge_json(const char *aJsonPtr)
;

/*
 Adds a directed edge.
 */
rssn_
void rssn_num_graph_add_edge(struct rssn_Graph *aGraph,
                             size_t aU,
                             size_t aV,
                             double aWeight)
;

/*
 Computes BFS.
 */
rssn_
int32_t rssn_num_graph_bfs(struct rssn_Graph *aGraph,
                           size_t aStartNode,
                           size_t *aDist)
;

/*
 Computes Breadth-First Search (BFS) on a graph using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_graph_bfs_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes Breadth-First Search (BFS) on a graph using JSON for serialization.
 */
rssn_
char *rssn_num_graph_bfs_json(const char *aInputJson)
;

/*
 Computes Connected Components.
 Result array `components` must be allocated by caller with size `num_nodes`.
 */
rssn_
int32_t rssn_num_graph_connected_components(struct rssn_Graph *aGraph,
                                            size_t *aComponents)
;

/*
 Computes the connected components of a graph using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_graph_connected_components_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the connected components of a graph using JSON for serialization.
 */
rssn_
char *rssn_num_graph_connected_components_json(const char *aInputJson)
;

/*
 Creates a new graph.
 */
rssn_
struct rssn_Graph *rssn_num_graph_create(size_t aNumNodes)
;

/*
 Computes Dijkstra's algorithm.
 */
rssn_
int32_t rssn_num_graph_dijkstra(struct rssn_Graph *aGraph,
                                size_t aStartNode,
                                double *aDist,
                                ptrdiff_t *aPrev)
;

/*
 Computes Dijkstra's shortest path algorithm on a graph using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_graph_dijkstra_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes Dijkstra's shortest path algorithm on a graph using JSON for serialization.
 */
rssn_
char *rssn_num_graph_dijkstra_json(const char *aInputJson)
;

/*
 Computes Floyd-Warshall.
 */
rssn_
int32_t rssn_num_graph_floyd_warshall(struct rssn_Graph *aGraph,
                                      double *aDistMatrix)
;

/*
 Computes the Floyd-Warshall all-pairs shortest path algorithm on a graph using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_graph_floyd_warshall_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Floyd-Warshall all-pairs shortest path algorithm on a graph using JSON for serialization.
 */
rssn_
char *rssn_num_graph_floyd_warshall_json(const char *aInputJson)
;

/*
 Frees a graph.
 */
rssn_
void rssn_num_graph_free(struct rssn_Graph *aGraph)
;

/*
 Computes Minimum Spanning Tree (MST).
 Returns a new Graph handle.
 */
rssn_
struct rssn_Graph *rssn_num_graph_minimum_spanning_tree(struct rssn_Graph *aGraph)
;

/*
 Computes the Minimum Spanning Tree (MST) of a graph using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_graph_minimum_spanning_tree_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Minimum Spanning Tree (MST) of a graph using JSON for serialization.
 */
rssn_
char *rssn_num_graph_minimum_spanning_tree_json(const char *aInputJson)
;

/*
 Computes PageRank.
 */
rssn_
int32_t rssn_num_graph_page_rank(struct rssn_Graph *aGraph,
                                 double aDampingFactor,
                                 double aTolerance,
                                 size_t aMaxIter,
                                 double *aScores)
;

/*
 Computes the PageRank scores for nodes in a graph using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_graph_page_rank_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the PageRank scores for nodes in a graph using JSON for serialization.
 */
rssn_
char *rssn_num_graph_page_rank_json(const char *aInputJson)
;

/*
 Computes the angle between two 3D vectors in radians.
 */
rssn_
double rssn_num_graphics_angle_between(double aX1,
                                       double aY1,
                                       double aZ1,
                                       double aX2,
                                       double aY2,
                                       double aZ2)
;

/*
 Computes the angle between two 3D vectors using JSON for serialization.
 */
rssn_
char *rssn_num_graphics_angle_between_json(const char *aInput)
;

/*
 Bezier cubic curve evaluation.

 # Safety
 Pointers must be valid.
 */
rssn_
int32_t rssn_num_graphics_bezier_cubic(double aP0x,
                                       double aP0y,
                                       double aP0z,
                                       double aP1x,
                                       double aP1y,
                                       double aP1z,
                                       double aP2x,
                                       double aP2y,
                                       double aP2z,
                                       double aP3x,
                                       double aP3y,
                                       double aP3z,
                                       double aT,
                                       double *aOutX,
                                       double *aOutY,
                                       double *aOutZ)
;

/*
 Computes a point on a cubic Bezier curve using JSON for serialization.
 */
rssn_
char *rssn_num_graphics_bezier_cubic_json(const char *aInput)
;

/*
 Computes the cross product of two 3D vectors.
 Result is stored in out_x, out_y, out_z.

 # Safety
 Pointers must be valid.
 */
rssn_
int32_t rssn_num_graphics_cross_product(double aX1,
                                        double aY1,
                                        double aZ1,
                                        double aX2,
                                        double aY2,
                                        double aZ2,
                                        double *aOutX,
                                        double *aOutY,
                                        double *aOutZ)
;

/*
 Computes the cross product of two 3D vectors using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_graphics_cross_product_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the cross product of two 3D vectors using JSON for serialization.
 */
rssn_
char *rssn_num_graphics_cross_product_json(const char *aInput)
;

/*
 Converts degrees to radians.
 */
rssn_
double rssn_num_graphics_degrees_to_radians(double aDegrees)
;

/*
 Computes the dot product of two 3D vectors.
 */
rssn_
double rssn_num_graphics_dot_product(double aX1,
                                     double aY1,
                                     double aZ1,
                                     double aX2,
                                     double aY2,
                                     double aZ2)
;

/*
 Computes the dot product of two 3D vectors using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_graphics_dot_product_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the dot product of two 3D vectors using JSON for serialization.
 */
rssn_
char *rssn_num_graphics_dot_product_json(const char *aInput)
;

/*
 Creates a look-at matrix using JSON for serialization.
 */
rssn_
char *rssn_num_graphics_look_at_matrix_json(const char *aInput)
;

/*
 Computes the magnitude of a 3D vector.
 */
rssn_
double rssn_num_graphics_magnitude(double aX,
                                   double aY,
                                   double aZ)
;

/*
 Computes the magnitude of a 3D vector using JSON for serialization.
 */
rssn_
char *rssn_num_graphics_magnitude_json(const char *aInput)
;

/*
 Normalizes a 3D vector.

 # Safety
 Pointers must be valid.
 */
rssn_
int32_t rssn_num_graphics_normalize(double aX,
                                    double aY,
                                    double aZ,
                                    double *aOutX,
                                    double *aOutY,
                                    double *aOutZ)
;

/*
 Normalizes a 3D vector using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_graphics_normalize_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Normalizes a 3D vector using JSON for serialization.
 */
rssn_
char *rssn_num_graphics_normalize_json(const char *aInput)
;

/*
 Creates a perspective projection matrix using JSON for serialization.
 */
rssn_
char *rssn_num_graphics_perspective_matrix_json(const char *aInput)
;

/*
 Quaternion multiply.

 # Safety
 Pointers must be valid.
 */
rssn_
int32_t rssn_num_graphics_quaternion_multiply(double aW1,
                                              double aX1,
                                              double aY1,
                                              double aZ1,
                                              double aW2,
                                              double aX2,
                                              double aY2,
                                              double aZ2,
                                              double *aOutW,
                                              double *aOutX,
                                              double *aOutY,
                                              double *aOutZ)
;

/*
 Multiplies two quaternions using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_graphics_quaternion_multiply_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Multiplies two quaternions using JSON for serialization.
 */
rssn_
char *rssn_num_graphics_quaternion_multiply_json(const char *aInput)
;

/*
 Computes the spherical linear interpolation (SLERP) between two quaternions using JSON for serialization.
 */
rssn_
char *rssn_num_graphics_quaternion_slerp_json(const char *aInput)
;

/*
 Converts radians to degrees.
 */
rssn_
double rssn_num_graphics_radians_to_degrees(double aRadians)
;

/*
 Ray-sphere intersection.
 Returns t value or -1 if no intersection.
 */
rssn_
double rssn_num_graphics_ray_sphere_intersection(double aRayOx,
                                                 double aRayOy,
                                                 double aRayOz,
                                                 double aRayDx,
                                                 double aRayDy,
                                                 double aRayDz,
                                                 double aSphereCx,
                                                 double aSphereCy,
                                                 double aSphereCz,
                                                 double aSphereR)
;

/*
 Computes the intersection of a ray with a sphere using JSON for serialization.
 */
rssn_
char *rssn_num_graphics_ray_sphere_intersection_json(const char *aInput)
;

/*
 Computes the reflection vector.

 # Safety
 Pointers must be valid.
 */
rssn_
int32_t rssn_num_graphics_reflect(double aIx,
                                  double aIy,
                                  double aIz,
                                  double aNx,
                                  double aNy,
                                  double aNz,
                                  double *aOutX,
                                  double *aOutY,
                                  double *aOutZ)
;

/*
 Computes the reflection of an incident vector across a normal vector using JSON for serialization.
 */
rssn_
char *rssn_num_graphics_reflect_json(const char *aInput)
;

/*
 Creates a 3D rotation matrix around an arbitrary axis using JSON for serialization.
 */
rssn_
char *rssn_num_graphics_rotation_matrix_axis_json(const char *aInput)
;

/*
 Rotation matrix around X axis.
 Output: 16 f64 values in row-major order.

 # Safety
 `out_ptr` must point to at least 16 f64 values.
 */
rssn_
int32_t rssn_num_graphics_rotation_matrix_x(double aAngleRad,
                                            double *aOutPtr)
;

/*
 Creates a 3D rotation matrix around the X-axis using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_graphics_rotation_matrix_x_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Creates a 3D rotation matrix around the X-axis using JSON for serialization.
 */
rssn_
char *rssn_num_graphics_rotation_matrix_x_json(const char *aInput)
;

/*
 Creates a 3D rotation matrix around the Y-axis using JSON for serialization.
 */
rssn_
char *rssn_num_graphics_rotation_matrix_y_json(const char *aInput)
;

/*
 Creates a 3D rotation matrix around the Z-axis using JSON for serialization.
 */
rssn_
char *rssn_num_graphics_rotation_matrix_z_json(const char *aInput)
;

/*
 Creates a 3D scaling matrix using JSON for serialization.
 */
rssn_
char *rssn_num_graphics_scaling_matrix_json(const char *aInput)
;

/*
 Creates a 3D translation matrix using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_graphics_translation_matrix_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Creates a 3D translation matrix using JSON for serialization.
 */
rssn_
char *rssn_num_graphics_translation_matrix_json(const char *aInput)
;

/*
 Computes the Inverse Fast Fourier Transform (IFFT) in-place using bincode serialization.

 The IFFT converts a sequence from the frequency domain back to the time/space domain,
 computing x(n) = (1/N) ΣX(k)e^(2πikn/N) for n = 0, ..., N-1.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `TransformInput` with:
   - `data`: Vector of complex numbers in frequency domain

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<Complex<f64>>, String>` with either:
 - `ok`: IFFT-transformed data in time/space domain
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_ifft_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Inverse Fast Fourier Transform (IFFT) in-place.
 */
rssn_
int32_t rssn_num_ifft_inplace(double *aReal,
                              double *aImag,
                              size_t aLen)
;

/*
 Computes the Inverse Fast Fourier Transform (IFFT) in-place via JSON serialization.

 The IFFT converts a sequence from the frequency domain back to the time/space domain,
 computing x(n) = (1/N) ΣX(k)e^(2πikn/N) for n = 0, ..., N-1.

 # Arguments

 * `input_json` - A JSON string pointer containing:
   - `data`: Array of complex numbers in frequency domain

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<Complex<f64>>, String>` with
 IFFT-transformed data in time/space domain.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_ifft_json(const char *aInputJson)
;

/*
 Computes Lagrange interpolation and returns a Polynomial pointer.
 */
rssn_
struct rssn_Polynomial *rssn_num_lagrange_interpolation(const double *aXCoords,
                                                        const double *aYCoords,
                                                        size_t aLen)
;

/*
 Computes the Lagrange interpolation polynomial for a given set of points using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_lagrange_interpolation_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Lagrange interpolation polynomial for a given set of points using JSON for serialization.
 */
rssn_
char *rssn_num_lagrange_interpolation_json(const char *aInputPtr)
;

/*
 Adds two numerical matrices.

 # Arguments
 * `m1` - Handle to the first matrix.
 * `m2` - Handle to the second matrix.

 # Returns
 A handle to the resulting matrix, or null on error.
 */
rssn_
struct rssn_RssnMatrixHandle *rssn_num_matrix_add(const struct rssn_RssnMatrixHandle *aM1,
                                                  const struct rssn_RssnMatrixHandle *aM2)
;

/*
 Matrix addition via Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_matrix_add_bincode(const uint8_t *aData,
                                                      size_t aLen)
;

/*
 Matrix addition via Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_matrix_add_bincode_nightly(const uint8_t *aData,
                                                              size_t aLen)
;

/*
 Evaluates a matrix addition from JSON.
 */
rssn_
char *rssn_num_matrix_add_json(const char *aJsonPtr)
;

/*
 Evaluates a matrix addition from JSON.
 */
rssn_
char *rssn_num_matrix_add_json_nightly(const char *aJsonPtr)
;

/*
 Adds two matrices.
 */
rssn_
struct rssn_RssnMatrixHandle *rssn_num_matrix_add_nightly(const struct rssn_RssnMatrixHandle *aM1,
                                                          const struct rssn_RssnMatrixHandle *aM2)
;

/*
 Creates a new f64 matrix from dimensions and a raw data array.

 # Arguments
 * `rows` - Number of rows.
 * `cols` - Number of columns.
 * `data` - Pointer to an array of doubles in row-major order.

 # Returns
 A raw pointer to the Matrix object, or null on error.
 */
rssn_
struct rssn_RssnMatrixHandle *rssn_num_matrix_create(size_t aRows,
                                                     size_t aCols,
                                                     const double *aData)
;

/*
 Creates a new f64 matrix from dimensions and a raw data array.

 # Arguments
 * `rows` - Number of rows.
 * `cols` - Number of columns.
 * `data` - Pointer to an array of doubles in row-major order.

 # Returns
 A raw pointer to the Matrix object, or null on error.
 */
rssn_
struct rssn_RssnMatrixHandle *rssn_num_matrix_create_nightly(size_t aRows,
                                                             size_t aCols,
                                                             const double *aData)
;

/*
 Decomposes a matrix via Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_matrix_decompose_bincode(const uint8_t *aData,
                                                            size_t aLen)
;

/*
 Decomposes a matrix via Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_matrix_decompose_bincode_nightly(const uint8_t *aData,
                                                                    size_t aLen)
;

/*
 Computes Cholesky decomposition: A = L * L^T.
 */
rssn_
int32_t rssn_num_matrix_decompose_cholesky(const struct rssn_RssnMatrixHandle *aMatrix,
                                           struct rssn_RssnMatrixHandle **aOutL)
;

/*
 Computes Cholesky decomposition: A = L * L^T.
 */
rssn_
int32_t rssn_num_matrix_decompose_cholesky_nightly(const struct rssn_RssnMatrixHandle *aMatrix,
                                                   struct rssn_RssnMatrixHandle **aOutL)
;

/*
 Computes Symmetric Eigendecomposition: A = V * D * V^T.
 */
rssn_
int32_t rssn_num_matrix_decompose_eigen_symmetric(const struct rssn_RssnMatrixHandle *aMatrix,
                                                  struct rssn_RssnMatrixHandle **aOutValues,
                                                  struct rssn_RssnMatrixHandle **aOutVectors)
;

/*
 Computes Symmetric Eigendecomposition: A = V * D * V^T.
 */
rssn_
int32_t rssn_num_matrix_decompose_eigen_symmetric_nightly(const struct rssn_RssnMatrixHandle *aMatrix,
                                                          struct rssn_RssnMatrixHandle **aOutValues,
                                                          struct rssn_RssnMatrixHandle **aOutVectors)
;

/*
 Decomposes a matrix from JSON.
 */
rssn_
char *rssn_num_matrix_decompose_json(const char *aJsonPtr)
;

/*
 Decomposes a matrix from JSON.
 */
rssn_
char *rssn_num_matrix_decompose_json_nightly(const char *aJsonPtr)
;

/*
 Computes SVD decomposition: A = U * S * V^T.
 Returns 0 on success, -1 on error.
 */
rssn_
int32_t rssn_num_matrix_decompose_svd(const struct rssn_RssnMatrixHandle *aMatrix,
                                      struct rssn_RssnMatrixHandle **aOutU,
                                      struct rssn_RssnMatrixHandle **aOutS,
                                      struct rssn_RssnMatrixHandle **aOutV)
;

/*
 Computes SVD decomposition: A = U * S * V^T.
 Returns 0 on success, -1 on error.
 */
rssn_
int32_t rssn_num_matrix_decompose_svd_nightly(const struct rssn_RssnMatrixHandle *aMatrix,
                                              struct rssn_RssnMatrixHandle **aOutU,
                                              struct rssn_RssnMatrixHandle **aOutS,
                                              struct rssn_RssnMatrixHandle **aOutV)
;

/*
 Computes determinant from JSON.
 */
rssn_
char *rssn_num_matrix_det_json(const char *aJsonPtr)
;

/*
 Computes determinant from JSON.
 */
rssn_
char *rssn_num_matrix_det_json_nightly(const char *aJsonPtr)
;

/*
 Computes the determinant of a numerical matrix.

 # Arguments
 * `matrix` - Handle to the matrix.
 * `result` - Pointer to store the result.

 # Returns
 0 on success, -1 on error.
 */
rssn_
int32_t rssn_num_matrix_determinant(const struct rssn_RssnMatrixHandle *aMatrix,
                                    double *aResult)
;

/*
 Computes the determinant of a matrix.
 */
rssn_
int32_t rssn_num_matrix_determinant_nightly(const struct rssn_RssnMatrixHandle *aMatrix,
                                            double *aResult)
;

/*
 Frees a previously allocated Matrix.
 */
rssn_
void rssn_num_matrix_free(struct rssn_RssnMatrixHandle *aMatrix)
;

/*
 Frees a previously allocated Matrix.
 */
rssn_
void rssn_num_matrix_free_nightly(struct rssn_RssnMatrixHandle *aMatrix)
;

/*
 Returns the Frobenius norm.
 */
rssn_
double rssn_num_matrix_frobenius_norm(const struct rssn_RssnMatrixHandle *aMatrix)
;

/*
 Returns the Frobenius norm.
 */
rssn_
double rssn_num_matrix_frobenius_norm_nightly(const struct rssn_RssnMatrixHandle *aMatrix)
;

/*
 Returns the number of columns of a given matrix.
 */
rssn_
size_t rssn_num_matrix_get_cols(const struct rssn_RssnMatrixHandle *aMatrix)
;

/*
 Returns the number of columns of a given matrix.
 */
rssn_
size_t rssn_num_matrix_get_cols_nightly(const struct rssn_RssnMatrixHandle *aMatrix)
;

/*
 Copies the matrix data into a provided buffer.

 # Arguments
 * `matrix` - Handle to the matrix.
 * `buffer` - Pointer to a buffer of size `rows * cols`.

 # Returns
 0 on success, -1 on error.
 */
rssn_
int32_t rssn_num_matrix_get_data(const struct rssn_RssnMatrixHandle *aMatrix,
                                 double *aBuffer)
;

/*
 Retrieves the raw data of a given matrix.
 */
rssn_
int32_t rssn_num_matrix_get_data_nightly(const struct rssn_RssnMatrixHandle *aMatrix,
                                         double *aBuffer)
;

/*
 Returns the number of rows of a given matrix.
 */
rssn_
size_t rssn_num_matrix_get_rows(const struct rssn_RssnMatrixHandle *aMatrix)
;

/*
 Returns the number of rows of a given matrix.
 */
rssn_
size_t rssn_num_matrix_get_rows_nightly(const struct rssn_RssnMatrixHandle *aMatrix)
;

/*
 Creates an identity matrix.
 */
rssn_
struct rssn_RssnMatrixHandle *rssn_num_matrix_identity(size_t aSize)
;

/*
 Creates an identity matrix.
 */
rssn_
struct rssn_RssnMatrixHandle *rssn_num_matrix_identity_nightly(size_t aSize)
;

/*
 Computes the inverse of a numerical matrix.

 # Arguments
 * `matrix` - Handle to the matrix.

 # Returns
 A handle to the inverse matrix, or null if the matrix is singular or not square.
 */
rssn_
struct rssn_RssnMatrixHandle *rssn_num_matrix_inverse(const struct rssn_RssnMatrixHandle *aMatrix)
;

/*
 Computes the inverse of a matrix.
 */
rssn_
struct rssn_RssnMatrixHandle *rssn_num_matrix_inverse_nightly(const struct rssn_RssnMatrixHandle *aMatrix)
;

/*
 Checks if it's identity.
 */
rssn_
int32_t rssn_num_matrix_is_identity(const struct rssn_RssnMatrixHandle *aMatrix,
                                    double aEpsilon)
;

/*
 Checks if it's identity.
 */
rssn_
int32_t rssn_num_matrix_is_identity_nightly(const struct rssn_RssnMatrixHandle *aMatrix,
                                            double aEpsilon)
;

/*
 Checks if it's orthogonal.
 */
rssn_
int32_t rssn_num_matrix_is_orthogonal(const struct rssn_RssnMatrixHandle *aMatrix,
                                      double aEpsilon)
;

/*
 Checks if it's orthogonal.
 */
rssn_
int32_t rssn_num_matrix_is_orthogonal_nightly(const struct rssn_RssnMatrixHandle *aMatrix,
                                              double aEpsilon)
;

/*
 Multiplies two numerical matrices.

 # Arguments
 * `m1` - Handle to the first matrix.
 * `m2` - Handle to the second matrix.

 # Returns
 A handle to the resulting matrix, or null on error.
 */
rssn_
struct rssn_RssnMatrixHandle *rssn_num_matrix_mul(const struct rssn_RssnMatrixHandle *aM1,
                                                  const struct rssn_RssnMatrixHandle *aM2)
;

/*
 Matrix multiplication via Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_matrix_mul_bincode(const uint8_t *aData,
                                                      size_t aLen)
;

/*
 Matrix multiplication via Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_matrix_mul_bincode_nightly(const uint8_t *aData,
                                                              size_t aLen)
;

/*
 Evaluates a matrix multiplication from JSON.
 */
rssn_
char *rssn_num_matrix_mul_json(const char *aJsonPtr)
;

/*
 Evaluates a matrix multiplication from JSON.
 */
rssn_
char *rssn_num_matrix_mul_json_nightly(const char *aJsonPtr)
;

/*
 Multiplies two matrices.
 */
rssn_
struct rssn_RssnMatrixHandle *rssn_num_matrix_mul_nightly(const struct rssn_RssnMatrixHandle *aM1,
                                                          const struct rssn_RssnMatrixHandle *aM2)
;

/*
 Returns the rank.
 */
rssn_
int32_t rssn_num_matrix_rank(const struct rssn_RssnMatrixHandle *aMatrix,
                             size_t *aOutRank)
;

/*
 Returns the rank.
 */
rssn_
int32_t rssn_num_matrix_rank_nightly(const struct rssn_RssnMatrixHandle *aMatrix,
                                     size_t *aOutRank)
;

/*
 Sets the backend for the matrix.
 0: Native, 1: Faer
 */
rssn_
int32_t rssn_num_matrix_set_backend(struct rssn_RssnMatrixHandle *aMatrix,
                                    int32_t aBackendId)
;

/*
 Sets backend for a matrix via Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_matrix_set_backend_bincode(const uint8_t *aData,
                                                              size_t aLen)
;

/*
 Sets backend for a matrix via Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_matrix_set_backend_bincode_nightly(const uint8_t *aData,
                                                                      size_t aLen)
;

/*
 Sets backend for a matrix (returns new matrix with backend set) from JSON.
 */
rssn_
char *rssn_num_matrix_set_backend_json(const char *aJsonPtr)
;

/*
 Sets backend for a matrix (returns new matrix with backend set) from JSON.
 */
rssn_
char *rssn_num_matrix_set_backend_json_nightly(const char *aJsonPtr)
;

/*
 Sets the backend for the matrix.
 0: Native, 1: Faer
 */
rssn_
int32_t rssn_num_matrix_set_backend_nightly(struct rssn_RssnMatrixHandle *aMatrix,
                                            int32_t aBackendId)
;

/*
 Returns the trace.
 */
rssn_
int32_t rssn_num_matrix_trace(const struct rssn_RssnMatrixHandle *aMatrix,
                              double *aOutTrace)
;

/*
 Returns the trace.
 */
rssn_
int32_t rssn_num_matrix_trace_nightly(const struct rssn_RssnMatrixHandle *aMatrix,
                                      double *aOutTrace)
;

/*
 Transposes a numerical matrix.

 # Arguments
 * `matrix` - Handle to the matrix.

 # Returns
 A handle to the transposed matrix, or null on error.
 */
rssn_
struct rssn_RssnMatrixHandle *rssn_num_matrix_transpose(const struct rssn_RssnMatrixHandle *aMatrix)
;

/*
 Transposes a matrix.
 */
rssn_
struct rssn_RssnMatrixHandle *rssn_num_matrix_transpose_nightly(const struct rssn_RssnMatrixHandle *aMatrix)
;

/*
 Applies periodic boundary condition to a 1D position.
 */
rssn_
double rssn_num_md_apply_pbc_1d(double aX,
                                double aBoxLength)
;

/*
 Applies periodic boundary conditions (PBC) to wrap particle coordinates into the simulation box using bincode serialization.

 Periodic boundary conditions create an infinite tiling of the simulation box,
 ensuring particles that exit one side re-enter from the opposite side.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `PbcInput` with:
   - `position`: Position vector to wrap (x, y, z)
   - `box_size`: Simulation box dimensions (Lx, Ly, Lz)

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<f64>, String>` with either:
 - `ok`: Wrapped position vector within [0, box_size)
 - `err`: Error message if input invalid

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_md_apply_pbc_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Applies periodic boundary conditions (PBC) to wrap particle coordinates using JSON serialization.

 Periodic boundary conditions create an infinite tiling of the simulation box.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `position`: Position vector to wrap [x, y, z]
   - `box_size`: Simulation box dimensions [Lx, Ly, Lz]

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the wrapped position vector within [0, box_size).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_md_apply_pbc_json(const char *aInput)
;

/*
 Returns Avogadro's number.
 */
rssn_
double rssn_num_md_avogadro_number(void)
;

/*
 Returns Boltzmann constant in SI units.
 */
rssn_
double rssn_num_md_boltzmann_constant_si(void)
;

/*
 Calculates CFL number for MD stability.
 */
rssn_
double rssn_num_md_cfl_check(double aVelocity,
                             double aDt,
                             double aSigma)
;

/*
 Creates a simple cubic lattice of particles using JSON serialization.

 Generates a 3D cubic lattice structure commonly used for initial configurations
 in molecular dynamics simulations.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `n_per_side`: Number of particles per lattice dimension
   - `lattice_constant`: Spacing between adjacent lattice sites
   - `mass`: Mass of each particle

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<ParticleOutput>, String>` with
 an array of particles positioned on a cubic lattice.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_md_create_cubic_lattice_json(const char *aInput)
;

/*
 Computes the harmonic interaction potential and force between two particles using JSON serialization.

 The harmonic potential models elastic bonds:
 V(r) = ½k(r - r₀)², where k is the spring constant.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `p1_position`: Position vector of first particle [x, y, z]
   - `p2_position`: Position vector of second particle [x, y, z]
   - `k`: Spring constant k (force/length units)
   - `r0`: Equilibrium distance r₀

 # Returns

 A C string pointer containing JSON-encoded `FfiResult` with potential and force.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_md_harmonic_json(const char *aInput)
;

/*
 Computes the Lennard-Jones interaction potential and force between two particles using bincode serialization.

 The Lennard-Jones potential models van der Waals interactions:
 V(r) = 4ε[(σ/r)¹² - (σ/r)⁶], where ε is the depth of the potential well and σ is the finite distance at which the potential is zero.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `LennardJonesInput` with:
   - `p1_position`: Position vector of first particle (x, y, z)
   - `p2_position`: Position vector of second particle (x, y, z)
   - `epsilon`: Well depth ε (energy units)
   - `sigma`: Finite distance σ at which V=0 (length units)

 # Returns

 A bincode-encoded buffer containing `FfiResult<InteractionOutput, String>` with either:
 - `ok`: Object containing:
   - `potential`: Interaction potential energy V(r)
   - `force`: Force vector acting on particle 1
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_md_lennard_jones_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Lennard-Jones interaction potential and force between two particles using JSON serialization.

 The Lennard-Jones potential models van der Waals interactions:
 V(r) = 4ε[(σ/r)¹² - (σ/r)⁶].

 # Arguments

 * `input` - A JSON string pointer containing:
   - `p1_position`: Position vector of first particle [x, y, z]
   - `p2_position`: Position vector of second particle [x, y, z]
   - `epsilon`: Well depth ε (energy units)
   - `sigma`: Finite distance σ at which V=0 (length units)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult` with potential and force.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_md_lennard_jones_json(const char *aInput)
;

/*
 Applies minimum image convention to a 1D distance.
 */
rssn_
double rssn_num_md_minimum_image_1d(double aDx,
                                    double aBoxLength)
;

/*
 Computes the minimum image distance vector under periodic boundary conditions using JSON serialization.

 The minimum image convention finds the shortest distance between particles
 considering all periodic images of the simulation box.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `position`: Separation vector [x, y, z]
   - `box_size`: Simulation box dimensions [Lx, Ly, Lz]

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the minimum image distance vector.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_md_minimum_image_json(const char *aInput)
;

/*
 Computes the Morse interaction potential and force between two particles using JSON serialization.

 The Morse potential models chemical bonds:
 V(r) = D_e[1 - e⁻ᵃʳʳ⁻ʳᵉ⁾]², where D_e is the dissociation energy.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `p1_position`: Position vector of first particle [x, y, z]
   - `p2_position`: Position vector of second particle [x, y, z]
   - `de`: Dissociation energy D_e
   - `a`: Width parameter a (controls potential curvature)
   - `re`: Equilibrium bond distance r_e

 # Returns

 A C string pointer containing JSON-encoded `FfiResult` with potential and force.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_md_morse_json(const char *aInput)
;

/*
 Computes system-level properties for a collection of particles using JSON serialization.

 Calculates kinetic energy, temperature, center of mass, and total momentum.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `particles`: Array of particle objects with id, mass, position, velocity

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<SystemPropertiesOutput, String>` with:
 - `kinetic_energy`: Total kinetic energy of the system
 - `temperature`: System temperature T = 2K/(3Nk_B)
 - `center_of_mass`: Center of mass position vector
 - `total_momentum`: Total linear momentum vector

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_md_system_properties_json(const char *aInput)
;

/*
 Returns temperature unit for argon in reduced units.
 */
rssn_
double rssn_num_md_temperature_unit_argon(void)
;

/*
 Computes the k-th branch of the complex arccosine.
 */
rssn_
void rssn_num_mv_complex_arccos_k(double aRe,
                                  double aIm,
                                  int32_t aK,
                                  int32_t aS,
                                  double *aResRe,
                                  double *aResIm)
;

/*
 Computes the k-th branch of the complex arcsine.
 */
rssn_
void rssn_num_mv_complex_arcsin_k(double aRe,
                                  double aIm,
                                  int32_t aK,
                                  double *aResRe,
                                  double *aResIm)
;

/*
 Computes the k-th branch of the complex arctangent.
 */
rssn_
void rssn_num_mv_complex_arctan_k(double aRe,
                                  double aIm,
                                  int32_t aK,
                                  double *aResRe,
                                  double *aResIm)
;

/*
 Computes the k-th branch of the complex logarithm.
 */
rssn_
void rssn_num_mv_complex_log_k(double aRe,
                               double aIm,
                               int32_t aK,
                               double *aResRe,
                               double *aResIm)
;

/*
 Computes the k-th branch of the complex logarithm using Bincode.

 # Arguments
 * `buffer` - Bincode-encoded `LogSqrtInput`.

 # Returns
 Bincode-encoded `FfiResult<ComplexResult, String>`.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_mv_complex_log_k_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the k-th branch of the complex logarithm using JSON.

 # Arguments
 * `json` - JSON-encoded `LogSqrtInput`.

 # Returns
 JSON-encoded `FfiResult<ComplexResult, String>`.
 */
rssn_
char *rssn_num_mv_complex_log_k_json(const char *aJson)
;

/*
 Computes the k-th branch of the complex n-th root.
 */
rssn_
void rssn_num_mv_complex_nth_root_k(double aRe,
                                    double aIm,
                                    uint32_t aN,
                                    int32_t aK,
                                    double *aResRe,
                                    double *aResIm)
;

/*
 Computes the k-th branch of the complex power z^w.
 */
rssn_
void rssn_num_mv_complex_pow_k(double aZRe,
                               double aZIm,
                               double aWRe,
                               double aWIm,
                               int32_t aK,
                               double *aResRe,
                               double *aResIm)
;

/*
 Computes the k-th branch of complex power using Bincode.

 # Arguments
 * `buffer` - Bincode-encoded `PowInput`.

 # Returns
 Bincode-encoded `FfiResult<ComplexResult, String>`.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_mv_complex_pow_k_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the k-th branch of complex power using JSON.

 # Arguments
 * `json` - JSON-encoded `PowInput`.

 # Returns
 JSON-encoded `FfiResult<ComplexResult, String>`.
 */
rssn_
char *rssn_num_mv_complex_pow_k_json(const char *aJson)
;

/*
 Computes the k-th branch of the complex square root.
 */
rssn_
void rssn_num_mv_complex_sqrt_k(double aRe,
                                double aIm,
                                int32_t aK,
                                double *aResRe,
                                double *aResIm)
;

/*
 Computes the k-th branch of the complex square root using Bincode.

 # Arguments
 * `buffer` - Bincode-encoded `LogSqrtInput`.

 # Returns
 Bincode-encoded `FfiResult<ComplexResult, String>`.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_mv_complex_sqrt_k_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the k-th branch of the complex square root using JSON.

 # Arguments
 * `json` - JSON-encoded `LogSqrtInput`.

 # Returns
 JSON-encoded `FfiResult<ComplexResult, String>`.
 */
rssn_
char *rssn_num_mv_complex_sqrt_k_json(const char *aJson)
;

/*
 Finds a root of a complex function using Newton's method.
 */
rssn_
int32_t rssn_num_mv_newton_method_complex(const struct rssn_Expr *aFPtr,
                                          const struct rssn_Expr *aFPrimePtr,
                                          double aStartRe,
                                          double aStartIm,
                                          double aTolerance,
                                          size_t aMaxIter,
                                          double *aResRe,
                                          double *aResIm)
;

/*
 Newton's method for complex roots using Bincode for FFI communication.

 # Arguments
 * `buffer` - Bincode-encoded `NewtonInput`.

 # Returns
 Bincode-encoded `FfiResult<ComplexResult, String>`.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_mv_newton_method_complex_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Newton's method for complex roots using JSON for FFI communication.

 # Arguments
 * `input_json` - JSON-encoded `NewtonInput`.

 # Returns
 JSON-encoded `FfiResult<ComplexResult, String>`.
 */
rssn_
char *rssn_num_mv_newton_method_complex_json(const char *aInputJson)
;

/*
 Returns the number of prime factors and writes them to out_factors.
 out_factors must be large enough.
 */
rssn_
size_t rssn_num_nt_factorize(uint64_t aN,
                             uint64_t *aOutFactors)
;

/*
 Factorizes a number via Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_nt_factorize_bincode(const uint8_t *aData,
                                                        size_t aLen)
;

/*
 Factorizes a number from JSON.
 */
rssn_
char *rssn_num_nt_factorize_json(const char *aJsonPtr)
;

/*
 Computes the greatest common divisor (GCD).
 */
rssn_
uint64_t rssn_num_nt_gcd(uint64_t aA,
                         uint64_t aB)
;

/*
 Tests if a number is prime using Miller-Rabin.
 */
rssn_
bool rssn_num_nt_is_prime(uint64_t aN)
;

/*
 Computes the least common multiple (LCM).
 */
rssn_
uint64_t rssn_num_nt_lcm(uint64_t aA,
                         uint64_t aB)
;

/*
 Finds the modular multiplicative inverse.
 Returns 0 if no inverse exists (modulus cannot be 0).
 */
rssn_
int64_t rssn_num_nt_mod_inverse(int64_t aA,
                                int64_t aM)
;

/*
 Modular inverse from JSON.
 */
rssn_
char *rssn_num_nt_mod_inverse_json(const char *aJsonPtr)
;

/*
 Computes (base^exp) % modulus.
 */
rssn_
uint64_t rssn_num_nt_mod_pow(rssn_u128 aBase,
                             uint64_t aExp,
                             uint64_t aModulus)
;

/*
 Computes Euler's totient function φ(n).
 */
rssn_
uint64_t rssn_num_nt_phi(uint64_t aN)
;

/*
 Solves a system of ODEs and returns the results as a Matrix handle.
 */
rssn_
struct rssn_Matrix_f64 *rssn_num_ode_solve(const struct rssn_Expr *const *aFuncs,
                                           size_t aNFuncs,
                                           const double *aY0,
                                           size_t aNY0,
                                           double aXStart,
                                           double aXEnd,
                                           size_t aNumSteps,
                                           int32_t aMethod)
;

/*
 Solves a system of ordinary differential equations (ODEs) using bincode serialization.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `OdeInput` with:
   - `funcs`: Vector of differential equations as `Expr`
   - `y0`: Initial values for each function
   - `x_range`: Integration range as (start, end)
   - `num_steps`: Number of steps for the solver
   - `method`: ODE solver method to use

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<Vec<f64>>, String>` with either:
 - `ok`: Solution matrix where each row represents a step
 - `err`: Error message if solving failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer is valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_ode_solve_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Solves a system of ordinary differential equations (ODEs) using JSON serialization.

 # Arguments

 * `input_json` - A JSON string pointer containing:
   - `funcs`: Array of differential equations as `Expr`
   - `y0`: Initial values for each function
   - `x_range`: Integration range as [start, end]
   - `num_steps`: Number of steps for the solver
   - `method`: ODE solver method to use

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<Vec<f64>>, String>` with either:
 - `ok`: Solution matrix where each row represents a step
 - `err`: Error message if solving failed

 # Safety

 This function is unsafe because it:
 - Receives a raw C string pointer that must be valid, null-terminated UTF-8
 - Returns a raw pointer that the caller must free using `rssn_free_string`
 */
rssn_
char *rssn_num_ode_solve_json(const char *aInputJson)
;

/*
 Computes the total power radiated by a blackbody via handle-based FFI.

 Uses the Stefan-Boltzmann law P = σAT⁴, where σ = 5.67 × 10⁻⁸ W/(m²·K⁴).

 # Arguments

 * `area` - Surface area A (m²)
 * `temperature` - Absolute temperature T (Kelvin)

 # Returns

 The radiated power P (Watts).
 */
rssn_
double rssn_num_physics_blackbody_power(double aArea,
                                        double aTemperature)
;

/*
 Computes the total power radiated by a blackbody using JSON serialization.

 Uses the Stefan-Boltzmann law P = σAT⁴, where σ = 5.67 × 10⁻⁸ W/(m²·K⁴).

 # Arguments

 * `input` - A JSON string pointer containing:
   - `area`: Surface area A (m²)
   - `temperature`: Absolute temperature T (Kelvin)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the radiated power P (Watts).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_physics_blackbody_power_json(const char *aInput)
;

/*
 Returns the Boltzmann constant k_B via handle-based FFI.

 # Returns

 The Boltzmann constant k_B = 1.381 × 10⁻²³ J/K.
 */
rssn_
double rssn_num_physics_boltzmann_constant(void)
;

/*
 Computes the Compton wavelength of a particle via handle-based FFI.

 The Compton wavelength is λ_C = h/(mc), characteristic of quantum scattering.

 # Arguments

 * `mass` - Particle rest mass m (kg)

 # Returns

 The Compton wavelength λ_C (meters).
 */
rssn_
double rssn_num_physics_compton_wavelength(double aMass)
;

/*
 Computes the Coulomb electrostatic force between two point charges via handle-based FFI.

 The force is F = k_e q₁q₂ / r², where k_e = 8.99 × 10⁹ N·m²/C².

 # Arguments

 * `q1` - First charge q₁ (Coulombs)
 * `q2` - Second charge q₂ (Coulombs)
 * `r` - Separation distance r (m)

 # Returns

 The Coulomb force magnitude F (Newtons, positive for repulsion).
 */
rssn_
double rssn_num_physics_coulomb_force(double aQ1,
                                      double aQ2,
                                      double aR)
;

/*
 Computes the Coulomb electrostatic force between two point charges using bincode serialization.

 The Coulomb force is the electrostatic interaction between charged particles:
 F = k_e q₁q₂ / r², where k_e is Coulomb's constant (8.99×10⁹ N·m²/C²).

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `TwoChargesInput` with:
   - `q1`: First charge q₁ (Coulombs)
   - `q2`: Second charge q₂ (Coulombs)
   - `r`: Separation distance r (m)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The Coulomb force magnitude F (Newtons, positive for repulsion)
 - `err`: Error message if deserialization failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_physics_coulomb_force_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Coulomb electrostatic force between two point charges using JSON serialization.

 The force is F = k_e q₁q₂ / r², where k_e = 8.99 × 10⁹ N·m²/C².

 # Arguments

 * `input` - A JSON string pointer containing:
   - `q1`: First charge q₁ (Coulombs)
   - `q2`: Second charge q₂ (Coulombs)
   - `r`: Separation distance r (m)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the Coulomb force magnitude F (Newtons, positive for repulsion).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_physics_coulomb_force_json(const char *aInput)
;

/*
 Computes the cyclotron radius for a charged particle in a magnetic field via handle-based FFI.

 The radius is r = (mv) / (qB), representing circular motion radius in a uniform B-field.

 # Arguments

 * `mass` - Particle mass m (kg)
 * `velocity` - Particle velocity v (m/s)
 * `charge` - Particle charge q (Coulombs)
 * `b_field` - Magnetic field magnitude B (Tesla)

 # Returns

 The cyclotron radius r (m).
 */
rssn_
double rssn_num_physics_cyclotron_radius(double aMass,
                                         double aVelocity,
                                         double aCharge,
                                         double aBField)
;

/*
 Computes the displacement of a damped harmonic oscillator via handle-based FFI.

 The displacement is x(t) = A e⁻γᵗ cos(ω't + φ), where ω' = √(ω₀² - γ²).

 # Arguments

 * `amplitude` - Initial amplitude A (m)
 * `omega0` - Natural angular frequency ω₀ (rad/s)
 * `gamma` - Damping coefficient γ (1/s)
 * `phase` - Phase angle φ (radians)
 * `time` - Time t at which to evaluate displacement (s)

 # Returns

 The displacement x(t) for underdamped oscillation (m).
 */
rssn_
double rssn_num_physics_damped_harmonic_oscillator(double aAmplitude,
                                                   double aOmega0,
                                                   double aGamma,
                                                   double aPhase,
                                                   double aTime)
;

/*
 Computes the displacement of a damped harmonic oscillator using JSON serialization.

 The displacement is x(t) = A e⁻γᵗ cos(ω't + φ), where ω' = √(ω₀² - γ²).

 # Arguments

 * `input` - A JSON string pointer containing:
   - `amplitude`: Initial amplitude A (m)
   - `omega0`: Natural angular frequency ω₀ (rad/s)
   - `gamma`: Damping coefficient γ (1/s)
   - `phase`: Phase angle φ (radians)
   - `time`: Time t at which to evaluate displacement (s)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the displacement x(t) for underdamped oscillation (m).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_physics_damped_harmonic_oscillator_json(const char *aInput)
;

/*
 Computes the de Broglie wavelength of a particle via handle-based FFI.

 The wavelength is λ = h/p, where h is Planck's constant and p is momentum.

 # Arguments

 * `momentum` - Particle momentum p (kg·m/s)

 # Returns

 The de Broglie wavelength λ (meters).
 */
rssn_
double rssn_num_physics_de_broglie_wavelength(double aMomentum)
;

/*
 Computes the de Broglie wavelength of a particle using JSON serialization.

 The wavelength is λ = h/p, where h is Planck's constant and p is momentum.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `momentum`: Particle momentum p (kg·m/s)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the de Broglie wavelength λ (meters).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_physics_de_broglie_wavelength_json(const char *aInput)
;

/*
 Computes the electric field magnitude of a point charge via handle-based FFI.

 The electric field is E = k_e q / r².

 # Arguments

 * `q` - Point charge q (Coulombs)
 * `r` - Distance from charge r (m)

 # Returns

 The electric field magnitude E (N/C or V/m).
 */
rssn_
double rssn_num_physics_electric_field_point_charge(double aQ,
                                                    double aR)
;

/*
 Computes the electric field magnitude of a point charge using JSON serialization.

 The electric field is E = k_e q / r².

 # Arguments

 * `input` - A JSON string pointer containing:
   - `q`: Point charge q (Coulombs)
   - `r`: Distance from charge r (m)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the electric field magnitude E (N/C or V/m).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_physics_electric_field_point_charge_json(const char *aInput)
;

/*
 Computes the electric potential of a point charge via handle-based FFI.

 The potential is V = k_e q / r.

 # Arguments

 * `q` - Point charge q (Coulombs)
 * `r` - Distance from charge r (m)

 # Returns

 The electric potential V (Volts).
 */
rssn_
double rssn_num_physics_electric_potential_point_charge(double aQ,
                                                        double aR)
;

/*
 Returns the electron rest mass m_e via handle-based FFI.

 # Returns

 The electron rest mass m_e = 9.109 × 10⁻³¹ kg.
 */
rssn_
double rssn_num_physics_electron_mass(void)
;

/*
 Returns the elementary charge e via handle-based FFI.

 # Returns

 The elementary charge e = 1.602 × 10⁻¹⁹ Coulombs.
 */
rssn_
double rssn_num_physics_elementary_charge(void)
;

/*
 Returns the gravitational constant G via handle-based FFI.

 # Returns

 The gravitational constant G = 6.674 × 10⁻¹¹ N·m²/kg².
 */
rssn_
double rssn_num_physics_gravitational_constant(void)
;

/*
 Computes the energy level of the hydrogen atom using the Bohr model via handle-based FFI.

 The energy is E_n = -13.6 eV / n², where n is the principal quantum number.

 # Arguments

 * `n` - Principal quantum number n (positive integer, ground state = 1)

 # Returns

 The energy level E_n (Joules, negative for bound states).
 */
rssn_
double rssn_num_physics_hydrogen_energy_level(uint64_t aN)
;

/*
 Computes the energy level of the hydrogen atom using the Bohr model and bincode serialization.

 The Bohr model gives hydrogen atom energy levels as:
 E_n = -13.6 eV / n², where n is the principal quantum number (n ≥ 1).
 Energy is negative, indicating a bound state.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `QuantumNumberInput` with:
   - `n`: Principal quantum number n (positive integer, ground state = 1)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The energy level E_n (Joules, negative for bound states)
 - `err`: Error message if deserialization failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_physics_hydrogen_energy_level_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the energy level of the hydrogen atom using the Bohr model and JSON serialization.

 The energy is E_n = -13.6 eV / n², where n is the principal quantum number.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `n`: Principal quantum number n (positive integer, ground state = 1)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the energy level E_n (Joules, negative for bound states).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_physics_hydrogen_energy_level_json(const char *aInput)
;

/*
 Computes the pressure of an ideal gas via handle-based FFI.

 Uses the ideal gas law PV = nRT, where R = 8.314 J/(mol·K).

 # Arguments

 * `n` - Amount of substance (moles)
 * `t` - Absolute temperature T (Kelvin)
 * `v` - Volume V (m³)

 # Returns

 The gas pressure P (Pascals).
 */
rssn_
double rssn_num_physics_ideal_gas_pressure(double aN,
                                           double aT,
                                           double aV)
;

/*
 Computes the pressure of an ideal gas using the ideal gas law and bincode serialization.

 The ideal gas law relates pressure, volume, temperature, and amount of substance:
 PV = nRT, where R is the universal gas constant (8.314 J/(mol·K)).

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `IdealGasInput` with:
   - `n`: Amount of substance (moles)
   - `t`: Absolute temperature T (Kelvin)
   - `v`: Volume V (m³)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The gas pressure P (Pascals)
 - `err`: Error message if deserialization failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_physics_ideal_gas_pressure_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the pressure of an ideal gas using JSON serialization.

 Uses the ideal gas law PV = nRT, where R = 8.314 J/(mol·K).

 # Arguments

 * `input` - A JSON string pointer containing:
   - `n`: Amount of substance (moles)
   - `t`: Absolute temperature T (Kelvin)
   - `v`: Volume V (m³)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the gas pressure P (Pascals).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_physics_ideal_gas_pressure_json(const char *aInput)
;

/*
 Computes the temperature of an ideal gas via handle-based FFI.

 Uses the ideal gas law T = PV/(nR).

 # Arguments

 * `p` - Pressure P (Pascals)
 * `v` - Volume V (m³)
 * `n` - Amount of substance (moles)

 # Returns

 The absolute temperature T (Kelvin).
 */
rssn_
double rssn_num_physics_ideal_gas_temperature(double aP,
                                              double aV,
                                              double aN)
;

/*
 Computes the volume of an ideal gas via handle-based FFI.

 Uses the ideal gas law V = nRT/P.

 # Arguments

 * `n` - Amount of substance (moles)
 * `t` - Absolute temperature T (Kelvin)
 * `p` - Pressure P (Pascals)

 # Returns

 The gas volume V (m³).
 */
rssn_
double rssn_num_physics_ideal_gas_volume(double aN,
                                         double aT,
                                         double aP)
;

/*
 Computes relativistic length contraction via handle-based FFI.

 The contracted length is L = L₀/γ, where γ is the Lorentz factor.

 # Arguments

 * `proper_length` - Proper length L₀ (m)
 * `velocity` - Relative velocity v (m/s)

 # Returns

 The contracted length L (m).
 */
rssn_
double rssn_num_physics_length_contraction(double aProperLength,
                                           double aVelocity)
;

/*
 Computes the Lorentz factor for relativistic transformations via handle-based FFI.

 The Lorentz factor is γ = 1 / √(1 - v²/c²).

 # Arguments

 * `velocity` - Velocity v (m/s)

 # Returns

 The Lorentz factor γ (dimensionless, ≥ 1).
 */
rssn_
double rssn_num_physics_lorentz_factor(double aVelocity)
;

/*
 Computes the Lorentz factor for relativistic time dilation and length contraction using bincode serialization.

 The Lorentz factor γ appears in special relativity transformations:
 γ = 1 / √(1 - v²/c²), where v is velocity and c is the speed of light.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `VelocityInput` with:
   - `velocity`: Velocity v (m/s, typically as a fraction of c)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The Lorentz factor γ (dimensionless, ≥ 1)
 - `err`: Error message if deserialization failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_physics_lorentz_factor_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Lorentz factor for relativistic transformations using JSON serialization.

 The Lorentz factor is γ = 1 / √(1 - v²/c²).

 # Arguments

 * `input` - A JSON string pointer containing:
   - `velocity`: Velocity v (m/s)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the Lorentz factor γ (dimensionless, ≥ 1).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_physics_lorentz_factor_json(const char *aInput)
;

/*
 Computes the Lorentz force on a charged particle in electromagnetic fields via handle-based FFI.

 The force is F = q(E + v × B), simplified for parallel fields.

 # Arguments

 * `charge` - Particle charge q (Coulombs)
 * `velocity` - Particle velocity v (m/s)
 * `e_field` - Electric field magnitude E (V/m)
 * `b_field` - Magnetic field magnitude B (Tesla)

 # Returns

 The Lorentz force magnitude F (Newtons).
 */
rssn_
double rssn_num_physics_lorentz_force(double aCharge,
                                      double aVelocity,
                                      double aEField,
                                      double aBField)
;

/*
 Computes the magnetic field magnitude around an infinite straight current-carrying wire via handle-based FFI.

 The magnetic field is B = (μ₀ I) / (2πr), where μ₀ is the permeability of free space.

 # Arguments

 * `current` - Electric current I (Amperes)
 * `r` - Perpendicular distance from wire r (m)

 # Returns

 The magnetic field magnitude B (Tesla).
 */
rssn_
double rssn_num_physics_magnetic_field_infinite_wire(double aCurrent,
                                                     double aR)
;

/*
 Computes rest mass energy using Einstein's mass-energy equivalence via handle-based FFI.

 The rest energy is E = mc².

 # Arguments

 * `mass` - Rest mass m (kg)

 # Returns

 The rest energy E (Joules).
 */
rssn_
double rssn_num_physics_mass_energy(double aMass)
;

/*
 Computes the rest mass energy using Einstein's mass-energy equivalence and bincode serialization.

 Einstein's mass-energy relation is one of the most famous equations in physics:
 E = mc², where m is rest mass and c is the speed of light (2.998×10⁸ m/s).

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `MassInput` with:
   - `mass`: Rest mass m (kg)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The rest energy E (Joules)
 - `err`: Error message if deserialization failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_physics_mass_energy_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes rest mass energy using Einstein's mass-energy equivalence and JSON serialization.

 The rest energy is E = mc².

 # Arguments

 * `input` - A JSON string pointer containing:
   - `mass`: Rest mass m (kg)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the rest energy E (Joules).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_physics_mass_energy_json(const char *aInput)
;

/*
 Computes the mean speed of particles in a Maxwell-Boltzmann distribution via handle-based FFI.

 The mean speed is ⟨v⟩ = √(8k_BT/(πm)).

 # Arguments

 * `mass` - Particle mass m (kg)
 * `temperature` - Absolute temperature T (Kelvin)

 # Returns

 The mean speed ⟨v⟩ (m/s).
 */
rssn_
double rssn_num_physics_maxwell_boltzmann_mean_speed(double aMass,
                                                     double aTemperature)
;

/*
 Computes the mean speed of particles in a Maxwell-Boltzmann distribution using JSON serialization.

 The mean speed is ⟨v⟩ = √(8k_BT/(πm)).

 # Arguments

 * `input` - A JSON string pointer containing:
   - `mass`: Particle mass m (kg)
   - `temperature`: Absolute temperature T (Kelvin)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the mean speed ⟨v⟩ (m/s).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_physics_maxwell_boltzmann_mean_speed_json(const char *aInput)
;

/*
 Computes the root-mean-square speed of particles in a Maxwell-Boltzmann distribution via handle-based FFI.

 The RMS speed is v_rms = √(3k_BT/m).

 # Arguments

 * `mass` - Particle mass m (kg)
 * `temperature` - Absolute temperature T (Kelvin)

 # Returns

 The RMS speed v_rms (m/s).
 */
rssn_
double rssn_num_physics_maxwell_boltzmann_rms_speed(double aMass,
                                                    double aTemperature)
;

/*
 Computes the Maxwell-Boltzmann speed distribution probability density via handle-based FFI.

 The distribution is f(v) = 4π(m/(2πk_BT))³¹² v² exp(-mv²/(2k_BT)).

 # Arguments

 * `v` - Particle speed v (m/s)
 * `mass` - Particle mass m (kg)
 * `temperature` - Absolute temperature T (Kelvin)

 # Returns

 The probability density f(v) (s/m).
 */
rssn_
double rssn_num_physics_maxwell_boltzmann_speed_distribution(double aV,
                                                             double aMass,
                                                             double aTemperature)
;

/*
 Computes the energy of a photon from its wavelength via handle-based FFI.

 The energy is E = hc/λ.

 # Arguments

 * `wavelength` - Photon wavelength λ (meters)

 # Returns

 The photon energy E (Joules).
 */
rssn_
double rssn_num_physics_photon_energy(double aWavelength)
;

/*
 Computes the energy of a photon from its wavelength using JSON serialization.

 The energy is E = hc/λ.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `wavelength`: Photon wavelength λ (meters)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the photon energy E (Joules).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_physics_photon_energy_json(const char *aInput)
;

/*
 Computes the wavelength of a photon from its energy via handle-based FFI.

 The wavelength is λ = hc/E.

 # Arguments

 * `energy` - Photon energy E (Joules)

 # Returns

 The photon wavelength λ (meters).
 */
rssn_
double rssn_num_physics_photon_wavelength(double aEnergy)
;

/*
 Computes the wavelength of a photon from its energy using JSON serialization.

 The wavelength is λ = hc/E.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `energy`: Photon energy E (Joules)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the photon wavelength λ (meters).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_physics_photon_wavelength_json(const char *aInput)
;

/*
 Returns Planck's constant h via handle-based FFI.

 # Returns

 Planck's constant h = 6.626 × 10⁻³⁴ J·s.
 */
rssn_
double rssn_num_physics_planck_constant(void)
;

/*
 Computes the energy eigenvalue of a quantum harmonic oscillator via handle-based FFI.

 The energy is E_n = ℏω(n + 1/2), where ℏ is the reduced Planck constant.

 # Arguments

 * `n` - Quantum number n (non-negative integer, ground state = 0)
 * `omega` - Angular frequency ω (rad/s)

 # Returns

 The energy eigenvalue E_n (Joules).
 */
rssn_
double rssn_num_physics_quantum_harmonic_oscillator_energy(uint64_t aN,
                                                           double aOmega)
;

/*
 Computes the energy eigenvalue of a quantum harmonic oscillator using bincode serialization.

 The quantum harmonic oscillator has discrete energy levels given by:
 E_n = ℏω(n + 1/2), where n is the quantum number, ℏ is the reduced Planck constant,
 and ω is the angular frequency.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `QuantumHarmonicInput` with:
   - `n`: Quantum number n (non-negative integer, ground state = 0)
   - `omega`: Angular frequency ω (rad/s)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The energy eigenvalue E_n (Joules)
 - `err`: Error message if deserialization failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_physics_quantum_harmonic_oscillator_energy_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the energy eigenvalue of a quantum harmonic oscillator using JSON serialization.

 The energy is E_n = ℏω(n + 1/2), where ℏ is the reduced Planck constant.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `n`: Quantum number n (non-negative integer, ground state = 0)
   - `omega`: Angular frequency ω (rad/s)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the energy eigenvalue E_n (Joules).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_physics_quantum_harmonic_oscillator_energy_json(const char *aInput)
;

/*
 Computes relativistic kinetic energy via handle-based FFI.

 The kinetic energy is K = (γ - 1)mc².

 # Arguments

 * `mass` - Rest mass m (kg)
 * `velocity` - Velocity v (m/s)

 # Returns

 The kinetic energy K (Joules).
 */
rssn_
double rssn_num_physics_relativistic_kinetic_energy(double aMass,
                                                    double aVelocity)
;

/*
 Computes relativistic momentum via handle-based FFI.

 The momentum is p = γmv, where γ is the Lorentz factor.

 # Arguments

 * `mass` - Rest mass m (kg)
 * `velocity` - Velocity v (m/s)

 # Returns

 The relativistic momentum p (kg·m/s).
 */
rssn_
double rssn_num_physics_relativistic_momentum(double aMass,
                                              double aVelocity)
;

/*
 Computes relativistic velocity addition via handle-based FFI.

 The combined velocity is u = (v + w) / (1 + vw/c²).

 # Arguments

 * `v` - First velocity (m/s)
 * `w` - Second velocity (m/s)

 # Returns

 The combined velocity u (m/s).
 */
rssn_
double rssn_num_physics_relativistic_velocity_addition(double aV,
                                                       double aW)
;

/*
 Computes relativistic velocity addition using JSON serialization.

 The combined velocity is u = (v + w) / (1 + vw/c²).

 # Arguments

 * `input` - A JSON string pointer containing:
   - `v`: First velocity (m/s)
   - `w`: Second velocity (m/s)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the combined velocity u (m/s).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_physics_relativistic_velocity_addition_json(const char *aInput)
;

/*
 Computes the displacement of a simple harmonic oscillator via handle-based FFI.

 The displacement is given by x(t) = A cos(ωt + φ).

 # Arguments

 * `amplitude` - Oscillation amplitude A (m)
 * `omega` - Angular frequency ω (rad/s)
 * `phase` - Phase angle φ (radians)
 * `time` - Time t at which to evaluate displacement (s)

 # Returns

 The displacement x(t) (m).
 */
rssn_
double rssn_num_physics_simple_harmonic_oscillator(double aAmplitude,
                                                   double aOmega,
                                                   double aPhase,
                                                   double aTime)
;

/*
 Computes the displacement of a simple harmonic oscillator using bincode serialization.

 The simple harmonic oscillator describes oscillatory motion with displacement:
 x(t) = A cos(ωt + φ), where A is amplitude, ω is angular frequency, and φ is phase.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `HarmonicOscillatorInput` with:
   - `amplitude`: Oscillation amplitude A (m)
   - `omega`: Angular frequency ω (rad/s)
   - `phase`: Phase angle φ (radians)
   - `time`: Time t at which to evaluate displacement (s)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The displacement x(t) (m)
 - `err`: Error message if deserialization failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_physics_simple_harmonic_oscillator_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the displacement of a simple harmonic oscillator using JSON serialization.

 The displacement is x(t) = A cos(ωt + φ).

 # Arguments

 * `input` - A JSON string pointer containing:
   - `amplitude`: Oscillation amplitude A (m)
   - `omega`: Angular frequency ω (rad/s)
   - `phase`: Phase angle φ (radians)
   - `time`: Time t at which to evaluate displacement (s)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the displacement x(t) (m).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_physics_simple_harmonic_oscillator_json(const char *aInput)
;

/*
 Returns the speed of light constant c via handle-based FFI.

 # Returns

 The speed of light c = 2.998 × 10⁸ m/s.
 */
rssn_
double rssn_num_physics_speed_of_light(void)
;

/*
 Computes relativistic time dilation via handle-based FFI.

 The dilated time is t = γt₀, where γ is the Lorentz factor.

 # Arguments

 * `proper_time` - Proper time t₀ (s)
 * `velocity` - Relative velocity v (m/s)

 # Returns

 The dilated time t (s).
 */
rssn_
double rssn_num_physics_time_dilation(double aProperTime,
                                      double aVelocity)
;

/*
 Computes relativistic time dilation using JSON serialization.

 The dilated time is t = γt₀, where γ is the Lorentz factor.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `proper_time`: Proper time t₀ (s)
   - `velocity`: Relative velocity v (m/s)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the dilated time t (s).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_physics_time_dilation_json(const char *aInput)
;

/*
 Computes the peak wavelength of blackbody radiation using Wien's displacement law via handle-based FFI.

 Wien's law states λ_max = b/T, where b = 2.898 × 10⁻³ m·K.

 # Arguments

 * `temperature` - Absolute temperature T (Kelvin)

 # Returns

 The peak wavelength λ_max (meters).
 */
rssn_
double rssn_num_physics_wien_displacement_wavelength(double aTemperature)
;

/*
 Computes the peak wavelength of blackbody radiation using Wien's displacement law and JSON serialization.

 Wien's law states λ_max = b/T, where b = 2.898 × 10⁻³ m·K.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `temperature`: Absolute temperature T (Kelvin)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the peak wavelength λ_max (meters).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_physics_wien_displacement_wavelength_json(const char *aInput)
;

/*
 Adds two polynomials.
 */
rssn_
struct rssn_Polynomial *rssn_num_poly_add(const struct rssn_Polynomial *aA,
                                          const struct rssn_Polynomial *aB)
;

/*
 Adds two polynomials via Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_poly_add_bincode(const uint8_t *aData,
                                                    size_t aLen)
;

/*
 Adds two polynomials from JSON.
 */
rssn_
char *rssn_num_poly_add_json(const char *aJsonPtr)
;

/*
 Creates a new polynomial from coefficients.
 */
rssn_
struct rssn_Polynomial *rssn_num_poly_create(const double *aCoeffs,
                                             size_t aLen)
;

/*
 Returns the degree of a polynomial.
 */
rssn_
size_t rssn_num_poly_degree(const struct rssn_Polynomial *aPoly)
;

/*
 Computes the derivative.
 */
rssn_
struct rssn_Polynomial *rssn_num_poly_derivative(const struct rssn_Polynomial *aPoly)
;

/*
 Evaluates a polynomial at x.
 */
rssn_
double rssn_num_poly_eval(const struct rssn_Polynomial *aPoly,
                          double aX)
;

/*
 Frees a polynomial object.
 */
rssn_
void rssn_num_poly_free(struct rssn_Polynomial *aPoly)
;

/*
 Computes the integral.
 */
rssn_
struct rssn_Polynomial *rssn_num_poly_integral(const struct rssn_Polynomial *aPoly)
;

/*
 Multiplies two polynomials.
 */
rssn_
struct rssn_Polynomial *rssn_num_poly_mul(const struct rssn_Polynomial *aA,
                                          const struct rssn_Polynomial *aB)
;

/*
 Multiplies two polynomials from JSON.
 */
rssn_
char *rssn_num_poly_mul_json(const char *aJsonPtr)
;

/*
 Subtracts two polynomials.
 */
rssn_
struct rssn_Polynomial *rssn_num_poly_sub(const struct rssn_Polynomial *aA,
                                          const struct rssn_Polynomial *aB)
;

/*
 Computes the absolute value of a f64 value.
 */
rssn_
double rssn_num_pure_abs(double aX)
;

/*
 Computes the arccosine of a f64 value.
 */
rssn_
double rssn_num_pure_acos(double aX)
;

/*
 Computes the arcsine of a f64 value.
 */
rssn_
double rssn_num_pure_asin(double aX)
;

/*
 Computes the arctangent of a f64 value.
 */
rssn_
double rssn_num_pure_atan(double aX)
;

/*
 Computes the arctangent of y/x using the signs of the arguments to determine the correct quadrant.
 */
rssn_
double rssn_num_pure_atan2(double aY,
                           double aX)
;

/*
 Computes the cosine of a f64 value.
 */
rssn_
double rssn_num_pure_cos(double aX)
;

/*
 Computes the hyperbolic cosine of a f64 value.
 */
rssn_
double rssn_num_pure_cosh(double aX)
;

/*
 Computes e raised to the power of a f64 value.
 */
rssn_
double rssn_num_pure_exp(double aX)
;

/*
 Computes the natural logarithm of a f64 value.
 */
rssn_
double rssn_num_pure_ln(double aX)
;

/*
 Computes `base` raised to the power of `exp`.
 */
rssn_
double rssn_num_pure_pow(double aBase,
                         double aExp)
;

/*
 Pure numerical functions exposed via FFI.
 Computes the sine of a f64 value.
 */
rssn_
double rssn_num_pure_sin(double aX)
;

/*
 Computes the hyperbolic sine of a f64 value.
 */
rssn_
double rssn_num_pure_sinh(double aX)
;

/*
 Computes the square root of a f64 value.
 */
rssn_
double rssn_num_pure_sqrt(double aX)
;

/*
 Computes the tangent of a f64 value.
 */
rssn_
double rssn_num_pure_tan(double aX)
;

/*
 Computes the hyperbolic tangent of a f64 value.
 */
rssn_
double rssn_num_pure_tanh(double aX)
;

/*
 Computes the convolution of two sequences.
 */
rssn_
struct rssn_Matrix_f64 *rssn_num_signal_convolve(const double *aA,
                                                 size_t aALen,
                                                 const double *aV,
                                                 size_t aVLen)
;

/*
 Computes the discrete convolution of two signals using bincode serialization.

 The convolution is defined as (a * v)[n] = Σ a[k]v[n-k], representing the
 combined effect of two systems or filtering operation.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `ConvolveInput` with:
   - `a`: First signal array
   - `v`: Second signal array (kernel)

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<f64>, String>` with
 the convolution result.

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_signal_convolve_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the discrete convolution of two signals using JSON serialization.

 The convolution is defined as (a * v)[n] = Σ a[k]v[n-k], representing the
 combined effect of two systems or filtering operation.

 # Arguments

 * `input_json` - A JSON string pointer containing:
   - `a`: First signal array
   - `v`: Second signal array (kernel)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the convolution result.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_signal_convolve_json(const char *aInputJson)
;

/*
 Computes the cross-correlation of two sequences.
 */
rssn_
struct rssn_Matrix_f64 *rssn_num_signal_cross_correlation(const double *aA,
                                                          size_t aALen,
                                                          const double *aV,
                                                          size_t aVLen)
;

/*
 Computes the cross-correlation of two signals using bincode serialization.

 Cross-correlation measures similarity between signals as a function of lag:
 (a ⋆ v)[n] = Σ a[k]v[n+k].

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `ConvolveInput` with:
   - `a`: First signal array
   - `v`: Second signal array

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<f64>, String>` with
 the cross-correlation result.

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_signal_cross_correlation_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the cross-correlation of two signals using JSON serialization.

 Cross-correlation measures similarity between signals as a function of lag:
 (a ⋆ v)[n] = Σ a[k]v[n+k].

 # Arguments

 * `input_json` - A JSON string pointer containing:
   - `a`: First signal array
   - `v`: Second signal array

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the cross-correlation result.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_signal_cross_correlation_json(const char *aInputJson)
;

/*
 Computes the FFT and returns a Matrix<Complex<f64>> as a Matrix<f64> (real, imag interleaved).
 */
rssn_
struct rssn_Matrix_f64 *rssn_num_signal_fft(const double *aReal,
                                            const double *aImag,
                                            size_t aLen)
;

/*
 Computes the Fast Fourier Transform (FFT) of complex data using bincode serialization.

 The FFT converts a signal from time/space domain to frequency domain using the
 Cooley-Tukey algorithm in O(N log N) time.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `FftInput` with:
   - `data`: Array of complex numbers to transform

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<Complex<f64>>, String>` with
 the frequency domain representation.

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_signal_fft_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Fast Fourier Transform (FFT) of complex data using JSON serialization.

 The FFT converts a signal from time/space domain to frequency domain using the
 Cooley-Tukey algorithm in O(N log N) time.

 # Arguments

 * `input_json` - A JSON string pointer containing:
   - `data`: Array of complex numbers to transform

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<Complex<f64>>, String>` with
 the frequency domain representation.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_signal_fft_json(const char *aInputJson)
;

/*
 Generates a Hamming window.
 */
rssn_
struct rssn_Matrix_f64 *rssn_num_signal_hamming_window(size_t aN)
;

/*
 Generates a Hann window.
 */
rssn_
struct rssn_Matrix_f64 *rssn_num_signal_hann_window(size_t aN)
;

/*
 Frees a `LinearSolution` object.
 */
rssn_
void rssn_num_solve_free_solution(struct rssn_LinearSolution *aPtr)
;

/*
 Gets the data of a unique solution.

 # Arguments
 * `ptr` - Pointer to the `LinearSolution`.
 * `buffer` - Buffer to store the solution vector.
 */
rssn_
void rssn_num_solve_get_unique_solution(const struct rssn_LinearSolution *aPtr,
                                        double *aBuffer)
;

/*
 Gets the length of the unique solution vector.
 */
rssn_
size_t rssn_num_solve_get_unique_solution_len(const struct rssn_LinearSolution *aPtr)
;

/*
 Checks if there is no solution.
 */
rssn_
bool rssn_num_solve_is_no_solution(const struct rssn_LinearSolution *aPtr)
;

/*
 Checks if the solution is unique.
 */
rssn_
bool rssn_num_solve_is_unique(const struct rssn_LinearSolution *aPtr)
;

/*
 Solves a linear system Ax = b.

 # Arguments
 * `matrix_ptr` - Pointer to the coefficient matrix A.
 * `vector_data` - Pointer to the constant vector b.
 * `vector_len` - Length of the vector b.

 # Returns
 A pointer to a `LinearSolution` object, or null on error.
 */
rssn_
struct rssn_LinearSolution *rssn_num_solve_linear_system_handle(const struct rssn_Matrix_f64 *aMatrixPtr,
                                                                const double *aVectorData,
                                                                size_t aVectorLen)
;

/*
 Creates a new sparse CSR matrix from dimensions and triplet data.

 # Arguments
 * `rows` - Number of rows.
 * `cols` - Number of columns.
 * `row_indices` - Array of row indices.
 * `col_indices` - Array of column indices.
 * `values` - Array of values.
 * `nnz` - Number of non-zero elements (length of the input arrays).

 # Returns
 A raw pointer to the CsMat object, or null on error.
 */
rssn_
rssn_CsMat<double> *rssn_num_sparse_create(size_t aRows,
                                           size_t aCols,
                                           const size_t *aRowIndices,
                                           const size_t *aColIndices,
                                           const double *aValues,
                                           size_t aNnz)
;

/*
 Frees a sparse matrix object.
 */
rssn_
void rssn_num_sparse_free(rssn_CsMat<double> *aMatrix)
;

/*
 Computes the Frobenius norm.
 */
rssn_
double rssn_num_sparse_frobenius_norm(const rssn_CsMat<double> *aMatrix)
;

/*
 Returns the number of columns.
 */
rssn_
size_t rssn_num_sparse_get_cols(const rssn_CsMat<double> *aMatrix)
;

/*
 Returns the number of non-zero elements.
 */
rssn_
size_t rssn_num_sparse_get_nnz(const rssn_CsMat<double> *aMatrix)
;

/*
 Returns the number of rows.
 */
rssn_
size_t rssn_num_sparse_get_rows(const rssn_CsMat<double> *aMatrix)
;

/*
 Solves the linear system Ax = b using the Conjugate Gradient iterative method via JSON.

 The Conjugate Gradient method is efficient for large sparse symmetric positive-definite matrices,
 converging in at most N iterations (typically much fewer).

 # Arguments

 * `json_ptr` - A JSON string pointer containing:
   - `a`: Sparse matrix A in CSR/COO format
   - `b`: Right-hand side vector b
   - `x0`: Optional initial guess for solution vector
   - `max_iter`: Maximum number of iterations
   - `tolerance`: Convergence tolerance for residual norm

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the solution vector x.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_sparse_solve_cg_json(const char *aJsonPtr)
;

/*
 Sparse matrix-vector multiplication.

 result = matrix * vector
 */
rssn_
int32_t rssn_num_sparse_spmv(const rssn_CsMat<double> *aMatrix,
                             const double *aVector,
                             size_t aVecLen,
                             double *aResult)
;

/*
 Sparse matrix-vector multiplication via Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_sparse_spmv_bincode(const uint8_t *aData,
                                                       size_t aLen)
;

/*
 Sparse matrix-vector multiplication from JSON.
 */
rssn_
char *rssn_num_sparse_spmv_json(const char *aJsonPtr)
;

/*
 Computes the trace.
 */
rssn_
int32_t rssn_num_sparse_trace(const rssn_CsMat<double> *aMatrix,
                              double *aOutTrace)
;

/*
 Computes the modified Bessel function of the first kind of order zero I₀(x) via handle-based FFI.

 Solution to the modified Bessel equation for ν = 0.

 # Arguments

 * `x` - Argument of the modified Bessel function

 # Returns

 The value I₀(x).
 */
rssn_
double rssn_num_special_bessel_i0(double aX)
;

/*
 Computes the modified Bessel function of the first kind of order one I₁(x) via handle-based FFI.

 Solution to the modified Bessel equation for ν = 1.

 # Arguments

 * `x` - Argument of the modified Bessel function

 # Returns

 The value I₁(x).
 */
rssn_
double rssn_num_special_bessel_i1(double aX)
;

/*
 Computes the Bessel function of the first kind of order zero J₀(x) via handle-based FFI.

 Solution to Bessel's differential equation for ν = 0.

 # Arguments

 * `x` - Argument of the Bessel function

 # Returns

 The value J₀(x).
 */
rssn_
double rssn_num_special_bessel_j0(double aX)
;

/*
 Computes the Bessel function of the first kind of order zero J₀(x) using bincode serialization.

 The Bessel function J₀(x) is a solution to Bessel's differential equation for ν = 0:
 x²y'' + xy' + x²y = 0. It appears in problems with cylindrical symmetry.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `SingleInput` with:
   - `x`: Argument of the Bessel function

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The value J₀(x)
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_special_bessel_j0_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Bessel function of the first kind of order zero J₀(x) via JSON serialization.

 Solution to Bessel's differential equation for ν = 0.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `x`: Argument of the Bessel function

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the value J₀(x).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_special_bessel_j0_json(const char *aInput)
;

/*
 Computes the Bessel function of the first kind of order one J₁(x) via handle-based FFI.

 Solution to Bessel's differential equation for ν = 1.

 # Arguments

 * `x` - Argument of the Bessel function

 # Returns

 The value J₁(x).
 */
rssn_
double rssn_num_special_bessel_j1(double aX)
;

/*
 Computes the Bessel function of the first kind of order one J₁(x) using bincode serialization.

 The Bessel function J₁(x) is a solution to Bessel's differential equation for ν = 1:
 x²y'' + xy' + (x² - 1)y = 0. It appears in wave propagation and vibration problems.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `SingleInput` with:
   - `x`: Argument of the Bessel function

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The value J₁(x)
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_special_bessel_j1_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Bessel function of the first kind of order one J₁(x) via JSON serialization.

 Solution to Bessel's differential equation for ν = 1.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `x`: Argument of the Bessel function

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the value J₁(x).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_special_bessel_j1_json(const char *aInput)
;

/*
 Computes the Bessel function of the second kind of order zero Y₀(x) via handle-based FFI.

 Also known as the Neumann function or Weber function.

 # Arguments

 * `x` - Argument of the Bessel function (must be positive)

 # Returns

 The value Y₀(x).
 */
rssn_
double rssn_num_special_bessel_y0(double aX)
;

/*
 Computes the Bessel function of the second kind of order one Y₁(x) via handle-based FFI.

 Also known as the Neumann function or Weber function.

 # Arguments

 * `x` - Argument of the Bessel function (must be positive)

 # Returns

 The value Y₁(x).
 */
rssn_
double rssn_num_special_bessel_y1(double aX)
;

/*
 Computes the Beta function B(a, b) = Γ(a)Γ(b) / Γ(a+b) via handle-based FFI.

 # Arguments

 * `a` - First shape parameter (must be positive)
 * `b` - Second shape parameter (must be positive)

 # Returns

 The value B(a, b).
 */
rssn_
double rssn_num_special_beta(double aA,
                             double aB)
;

/*
 Computes the Beta function B(a, b) using bincode serialization.

 The Beta function is defined as B(a, b) = ∫₀^1 t^(a-1) (1-t)^(b-1) dt,
 which can be expressed in terms of Gamma functions: B(a, b) = Γ(a)Γ(b) / Γ(a+b).

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `TwoInput` with:
   - `a`: First shape parameter (must be positive)
   - `b`: Second shape parameter (must be positive)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The value B(a, b)
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_special_beta_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Beta function B(a, b) = Γ(a)Γ(b) / Γ(a+b) via JSON serialization.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `a`: First shape parameter (must be positive)
   - `b`: Second shape parameter (must be positive)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the value B(a, b).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_special_beta_json(const char *aInput)
;

/*
 Computes the binomial coefficient C(n, k) via handle-based FFI.

 The number of ways to choose k items from n items.

 # Arguments

 * `n` - Total number of items (non-negative integer)
 * `k` - Number of items to choose (0 ≤ k ≤ n)

 # Returns

 The value C(n, k) (as f64).
 */
rssn_
double rssn_num_special_binomial(uint64_t aN,
                                 uint64_t aK)
;

/*
 Computes the binomial coefficient C(n, k) = n! / (k!(n-k)!) using bincode serialization.

 The binomial coefficient represents the number of ways to choose k items from n items
 without regard to order. Also appears as coefficients in the binomial expansion.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `BinomialInput` with:
   - `n`: Total number of items (non-negative integer)
   - `k`: Number of items to choose (0 ≤ k ≤ n)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The value C(n, k) (as f64)
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_special_binomial_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the binomial coefficient C(n, k) via JSON serialization.

 The number of ways to choose k items from n items.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `n`: Total number of items (non-negative integer)
   - `k`: Number of items to choose (0 ≤ k ≤ n)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the value C(n, k) (as f64).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_special_binomial_json(const char *aInput)
;

/*
 Computes the Chebyshev polynomial of the first kind Tₙ(x) via handle-based FFI.

 Satisfies Tₙ(cos θ) = cos(nθ), minimizes polynomial interpolation error.

 # Arguments

 * `n` - Polynomial degree (non-negative integer)
 * `x` - Evaluation point (typically in [-1, 1])

 # Returns

 The value Tₙ(x).
 */
rssn_
double rssn_num_special_chebyshev_t(uint32_t aN,
                                    double aX)
;

/*
 Computes the Chebyshev polynomial of the first kind Tₙ(x) using bincode serialization.

 The Chebyshev polynomials satisfy Tₙ(cos θ) = cos(nθ) and are orthogonal on [-1, 1]
 with weight function 1/√(1-x²). They minimize polynomial interpolation error.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `PolyInput` with:
   - `n`: Polynomial degree (non-negative integer)
   - `x`: Evaluation point (typically in [-1, 1])

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The value Tₙ(x)
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_special_chebyshev_t_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Chebyshev polynomial of the first kind Tₙ(x) via JSON serialization.

 Satisfies Tₙ(cos θ) = cos(nθ), minimizes polynomial interpolation error.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `n`: Polynomial degree (non-negative integer)
   - `x`: Evaluation point (typically in [-1, 1])

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the value Tₙ(x).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_special_chebyshev_t_json(const char *aInput)
;

/*
 Computes the Chebyshev polynomial of the second kind Uₙ(x) via handle-based FFI.

 Satisfies Uₙ(cos θ) = sin((n+1)θ) / sin(θ).

 # Arguments

 * `n` - Polynomial degree (non-negative integer)
 * `x` - Evaluation point (typically in [-1, 1])

 # Returns

 The value Uₙ(x).
 */
rssn_
double rssn_num_special_chebyshev_u(uint32_t aN,
                                    double aX)
;

/*
 Computes the Digamma function ψ(x) = d/dx[ln(Γ(x))] via handle-based FFI.

 The logarithmic derivative of the Gamma function.

 # Arguments

 * `x` - Argument of the Digamma function

 # Returns

 The value ψ(x).
 */
rssn_
double rssn_num_special_digamma(double aX)
;

/*
 Computes the Digamma function ψ(x) using bincode serialization.

 The Digamma function is the logarithmic derivative of the Gamma function:
 ψ(x) = d/dx[ln(Γ(x))] = Γ'(x) / Γ(x).

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `SingleInput` with:
   - `x`: Argument of the Digamma function

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The value ψ(x)
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_special_digamma_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Digamma function ψ(x) = d/dx[ln(Γ(x))] via JSON serialization.

 The logarithmic derivative of the Gamma function.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `x`: Argument of the Digamma function

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the value ψ(x).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_special_digamma_json(const char *aInput)
;

/*
 Computes the double factorial n!! via handle-based FFI.

 Defined as n!! = n × (n-2) × (n-4) × ... (down to 1 or 2).

 # Arguments

 * `n` - Non-negative integer

 # Returns

 The value n!! (as f64).
 */
rssn_
double rssn_num_special_double_factorial(uint64_t aN)
;

/*
 Computes the error function erf(x) via handle-based FFI.

 Defined as erf(x) = (2/√π) ∫₀^x e^(-t²) dt.

 # Arguments

 * `x` - Argument of the error function

 # Returns

 The value erf(x) ∈ [-1, 1].
 */
rssn_
double rssn_num_special_erf(double aX)
;

/*
 Computes the error function erf(x) using bincode serialization.

 The error function is defined as erf(x) = (2/√π) ∫₀^x e^(-t²) dt.
 It represents the probability that a random variable from a standard normal distribution
 falls within [-x, x].

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `SingleInput` with:
   - `x`: Argument of the error function

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The value erf(x) (range: [-1, 1])
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_special_erf_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the error function erf(x) via JSON serialization.

 Defined as erf(x) = (2/√π) ∫₀^x e^(-t²) dt.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `x`: Argument of the error function

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the value erf(x) ∈ [-1, 1].

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_special_erf_json(const char *aInput)
;

/*
 Computes the complementary error function erfc(x) = 1 - erf(x) via handle-based FFI.

 More accurate than 1 - erf(x) for large positive x.

 # Arguments

 * `x` - Argument of the complementary error function

 # Returns

 The value erfc(x) ∈ [0, 2].
 */
rssn_
double rssn_num_special_erfc(double aX)
;

/*
 Computes the complementary error function erfc(x) using bincode serialization.

 The complementary error function is defined as erfc(x) = 1 - erf(x) = (2/√π) ∫ₓ^∞ e^(-t²) dt.
 It is more accurate than computing 1 - erf(x) for large positive x.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `SingleInput` with:
   - `x`: Argument of the complementary error function

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The value erfc(x) (range: [0, 2])
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_special_erfc_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the complementary error function erfc(x) = 1 - erf(x) via JSON serialization.

 More accurate than 1 - erf(x) for large positive x.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `x`: Argument of the complementary error function

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the value erfc(x) ∈ [0, 2].

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_special_erfc_json(const char *aInput)
;

/*
 Computes the factorial n! via handle-based FFI.

 For large n, computed using the Gamma function.

 # Arguments

 * `n` - Non-negative integer

 # Returns

 The value n! (as f64).
 */
rssn_
double rssn_num_special_factorial(uint64_t aN)
;

/*
 Computes the factorial n! using bincode serialization.

 The factorial is defined as n! = n × (n-1) × ... × 2 × 1 for n ≥ 1, with 0! = 1.
 For large n, the result is computed using the Gamma function to avoid overflow.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `IntInput` with:
   - `n`: Non-negative integer

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The value n! (as f64)
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_special_factorial_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the factorial n! via JSON serialization.

 For large n, computed using the Gamma function.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `n`: Non-negative integer

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the value n! (as f64).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_special_factorial_json(const char *aInput)
;

/*
 Computes the Gamma function Γ(x) via handle-based FFI.

 The Gamma function extends the factorial to real and complex numbers: Γ(n) = (n-1)!.

 # Arguments

 * `x` - Argument of the Gamma function (must be positive)

 # Returns

 The value Γ(x).
 */
rssn_
double rssn_num_special_gamma(double aX)
;

/*
 Computes the Gamma function Γ(x) using bincode serialization.

 The Gamma function is defined as Γ(x) = ∫₀^∞ t^(x-1) e^(-t) dt for x > 0,
 generalizing the factorial function to real and complex numbers: Γ(n) = (n-1)!.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `SingleInput` with:
   - `x`: Argument of the Gamma function (must be positive)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The value Γ(x)
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_special_gamma_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Gamma function Γ(x) via JSON serialization.

 The Gamma function extends the factorial to real and complex numbers: Γ(n) = (n-1)!.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `x`: Argument of the Gamma function (must be positive)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the value Γ(x).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_special_gamma_json(const char *aInput)
;

/*
 Computes the Hermite polynomial Hₙ(x) via handle-based FFI.

 Orthogonal with weight e^(-x²), appears in quantum harmonic oscillator wavefunctions.

 # Arguments

 * `n` - Polynomial degree (non-negative integer)
 * `x` - Evaluation point

 # Returns

 The value Hₙ(x).
 */
rssn_
double rssn_num_special_hermite_h(uint32_t aN,
                                  double aX)
;

/*
 Computes the Hermite polynomial Hₙ(x) using bincode serialization.

 The Hermite polynomials (physicists' version) are orthogonal on (-∞, ∞) with weight
 function e^(-x²). They appear in quantum harmonic oscillator wavefunctions and
 probability theory.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `PolyInput` with:
   - `n`: Polynomial degree (non-negative integer)
   - `x`: Evaluation point

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The value Hₙ(x)
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_special_hermite_h_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Hermite polynomial Hₙ(x) via JSON serialization.

 Orthogonal with weight e^(-x²), appears in quantum harmonic oscillator wavefunctions.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `n`: Polynomial degree (non-negative integer)
   - `x`: Evaluation point

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the value Hₙ(x).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_special_hermite_h_json(const char *aInput)
;

/*
 Computes the inverse error function erf⁻¹(x) via handle-based FFI.

 Finds y such that erf(y) = x.

 # Arguments

 * `x` - Value in the range (-1, 1)

 # Returns

 The value y such that erf(y) = x.
 */
rssn_
double rssn_num_special_inverse_erf(double aX)
;

/*
 Computes the Laguerre polynomial Lₙ(x) via handle-based FFI.

 Orthogonal with weight e^(-x) on [0, ∞), appears in quantum mechanics (hydrogen atom).

 # Arguments

 * `n` - Polynomial degree (non-negative integer)
 * `x` - Evaluation point (typically ≥ 0)

 # Returns

 The value Lₙ(x).
 */
rssn_
double rssn_num_special_laguerre_l(uint32_t aN,
                                   double aX)
;

/*
 Computes the Legendre polynomial Pₙ(x) via handle-based FFI.

 Orthogonal on [-1, 1], used in multipole expansions and spherical harmonics.

 # Arguments

 * `n` - Polynomial degree (non-negative integer)
 * `x` - Evaluation point (typically in [-1, 1])

 # Returns

 The value Pₙ(x).
 */
rssn_
double rssn_num_special_legendre_p(uint32_t aN,
                                   double aX)
;

/*
 Computes the Legendre polynomial Pₙ(x) using bincode serialization.

 The Legendre polynomials are solutions to Legendre's differential equation:
 (1 - x²)y'' - 2xy' + n(n+1)y = 0. They are orthogonal on [-1, 1] and appear
 in multipole expansions and spherical harmonics.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `PolyInput` with:
   - `n`: Polynomial degree (non-negative integer)
   - `x`: Evaluation point (typically in [-1, 1])

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The value Pₙ(x)
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_special_legendre_p_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Legendre polynomial Pₙ(x) via JSON serialization.

 Orthogonal on [-1, 1], used in multipole expansions and spherical harmonics.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `n`: Polynomial degree (non-negative integer)
   - `x`: Evaluation point (typically in [-1, 1])

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the value Pₙ(x).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_special_legendre_p_json(const char *aInput)
;

/*
 Computes the natural logarithm of the Beta function ln(B(a, b)) via handle-based FFI.

 More numerically stable than ln(beta(a, b)) for large parameters.

 # Arguments

 * `a` - First shape parameter (must be positive)
 * `b` - Second shape parameter (must be positive)

 # Returns

 The value ln(B(a, b)).
 */
rssn_
double rssn_num_special_ln_beta(double aA,
                                double aB)
;

/*
 Computes the natural logarithm of the Gamma function ln(Γ(x)) via handle-based FFI.

 More numerically stable than ln(gamma(x)) for large x.

 # Arguments

 * `x` - Argument of the log-gamma function

 # Returns

 The value ln(Γ(x)).
 */
rssn_
double rssn_num_special_ln_gamma(double aX)
;

/*
 Computes the natural logarithm of the Gamma function ln(Γ(x)) using bincode serialization.

 This function is more numerically stable than computing ln(Γ(x)) = ln(gamma(x)),
 especially for large values of x where Γ(x) would overflow.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `SingleInput` with:
   - `x`: Argument of the log-gamma function

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The value ln(Γ(x))
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_special_ln_gamma_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the natural logarithm of the Gamma function ln(Γ(x)) via JSON serialization.

 More numerically stable than ln(gamma(x)) for large x.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `x`: Argument of the log-gamma function

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the value ln(Γ(x)).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_special_ln_gamma_json(const char *aInput)
;

/*
 Computes the logit function logit(p) = ln(p / (1 - p)) via handle-based FFI.

 The inverse of the sigmoid function, maps (0, 1) to ℝ.

 # Arguments

 * `p` - Probability value in the range (0, 1)

 # Returns

 The value logit(p).
 */
rssn_
double rssn_num_special_logit(double aP)
;

/*
 Computes the lower incomplete Gamma function γ(s, x) via handle-based FFI.

 Defined as γ(s, x) = ∫₀^x t^(s-1) e^(-t) dt.

 # Arguments

 * `s` - Shape parameter
 * `x` - Upper limit of integration

 # Returns

 The value γ(s, x).
 */
rssn_
double rssn_num_special_lower_incomplete_gamma(double aS,
                                               double aX)
;

/*
 Computes the regularized incomplete Beta function I(x; a, b) via handle-based FFI.

 The cumulative distribution function of the Beta distribution.

 # Arguments

 * `x` - Upper limit of integration (0 ≤ x ≤ 1)
 * `a` - First shape parameter (must be positive)
 * `b` - Second shape parameter (must be positive)

 # Returns

 The value I(x; a, b) ∈ [0, 1].
 */
rssn_
double rssn_num_special_regularized_beta(double aX,
                                         double aA,
                                         double aB)
;

/*
 Computes the regularized incomplete Beta function I(x; a, b) using bincode serialization.

 The regularized incomplete Beta function is defined as:
 I(x; a, b) = B(x; a, b) / B(a, b), where B(x; a, b) = ∫₀^x t^(a-1) (1-t)^(b-1) dt.
 This function is the cumulative distribution function of the Beta distribution.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `ThreeInput` with:
   - `x`: Upper limit of integration (0 ≤ x ≤ 1)
   - `a`: First shape parameter (must be positive)
   - `b`: Second shape parameter (must be positive)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The value I(x; a, b)
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_special_regularized_beta_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the regularized incomplete Beta function I(x; a, b) via JSON serialization.

 The cumulative distribution function of the Beta distribution.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `x`: Upper limit of integration (0 ≤ x ≤ 1)
   - `a`: First shape parameter (must be positive)
   - `b`: Second shape parameter (must be positive)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the value I(x; a, b) ∈ [0, 1].

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_special_regularized_beta_json(const char *aInput)
;

/*
 Computes the sigmoid function σ(x) = 1 / (1 + e^(-x)) via handle-based FFI.

 Common activation function in neural networks, maps ℝ to (0, 1).

 # Arguments

 * `x` - Input value

 # Returns

 The value σ(x) ∈ (0, 1).
 */
rssn_
double rssn_num_special_sigmoid(double aX)
;

/*
 Computes the sigmoid function σ(x) = 1 / (1 + e^(-x)) using bincode serialization.

 The sigmoid is a smooth, S-shaped activation function commonly used in neural networks
 and logistic regression. It maps any real value to the range (0, 1).

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `SingleInput` with:
   - `x`: Input value

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The value σ(x) ∈ (0, 1)
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_special_sigmoid_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the sigmoid function σ(x) = 1 / (1 + e^(-x)) via JSON serialization.

 Common activation function in neural networks, maps ℝ to (0, 1).

 # Arguments

 * `input` - A JSON string pointer containing:
   - `x`: Input value

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the value σ(x) ∈ (0, 1).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_special_sigmoid_json(const char *aInput)
;

/*
 Computes the normalized sinc function sinc(x) = sin(x) / x via handle-based FFI.

 With sinc(0) = 1 by continuity. Appears in signal processing and Fourier analysis.

 # Arguments

 * `x` - Input value (radians)

 # Returns

 The value sinc(x).
 */
rssn_
double rssn_num_special_sinc(double aX)
;

/*
 Computes the normalized sinc function sinc(x) = sin(x) / x using bincode serialization.

 The sinc function is defined as sinc(x) = sin(x)/x for x ≠ 0, and sinc(0) = 1 by continuity.
 It appears in signal processing (Fourier analysis) and optics (diffraction patterns).

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `SingleInput` with:
   - `x`: Input value (radians)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The value sinc(x)
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_special_sinc_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the normalized sinc function sinc(x) = sin(x) / x via JSON serialization.

 With sinc(0) = 1 by continuity. Appears in signal processing and Fourier analysis.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `x`: Input value (radians)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the value sinc(x).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_special_sinc_json(const char *aInput)
;

/*
 Computes the softplus function softplus(x) = ln(1 + e^x) via handle-based FFI.

 A smooth approximation to the ReLU activation function.

 # Arguments

 * `x` - Input value

 # Returns

 The value softplus(x) > 0.
 */
rssn_
double rssn_num_special_softplus(double aX)
;

/*
 Computes the upper incomplete Gamma function Γ(s, x) via handle-based FFI.

 Defined as Γ(s, x) = ∫ₓ^∞ t^(s-1) e^(-t) dt.

 # Arguments

 * `s` - Shape parameter
 * `x` - Lower limit of integration

 # Returns

 The value Γ(s, x).
 */
rssn_
double rssn_num_special_upper_incomplete_gamma(double aS,
                                               double aX)
;

/*
 Computes the Riemann zeta function ζ(s) via handle-based FFI.

 Defined as ζ(s) = ∑ₙ₌₁^∞ 1/n^s for Re(s) > 1.

 # Arguments

 * `s` - Argument of the zeta function

 # Returns

 The value ζ(s).
 */
rssn_
double rssn_num_special_zeta(double aS)
;

/*
 Performs a chi-squared test.
 Returns chi-squared statistic via out_chi and p-value via out_p.
 */
rssn_
int32_t rssn_num_stats_chi_squared_test(const double *aObserved,
                                        const double *aExpected,
                                        size_t aLen,
                                        double *aOutChi,
                                        double *aOutP)
;

/*
 Performs a chi-squared goodness-of-fit test using bincode serialization.

 Tests whether observed frequencies match expected frequencies according to
 the test statistic χ² = Σ(Oᵢ - Eᵢ)² / Eᵢ.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `TwoDataInput` with:
   - `data1`: Observed frequencies
   - `data2`: Expected frequencies

 # Returns

 A bincode-encoded buffer containing `FfiResult<TestOutput, String>` with either:
 - `ok`: Object containing `statistic` (χ²-statistic) and `p_value`
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_stats_chi_squared_test_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Performs a chi-squared goodness-of-fit test via JSON serialization.

 Tests whether observed frequencies match expected frequencies according to
 the test statistic χ² = Σ(Oᵢ - Eᵢ)² / Eᵢ.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `data1`: Observed frequencies
   - `data2`: Expected frequencies

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<TestOutput, String>` with
 `statistic` (χ²-statistic) and `p_value`.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_stats_chi_squared_test_json(const char *aInput)
;

/*
 Computes the Pearson correlation coefficient of two arrays.
 */
rssn_
double rssn_num_stats_correlation(const double *aData1,
                                  size_t aLen1,
                                  const double *aData2,
                                  size_t aLen2)
;

/*
 Computes the Pearson correlation coefficient between two datasets using bincode serialization.

 The Pearson correlation is defined as ρ = Cov(X,Y) / (σₓσᵧ), ranging from -1 to 1.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `TwoDataInput` with:
   - `data1`: First dataset
   - `data2`: Second dataset (must have same length as data1)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The correlation coefficient ρ ∈ [-1, 1]
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_stats_correlation_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Pearson correlation coefficient between two datasets via JSON serialization.

 The Pearson correlation is defined as ρ = Cov(X,Y) / (σₓσᵧ), ranging from -1 to 1.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `data1`: First dataset
   - `data2`: Second dataset (must have same length as data1)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the correlation coefficient ρ ∈ [-1, 1].

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_stats_correlation_json(const char *aInput)
;

/*
 Computes the covariance of two arrays.
 */
rssn_
double rssn_num_stats_covariance(const double *aData1,
                                 size_t aLen1,
                                 const double *aData2,
                                 size_t aLen2)
;

/*
 Computes the covariance between two datasets using bincode serialization.

 The sample covariance is defined as Cov(X,Y) = (1/(n-1)) Σ(xᵢ - μₓ)(yᵢ - μᵧ).

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `TwoDataInput` with:
   - `data1`: First dataset
   - `data2`: Second dataset (must have same length as data1)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The covariance Cov(X,Y)
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_stats_covariance_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the covariance between two datasets via JSON serialization.

 The sample covariance is defined as Cov(X,Y) = (1/(n-1)) Σ(xᵢ - μₓ)(yᵢ - μᵧ).

 # Arguments

 * `input` - A JSON string pointer containing:
   - `data1`: First dataset
   - `data2`: Second dataset (must have same length as data1)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the covariance Cov(X,Y).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_stats_covariance_json(const char *aInput)
;

/*
 Computes the coefficient of variation of an array.
 */
rssn_
double rssn_num_stats_cv(const double *aData,
                         size_t aLen)
;

/*
 Computes the geometric mean of an array.
 */
rssn_
double rssn_num_stats_geometric_mean(const double *aData,
                                     size_t aLen)
;

/*
 Computes the geometric mean of a dataset via JSON serialization.

 The geometric mean is defined as (∏xᵢ)^(1/n), useful for quantities with
 multiplicative relationships (e.g., growth rates).

 # Arguments

 * `input` - A JSON string pointer containing:
   - `data`: Array of positive numerical values

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the geometric mean.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_stats_geometric_mean_json(const char *aInput)
;

/*
 Computes the harmonic mean of an array.
 */
rssn_
double rssn_num_stats_harmonic_mean(const double *aData,
                                    size_t aLen)
;

/*
 Computes the harmonic mean of a dataset via JSON serialization.

 The harmonic mean is defined as n / Σ(1/xᵢ), useful for averaging rates
 and ratios.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `data`: Array of positive numerical values

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the harmonic mean.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_stats_harmonic_mean_json(const char *aInput)
;

/*
 Performs simple linear regression.
 Returns slope via out_slope and intercept via out_intercept.
 */
rssn_
int32_t rssn_num_stats_linear_regression(const double *aX,
                                         const double *aY,
                                         size_t aLen,
                                         double *aOutSlope,
                                         double *aOutIntercept)
;

/*
 Computes simple linear regression using least squares method via bincode serialization.

 Fits a line y = mx + b to the data by minimizing Σ(yᵢ - (mxᵢ + b))².

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `RegressionInput` with:
   - `x`: Independent variable values
   - `y`: Dependent variable values (must have same length as x)

 # Returns

 A bincode-encoded buffer containing `FfiResult<RegressionOutput, String>` with either:
 - `ok`: Object containing `slope` (m) and `intercept` (b)
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_stats_linear_regression_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes simple linear regression using least squares method via JSON serialization.

 Fits a line y = mx + b to the data by minimizing Σ(yᵢ - (mxᵢ + b))².

 # Arguments

 * `input` - A JSON string pointer containing:
   - `x`: Independent variable values
   - `y`: Dependent variable values (must have same length as x)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<RegressionOutput, String>` with
 `slope` (m) and `intercept` (b).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_stats_linear_regression_json(const char *aInput)
;

/*
 Computes the mean of an array.
 */
rssn_
double rssn_num_stats_mean(const double *aData,
                           size_t aLen)
;

/*
 Computes the arithmetic mean (average) of a dataset using bincode serialization.

 The arithmetic mean is defined as μ = (1/n) Σxᵢ.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `DataInput` with:
   - `data`: Vector of numerical values

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The mean value μ
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_stats_mean_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the arithmetic mean (average) of a dataset via JSON serialization.

 The arithmetic mean is defined as μ = (1/n) Σxᵢ.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `data`: Array of numerical values

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the mean value μ.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_stats_mean_json(const char *aInput)
;

/*
 Computes the range of an array.
 */
rssn_
double rssn_num_stats_range(const double *aData,
                            size_t aLen)
;

/*
 Computes the Shannon entropy of a probability distribution.
 */
rssn_
double rssn_num_stats_shannon_entropy(const double *aData,
                                      size_t aLen)
;

/*
 Computes Shannon entropy of a probability distribution using bincode serialization.

 Shannon entropy is defined as H(X) = -Σ p(xᵢ) log₂(p(xᵢ)), measuring
 the average information content or uncertainty in the distribution.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `DataInput` with:
   - `data`: Probability distribution (values should sum to 1)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: Shannon entropy H(X) in bits
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_stats_shannon_entropy_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes Shannon entropy of a probability distribution via JSON serialization.

 Shannon entropy is defined as H(X) = -Σ p(xᵢ) log₂(p(xᵢ)), measuring
 the average information content or uncertainty in the distribution.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `data`: Probability distribution (values should sum to 1)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 Shannon entropy H(X) in bits.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_stats_shannon_entropy_json(const char *aInput)
;

/*
 Computes the standard error of an array.
 */
rssn_
double rssn_num_stats_standard_error(const double *aData,
                                     size_t aLen)
;

/*
 Computes the standard deviation of an array.
 */
rssn_
double rssn_num_stats_std_dev(const double *aData,
                              size_t aLen)
;

/*
 Computes the sample standard deviation of a dataset using bincode serialization.

 The standard deviation is defined as s = √(s²) where s² is the sample variance.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `DataInput` with:
   - `data`: Vector of numerical values

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The standard deviation s
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_stats_std_dev_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the sample standard deviation of a dataset via JSON serialization.

 The standard deviation is defined as s = √(s²) where s² is the sample variance.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `data`: Array of numerical values

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the standard deviation s.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_stats_std_dev_json(const char *aInput)
;

/*
 Performs a two-sample t-test.
 Returns t-statistic via out_t and p-value via out_p.
 */
rssn_
int32_t rssn_num_stats_two_sample_t_test(const double *aSample1,
                                         size_t aLen1,
                                         const double *aSample2,
                                         size_t aLen2,
                                         double *aOutT,
                                         double *aOutP)
;

/*
 Performs a two-sample t-test for equal means using bincode serialization.

 Tests the null hypothesis that two independent samples have equal means,
 assuming equal variances (pooled variance).

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `TwoDataInput` with:
   - `data1`: First sample
   - `data2`: Second sample

 # Returns

 A bincode-encoded buffer containing `FfiResult<TestOutput, String>` with either:
 - `ok`: Object containing `statistic` (t-statistic) and `p_value`
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_stats_two_sample_t_test_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Performs a two-sample t-test for equal means via JSON serialization.

 Tests the null hypothesis that two independent samples have equal means,
 assuming equal variances (pooled variance).

 # Arguments

 * `input` - A JSON string pointer containing:
   - `data1`: First sample
   - `data2`: Second sample

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<TestOutput, String>` with
 `statistic` (t-statistic) and `p_value`.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_stats_two_sample_t_test_json(const char *aInput)
;

/*
 Computes the variance of an array.
 */
rssn_
double rssn_num_stats_variance(const double *aData,
                               size_t aLen)
;

/*
 Computes the sample variance of a dataset using bincode serialization.

 The sample variance is defined as s² = (1/(n-1)) Σ(xᵢ - μ)².

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `DataInput` with:
   - `data`: Vector of numerical values

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The variance s²
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_stats_variance_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the sample variance of a dataset via JSON serialization.

 The sample variance is defined as s² = (1/(n-1)) Σ(xᵢ - μ)².

 # Arguments

 * `input` - A JSON string pointer containing:
   - `data`: Array of numerical values

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the variance s².

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_stats_variance_json(const char *aInput)
;

/*
 Performs Welch's t-test.
 Returns t-statistic via out_t and p-value via out_p.
 */
rssn_
int32_t rssn_num_stats_welch_t_test(const double *aSample1,
                                    size_t aLen1,
                                    const double *aSample2,
                                    size_t aLen2,
                                    double *aOutT,
                                    double *aOutP)
;

/*
 Performs Welch's t-test for unequal variances using bincode serialization.

 Tests the null hypothesis that two independent samples have equal means,
 without assuming equal variances (Welch-Satterthwaite correction).

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `TwoDataInput` with:
   - `data1`: First sample
   - `data2`: Second sample

 # Returns

 A bincode-encoded buffer containing `FfiResult<TestOutput, String>` with either:
 - `ok`: Object containing `statistic` (t-statistic) and `p_value`
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_stats_welch_t_test_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Performs Welch's t-test for unequal variances via JSON serialization.

 Tests the null hypothesis that two independent samples have equal means,
 without assuming equal variances (Welch-Satterthwaite correction).

 # Arguments

 * `input` - A JSON string pointer containing:
   - `data1`: First sample
   - `data2`: Second sample

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<TestOutput, String>` with
 `statistic` (t-statistic) and `p_value`.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_stats_welch_t_test_json(const char *aInput)
;

/*
 Computes standardized z-scores for a dataset using bincode serialization.

 The z-score is defined as z = (x - μ) / σ, representing the number of
 standard deviations each value is from the mean.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `DataInput` with:
   - `data`: Vector of numerical values

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<f64>, String>` with either:
 - `ok`: Vector of z-scores
 - `err`: Error message if input is invalid

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_stats_z_scores_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes standardized z-scores for a dataset via JSON serialization.

 The z-score is defined as z = (x - μ) / σ, representing the number of
 standard deviations each value is from the mean.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `data`: Array of numerical values

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the vector of z-scores.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_stats_z_scores_json(const char *aInput)
;

/*
 Creates a new tensor from shape and data.
 */
rssn_
rssn_ArrayD<double> *rssn_num_tensor_create(const size_t *aShape,
                                            size_t aNdim,
                                            const double *aData,
                                            size_t aDataLen)
;

/*
 Frees a tensor object.
 */
rssn_
void rssn_num_tensor_free(rssn_ArrayD<double> *aTensor)
;

/*
 Returns the number of dimensions.
 */
rssn_
size_t rssn_num_tensor_get_ndim(const rssn_ArrayD<double> *aTensor)
;

/*
 Returns the shape of the tensor.
 */
rssn_
int32_t rssn_num_tensor_get_shape(const rssn_ArrayD<double> *aTensor,
                                  size_t *aOutShape)
;

/*
 Frobenius norm of a tensor.
 */
rssn_
double rssn_num_tensor_norm(const rssn_ArrayD<double> *aTensor)
;

/*
 Outer product of two tensors.
 */
rssn_
rssn_ArrayD<double> *rssn_num_tensor_outer_product(const rssn_ArrayD<double> *aA,
                                                   const rssn_ArrayD<double> *aB)
;

/*
 Outer product from JSON.
 */
rssn_
char *rssn_num_tensor_outer_product_json(const char *aJsonPtr)
;

/*
 Tensor contraction (tensordot).
 */
rssn_
rssn_ArrayD<double> *rssn_num_tensor_tensordot(const rssn_ArrayD<double> *aA,
                                               const rssn_ArrayD<double> *aB,
                                               const size_t *aAxesA,
                                               size_t aAxesALen,
                                               const size_t *aAxesB,
                                               size_t aAxesBLen)
;

/*
 Tensor contraction via Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_tensor_tensordot_bincode(const uint8_t *aData,
                                                            size_t aLen)
;

/*
 Tensor contraction from JSON.
 */
rssn_
char *rssn_num_tensor_tensordot_json(const char *aJsonPtr)
;

/*
 Computes the Betti numbers for a point cloud.
 */
rssn_
int32_t rssn_num_topology_betti_numbers(const double *const *aPoints,
                                        size_t aNPoints,
                                        size_t aDim,
                                        double aEpsilon,
                                        size_t aMaxDim,
                                        size_t *aResult)
;

/*
 Computes Betti numbers at a fixed radius for topological data analysis using bincode serialization.

 Betti numbers characterize topological features: β₀ (connected components),
 β₁ (holes/loops), β₂ (voids), etc., in the Vietoris-Rips complex.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `BettiInput` with:
   - `points`: Point cloud data as vectors of coordinates
   - `epsilon`: Radius parameter for Vietoris-Rips complex
   - `max_dim`: Maximum homology dimension to compute

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<usize>, String>` with either:
 - `ok`: Vector of Betti numbers [β₀, β₁, β₂, ...] up to max_dim
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_topology_betti_numbers_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes Betti numbers at a fixed radius for topological data analysis via JSON serialization.

 Betti numbers characterize topological features: β₀ (connected components),
 β₁ (holes/loops), β₂ (voids), etc., in the Vietoris-Rips complex.

 # Arguments

 * `input_json` - A JSON string pointer containing:
   - `points`: Point cloud data as arrays of coordinates
   - `epsilon`: Radius parameter for Vietoris-Rips complex
   - `max_dim`: Maximum homology dimension to compute

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<usize>, String>` with
 a vector of Betti numbers [β₀, β₁, β₂, ...] up to max_dim.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_topology_betti_numbers_json(const char *aInputJson)
;

/*
 Computes the Euclidean distance between two points.
 */
rssn_
double rssn_num_topology_euclidean_distance(const double *aP1,
                                            const double *aP2,
                                            size_t aDim)
;

/*
 Finds the connected components of a graph.
 */
rssn_
struct rssn_Vec_Vec_usize *rssn_num_topology_find_connected_components(const struct rssn_Graph *aGraphPtr)
;

/*
 Computes persistent homology for topological data analysis using bincode serialization.

 Tracks the birth and death of topological features (components, holes, voids)
 across multiple scales, producing persistence diagrams.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `PersistenceInput` with:
   - `points`: Point cloud data as vectors of coordinates
   - `max_epsilon`: Maximum radius to analyze
   - `steps`: Number of radius values to sample
   - `max_dim`: Maximum homology dimension to compute

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<PersistenceDiagram>, String>` with either:
 - `ok`: Persistence diagrams for each dimension
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_topology_persistence_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes persistent homology for topological data analysis via JSON serialization.

 Tracks the birth and death of topological features (components, holes, voids)
 across multiple scales, producing persistence diagrams.

 # Arguments

 * `input_json` - A JSON string pointer containing:
   - `points`: Point cloud data as arrays of coordinates
   - `max_epsilon`: Maximum radius to analyze
   - `steps`: Number of radius values to sample
   - `max_dim`: Maximum homology dimension to compute

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<PersistenceDiagram>, String>` with
 persistence diagrams for each dimension.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_topology_persistence_json(const char *aInputJson)
;

/*
 Computes the sum of two vectors.
 */
rssn_
struct rssn_Vec_f64 *rssn_num_vec_add(const struct rssn_Vec_f64 *aV1,
                                      const struct rssn_Vec_f64 *aV2)
;

/*
 Computes the angle between two vectors.
 */
rssn_
int32_t rssn_num_vec_angle(const struct rssn_Vec_f64 *aV1,
                           const struct rssn_Vec_f64 *aV2,
                           double *aResult)
;

/*
 Creates a new numerical vector from a raw array of doubles.
 The caller is responsible for freeing the returned pointer using rssn_num_vec_free.
 */
rssn_
struct rssn_Vec_f64 *rssn_num_vec_create(const double *aData,
                                         size_t aLen)
;

/*
 Computes the cross product of two 3D vectors.
 */
rssn_
struct rssn_Vec_f64 *rssn_num_vec_cross_product(const struct rssn_Vec_f64 *aV1,
                                                const struct rssn_Vec_f64 *aV2)
;

/*
 Returns a pointer to the underlying data of a numerical vector.
 */
rssn_
const double *rssn_num_vec_data(const struct rssn_Vec_f64 *aV)
;

/*
 Computes the dot product of two vectors.
 */
rssn_
int32_t rssn_num_vec_dot_product(const struct rssn_Vec_f64 *aV1,
                                 const struct rssn_Vec_f64 *aV2,
                                 double *aResult)
;

/*
 Frees a numerical vector allocated by the library.
 */
rssn_
void rssn_num_vec_free(struct rssn_Vec_f64 *aV)
;

/*
 Returns the length of a numerical vector.
 */
rssn_
size_t rssn_num_vec_len(const struct rssn_Vec_f64 *aV)
;

/*
 Computes the Lp norm of a vector.
 */
rssn_
int32_t rssn_num_vec_lp_norm(const struct rssn_Vec_f64 *aV,
                             double aP,
                             double *aResult)
;

/*
 Computes the L2 norm of a vector.
 */
rssn_
int32_t rssn_num_vec_norm(const struct rssn_Vec_f64 *aV,
                          double *aResult)
;

/*
 Normalizes a vector.
 */
rssn_
struct rssn_Vec_f64 *rssn_num_vec_normalize(const struct rssn_Vec_f64 *aV)
;

/*
 Projects v1 onto v2.
 */
rssn_
struct rssn_Vec_f64 *rssn_num_vec_project(const struct rssn_Vec_f64 *aV1,
                                          const struct rssn_Vec_f64 *aV2)
;

/*
 Reflects v about n.
 */
rssn_
struct rssn_Vec_f64 *rssn_num_vec_reflect(const struct rssn_Vec_f64 *aV,
                                          const struct rssn_Vec_f64 *aN)
;

/*
 Multiplies a vector by a scalar.
 */
rssn_
struct rssn_Vec_f64 *rssn_num_vec_scalar_mul(const struct rssn_Vec_f64 *aV,
                                             double aS)
;

/*
 Computes the difference of two vectors.
 */
rssn_
struct rssn_Vec_f64 *rssn_num_vec_sub(const struct rssn_Vec_f64 *aV1,
                                      const struct rssn_Vec_f64 *aV2)
;

/*
 Computes the numerical curl of a 3D vector field at a point.
 */
rssn_
struct rssn_Vec_f64 *rssn_num_vector_calculus_curl(const struct rssn_Expr *const *aFuncs,
                                                   const char *const *aVars,
                                                   const double *aPoint)
;

/*
 Computes the curl of a vector field at a point using bincode serialization.

 The curl measures the rotational tendency of a vector field. In 3D:
 curl(F) = (∂F₃/∂x₂ - ∂F₂/∂x₃, ∂F₁/∂x₃ - ∂F₃/∂x₁, ∂F₂/∂x₁ - ∂F₁/∂x₂).

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `CurlInput` with:
   - `funcs`: Vector field components as symbolic expressions
   - `vars`: Variable names corresponding to coordinates
   - `point`: Point at which to evaluate curl

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<f64>, String>` with either:
 - `ok`: The curl vector
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_vector_calculus_curl_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the curl of a vector field at a point via JSON serialization.

 The curl measures the rotational tendency of a vector field. In 3D:
 curl(F) = (∂F₃/∂x₂ - ∂F₂/∂x₃, ∂F₁/∂x₃ - ∂F₃/∂x₁, ∂F₂/∂x₁ - ∂F₁/∂x₂).

 # Arguments

 * `input_json` - A JSON string pointer containing:
   - `funcs`: Vector field components as symbolic expressions
   - `vars`: Variable names corresponding to coordinates
   - `point`: Point at which to evaluate curl

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the curl vector.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_vector_calculus_curl_json(const char *aInputJson)
;

/*
 Computes the numerical directional derivative of a function at a point.
 */
rssn_
int32_t rssn_num_vector_calculus_directional_derivative(const struct rssn_Expr *aF,
                                                        const char *const *aVars,
                                                        const double *aPoint,
                                                        const double *aDirection,
                                                        size_t aNVars,
                                                        double *aResult)
;

/*
 Computes the numerical divergence of a vector field at a point.
 */
rssn_
int32_t rssn_num_vector_calculus_divergence(const struct rssn_Expr *const *aFuncs,
                                            size_t aNFuncs,
                                            const char *const *aVars,
                                            const double *aPoint,
                                            size_t aNVars,
                                            double *aResult)
;

/*
 Computes the divergence of a vector field at a point using bincode serialization.

 The divergence measures the net outward flux of a vector field:
 div(F) = ∂F₁/∂x₁ + ∂F₂/∂x₂ + ... + ∂Fₙ/∂xₙ.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `DivergenceInput` with:
   - `funcs`: Vector field components as symbolic expressions
   - `vars`: Variable names corresponding to coordinates
   - `point`: Point at which to evaluate divergence

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The divergence value (scalar)
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_vector_calculus_divergence_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the divergence of a vector field at a point via JSON serialization.

 The divergence measures the net outward flux of a vector field:
 div(F) = ∂F₁/∂x₁ + ∂F₂/∂x₂ + ... + ∂Fₙ/∂xₙ.

 # Arguments

 * `input_json` - A JSON string pointer containing:
   - `funcs`: Vector field components as symbolic expressions
   - `vars`: Variable names corresponding to coordinates
   - `point`: Point at which to evaluate divergence

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the divergence value (scalar).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_vector_calculus_divergence_json(const char *aInputJson)
;

/*
 Computes the numerical Laplacian of a scalar field at a point.
 */
rssn_
int32_t rssn_num_vector_calculus_laplacian(const struct rssn_Expr *aF,
                                           const char *const *aVars,
                                           const double *aPoint,
                                           size_t aNVars,
                                           double *aResult)
;

/*
 Computes the Laplacian of a scalar field at a point using bincode serialization.

 The Laplacian is the divergence of the gradient:
 ∇²f = ∂²f/∂x₁² + ∂²f/∂x₂² + ... + ∂²f/∂xₙ².

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `LaplacianInput` with:
   - `f`: Scalar field as a symbolic expression
   - `vars`: Variable names corresponding to coordinates
   - `point`: Point at which to evaluate Laplacian

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The Laplacian value (scalar)
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_num_vector_calculus_laplacian_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Laplacian of a scalar field at a point via JSON serialization.

 The Laplacian is the divergence of the gradient:
 ∇²f = ∂²f/∂x₁² + ∂²f/∂x₂² + ... + ∂²f/∂xₙ².

 # Arguments

 * `input_json` - A JSON string pointer containing:
   - `f`: Scalar field as a symbolic expression
   - `vars`: Variable names corresponding to coordinates
   - `point`: Point at which to evaluate Laplacian

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the Laplacian value (scalar).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_num_vector_calculus_laplacian_json(const char *aInputJson)
;

/*
 Evaluates a power series at a point.
 */
rssn_
double rssn_numerical_evaluate_power_series(const struct rssn_Vec_f64 *aCoeffs,
                                            double aAtPoint,
                                            double aX)
;

/*
 Computes the numerical gradient of an expression at a point.

 # Safety
 * `vars` must be a valid pointer to an array of `num_vars` null-terminated strings.
 * `point` must be a valid pointer to an array of `point_len` f64 elements.
 * `result_vec` must point to a buffer of size at least `point_len` f64 elements.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_numerical_gradient(size_t aExprH,
                                const char *const *aVars,
                                size_t aNumVars,
                                const double *aPoint,
                                size_t aPointLen,
                                double *aResultVec)
;

/*
 Computes the gradient of an expression at a given point using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_numerical_gradient_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the gradient of an expression at a given point using JSON for serialization.
 */
rssn_
char *rssn_numerical_gradient_json(const char *aInputJson)
;

/*
 Computes the Hessian matrix of an expression at a given point using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_numerical_hessian_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Hessian matrix of an expression at a given point using JSON for serialization.
 */
rssn_
char *rssn_numerical_hessian_json(const char *aInputJson)
;

/*
 Computes the numerical definite integral of an expression using handles.

 # Safety
 * `var` must be a valid null-terminated C string.
 * `result` must be a valid pointer to store the f64 result.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_numerical_integrate(size_t aExprH,
                                 const char *aVar,
                                 double aStart,
                                 double aEnd,
                                 size_t aNSteps,
                                 uint32_t aMethod,
                                 double *aResult)
;

/*
 Computes the Jacobian matrix of a set of expressions at a given point using bincode for serialization.
 */
rssn_
struct rssn_BincodeBuffer rssn_numerical_jacobian_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Jacobian matrix of a set of expressions at a given point using JSON for serialization.
 */
rssn_
char *rssn_numerical_jacobian_json(const char *aInputJson)
;

/*
 Performs numerical integration (quadrature) of a function.

 # Arguments
 * `expr_ptr` - Pointer to the `Expr` to integrate.
 * `var_ptr` - Pointer to the C string representing the variable of integration.
 * `a` - Lower bound of integration.
 * `b` - Upper bound of integration.
 * `n_steps` - Number of steps for non-adaptive methods.
 * `method` - Integration method:
     0 - Trapezoidal
     1 - Simpson
     2 - Adaptive
     3 - Romberg
     4 - Gauss-Legendre
 * `result` - Pointer to store the result.

 # Returns
 0 on success, -1 on error.
 */
rssn_
int32_t rssn_numerical_quadrature(const struct rssn_Expr *aExprPtr,
                                  const char *aVarPtr,
                                  double aA,
                                  double aB,
                                  size_t aNSteps,
                                  int32_t aMethod,
                                  double *aResult)
;

/*
 Performs numerical integration via Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_numerical_quadrature_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Performs numerical integration via JSON.

 Input JSON format:
 {
   "expr": <Expr object>,
   "var": "x",
   "a": 0.0,
   "b": 1.0,
   "n_steps": 100,
   "method": "Simpson"
 }
 */
rssn_
char *rssn_numerical_quadrature_json(const char *aJsonPtr)
;

/*
 Computes the sum of a series.
 */
rssn_
int32_t rssn_numerical_sum_series(const struct rssn_Expr *aF,
                                  const char *aVar,
                                  int64_t aStart,
                                  int64_t aEnd,
                                  double *aResult)
;

/*
 Computes the numerical sum of a symbolic series using bincode serialization.

 Evaluates Σ f(var) for var from start to end, where f is a symbolic expression.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `SumInput` with:
   - `expr`: Symbolic expression to sum
   - `var`: Summation index variable name
   - `start`: Lower limit of summation (inclusive)
   - `end`: Upper limit of summation (inclusive)

 # Returns

 A bincode-encoded buffer containing `FfiResult<f64, String>` with either:
 - `ok`: The computed sum value
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_numerical_sum_series_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes the numerical sum of a symbolic series using JSON serialization.

 Evaluates Σ f(var) for var from start to end, where f is a symbolic expression.

 # Arguments

 * `input_json` - A JSON string pointer containing:
   - `expr`: Symbolic expression to sum
   - `var`: Summation index variable name
   - `start`: Lower limit of summation (inclusive)
   - `end`: Upper limit of summation (inclusive)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<f64, String>` with
 the computed sum value.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_numerical_sum_series_json(const char *aInputJson)
;

/*
 Computes the numerical Taylor series coefficients.
 Returns a pointer to a Vec<f64> containing the coefficients.
 */
rssn_
struct rssn_Vec_f64 *rssn_numerical_taylor_coefficients(const struct rssn_Expr *aF,
                                                        const char *aVar,
                                                        double aAtPoint,
                                                        size_t aOrder)
;

/*
 Computes Taylor series coefficients for a symbolic expression using bincode serialization.

 Evaluates the derivatives of the expression at a point to obtain Taylor expansion coefficients:
 f(x) ≈ Σ [fⁿⁿⁿ(a)/n!](x-a)ⁿ for n = 0 to order.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `TaylorInput` with:
   - `expr`: Symbolic expression to expand
   - `var`: Variable name for expansion
   - `at_point`: Point a around which to expand
   - `order`: Maximum order of Taylor expansion

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<f64>, String>` with either:
 - `ok`: Array of Taylor coefficients [c₀, c₁, ..., cₙ]
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_numerical_taylor_coefficients_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes Taylor series coefficients for a symbolic expression using JSON serialization.

 Evaluates the derivatives of the expression at a point to obtain Taylor expansion coefficients:
 f(x) ≈ Σ [fⁿⁿⁿ(a)/n!](x-a)ⁿ for n = 0 to order.

 # Arguments

 * `input_json` - A JSON string pointer containing:
   - `expr`: Symbolic expression to expand
   - `var`: Variable name for expansion
   - `at_point`: Point a around which to expand
   - `order`: Maximum order of Taylor expansion

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 an array of Taylor coefficients [c₀, c₁, ..., cₙ].

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_numerical_taylor_coefficients_json(const char *aInputJson)
;

/*
 Performs a one-sample t-test.

 Takes a raw pointer to an array of `Expr` (data), its length,
 and a raw pointer to an `Expr` (target mean).
 Returns a raw pointer to an `Expr` tuple containing the test statistic,
 p-value formula, and degrees of freedom.
 */
rssn_
struct rssn_Expr *rssn_one_sample_t_test(const struct rssn_Expr *const *aData,
                                         size_t aLen,
                                         const struct rssn_Expr *aTargetMean)
;

/*
 Frees an Operator.
 */
rssn_
void rssn_operator_free(struct rssn_Operator *aOpPtr)
;

/*
 Creates a new Operator from an expression.
 */
rssn_
struct rssn_Operator *rssn_operator_new(const struct rssn_Expr *aOp)
;

/*
 Generates a 4x4 orthographic projection matrix.
 */
rssn_
struct rssn_Expr *rssn_orthographic_projection(const struct rssn_Expr *aLeft,
                                               const struct rssn_Expr *aRight,
                                               const struct rssn_Expr *aBottom,
                                               const struct rssn_Expr *aTop,
                                               const struct rssn_Expr *aNear,
                                               const struct rssn_Expr *aFar)
;

/*
 Frees a ParametricCurve handle.
 */
rssn_
void rssn_parametric_curve_free(struct rssn_ParametricCurve *aCurve)
;

/*
 Creates a new ParametricCurve.
 */
rssn_
struct rssn_ParametricCurve *rssn_parametric_curve_new(const char *aRX,
                                                       const char *aRY,
                                                       const char *aRZ,
                                                       const char *aTVar,
                                                       const char *aTLower,
                                                       const char *aTUpper)
;

/*
 Frees a ParametricSurface handle.
 */
rssn_
void rssn_parametric_surface_free(struct rssn_ParametricSurface *aSurface)
;

/*
 Creates a new ParametricSurface.
 */
rssn_
struct rssn_ParametricSurface *rssn_parametric_surface_new(const char *aRX,
                                                           const char *aRY,
                                                           const char *aRZ,
                                                           const char *aUVar,
                                                           const char *aULower,
                                                           const char *aUUpper,
                                                           const char *aVVar,
                                                           const char *aVLower,
                                                           const char *aVUpper)
;

/*
 Clears a ParsingCache.
 */
rssn_
void rssn_parsing_cache_clear(struct rssn_ParsingCache *aCache)
;

/*
 Frees a ParsingCache.
 */
rssn_
void rssn_parsing_cache_free(struct rssn_ParsingCache *aCache)
;

/*
 Retrieves an expression from the ParsingCache.
 Returns a pointer to the Expr (Arc<Expr> with incremented refcount), or null if not found.
 The caller is responsible for freeing the returned Expr (using the appropriate Expr free function).
 */
rssn_
struct rssn_Expr *rssn_parsing_cache_get(struct rssn_ParsingCache *aCache,
                                         const char *aInput)
;

/*
 Retrieves an expression from the ParsingCache as a bincode buffer.
 */
rssn_
struct rssn_BincodeBuffer rssn_parsing_cache_get_bincode(struct rssn_ParsingCache *aCache,
                                                         const char *aInput)
;

/*
 Retrieves an expression from the ParsingCache as a JSON string.
 Returns null if not found or error.
 */
rssn_
char *rssn_parsing_cache_get_json(struct rssn_ParsingCache *aCache,
                                  const char *aInput)
;

/*
 Creates a new ParsingCache.
 The caller is responsible for freeing the memory using rssn_parsing_cache_free.
 */
rssn_
struct rssn_ParsingCache *rssn_parsing_cache_new(void)
;

/*
 Stores an expression in the ParsingCache.
 The expr pointer is cloned (deep copy of the structure, but DAG nodes are shared).
 */
rssn_
void rssn_parsing_cache_set(struct rssn_ParsingCache *aCache,
                            const char *aInput,
                            const struct rssn_Expr *aExpr)
;

/*
 Stores an expression in the ParsingCache from a bincode buffer.
 */
rssn_
void rssn_parsing_cache_set_bincode(struct rssn_ParsingCache *aCache,
                                    const char *aInput,
                                    struct rssn_BincodeBuffer aBuffer)
;

/*
 Stores an expression in the ParsingCache from a JSON string.
 */
rssn_
void rssn_parsing_cache_set_json(struct rssn_ParsingCache *aCache,
                                 const char *aInput,
                                 const char *aJsonExpr)
;

/*
 Computes the partial fraction decomposition of an expression.

 Takes a raw pointer to an `Expr` (expression) and a C-style string (variable).
 Returns a raw pointer to an `ExprList` representing the decomposition.
 */
rssn_
struct rssn_ExprList *rssn_partial_fraction_decomposition(const struct rssn_Expr *aExpr,
                                                          const char *aVar)
;

/*
 Computes a path integral.
 */
rssn_
struct rssn_Expr *rssn_path_integrate(const struct rssn_Expr *aExpr,
                                      const char *aVar,
                                      const struct rssn_Expr *aContour)
;

/*
 Pauli matrices σ_x, σ_y, σ_z.
 */
rssn_
void rssn_pauli_matrices(struct rssn_Expr **aSigmaX,
                         struct rssn_Expr **aSigmaY,
                         struct rssn_Expr **aSigmaZ)
;

/*
 Computes the number of permutations symbolically as an `Expr`.

 This corresponds to \( P(n,k) = n! / (n-k)! \) for integer `n` and `k`, but also
 supports symbolic `Expr` arguments.

 # Arguments

 * `n` - Pointer to an `Expr` representing the population size.
 * `k` - Pointer to an `Expr` representing the selection size.

 # Returns

 A newly allocated `Expr` pointer representing the symbolic permutation count.

 # Safety

 This function is unsafe because it dereferences raw `Expr` pointers and returns
 ownership of a heap-allocated `Expr` to the caller.
 */
rssn_
struct rssn_Expr *rssn_permutations(const struct rssn_Expr *aN,
                                    const struct rssn_Expr *aK)
;

/*
 Generates a 4x4 perspective projection matrix.
 */
rssn_
struct rssn_Expr *rssn_perspective_projection(const struct rssn_Expr *aFovy,
                                              const struct rssn_Expr *aAspect,
                                              const struct rssn_Expr *aNear,
                                              const struct rssn_Expr *aFar)
;

/*
 Solves the 1D advection-diffusion equation numerically.

 # Safety
 * `initial_cond` must be a valid pointer to an array of `len` f64 elements.
 * `result_ptr` must point to a buffer of size at least `len` f64 elements.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_physics_advection_diffusion_1d(const double *aInitialCond,
                                            size_t aLen,
                                            double aDx,
                                            double aC,
                                            double aD,
                                            double aDt,
                                            size_t aSteps,
                                            double *aResultPtr)
;

/*
 Solves a 2D Laplace problem using BEM and returns the results as a flat array.
 The `bcs_type` array should be 0 for Potential and 1 for Flux.
 # Safety
 This function is unsafe because it dereferences pointers.
 */
rssn_
int32_t rssn_physics_bem_solve_laplace_2d(const double *aPointsX,
                                          const double *aPointsY,
                                          const int32_t *aBcsType,
                                          const double *aBcsValue,
                                          size_t aN,
                                          double *aOutU,
                                          double *aOutQ)
;

/*
 Solves the 2D Laplace equation using Boundary Element Method (BEM) via bincode serialization.

 The Laplace equation ∇²u = 0 is solved using BEM, where the domain is discretized
 into boundary elements and the solution is represented by potential u and flux q
 on the boundary.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `Bem2DInput` with:
   - `points`: Boundary points as (x, y) coordinates
   - `bcs`: Boundary conditions (Potential or Flux) at each point

 # Returns

 A bincode-encoded buffer containing `FfiResult<Bem2DOutput, String>` with either:
 - `ok`: Object containing:
   - `u`: Potential values at boundary nodes
   - `q`: Flux values at boundary nodes
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_physics_bem_solve_laplace_2d_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Solves the 2D Laplace equation using Boundary Element Method (BEM) via JSON serialization.

 The Laplace equation ∇²u = 0 is solved using BEM, where the domain is discretized
 into boundary elements and the solution is represented by potential u and flux q
 on the boundary.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `points`: Boundary points as (x, y) coordinate pairs
   - `bcs`: Boundary conditions (Potential or Flux) at each point

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Bem2DOutput, String>` with
 potential `u` and flux `q` values at boundary nodes.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_physics_bem_solve_laplace_2d_json(const char *aInput)
;

/*
 Solves 1D heat equation using CN and returns a flat array of doubles.
 The caller is responsible for freeing the memory using rssn_free_f64_array.
 */
rssn_
double *rssn_physics_cnm_solve_heat_1d(const double *aInitialCondition,
                                       size_t aN,
                                       double aDx,
                                       double aDt,
                                       double aDCoeff,
                                       size_t aSteps,
                                       size_t *aOutSize)
;

/*
 Solves the 2D heat equation using Crank-Nicolson ADI method via bincode serialization.

 The heat equation ∂u/∂t = α∇²u is solved using the Crank-Nicolson Alternating
 Direction Implicit (ADI) method, which is unconditionally stable and second-order
 accurate in both space and time.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `Heat2DInput` with:
   - `initial_condition`: Initial temperature distribution (flattened 2D grid)
   - `config`: Solver configuration (grid size, time step, thermal diffusivity, etc.)

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<f64>, String>` with either:
 - `ok`: Final temperature distribution after time evolution
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_physics_cnm_solve_heat_2d_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Solves the 2D heat equation using Crank-Nicolson ADI method via JSON serialization.

 The heat equation ∂u/∂t = α∇²u is solved using the Crank-Nicolson Alternating
 Direction Implicit (ADI) method, which is unconditionally stable and second-order
 accurate in both space and time.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `initial_condition`: Initial temperature distribution (flattened 2D grid)
   - `config`: Solver configuration (grid size, time step, thermal diffusivity, etc.)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the final temperature distribution after time evolution.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_physics_cnm_solve_heat_2d_json(const char *aInput)
;

/*
 Simulates the gravity semi-implicit Euler scenario and returns the results as a Matrix handle.
 */
rssn_
struct rssn_Matrix_f64 *rssn_physics_em_simulate_gravity_semi_implicit(void)
;

/*
 Simulates the oscillator forward Euler scenario and returns the results as a Matrix handle.
 */
rssn_
struct rssn_Matrix_f64 *rssn_physics_em_simulate_oscillator_forward(void)
;

/*
 Simulates the stiff decay scenario using backward Euler and returns a Matrix handle.
 */
rssn_
struct rssn_Matrix_f64 *rssn_physics_em_simulate_stiff_decay_backward(void)
;

/*
 Solves ODE systems using Euler methods (forward, midpoint, or Heun) via bincode serialization.

 Supports various dynamical systems including Lorenz attractor and damped oscillators,
 using explicit Euler integration methods.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `EulerInput` with:
   - `system_type`: System identifier ("lorenz", "oscillator")
   - `params_bincode`: System parameters encoded with bincode
   - `y0`: Initial state vector
   - `t_span`: Time interval (t_start, t_end)
   - `dt`: Time step size
   - `method`: Integration method ("forward", "midpoint", "heun")

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<(f64, Vec<f64>)>, String>` with either:
 - `ok`: Trajectory as (time, state) pairs
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_physics_em_solve_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Solves ODE systems using Euler methods (forward, midpoint, or Heun) via JSON serialization.

 Supports various dynamical systems including Lorenz attractor, damped oscillators,
 and orbital mechanics, using explicit Euler integration methods.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `system_type`: System identifier ("lorenz", "oscillator", "orbital")
   - `params`: System parameters as JSON object
   - `y0`: Initial state vector
   - `t_span`: Time interval [t_start, t_end]
   - `dt`: Time step size
   - `method`: Integration method ("forward", "midpoint", "heun")

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<(f64, Vec<f64>)>, String>` with
 the trajectory as (time, state) pairs.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_physics_em_solve_json(const char *aInput)
;

/*
 Solves the 1D Burgers' equation using Finite Difference Method via JSON serialization.

 Burgers' equation ∂u/∂t + u∂u/∂x = ν∂²u/∂x² combines nonlinear convection
 with diffusion, modeling shock wave formation and viscous fluid flow.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `initial_u`: Initial velocity field
   - `dx`: Spatial step size
   - `nu`: Kinematic viscosity coefficient ν
   - `dt`: Time step size
   - `steps`: Number of time steps to simulate

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the final velocity field.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_physics_fdm_burgers_json(const char *aInput)
;

/*
 Returns a pointer to the grid data.
 */
rssn_
double *rssn_physics_fdm_grid_data(rssn_FdmGrid<double> *aGrid)
;

/*
 Frees a FdmGrid handle.
 */
rssn_
void rssn_physics_fdm_grid_free(rssn_FdmGrid<double> *aGrid)
;

/*
 Returns the size of the grid data.
 */
rssn_
size_t rssn_physics_fdm_grid_len(rssn_FdmGrid<double> *aGrid)
;

/*
 Creates a new FdmGrid handle with the given dimensions.
 */
rssn_
rssn_FdmGrid<double> *rssn_physics_fdm_grid_new(size_t aD1,
                                                size_t aD2,
                                                size_t aD3)
;

/*
 Solves the 2D heat equation using Finite Difference Method (FDM) via JSON serialization.

 The heat equation ∂u/∂t = α∇²u is solved using explicit finite differences with
 a square heat source at the center of the domain.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `width`: Grid width (number of cells in x-direction)
   - `height`: Grid height (number of cells in y-direction)
   - `alpha`: Thermal diffusivity coefficient α
   - `dx`: Spatial step size in x-direction
   - `dy`: Spatial step size in y-direction
   - `dt`: Time step size
   - `steps`: Number of time steps to simulate
   - `initial_temp`: Temperature of the central heat source

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<FdmGrid<f64>, String>` with
 the final temperature field grid.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_physics_fdm_heat_json(const char *aInput)
;

/*
 Solves the 2D Poisson equation using Finite Difference Method with SOR via JSON serialization.

 The Poisson equation ∇²u = f is solved using Successive Over-Relaxation (SOR)
 iteration to find the steady-state potential field given a source distribution.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `width`: Grid width (number of cells in x-direction)
   - `height`: Grid height (number of cells in y-direction)
   - `source`: Source term f (flattened 2D array)
   - `dx`: Spatial step size in x-direction
   - `dy`: Spatial step size in y-direction
   - `omega`: SOR relaxation parameter (1 < ω < 2 for optimal convergence)
   - `max_iter`: Maximum number of iterations
   - `tolerance`: Convergence tolerance for residual norm

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<FdmGrid<f64>, String>` with
 the solution grid u.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_physics_fdm_poisson_json(const char *aInput)
;

/*
 Simulates 2D heat conduction and returns a new FdmGrid handle.
 */
rssn_
rssn_FdmGrid<double> *rssn_physics_fdm_simulate_heat_2d(void)
;

/*
 Simulates 2D wave propagation and returns a new FdmGrid handle.
 */
rssn_
rssn_FdmGrid<double> *rssn_physics_fdm_simulate_wave_2d(void)
;

/*
 Solves the 2D wave equation using Finite Difference Method (FDM) via bincode serialization.

 The wave equation ∂²u/∂t² = c²∇²u is solved using explicit finite differences with
 a Gaussian initial condition centered at the grid midpoint.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `WaveEquationInput` with:
   - `width`: Grid width (number of cells in x-direction)
   - `height`: Grid height (number of cells in y-direction)
   - `c`: Wave speed
   - `dx`: Spatial step size in x-direction
   - `dy`: Spatial step size in y-direction
   - `dt`: Time step size
   - `steps`: Number of time steps to simulate

 # Returns

 A bincode-encoded buffer containing `FfiResult<FdmGrid<f64>, String>` with either:
 - `ok`: Final wave field grid after time evolution
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_physics_fdm_wave_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Solves the 2D wave equation using Finite Difference Method (FDM) via JSON serialization.

 The wave equation ∂²u/∂t² = c²∇²u is solved using explicit finite differences with
 a Gaussian initial condition centered at the grid midpoint.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `width`: Grid width (number of cells in x-direction)
   - `height`: Grid height (number of cells in y-direction)
   - `c`: Wave speed
   - `dx`: Spatial step size in x-direction
   - `dy`: Spatial step size in y-direction
   - `dt`: Time step size
   - `steps`: Number of time steps to simulate

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<FdmGrid<f64>, String>` with
 the final wave field grid.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_physics_fdm_wave_json(const char *aInput)
;

/*
 Solves 1D Poisson using FEM and returns a flat array of doubles.
 The caller is responsible for freeing the memory using rssn_free_f64_array.
 */
rssn_
double *rssn_physics_fem_solve_poisson_1d(size_t aNElements,
                                          double aDomainLength,
                                          size_t *aOutSize)
;

/*
 Solves the 1D Poisson equation using Finite Element Method (FEM) via bincode serialization.

 The Poisson equation -d²u/dx² = f(x) is solved using linear finite elements
 with homogeneous Dirichlet boundary conditions (u = 0 at boundaries).

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `Poisson1DInput` with:
   - `n_elements`: Number of finite elements in the mesh
   - `domain_length`: Total length of the 1D domain

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<f64>, String>` with either:
 - `ok`: Solution vector u at nodal points
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_physics_fem_solve_poisson_1d_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Solves the 1D Poisson equation using Finite Element Method (FEM) via JSON serialization.

 The Poisson equation -d²u/dx² = f(x) is solved using linear finite elements
 with homogeneous Dirichlet boundary conditions (u = 0 at boundaries).

 # Arguments

 * `input` - A JSON string pointer containing:
   - `n_elements`: Number of finite elements in the mesh
   - `domain_length`: Total length of the 1D domain

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the solution vector u at nodal points.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_physics_fem_solve_poisson_1d_json(const char *aInput)
;

/*
 Solves the 1D advection equation using Finite Volume Method (FVM) via JSON serialization.

 The advection equation ∂u/∂t + v∂u/∂x = 0 models conservative transport
 of a scalar quantity u with constant velocity v.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `num_cells`: Number of cells in the mesh
   - `domain_size`: Total length of the 1D domain
   - `velocity`: Advection velocity v
   - `dt`: Time step size
   - `steps`: Number of time steps to simulate
   - `initial_values`: Initial field distribution

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the final field distribution.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_physics_fvm_advection_json(const char *aInput)
;

/*
 Returns a pointer to the mesh data.
 */
rssn_
double *rssn_physics_fvm_mesh_data(struct rssn_Mesh *aMesh)
;

/*
 Frees a Mesh handle.
 */
rssn_
void rssn_physics_fvm_mesh_free(struct rssn_Mesh *aMesh)
;

/*
 Creates a new Mesh handle.
 */
rssn_
struct rssn_Mesh *rssn_physics_fvm_mesh_new(size_t aNumCells,
                                            double aDomainSize)
;

/*
 Simulates 1D advection and returns the final values in a new buffer.
 */
rssn_
double *rssn_physics_fvm_simulate_advection_1d(void)
;

/*
 Solves the 1D shallow water equations using Finite Volume Method (FVM) via bincode serialization.

 The shallow water equations model conservation of mass and momentum in free-surface flows:
 ∂h/∂t + ∂(hu)/∂x = 0 and ∂(hu)/∂t + ∂(hu² + gh²/2)/∂x = 0.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `SweInput` with:
   - `h`: Initial water depth distribution
   - `hu`: Initial momentum (h×velocity) distribution
   - `dx`: Spatial step size
   - `dt`: Time step size
   - `steps`: Number of time steps to simulate
   - `g`: Gravitational acceleration

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<SweState>, String>` with either:
 - `ok`: Time series of shallow water states (h, hu)
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_physics_fvm_swe_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Solves the 1D shallow water equations using Finite Volume Method (FVM) via JSON serialization.

 The shallow water equations model conservation of mass and momentum in free-surface flows:
 ∂h/∂t + ∂(hu)/∂x = 0 and ∂(hu)/∂t + ∂(hu² + gh²/2)/∂x = 0.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `h`: Initial water depth distribution
   - `hu`: Initial momentum (h×velocity) distribution
   - `dx`: Spatial step size
   - `dt`: Time step size
   - `steps`: Number of time steps to simulate
   - `g`: Gravitational acceleration

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<SweState>, String>` with
 the time series of shallow water states (h, hu).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_physics_fvm_swe_json(const char *aInput)
;

/*
 Simulates the dam break scenario and returns the final particle positions as a Matrix handle (Nx2).
 */
rssn_
struct rssn_Matrix_f64 *rssn_physics_mm_simulate_dam_break(void)
;

/*
 Simulates a 2D dam break scenario using SPH method via JSON serialization.

 Models the collapse of a water column and its subsequent flow, a classical
 validation case for SPH fluid simulation.

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<(f64, f64)>, String>` with
 particle positions (x, y) after simulation.

 # Safety

 This function is unsafe because it returns a raw C string pointer that the
 caller must free.
 */
rssn_
char *rssn_physics_mm_simulate_dam_break_json(void)
;

/*
 Adds a particle to the SPH system.
 */
rssn_
void rssn_physics_mm_sph_add_particle(struct rssn_SPHSystem *aSystem,
                                      double aX,
                                      double aY,
                                      double aVx,
                                      double aVy,
                                      double aMass)
;

/*
 Creates a new SPH system.
 */
rssn_
struct rssn_SPHSystem *rssn_physics_mm_sph_create(double aH,
                                                  double aBoundsX,
                                                  double aBoundsY)
;

/*
 Frees an SPH system.
 */
rssn_
void rssn_physics_mm_sph_free(struct rssn_SPHSystem *aSystem)
;

/*
 Returns the number of particles in the SPH system.
 */
rssn_
size_t rssn_physics_mm_sph_get_particle_count(struct rssn_SPHSystem *aSystem)
;

/*
 Gets particle positions as a Matrix (Nx2).
 */
rssn_
struct rssn_Matrix_f64 *rssn_physics_mm_sph_get_positions(struct rssn_SPHSystem *aSystem)
;

/*
 Updates the SPH system by one time step.
 */
rssn_
void rssn_physics_mm_sph_update(struct rssn_SPHSystem *aSystem,
                                double aDt)
;

/*
 Updates a Smoothed Particle Hydrodynamics (SPH) system by one time step via bincode serialization.

 SPH is a meshfree Lagrangian method for simulating fluid dynamics by representing
 the continuum as a set of particles with smoothed properties.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `SphInput` with:
   - `system`: SPH system state (particles with positions, velocities, densities, etc.)
   - `dt`: Time step size

 # Returns

 A bincode-encoded buffer containing `FfiResult<SPHSystem, String>` with either:
 - `ok`: Updated SPH system state after time step
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_physics_mm_sph_update_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Updates a Smoothed Particle Hydrodynamics (SPH) system by one time step via JSON serialization.

 SPH is a meshfree Lagrangian method for simulating fluid dynamics by representing
 the continuum as a set of particles with smoothed properties.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `system`: SPH system state (particles with positions, velocities, densities, etc.)
   - `dt`: Time step size

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<SPHSystem, String>` with
 the updated SPH system state after time step.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_physics_mm_sph_update_json(const char *aInput)
;

/*
 Solves 1D Poisson using Multigrid and returns a flat array of doubles.
 The `out_size` will be set to `n + 2` (including boundaries).
 The caller is responsible for freeing the memory using rssn_free_f64_mtm_array.
 */
rssn_
double *rssn_physics_mtm_solve_poisson_1d(size_t aNInterior,
                                          const double *aF,
                                          size_t aNumCycles,
                                          size_t *aOutSize)
;

/*
 Solves the 1D Poisson equation using Multigrid Method via JSON serialization.

 The Poisson equation -d²u/dx² = f is solved using the multigrid method, which achieves
 optimal O(N) complexity through hierarchical coarse-grid correction.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `n_interior`: Number of interior grid points
   - `f`: Right-hand side source term
   - `num_cycles`: Number of V-cycles or W-cycles to perform

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the solution vector u.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_physics_mtm_solve_poisson_1d_json(const char *aInput)
;

/*
 Solves 2D Poisson using Multigrid and returns a flat array of doubles.
 The `out_size` will be set to `n * n`.
 */
rssn_
double *rssn_physics_mtm_solve_poisson_2d(size_t aN,
                                          const double *aF,
                                          size_t aNumCycles,
                                          size_t *aOutSize)
;

/*
 Solves the 2D Poisson equation using Multigrid Method via bincode serialization.

 The Poisson equation ∇²u = f is solved using the multigrid method, which achieves
 optimal O(N) complexity through hierarchical coarse-grid correction.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `Multigrid2DInput` with:
   - `n`: Grid size (n×n interior points)
   - `f`: Right-hand side source term (flattened 2D array)
   - `num_cycles`: Number of V-cycles or W-cycles to perform

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<f64>, String>` with either:
 - `ok`: Solution vector u (flattened 2D array)
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_physics_mtm_solve_poisson_2d_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Solves the 2D Poisson equation using Multigrid Method via JSON serialization.

 The Poisson equation ∇²u = f is solved using the multigrid method, which achieves
 optimal O(N) complexity through hierarchical coarse-grid correction.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `n`: Grid size (n×n interior points)
   - `f`: Right-hand side source term (flattened 2D array)
   - `num_cycles`: Number of V-cycles or W-cycles to perform

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the solution vector u (flattened 2D array).

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_physics_mtm_solve_poisson_2d_json(const char *aInput)
;

/*
 Solves the damped oscillator system using RK4 method via JSON serialization.

 The damped harmonic oscillator is defined by:
 d²x/dt² + 2ζωdx/dt + ω²x = 0.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `omega`: Natural frequency ω
   - `zeta`: Damping ratio ζ
   - `y0`: Initial state [x₀, v₀]
   - `t_span`: Time interval [t_start, t_end]
   - `dt`: Time step size

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<OdeResult, String>` with
 `time` and `states` arrays.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_physics_rkm_damped_oscillator_json(const char *aInput)
;

/*
 Solves the Lorenz system using adaptive Dormand-Prince RK5(4) method via bincode serialization.

 The Lorenz system is a chaotic dynamical system defined by:
 dx/dt = σ(y - x), dy/dt = x(ρ - z) - y, dz/dt = xy - βz.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `LorenzInput` with:
   - `sigma`: Prandtl number σ
   - `rho`: Rayleigh number ρ
   - `beta`: Geometric parameter β
   - `y0`: Initial state [x₀, y₀, z₀]
   - `t_span`: Time interval (t_start, t_end)
   - `dt_initial`: Initial time step size
   - `tol`: Error tolerances (absolute, relative)

 # Returns

 A bincode-encoded buffer containing `FfiResult<OdeResult, String>` with either:
 - `ok`: Object containing `time` and `states` arrays
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_physics_rkm_lorenz_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Solves the Lorenz system using adaptive Dormand-Prince RK5(4) method via JSON serialization.

 The Lorenz system is a chaotic dynamical system defined by:
 dx/dt = σ(y - x), dy/dt = x(ρ - z) - y, dz/dt = xy - βz.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `sigma`: Prandtl number σ
   - `rho`: Rayleigh number ρ
   - `beta`: Geometric parameter β
   - `y0`: Initial state [x₀, y₀, z₀]
   - `t_span`: Time interval [t_start, t_end]
   - `dt_initial`: Initial time step size
   - `tol`: Error tolerances [absolute, relative]

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<OdeResult, String>` with
 `time` and `states` arrays.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_physics_rkm_lorenz_json(const char *aInput)
;

/*
 Solves the Lotka-Volterra predator-prey system using Bogacki-Shampine RK2(3) via JSON serialization.

 The Lotka-Volterra equations model population dynamics:
 dx/dt = αx - βxy, dy/dt = δxy - γy.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `alpha`: Prey growth rate α
   - `beta`: Predation rate β
   - `delta`: Predator efficiency δ
   - `gamma`: Predator death rate γ
   - `y0`: Initial state [prey₀, predator₀]
   - `t_span`: Time interval [t_start, t_end]
   - `dt_initial`: Initial time step size
   - `tol`: Error tolerances [absolute, relative]

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<OdeResult, String>` with
 `time` and `states` arrays.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_physics_rkm_lotka_volterra_json(const char *aInput)
;

/*
 Simulates the damped oscillator scenario and returns the results as a Matrix handle.
 */
rssn_
struct rssn_Matrix_f64 *rssn_physics_rkm_simulate_damped_oscillator(void)
;

/*
 Simulates the Lorenz attractor scenario and returns the results as a Matrix handle.
 */
rssn_
struct rssn_Matrix_f64 *rssn_physics_rkm_simulate_lorenz(void)
;

/*
 Simulates the Lotka-Volterra predator-prey scenario and returns the results as a Matrix handle.
 */
rssn_
struct rssn_Matrix_f64 *rssn_physics_rkm_simulate_lotka_volterra(void)
;

/*
 Simulates the Van der Pol oscillator scenario and returns the results as a Matrix handle.
 */
rssn_
struct rssn_Matrix_f64 *rssn_physics_rkm_simulate_vanderpol(void)
;

/*
 Solves the Van der Pol oscillator using adaptive Cash-Karp RK4(5) method via JSON serialization.

 The Van der Pol equation models nonlinear oscillations with self-excitation:
 d²x/dt² - μ(1 - x²)dx/dt + x = 0.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `mu`: Nonlinearity parameter μ
   - `y0`: Initial state [x₀, v₀]
   - `t_span`: Time interval [t_start, t_end]
   - `dt_initial`: Initial time step size
   - `tol`: Error tolerances [absolute, relative]

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<OdeResult, String>` with
 `time` and `states` arrays.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_physics_rkm_vanderpol_json(const char *aInput)
;

/*
 Runs a 2D FDTD simulation and returns the final Ez field as a Matrix handle (WxH).
 */
rssn_
struct rssn_Matrix_f64 *rssn_physics_sim_fdtd_run_2d(size_t aWidth,
                                                     size_t aHeight,
                                                     size_t aTimeSteps,
                                                     size_t aSourceX,
                                                     size_t aSourceY,
                                                     double aSourceFreq)
;

/*
 Runs a Finite-Difference Time-Domain (FDTD) electromagnetic simulation via bincode serialization.

 FDTD solves Maxwell's equations ∇×E = -∂B/∂t and ∇×H = ∂D/∂t + J using a staggered
 Yee lattice grid, advancing the electric field Ez and magnetic field components in time.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `FdtdParameters` with:
   - `width`, `height`: Grid dimensions
   - `dx`, `dy`: Spatial discretization steps
   - `dt`: Time step size (must satisfy Courant-Friedrichs-Lewy stability condition)
   - `steps`: Number of time steps to simulate
   - `source_x`, `source_y`: Position of electromagnetic source
   - `source_frequency`: Angular frequency ω of the source

 # Returns

 A bincode-encoded buffer containing `FfiResult<Array2<f64>, String>` with either:
 - `ok`: Final Ez field as a 2D array
 - `err`: Error message if computation failed or no snapshots were produced

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_physics_sim_fdtd_run_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Runs a Finite-Difference Time-Domain (FDTD) electromagnetic simulation via JSON serialization.

 FDTD solves Maxwell's equations ∇×E = -∂B/∂t and ∇×H = ∂D/∂t + J using a staggered
 Yee lattice grid, advancing the electric field Ez and magnetic field components in time.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `width`, `height`: Grid dimensions
   - `dx`, `dy`: Spatial discretization steps
   - `dt`: Time step size (must satisfy Courant-Friedrichs-Lewy stability condition)
   - `steps`: Number of time steps to simulate
   - `source_x`, `source_y`: Position of electromagnetic source
   - `source_frequency`: Angular frequency ω of the source

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<Vec<f64>>, String>` with
 the final Ez field as a 2D vector array.

 # Safety

 This function is unsafe because it dereferences a raw C string pointer.
 */
rssn_
char *rssn_physics_sim_fdtd_run_json(const char *aInput)
;

/*
 Runs a geodesic simulation and returns the resulting path as a Matrix handle (Nx2).
 */
rssn_
struct rssn_Matrix_f64 *rssn_physics_sim_geodesic_run(double aBlackHoleMass,
                                                      double aR0,
                                                      double aRdot0,
                                                      double aPhi0,
                                                      double aPhidot0,
                                                      double aProperTimeEnd,
                                                      double aInitialDt)
;

/*
 Computes a geodesic trajectory in curved spacetime using general relativity via bincode serialization.

 Integrates the geodesic equation d²xᵘ/dτ² + Γᵘᵥᵨ(dxᵥ/dτ)(dxᵨ/dτ) = 0 where Γᵘᵥᵨ are
 Christoffel symbols of the metric tensor, modeling particle motion in curved spacetime
 (e.g., near a black hole using Schwarzschild metric).

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `GeodesicParameters` with:
   - `mass`: Central mass M (e.g., black hole mass)
   - `r0`, `phi0`: Initial radial and angular coordinates
   - `v_r`, `v_phi`: Initial radial and angular velocities
   - `dt`: Time step for integration
   - `steps`: Number of integration steps

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<(f64, f64)>, String>` with
 the geodesic path as (r, φ) coordinate pairs.

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_physics_sim_geodesic_run_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Computes a geodesic trajectory in curved spacetime using general relativity via JSON serialization.

 Integrates the geodesic equation d²xᵘ/dτ² + Γᵘᵥᵨ(dxᵥ/dτ)(dxᵨ/dτ) = 0 where Γᵘᵥᵨ are
 Christoffel symbols of the metric tensor, modeling particle motion in curved spacetime
 (e.g., near a black hole using Schwarzschild metric).

 # Arguments

 * `input` - A JSON string pointer containing:
   - `mass`: Central mass M (e.g., black hole mass)
   - `r0`, `phi0`: Initial radial and angular coordinates
   - `v_r`, `v_phi`: Initial radial and angular velocities
   - `dt`: Time step for integration
   - `steps`: Number of integration steps

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<(f64, f64)>, String>` with
 the geodesic path as (r, φ) coordinate pairs.

 # Safety

 This function is unsafe because it dereferences a raw C string pointer.
 */
rssn_
char *rssn_physics_sim_geodesic_run_json(const char *aInput)
;

/*
 Solves the Gross-Pitaevskii equation (GPE) for Bose-Einstein condensate ground state via bincode serialization.

 The GPE iℏ∂ψ/∂t = [-ℏ²∇²/(2m) + V(r) + g|ψ|²]ψ describes the macroscopic wavefunction
 of a superfluid quantum gas. This solver finds the ground state using imaginary time
 evolution or variational methods.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `GpeParameters` with:
   - `n_points`: Number of spatial grid points
   - `dx`: Spatial discretization step
   - `g`: Nonlinear interaction strength (proportional to scattering length)
   - `v_trap`: External trapping potential coefficients
   - `tolerance`: Convergence tolerance for ground state search
   - `max_iterations`: Maximum iterations for solver

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<f64>, String>` with either:
 - `ok`: Ground state wavefunction ψ(x) as probability density |ψ|²
 - `err`: Error message if computation failed or did not converge

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_physics_sim_gpe_run_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Runs the GPE ground state finder and returns the result as a Matrix handle (Nx x Ny).
 */
rssn_
struct rssn_Matrix_f64 *rssn_physics_sim_gpe_run_ground_state_finder(size_t aNx,
                                                                     size_t aNy,
                                                                     double aLx,
                                                                     double aLy,
                                                                     double aDTau,
                                                                     size_t aTimeSteps,
                                                                     double aG,
                                                                     double aTrapStrength)
;

/*
 Solves the Gross-Pitaevskii equation (GPE) for Bose-Einstein condensate ground state via JSON serialization.

 The GPE iℏ∂ψ/∂t = [-ℏ²∇²/(2m) + V(r) + g|ψ|²]ψ describes the macroscopic wavefunction
 of a superfluid quantum gas. This solver finds the ground state using imaginary time
 evolution or variational methods.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `n_points`: Number of spatial grid points
   - `dx`: Spatial discretization step
   - `g`: Nonlinear interaction strength (proportional to scattering length)
   - `v_trap`: External trapping potential coefficients
   - `tolerance`: Convergence tolerance for ground state search
   - `max_iterations`: Maximum iterations for solver

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the ground state wavefunction ψ(x) as probability density |ψ|².

 # Safety

 This function is unsafe because it dereferences a raw C string pointer.
 */
rssn_
char *rssn_physics_sim_gpe_run_json(const char *aInput)
;

/*
 Frees the Ising result handle.
 */
rssn_
void rssn_physics_sim_ising_free_result(struct rssn_IsingResultHandle aHandle)
;

/*
 Runs a 2D Ising model simulation and returns the final grid as a Matrix handle and the magnetization.
 */
rssn_
struct rssn_IsingResultHandle rssn_physics_sim_ising_run(size_t aWidth,
                                                         size_t aHeight,
                                                         double aTemperature,
                                                         size_t aMcSteps)
;

/*
 Runs a 2D Ising model Monte Carlo simulation using the Metropolis algorithm via bincode serialization.

 The Ising model with Hamiltonian H = -J∑⟨i,j⟩sᵢsⱼ - h∑ᵢsᵢ describes phase transitions
 in magnetic systems. The simulation uses Metropolis-Hastings sampling to evolve spin
 configurations toward thermal equilibrium.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `IsingParameters` with:
   - `width`, `height`: Grid dimensions
   - `temperature`: Temperature T in units of J/k_B
   - `mc_steps`: Number of Monte Carlo sweeps to perform

 # Returns

 A bincode-encoded buffer containing `FfiResult<IsingOutput, String>` with either:
 - `ok`: Object containing:
   - `grid`: Final spin configuration (±1 values)
   - `magnetization`: Average magnetization M = ⟨∑ᵢsᵢ⟩/N
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_physics_sim_ising_run_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Runs a 2D Ising model Monte Carlo simulation using the Metropolis algorithm via JSON serialization.

 The Ising model with Hamiltonian H = -J∑⟨i,j⟩sᵢsⱼ - h∑ᵢsᵢ describes phase transitions
 in magnetic systems. The simulation uses Metropolis-Hastings sampling to evolve spin
 configurations toward thermal equilibrium.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `width`, `height`: Grid dimensions
   - `temperature`: Temperature T in units of J/k_B
   - `mc_steps`: Number of Monte Carlo sweeps to perform

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<IsingOutput, String>` with:
 - `grid`: Final spin configuration (±1 values)
 - `magnetization`: Average magnetization M = ⟨∑ᵢsᵢ⟩/N

 # Safety

 This function is unsafe because it dereferences a raw C string pointer.
 */
rssn_
char *rssn_physics_sim_ising_run_json(const char *aInput)
;

/*
 Solves the linear elasticity equations for stress and displacement in a deformable solid via bincode serialization.

 The elasticity equations σᵢⱼ = Cᵢⱼₖₗεₖₗ with strain εᵢⱼ = ½(∂uᵢ/∂xⱼ + ∂uⱼ/∂xᵢ) describe
 small deformations in elastic materials, where σ is stress tensor, ε is strain tensor,
 u is displacement field, and C is the stiffness tensor.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `ElasticityParameters` with:
   - `nx`, `ny`: Grid dimensions for finite element discretization
   - `young_modulus`: Young's modulus E (stiffness)
   - `poisson_ratio`: Poisson's ratio ν (lateral contraction)
   - `applied_force`: External force distribution
   - `boundary_conditions`: Fixed displacement constraints

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<f64>, String>` with either:
 - `ok`: Displacement field u(x,y) as flattened vector
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_physics_sim_linear_elasticity_run_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Solves the linear elasticity equations for stress and displacement in a deformable solid via JSON serialization.

 The elasticity equations σᵢⱼ = Cᵢⱼₖₗεₖₗ with strain εᵢⱼ = ½(∂uᵢ/∂xⱼ + ∂uⱼ/∂xᵢ) describe
 small deformations in elastic materials, where σ is stress tensor, ε is strain tensor,
 u is displacement field, and C is the stiffness tensor.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `nx`, `ny`: Grid dimensions for finite element discretization
   - `young_modulus`: Young's modulus E (stiffness)
   - `poisson_ratio`: Poisson's ratio ν (lateral contraction)
   - `applied_force`: External force distribution
   - `boundary_conditions`: Fixed displacement constraints

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the displacement field u(x,y) as a flattened vector.

 # Safety

 This function is unsafe because it dereferences a raw C string pointer.
 */
rssn_
char *rssn_physics_sim_linear_elasticity_run_json(const char *aInput)
;

/*
 Runs the 2D cantilever beam scenario and returns the displacement results as a Matrix handle (Nx2).
 */
rssn_
struct rssn_Matrix_f64 *rssn_physics_sim_linear_elasticity_simulate_cantilever(void)
;

/*
 Frees the result handles.
 */
rssn_
void rssn_physics_sim_navier_stokes_free_results(struct rssn_NavierStokesResultHandles aHandles)
;

/*
 Solves the incompressible Navier-Stokes equations for fluid flow in a lid-driven cavity via bincode serialization.

 The Navier-Stokes equations ∂u/∂t + (u·∇)u = -∇p/ρ + ν∇²u with incompressibility
 constraint ∇·u = 0 govern viscous fluid dynamics. This solver uses a projection method
 to enforce divergence-free velocity fields.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `NavierStokesParameters` with:
   - `nx`, `ny`: Grid dimensions
   - `re`: Reynolds number Re = UL/ν (ratio of inertial to viscous forces)
   - `dt`: Time step size
   - `n_iter`: Number of time iterations
   - `lid_velocity`: Velocity of the moving lid boundary

 # Returns

 A bincode-encoded buffer containing `FfiResult<NavierStokesOutputData, String>` with either:
 - `ok`: Object containing:
   - `u`: Horizontal velocity field u(x,y)
   - `v`: Vertical velocity field v(x,y)
   - `p`: Pressure field p(x,y)
 - `err`: Error message if computation failed

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_physics_sim_navier_stokes_run_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Solves the incompressible Navier-Stokes equations for fluid flow in a lid-driven cavity via JSON serialization.

 The Navier-Stokes equations ∂u/∂t + (u·∇)u = -∇p/ρ + ν∇²u with incompressibility
 constraint ∇·u = 0 govern viscous fluid dynamics. This solver uses a projection method
 to enforce divergence-free velocity fields.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `nx`, `ny`: Grid dimensions
   - `re`: Reynolds number Re = UL/ν (ratio of inertial to viscous forces)
   - `dt`: Time step size
   - `n_iter`: Number of time iterations
   - `lid_velocity`: Velocity of the moving lid boundary

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<NavierStokesOutputData, String>` with:
 - `u`: Horizontal velocity field u(x,y)
 - `v`: Vertical velocity field v(x,y)
 - `p`: Pressure field p(x,y)

 # Safety

 This function is unsafe because it dereferences a raw C string pointer.
 */
rssn_
char *rssn_physics_sim_navier_stokes_run_json(const char *aInput)
;

/*
 Runs the lid-driven cavity simulation and returns handles to the U, V, and P matrices.
 */
rssn_
struct rssn_NavierStokesResultHandles rssn_physics_sim_navier_stokes_run_lid_driven_cavity(size_t aNx,
                                                                                           size_t aNy,
                                                                                           double aRe,
                                                                                           double aDt,
                                                                                           size_t aNIter,
                                                                                           double aLidVelocity)
;

/*
 Runs a Schrodinger simulation and returns the final probability density as a Matrix handle (NxxNy).
 */
rssn_
struct rssn_Matrix_f64 *rssn_physics_sim_schrodinger_run_2d(size_t aNx,
                                                            size_t aNy,
                                                            double aLx,
                                                            double aLy,
                                                            double aDt,
                                                            size_t aTimeSteps,
                                                            double aHbar,
                                                            double aMass,
                                                            const double *aPotentialPtr,
                                                            const double *aInitialPsiRePtr,
                                                            const double *aInitialPsiImPtr)
;

/*
 Solves the time-dependent Schrödinger equation for quantum wavefunction evolution via bincode serialization.

 The Schrödinger equation iℏ∂ψ/∂t = Ĥψ where Ĥ = -ℏ²∇²/(2m) + V(r) governs quantum
 mechanical evolution of the wavefunction ψ(r,t) under a potential V. This solver uses
 the Crank-Nicolson or split-operator method for unitary time evolution.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `SchrodingerInput` with:
   - `params`: Schrödinger parameters including:
     - `n_points`: Number of spatial grid points
     - `dx`: Spatial discretization step
     - `dt`: Time step size
     - `steps`: Number of time steps
     - `potential`: External potential V(x) values
   - `initial_psi_re`: Real part of initial wavefunction ψ(x,0)
   - `initial_psi_im`: Imaginary part of initial wavefunction ψ(x,0)

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<f64>, String>` with either:
 - `ok`: Final probability density |ψ(x,t)|² as a vector
 - `err`: Error message if computation failed or produced no snapshots

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_physics_sim_schrodinger_run_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Solves the time-dependent Schrödinger equation for quantum wavefunction evolution via JSON serialization.

 The Schrödinger equation iℏ∂ψ/∂t = Ĥψ where Ĥ = -ℏ²∇²/(2m) + V(r) governs quantum
 mechanical evolution of the wavefunction ψ(r,t) under a potential V. This solver uses
 the Crank-Nicolson or split-operator method for unitary time evolution.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `params`: Schrödinger parameters including:
     - `n_points`: Number of spatial grid points
     - `dx`: Spatial discretization step
     - `dt`: Time step size
     - `steps`: Number of time steps
     - `potential`: External potential V(x) values
   - `initial_psi_re`: Real part of initial wavefunction ψ(x,0)
   - `initial_psi_im`: Imaginary part of initial wavefunction ψ(x,0)

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the final probability density |ψ(x,t)|² as a vector.

 # Safety

 This function is unsafe because it dereferences a raw C string pointer.
 */
rssn_
char *rssn_physics_sim_schrodinger_run_json(const char *aInput)
;

/*
 Simulates the 1D advection-diffusion scenario and returns the results as a Matrix handle (1xN).
 */
rssn_
struct rssn_Matrix_f64 *rssn_physics_sm_simulate_1d_advection(void)
;

/*
 Simulates the 2D advection-diffusion scenario and returns the results as a Matrix handle (WxH).
 */
rssn_
struct rssn_Matrix_f64 *rssn_physics_sm_simulate_2d_advection(void)
;

/*
 Solves the 1D advection-diffusion equation using spectral methods via JSON serialization.

 The 1D advection-diffusion equation ∂u/∂t + c∂u/∂x = D∂²u/∂x² models scalar transport
 with velocity c and diffusivity D. Spectral methods provide exponential convergence
 for smooth solutions.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `initial_condition`: Initial scalar field u(x,0)
   - `dx`: Spatial step size
   - `c`: Advection velocity
   - `d`: Diffusion coefficient D
   - `dt`: Time step size
   - `steps`: Number of time steps

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the final scalar field u(x,t).

 # Safety

 This function is unsafe because it dereferences a raw C string pointer.
 */
rssn_
char *rssn_physics_sm_solve_advection_1d_json(const char *aInput)
;

/*
 Solves the 2D advection-diffusion equation using spectral methods via bincode serialization.

 The advection-diffusion equation ∂u/∂t + c·∇u = D∇²u models transport phenomena
 combining convective transport (advection) and diffusive spreading. Spectral methods
 use Fourier basis functions for high-order accuracy.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing:
   - `initial_condition`: Initial scalar field u(x,y,0) as flattened vector
   - `config`: Configuration including:
     - `nx`, `ny`: Grid dimensions
     - `dx`, `dy`: Spatial steps
     - `cx`, `cy`: Advection velocities in x and y directions
     - `d`: Diffusion coefficient D
     - `dt`: Time step size
     - `steps`: Number of time steps

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<f64>, String>` with
 the final scalar field u(x,y,t) as a flattened vector.

 # Safety

 This function is unsafe because it receives a raw bincode buffer that must be
 valid and properly encoded.
 */
rssn_
struct rssn_BincodeBuffer rssn_physics_sm_solve_advection_2d_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Solves the 2D advection-diffusion equation using spectral methods via JSON serialization.

 The 2D advection-diffusion equation ∂u/∂t + c·∇u = D∇²u models transport phenomena
 combining convective transport (advection) and diffusive spreading. Spectral methods
 use Fourier basis functions for high-order accuracy.

 # Arguments

 * `input` - A JSON string pointer containing:
   - `initial_condition`: Initial scalar field u(x,y,0) as flattened vector
   - `config`: Configuration including:
     - `nx`, `ny`: Grid dimensions
     - `dx`, `dy`: Spatial steps
     - `cx`, `cy`: Advection velocities in x and y directions
     - `d`: Diffusion coefficient D
     - `dt`: Time step size
     - `steps`: Number of time steps

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 the final scalar field u(x,y,t) as a flattened vector.

 # Safety

 This function is unsafe because it dereferences a raw C string pointer.
 */
rssn_
char *rssn_physics_sm_solve_advection_2d_json(const char *aInput)
;

/*
 Returns the symbolic representation of Pi.
 */
rssn_
struct rssn_Expr *rssn_pi(void)
;

/*
 Returns Pi as bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_pi_bincode(void)
;

/*
 Returns Pi as JSON.
 */
rssn_ char *rssn_pi_json(void) ;

/*
 Executes a command on a loaded plugin.

 # Arguments
 * `plugin_name_ptr` - A null-terminated UTF-8 string representing the plugin's name.
 * `command_ptr` - A null-terminated UTF-8 string for the command to execute.
 * `args_handle` - A handle to the `Expr` object to be passed as an argument.

 # Returns
 A handle to the resulting `Expr` object on success, or 0 on failure.
 On failure, an error message can be retrieved with `rssn_get_last_error`.
 */
rssn_
DEPRECATED_WITH_NOTE
size_t rssn_plugin_execute(const char *aPluginNamePtr,
                           const char *aCommandPtr,
                           size_t aArgsHandle)
;

/*
 Executes a plugin command.

 # Arguments
 * `name` - Plugin name.
 * `command` - Command string.
 * `args_handle` - Handle to the argument expression.

 # Returns
 Handle to the result expression, or 0 on error.
 */
rssn_
size_t rssn_plugins_execute(const char *aName,
                            const char *aCommand,
                            size_t aArgsHandle)
;

/*
 Executes a plugin command via Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_plugins_execute_bincode(const uint8_t *aData,
                                                       size_t aLen)
;

/*
 Executes a plugin command via JSON (args passed as JSON expr).
 */
rssn_
char *rssn_plugins_execute_json(const char *aJsonPtr)
;

/*
 Returns a JSON array of loaded plugin names.

 The caller must free the string using `rssn_free_string`.
 */
rssn_
char *rssn_plugins_get_loaded(void)
;

/*
 Loads plugins from a specified directory.

 # Arguments
 * `path` - Path to the plugin directory.

 # Returns
 True if successful, false otherwise.
 */
rssn_
bool rssn_plugins_load(const char *aPath)
;

/*
 Unloads a plugin by name.
 */
rssn_
bool rssn_plugins_unload(const char *aName)
;

/*
 Compresses a point. Returns the x-coordinate string. sets *is_odd to the parity.
 */
rssn_
char *rssn_point_compress(const struct rssn_CurvePoint *aPoint,
                          bool *aIsOddOut)
;

/*
 Decompresses a point.
 */
rssn_
struct rssn_CurvePoint *rssn_point_decompress(const char *aXStr,
                                              bool aIsOdd,
                                              const struct rssn_EllipticCurve *aCurve)
;

/*
 Returns a cloned pole expression at the given index.

 # Arguments

 * `poles` - Pointer to a vector of pole expressions as returned by `rssn_find_poles`.
 * `index` - Zero-based index of the pole to retrieve.

 # Returns

 A newly allocated `Expr` pointer to the selected pole, or null if the pointer is
 null or the index is out of bounds.

 # Safety

 This function is unsafe because it dereferences a raw pointer to a `Vec<Expr>` and
 returns ownership of a heap-allocated `Expr` to the caller.
 */
rssn_
struct rssn_Expr *rssn_poles_get(const struct rssn_Vec_Expr *aPoles,
                                 size_t aIndex)
;

/*
 Returns the number of poles found for a given expression.

 # Arguments

 * `poles` - Pointer to a vector of pole expressions as returned by `rssn_find_poles`.

 # Returns

 The number of poles in the vector, or 0 if the pointer is null.

 # Safety

 This function is unsafe because it dereferences a raw pointer to a `Vec<Expr>`.
 */
rssn_
size_t rssn_poles_len(const struct rssn_Vec_Expr *aPoles)
;

/*
 Adds two polynomials over a general finite field.

 # Safety
 Caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_poly_add_gf(const struct rssn_Expr *aP1,
                                   const struct rssn_Expr *aP2,
                                   const struct rssn_Arc_FiniteField *aField)
;

/*
 Adds two polynomials over GF(2^8).

 # Safety
 Caller must ensure pointers are valid. Result is allocated and must be freed.
 */
rssn_
uint8_t *rssn_poly_add_gf256(const uint8_t *aP1,
                             size_t aP1Len,
                             const uint8_t *aP2,
                             size_t aP2Len,
                             size_t *aOutLen)
;

/*
 Computes the degree of a polynomial expression with respect to a given variable.

 # Arguments
 * `expr_handle` - A handle to the expression to check.
 * `var_ptr` - A pointer to a null-terminated C string representing the variable.
 * `result` - A pointer to store the degree of the polynomial.

 # Returns
 0 on success, -1 on error (e.g., null pointer, invalid handle).

 # Safety
 The `var_ptr` must point to a valid null-terminated C string.
 The `result` pointer must point to a valid `i64` location.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_poly_degree(size_t aExprHandle,
                         const char *aVarPtr,
                         int64_t *aResult)
;

/*
 Computes the formal derivative of a polynomial in GF(2^8).

 # Safety
 Caller must ensure pointer is valid. Result is allocated and must be freed.
 */
rssn_
uint8_t *rssn_poly_derivative_gf256(const uint8_t *aPoly,
                                    size_t aLen,
                                    size_t *aOutLen)
;

/*
 Computes polynomial derivative over finite field (Handle)
 */
rssn_
struct rssn_FiniteFieldPolynomial *rssn_poly_derivative_gf_handle(const struct rssn_FiniteFieldPolynomial *aPoly)
;

/*
 Evaluates a polynomial over GF(2^8) at point x.

 # Safety
 Caller must ensure `poly` is a valid pointer to an array of `len` bytes.
 */
rssn_
uint8_t rssn_poly_eval_gf256(const uint8_t *aPoly,
                             size_t aLen,
                             uint8_t aX)
;

/*
 Computes the GCD of two polynomials over GF(2^8).

 # Safety
 Caller must ensure pointers are valid. Result is allocated and must be freed.
 */
rssn_
uint8_t *rssn_poly_gcd_gf256(const uint8_t *aP1,
                             size_t aP1Len,
                             const uint8_t *aP2,
                             size_t aP2Len,
                             size_t *aOutLen)
;

/*
 Computes polynomial GCD over finite field (Handle)
 */
rssn_
struct rssn_FiniteFieldPolynomial *rssn_poly_gcd_gf_handle(const struct rssn_FiniteFieldPolynomial *aA,
                                                           const struct rssn_FiniteFieldPolynomial *aB)
;

/*
 Checks if an expression is a polynomial with respect to a given variable.

 # Arguments
 * `expr_handle` - A handle to the expression to check.
 * `var_ptr` - A pointer to a null-terminated C string representing the variable.
 * `result` - A pointer to store the boolean result (true if it's a polynomial, false otherwise).

 # Returns
 0 on success, -1 on error (e.g., null pointer, invalid handle).

 # Safety
 The `var_ptr` must point to a valid null-terminated C string.
 The `result` pointer must point to a valid boolean location.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_poly_is_polynomial(size_t aExprHandle,
                                const char *aVarPtr,
                                bool *aResult)
;

/*
 Performs polynomial long division on two expressions with respect to a given variable.

 # Arguments
 * `n_handle` - A handle to the numerator expression.
 * `d_handle` - A handle to the denominator expression.
 * `var_ptr` - A pointer to a null-terminated C string representing the variable.
 * `q_handle` - A pointer to store the handle of the quotient expression.
 * `r_handle` - A pointer to store the handle of the remainder expression.

 # Returns
 0 on success, -1 on error (e.g., null pointer, invalid handle).

 # Safety
 The `var_ptr` must point to a valid null-terminated C string.
 The `q_handle` and `r_handle` pointers must point to valid `usize` locations.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_poly_long_division(size_t aNHandle,
                                size_t aDHandle,
                                const char *aVarPtr,
                                size_t *aQHandle,
                                size_t *aRHandle)
;

/*
 Multiplies two polynomials over a general finite field.

 # Safety
 Caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_poly_mul_gf(const struct rssn_Expr *aP1,
                                   const struct rssn_Expr *aP2,
                                   const struct rssn_Arc_FiniteField *aField)
;

/*
 Multiplies two polynomials over GF(2^8).

 # Safety
 Caller must ensure pointers are valid. Result is allocated and must be freed.
 */
rssn_
uint8_t *rssn_poly_mul_gf256(const uint8_t *aP1,
                             size_t aP1Len,
                             const uint8_t *aP2,
                             size_t aP2Len,
                             size_t *aOutLen)
;

/*
 Scales a polynomial by a constant in GF(2^8).

 # Safety
 Caller must ensure pointer is valid. Result is allocated and must be freed.
 */
rssn_
uint8_t *rssn_poly_scale_gf256(const uint8_t *aPoly,
                               size_t aLen,
                               uint8_t aScalar,
                               size_t *aOutLen)
;

/*
 Computes the symbolic Polygamma function ψ⁽ⁿ⁾(z).
 */
rssn_
struct rssn_Expr *rssn_polygamma(const struct rssn_Expr *aN,
                                 const struct rssn_Expr *aZ)
;

/*
 Frees a polygon mesh.
 */
rssn_
void rssn_polygon_mesh_free(struct rssn_PolygonMesh *aMesh)
;

/*
 Creates a new polygon mesh.
 */
rssn_
struct rssn_PolygonMesh *rssn_polygon_mesh_new(const rssn_Vector *aVertices,
                                               size_t aVertexCount)
;

/*
 Triangulates a polygon mesh.
 */
rssn_
struct rssn_PolygonMesh *rssn_polygon_mesh_triangulate(const struct rssn_PolygonMesh *aMesh)
;

/*
 Performs a polynomial regression.

 Takes raw pointers to arrays of `Expr` (x and y data), the length of the data,
 and the degree of the polynomial.
 Returns a raw pointer to an `Expr` (vector) containing the coefficients of the polynomial.
 */
rssn_
struct rssn_Expr *rssn_polynomial_regression(const struct rssn_Expr *const *aXData,
                                             const struct rssn_Expr *const *aYData,
                                             size_t aLen,
                                             size_t aDegree)
;

/*
 Creates a power expression: base^exp.
 */
rssn_
struct rssn_Expr *rssn_pow(const struct rssn_Expr *aBase,
                           const struct rssn_Expr *aExp)
;

/*
 Creates a power expression from bincode: base^exp.

 # Arguments
 * `base_buffer` - Bincode-serialized base Expr
 * `exp_buffer` - Bincode-serialized exponent Expr
 */
rssn_
struct rssn_BincodeBuffer rssn_pow_bincode(struct rssn_BincodeBuffer aBaseBuffer,
                                           struct rssn_BincodeBuffer aExpBuffer)
;

/*
 Creates a power expression from JSON: base^exp.

 # Arguments
 * `json_base` - JSON-serialized base Expr
 * `json_exp` - JSON-serialized exponent Expr
 */
rssn_
char *rssn_pow_json(const char *aJsonBase,
                    const char *aJsonExp)
;

/*
 Calculates power: F . v.
 */
rssn_
struct rssn_Expr *rssn_power(const rssn_Vector *aForce,
                             const rssn_Vector *aVelocity)
;

/*
 Calculates the Poynting vector.
 */
rssn_
rssn_Vector *rssn_poynting_vector(const rssn_Vector *aEField,
                                  const rssn_Vector *aBField)
;

/*
 Adds two prime field elements (Handle)
 */
rssn_
struct rssn_PrimeFieldElement *rssn_prime_field_element_add_handle(const struct rssn_PrimeFieldElement *aA,
                                                                   const struct rssn_PrimeFieldElement *aB)
;

/*
 Frees a prime field element (Handle)
 */
rssn_
void rssn_prime_field_element_free_handle(struct rssn_PrimeFieldElement *aElem)
;

/*
 Computes the inverse of a prime field element (Handle)
 */
rssn_
struct rssn_PrimeFieldElement *rssn_prime_field_element_inverse_handle(const struct rssn_PrimeFieldElement *aElem)
;

/*
 Multiplies two prime field elements (Handle)
 */
rssn_
struct rssn_PrimeFieldElement *rssn_prime_field_element_mul_handle(const struct rssn_PrimeFieldElement *aA,
                                                                   const struct rssn_PrimeFieldElement *aB)
;

/*
 Creates a new prime field element (Handle)
 Returns a boxed pointer to the element
 */
rssn_
struct rssn_PrimeFieldElement *rssn_prime_field_element_new_handle(const rssn_BigInt *aValue,
                                                                   const rssn_BigInt *aModulus)
;

/*
 Computes the probability density |ψ(x)|^2.
 */
rssn_
struct rssn_Expr *rssn_probability_density(const struct rssn_Ket *aPsi)
;

/*
 Computes the product of an expression.

 Takes a raw pointer to `Expr` (expression), a C-style string (variable),
 raw pointers to `Expr` (lower bound), and `Expr` (upper bound).
 Returns a raw pointer to a new `Expr` representing the product.
 */
rssn_
struct rssn_Expr *rssn_product_handle(const struct rssn_Expr *aExpr,
                                      const char *aVar,
                                      const struct rssn_Expr *aLower,
                                      const struct rssn_Expr *aUpper)
;

/*
 Projects one function onto another within a Hilbert space.

 # Arguments
 * `space` - Handle to the Hilbert space.
 * `f` - Handle to the function to project.
 * `g` - Handle to the function onto which $f$ is projected.

 # Returns
 A raw pointer to the resulting projection expression.
 */
rssn_
struct rssn_Expr *rssn_project(const struct rssn_HilbertSpace *aSpace,
                               const struct rssn_Expr *aF,
                               const struct rssn_Expr *aG)
;

/*
 Lagrangian density for QCD.
 */
rssn_
struct rssn_Expr *rssn_qcd_lagrangian(const struct rssn_Expr *aPsiBar,
                                      const struct rssn_Expr *aPsi,
                                      const struct rssn_Expr *aGMu,
                                      const struct rssn_Expr *aM,
                                      const struct rssn_Expr *aGs)
;

/*
 Lagrangian density for QED.
 */
rssn_
struct rssn_Expr *rssn_qed_lagrangian(const struct rssn_Expr *aPsiBar,
                                      const struct rssn_Expr *aPsi,
                                      const struct rssn_Expr *aAMu,
                                      const struct rssn_Expr *aM,
                                      const struct rssn_Expr *aE)
;

/*
 Computes a propagator for a particle in QFT.
 */
rssn_
struct rssn_Expr *rssn_qft_propagator(const struct rssn_Expr *aP,
                                      const struct rssn_Expr *aM,
                                      bool aIsFermion)
;

/*
 Scattering cross-section.
 */
rssn_
struct rssn_Expr *rssn_qft_scattering_cross_section(const struct rssn_Expr *aMatrixElement,
                                                    const struct rssn_Expr *aFlux,
                                                    const struct rssn_Expr *aPhaseSpace)
;

/*
 Findings roots of a polynomial from coefficients.

 # Arguments
 * `coeffs_ptr` - Pointer to the coefficients array (f64).
 * `len` - Number of coefficients.
 * `tolerance` - The tolerance for root finding.

 # Returns
 A pointer to a `Vec<f64>` containing the sorted real roots, or null on error.
 */
rssn_
struct rssn_Vec_f64 *rssn_real_roots_find_roots(const double *aCoeffsPtr,
                                                size_t aLen,
                                                double aTolerance)
;

/*
 Finds all real roots of a polynomial using numerical methods and bincode serialization.

 Uses root-finding algorithms to locate all real zeros of the polynomial.

 # Arguments

 * `buffer` - A bincode-encoded buffer containing `FindRootsInput` with:
   - `coeffs`: Polynomial coefficients [a₀, a₁, ..., aₙ] for a₀ + a₁x + ... + aₙxⁿ
   - `tolerance`: Convergence tolerance for root finding

 # Returns

 A bincode-encoded buffer containing `FfiResult<Vec<f64>, String>` with either:
 - `ok`: Array of real roots found
 - `err`: Error message if root finding failed

 # Safety

 This function is unsafe because it receives raw pointers through FFI.
 The caller must ensure the input buffer contains valid bincode data.
 */
rssn_
struct rssn_BincodeBuffer rssn_real_roots_find_roots_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Finds all real roots of a polynomial using numerical methods and JSON serialization.

 Uses root-finding algorithms to locate all real zeros of the polynomial.

 # Arguments

 * `json_ptr` - A JSON string pointer containing:
   - `coeffs`: Polynomial coefficients [a₀, a₁, ..., aₙ] for a₀ + a₁x + ... + aₙxⁿ
   - `tolerance`: Convergence tolerance for root finding

 # Returns

 A C string pointer containing JSON-encoded `FfiResult<Vec<f64>, String>` with
 an array of real roots found.

 # Safety

 This function is unsafe because it receives a raw C string pointer that must be
 valid, null-terminated UTF-8. The caller must free the returned pointer.
 */
rssn_
char *rssn_real_roots_find_roots_json(const char *aJsonPtr)
;

/*
 Frees a roots vector.
 */
rssn_
void rssn_real_roots_free_vec(struct rssn_Vec_f64 *aPtr)
;

/*
 Gets the data of the roots vector.
 */
rssn_
void rssn_real_roots_get_vec_data(const struct rssn_Vec_f64 *aPtr,
                                  double *aBuffer)
;

/*
 Gets the length of the roots vector.
 */
rssn_
size_t rssn_real_roots_get_vec_len(const struct rssn_Vec_f64 *aPtr)
;

/*
 Generates a 3x3 2D reflection matrix across a line.
 */
rssn_
struct rssn_Expr *rssn_reflection_2d(const struct rssn_Expr *aAngle)
;

/*
 Generates a 4x4 3D reflection matrix across a plane.
 */
rssn_
struct rssn_Expr *rssn_reflection_3d(const struct rssn_Expr *aNx,
                                     const struct rssn_Expr *aNy,
                                     const struct rssn_Expr *aNz)
;

/*
 Computes the regularized lower incomplete gamma function P(a, x).
 */
rssn_
double rssn_regularized_gamma_p(double aA,
                                double aX)
;

/*
 Computes the regularized upper incomplete gamma function Q(a, x).
 */
rssn_
double rssn_regularized_gamma_q(double aA,
                                double aX)
;

/*
 Computes the regularized incomplete beta function Iₓ(a, b).
 */
rssn_
double rssn_regularized_incomplete_beta(double aA,
                                        double aB,
                                        double aX)
;

rssn_
struct rssn_Representation *rssn_representation_create(const struct rssn_Expr *const *aElementsPtr,
                                                       size_t aElementsLen,
                                                       const struct rssn_Expr *const *aKeysPtr,
                                                       const struct rssn_Expr *const *aValuesPtr,
                                                       size_t aMapLen)
;

rssn_
void rssn_representation_free(struct rssn_Representation *aPtr)
;

rssn_
bool rssn_representation_is_valid(const struct rssn_Representation *aRep,
                                  const struct rssn_Group *aGroup)
;

/*
 Frees a rewrite rule.

 # Safety
 The caller must ensure `rule` was created by this module and hasn't been freed yet.
 */
rssn_
void rssn_rewrite_rule_free(struct rssn_RewriteRule *aRule)
;

/*
 Gets the LHS of a rewrite rule.

 Returns a new owned Expr pointer that must be freed by the caller.

 # Safety
 The caller must ensure `rule` is a valid RewriteRule pointer.
 */
rssn_
struct rssn_Expr *rssn_rewrite_rule_get_lhs(const struct rssn_RewriteRule *aRule)
;

/*
 Gets the RHS of a rewrite rule.

 Returns a new owned Expr pointer that must be freed by the caller.

 # Safety
 The caller must ensure `rule` is a valid RewriteRule pointer.
 */
rssn_
struct rssn_Expr *rssn_rewrite_rule_get_rhs(const struct rssn_RewriteRule *aRule)
;

/*
 Creates a new rewrite rule from lhs and rhs expressions.

 # Safety
 The caller must ensure `lhs` and `rhs` are valid Expr pointers.
 */
rssn_
struct rssn_RewriteRule *rssn_rewrite_rule_new(const struct rssn_Expr *aLhs,
                                               const struct rssn_Expr *aRhs)
;

/*
 Creates a rewrite rule from Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_rewrite_rule_new_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Creates a rewrite rule from JSON.

 Input: JSON object with "lhs" and "rhs" fields (both Expr)
 Output: JSON-serialized RewriteRule
 */
rssn_
char *rssn_rewrite_rule_new_json(const char *aJsonStr)
;

/*
 Converts a rewrite rule to a string representation.

 The returned string must be freed using `rssn_free_string`.

 # Safety
 The caller must free the returned string.
 */
rssn_
char *rssn_rewrite_rule_to_string(const struct rssn_RewriteRule *aRule)
;

/*
 Converts a rewrite rule to a human-readable string (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_rewrite_rule_to_string_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Converts a rewrite rule to a human-readable string (JSON).

 Input: JSON-serialized RewriteRule
 Output: JSON object with "string" field
 */
rssn_
char *rssn_rewrite_rule_to_string_json(const char *aJsonStr)
;

/*
 Integrates an expression using the Risch-Norman algorithm (Handle)
 */
rssn_
struct rssn_Expr *rssn_risch_norman_integrate_handle(const struct rssn_Expr *aExpr,
                                                     const char *aX)
;

/*
 Computes the rising factorial (Pochhammer symbol) (x)ₙ.
 */
rssn_
double rssn_rising_factorial(double aX,
                             uint32_t aN)
;

/*
 Generates a 3x3 2D rotation matrix.
 */
rssn_
struct rssn_Expr *rssn_rotation_2d(const struct rssn_Expr *aAngle)
;

/*
 Generates a 4x4 3D rotation matrix around the X-axis.
 */
rssn_
struct rssn_Expr *rssn_rotation_3d_x(const struct rssn_Expr *aAngle)
;

/*
 Generates a 4x4 3D rotation matrix around the Y-axis.
 */
rssn_
struct rssn_Expr *rssn_rotation_3d_y(const struct rssn_Expr *aAngle)
;

/*
 Generates a 4x4 3D rotation matrix around the Z-axis.
 */
rssn_
struct rssn_Expr *rssn_rotation_3d_z(const struct rssn_Expr *aAngle)
;

/*
 Generates a 4x4 3D rotation matrix around an arbitrary axis.
 */
rssn_
struct rssn_Expr *rssn_rotation_axis_angle(const rssn_Vector *aAxis,
                                           const struct rssn_Expr *aAngle)
;

/*
 Checks if a Reed-Solomon codeword is valid without attempting correction.

 # Safety
 Caller must ensure `codeword` points to `codeword_len` bytes.
 Returns 1 if valid, 0 if invalid, -1 on error.
 */
rssn_
int32_t rssn_rs_check(const uint8_t *aCodeword,
                      size_t aCodewordLen,
                      size_t aNSym)
;

/*
 Decodes a Reed-Solomon codeword, correcting errors if possible.

 # Safety
 Caller must ensure `codeword` is valid. Returns allocated memory that must be freed.
 */
rssn_
uint8_t *rssn_rs_decode(const uint8_t *aCodeword,
                        size_t aCodewordLen,
                        size_t aNSym,
                        size_t *aOutLen)
;

/*
 Encodes data using Reed-Solomon code with n_sym error correction symbols.

 # Safety
 Caller must ensure `data` is valid. Returns allocated memory that must be freed.
 */
rssn_
uint8_t *rssn_rs_encode(const uint8_t *aData,
                        size_t aDataLen,
                        size_t aNSym,
                        size_t *aOutLen)
;

/*
 Estimates the number of errors in a Reed-Solomon codeword.

 # Safety
 Caller must ensure `codeword` points to `codeword_len` bytes.
 Returns error count or -1 on error.
 */
rssn_
int32_t rssn_rs_error_count(const uint8_t *aCodeword,
                            size_t aCodewordLen,
                            size_t aNSym)
;

/*
 Frees memory allocated by rs_encode or rs_decode.

 # Safety
 Caller must ensure `ptr` was returned by rssn_rs_encode or rssn_rs_decode.
 */
rssn_
void rssn_rs_free(uint8_t *aPtr,
                  size_t aLen)
;

/*
 Frees a rules vector.

 # Safety
 The caller must ensure `rules` was created by this module and hasn't been freed yet.
 */
rssn_
void rssn_rules_vec_free(struct rssn_Vec_RewriteRule *aRules)
;

/*
 Gets a rule from a rules vector by index.

 Returns a new owned RewriteRule pointer that must be freed by the caller.

 # Safety
 The caller must ensure `rules` is a valid Vec<RewriteRule> pointer.
 */
rssn_
struct rssn_RewriteRule *rssn_rules_vec_get(const struct rssn_Vec_RewriteRule *aRules,
                                            size_t aIndex)
;

/*
 Gets the length of a rules vector.

 # Safety
 The caller must ensure `rules` is a valid Vec<RewriteRule> pointer.
 */
rssn_
size_t rssn_rules_vec_len(const struct rssn_Vec_RewriteRule *aRules)
;

/*
 Lagrangian density for a free real scalar field.
 */
rssn_
struct rssn_Expr *rssn_scalar_field_lagrangian(const struct rssn_Expr *aPhi,
                                               const struct rssn_Expr *aM)
;

/*
 Generates a 3x3 2D scaling matrix.
 */
rssn_
struct rssn_Expr *rssn_scaling_2d(const struct rssn_Expr *aSx,
                                  const struct rssn_Expr *aSy)
;

/*
 Generates a 4x4 3D scaling matrix.
 */
rssn_
struct rssn_Expr *rssn_scaling_3d(const struct rssn_Expr *aSx,
                                  const struct rssn_Expr *aSy,
                                  const struct rssn_Expr *aSz)
;

/*
 Scattering amplitude.
 */
rssn_
struct rssn_Expr *rssn_scattering_amplitude(const struct rssn_Ket *aInitialState,
                                            const struct rssn_Ket *aFinalState,
                                            const struct rssn_Operator *aPotential)
;

/*
 Calculates Schwarzschild radius.
 */
rssn_
struct rssn_Expr *rssn_schwarzschild_radius(const struct rssn_Expr *aMass)
;

/*
 Analyzes the convergence of a series.

 Takes a raw pointer to `Expr` (series expression) and a C-style string (variable).
 Returns a raw pointer to a `ConvergenceResult` representing the convergence analysis result.
 */
rssn_
enum rssn_ConvergenceResult *rssn_series_analyze_convergence_handle(const struct rssn_Expr *aSeries,
                                                                    const char *aVar)
;

/*
 Analyzes the convergence of a series.

 Takes bincode-serialized `Expr` (series expression) and `String` (variable).
 Returns a bincode-serialized `Expr` representing the convergence analysis result.
 */
rssn_
struct rssn_BincodeBuffer rssn_series_bincode_analyze_convergence(struct rssn_BincodeBuffer aSeriesBuf,
                                                                  struct rssn_BincodeBuffer aVarBuf)
;

/*
 Analyzes the convergence of a series.

 Takes JSON strings representing `Expr` (series expression) and `String` (variable).
 Returns a JSON string representing the `Expr` of the convergence analysis result.
 */
rssn_
char *rssn_series_json_analyze_convergence(const char *aSeriesJson,
                                           const char *aVarJson)
;

/*
 Computes the Shannon entropy of a probability distribution.

 Takes a raw pointer to an array of `Expr` (probabilities) and its length.
 Returns a raw pointer to an `Expr` representing the entropy.
 */
rssn_
struct rssn_Expr *rssn_shannon_entropy(const struct rssn_Expr *const *aProbs,
                                       size_t aLen)
;

/*
 Generates a 3x3 2D shear matrix.
 */
rssn_
struct rssn_Expr *rssn_shear_2d(const struct rssn_Expr *aShx,
                                const struct rssn_Expr *aShy)
;

/*
 Performs a simple linear regression.

 Takes raw pointers to arrays of `Expr` (x and y data) and the length of the data.
 Returns a raw pointer to an `Expr` (vector) containing the intercept and slope coefficients.
 */
rssn_
struct rssn_Expr *rssn_simple_linear_regression(const struct rssn_Expr *const *aXData,
                                                const struct rssn_Expr *const *aYData,
                                                size_t aLen)
;

/*
 Creates a new Simplex (Handle)
 */
rssn_
rssn_Simplex *rssn_simplex_create(const size_t *aVerticesPtr,
                                  size_t aLen)
;

/*
 Gets the dimension of a Simplex
 */
rssn_
size_t rssn_simplex_dimension(const rssn_Simplex *aPtr)
;

/*
 Frees a Simplex handle
 */
rssn_
void rssn_simplex_free(rssn_Simplex *aPtr)
;

/*
 Adds a simplex to a SimplicialComplex
 */
rssn_
void rssn_simplicial_complex_add_simplex(struct rssn_SimplicialComplex *aComplexPtr,
                                         const size_t *aVerticesPtr,
                                         size_t aLen)
;

/*
 Applies the symbolic boundary operator to a SymbolicChain
 */
rssn_
struct rssn_SymbolicChain *rssn_simplicial_complex_apply_symbolic_boundary_operator(const struct rssn_SimplicialComplex *aComplexPtr,
                                                                                    const struct rssn_SymbolicChain *aChainPtr)
;

/*
 Creates a new SimplicialComplex (Handle)
 */
rssn_
struct rssn_SimplicialComplex *rssn_simplicial_complex_create(void)
;

/*
 Gets the dimension of a SimplicialComplex
 */
rssn_
int rssn_simplicial_complex_dimension(const struct rssn_SimplicialComplex *aPtr)
;

/*
 Computes the Euler characteristic
 */
rssn_
ptrdiff_t rssn_simplicial_complex_euler_characteristic(const struct rssn_SimplicialComplex *aPtr)
;

/*
 Frees a SimplicialComplex handle
 */
rssn_
void rssn_simplicial_complex_free(struct rssn_SimplicialComplex *aPtr)
;

/*
 Gets the symbolic boundary matrix for dimension k
 */
rssn_
struct rssn_Expr *rssn_simplicial_complex_get_symbolic_boundary_matrix(const struct rssn_SimplicialComplex *aComplexPtr,
                                                                       size_t aK)
;

/*
 Simplifies an expression using the legacy simplifier.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_
struct rssn_Expr *rssn_simplify(const struct rssn_Expr *aExpr)
;

/*
 Simplifies an expression using the DAG-based simplifier.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_
struct rssn_Expr *rssn_simplify_dag(const struct rssn_Expr *aExpr)
;

/*
 Simplifies a logical expression using handle-based FFI.

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_
struct rssn_Expr *rssn_simplify_logic_handle(const struct rssn_Expr *aExpr)
;

/*
 Simplifies radical expressions (Handle)
 */
rssn_
struct rssn_Expr *rssn_simplify_radicals_handle(const struct rssn_Expr *aExpr)
;

/*
 Creates a sine expression: sin(expr).

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_
struct rssn_Expr *rssn_sin(const struct rssn_Expr *aExpr)
;

/*
 Creates a sine expression from bincode: sin(expr).

 # Arguments
 * `expr_buffer` - Bincode-serialized Expr

 # Returns
 Bincode-serialized Expr
 */
rssn_
struct rssn_BincodeBuffer rssn_sin_bincode(struct rssn_BincodeBuffer aExprBuffer)
;

/*
 Creates a sine expression from JSON: sin(expr).

 # Arguments
 * `json_expr` - JSON-serialized Expr

 # Returns
 JSON-serialized Expr or null on error
 */
rssn_
char *rssn_sin_json(const char *aJsonExpr)
;

/*
 Computes the normalized sinc function sin(πx)/(πx).
 */
rssn_
double rssn_sinc(double aX)
;

rssn_
struct rssn_Expr **rssn_so3_generators(size_t *aOutLen)
;

/*
 Solves an equation or searches for zeros of an expression.

 # Safety
 * `var` must be a valid null-terminated C string.
 * `result_h` must be a valid pointer to store the handle of the solution.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_solve(size_t aExprH,
                   const char *aVar,
                   size_t *aResultH)
;

/*
 Solves the airfoil singular integral equation.
 */
rssn_
struct rssn_Expr *rssn_solve_airfoil_equation(const struct rssn_Expr *aFX,
                                              const char *aVarX,
                                              const char *aVarT)
;

/*
 Solves the airfoil singular integral equation (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_solve_airfoil_equation_bincode(const uint8_t *aInputPtr,
                                                              size_t aInputLen)
;

/*
 Solves the airfoil singular integral equation (JSON).
 */
rssn_
char *rssn_solve_airfoil_equation_json(const char *aInputJson)
;

/*
 Solves a Bernoulli ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_bernoulli_ode(const struct rssn_Expr *aEquation,
                                           const char *aFunc,
                                           const char *aVar)
;

/*
 Solves a second-order ODE by reduction of order with a known solution.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_by_reduction_of_order(const struct rssn_Expr *aEquation,
                                                   const char *aFunc,
                                                   const char *aVar,
                                                   const struct rssn_Expr *aY1)
;

/*
 Solves a Cauchy-Euler ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_cauchy_euler_ode(const struct rssn_Expr *aEquation,
                                              const char *aFunc,
                                              const char *aVar)
;

/*
 Solves a Diophantine equation.

 # Safety
 `equation` must be a valid pointer to an `Expr`.
 `vars_ptr` must be a valid pointer to an array of C strings of length `vars_len`.
 */
rssn_
struct rssn_Expr *rssn_solve_diophantine_handle(const struct rssn_Expr *aEquation,
                                                const char *const *aVarsPtr,
                                                int aVarsLen)
;

/*
 Generates and attempts to solve the Euler-Lagrange equation.

 # Safety
 The caller must ensure `lagrangian` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_euler_lagrange(const struct rssn_Expr *aLagrangian,
                                            const char *aFunc,
                                            const char *aVar)
;

/*
 Solves an exact ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_exact_ode(const struct rssn_Expr *aEquation,
                                       const char *aFunc,
                                       const char *aVar)
;

/*
 Solves a first-order linear ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_first_order_linear_ode(const struct rssn_Expr *aEquation,
                                                    const char *aFunc,
                                                    const char *aVar)
;

/*
 Solves an equation for a given variable.

 Takes a raw pointer to `Expr` (equation) and a C-style string (variable).
 Returns a raw pointer to a `Vec<Expr>` representing the solutions.
 */
rssn_
struct rssn_Vec_Expr *rssn_solve_handle(const struct rssn_Expr *aExpr,
                                        const char *aVar)
;

/*
 Solves the 1D heat equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_heat_equation_1d(const struct rssn_Expr *aEquation,
                                              const char *aFunc,
                                              const char *const *aVars,
                                              size_t aVarsLen)
;

/*
 Solves the Helmholtz equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_helmholtz_equation(const struct rssn_Expr *aEquation,
                                                const char *aFunc,
                                                const char *const *aVars,
                                                size_t aVarsLen)
;

/*
 Solves the Klein-Gordon equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_klein_gordon_equation(const struct rssn_Expr *aEquation,
                                                   const char *aFunc,
                                                   const char *const *aVars,
                                                   size_t aVarsLen)
;

/*
 Solves the 2D Laplace equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_laplace_equation_2d(const struct rssn_Expr *aEquation,
                                                 const char *aFunc,
                                                 const char *const *aVars,
                                                 size_t aVarsLen)
;

/*
 Bincode FFI for solving linear systems.
 */
rssn_
struct rssn_BincodeBuffer rssn_solve_linear_system_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 Solves a linear system of equations.

 Takes a raw pointer to `Expr` (system) and a raw pointer to `Vec<String>` (variables).
 Returns a raw pointer to a `Vec<Expr>` representing the solutions.
 */
rssn_
struct rssn_Vec_Expr *rssn_solve_linear_system_handle(const struct rssn_Expr *aSystem,
                                                      const struct rssn_Vec_String *aVars)
;

/*
 JSON FFI for solving linear systems.
 */
rssn_
char *rssn_solve_linear_system_json(const char *aJsonPtr)
;

/*
 Solves an ordinary differential equation.

 # Safety
 The caller must ensure `ode_expr` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_ode(const struct rssn_Expr *aOdeExpr,
                                 const char *aFunc,
                                 const char *aVar)
;

/*
 Solves a partial differential equation using automatic method selection.

 # Safety
 The caller must ensure `pde_expr` is a valid Expr pointer, `func` and `vars` are valid C strings,
 and `vars_len` accurately represents the number of variables.
 */
rssn_
struct rssn_Expr *rssn_solve_pde(const struct rssn_Expr *aPdeExpr,
                                 const char *aFunc,
                                 const char *const *aVars,
                                 size_t aVarsLen)
;

/*
 Solves a PDE using the method of characteristics.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_pde_by_characteristics(const struct rssn_Expr *aEquation,
                                                    const char *aFunc,
                                                    const char *const *aVars,
                                                    size_t aVarsLen)
;

/*
 Solves the 2D Poisson equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_poisson_equation_2d(const struct rssn_Expr *aEquation,
                                                 const char *aFunc,
                                                 const char *const *aVars,
                                                 size_t aVarsLen)
;

/*
 Solves a Riccati ODE with a known particular solution.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_riccati_ode(const struct rssn_Expr *aEquation,
                                         const char *aFunc,
                                         const char *aVar,
                                         const struct rssn_Expr *aY1)
;

/*
 Solves the Schrödinger equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_schrodinger_equation(const struct rssn_Expr *aEquation,
                                                  const char *aFunc,
                                                  const char *const *aVars,
                                                  size_t aVarsLen)
;

/*
 Solves a separable ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_separable_ode(const struct rssn_Expr *aEquation,
                                           const char *aFunc,
                                           const char *aVar)
;

/*
 Solves the 1D wave equation using D'Alembert's formula.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_wave_equation_1d_dalembert(const struct rssn_Expr *aEquation,
                                                        const char *aFunc,
                                                        const char *const *aVars,
                                                        size_t aVarsLen)
;

/*
 Spin operator S = hbar/2 * σ.
 */
rssn_
struct rssn_Expr *rssn_spin_operator(const struct rssn_Expr *aPauli)
;

/*
 Creates a square root expression: sqrt(expr).
 */
rssn_
struct rssn_Expr *rssn_sqrt(const struct rssn_Expr *aExpr)
;

/*
 Creates a square root expression from bincode: sqrt(expr).
 */
rssn_
struct rssn_BincodeBuffer rssn_sqrt_bincode(struct rssn_BincodeBuffer aExprBuffer)
;

/*
 Creates a square root expression from JSON: sqrt(expr).
 */
rssn_
char *rssn_sqrt_json(const char *aJsonExpr)
;

/*
 Frees a State.
 */
rssn_
void rssn_state_free(struct rssn_State *aState)
;

/*
 Gets the intermediate value from the state.
 The returned string must be freed by the caller using rssn_free_string.
 */
rssn_
char *rssn_state_get_intermediate_value(const struct rssn_State *aState)
;

/*
 Gets the intermediate value from a bincode state buffer.
 Returns the value as a bincode buffer containing a String.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
struct rssn_BincodeBuffer rssn_state_get_intermediate_value_bincode(struct rssn_BincodeBuffer aStateBuffer)
;

/*
 Gets the intermediate value from a JSON state string.
 Returns the value as a plain string (not JSON-encoded).
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_state_get_intermediate_value_json(const char *aJsonState)
;

/*
 Creates a new State.
 The caller is responsible for freeing the memory using rssn_state_free.
 */
rssn_
struct rssn_State *rssn_state_new(void)
;

/*
 Creates a new State and returns it as a bincode buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
struct rssn_BincodeBuffer rssn_state_new_bincode(void)
;

/*
 Creates a new State and returns it as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_state_new_json(void)
;

/*
 Sets the intermediate value in the state.
 */
rssn_
void rssn_state_set_intermediate_value(struct rssn_State *aState,
                                       const char *aValue)
;

/*
 Sets the intermediate value in a bincode state buffer and returns the updated buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
struct rssn_BincodeBuffer rssn_state_set_intermediate_value_bincode(struct rssn_BincodeBuffer aStateBuffer,
                                                                    struct rssn_BincodeBuffer aValueBuffer)
;

/*
 Sets the intermediate value in a JSON state string and returns the updated JSON.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_state_set_intermediate_value_json(const char *aJsonState,
                                             const char *aValue)
;

/*
 Computes the covariance between two datasets.

 # Safety
 * `d1` and `d2` must be valid pointers to arrays of length `len`.
 * `result` must be a valid pointer to store the f64 result.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_stats_covariance(const double *aD1,
                              const double *aD2,
                              size_t aLen,
                              double *aResult)
;

/*
 Computes the mean of a slice of f64 values.

 # Arguments
 * `data` - A pointer to the first element of the data slice.
 * `len` - The length of the data slice.
 * `result` - A pointer to store the computed mean.

 # Returns
 0 on success, -1 on error (e.g., null pointer).

 # Safety
 The `data` pointer must point to a valid array of `len` f64 elements.
 The `result` pointer must point to a valid f64 location.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_stats_mean(const double *aData,
                        size_t aLen,
                        double *aResult)
;

/*
 Computes the standard deviation of a slice of f64 values.

 # Arguments
 * `data` - A pointer to the first element of the data slice.
 * `len` - The length of the data slice.
 * `result` - A pointer to store the computed standard deviation.

 # Returns
 0 on success, -1 on error (e.g., null pointer).

 # Safety
 The `data` pointer must point to a valid array of `len` f64 elements.
 The `result` pointer must point to a valid f64 location.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_stats_std_dev(const double *aData,
                           size_t aLen,
                           double *aResult)
;

/*
 Computes the variance of a slice of f64 values.

 # Arguments
 * `data` - A pointer to the first element of the data slice.
 * `len` - The length of the data slice.
 * `result` - A pointer to store the computed variance.

 # Returns
 0 on success, -1 on error (e.g., null pointer).

 # Safety
 The `data` pointer must point to a valid array of `len` f64 elements.
 The `result` pointer must point to a valid f64 location.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_stats_variance(const double *aData,
                            size_t aLen,
                            double *aResult)
;

/*
 Computes the symbolic standard deviation of a set of expressions.

 # Safety
 The caller must ensure `data` is a valid pointer to an array of `Expr` pointers of size `len`.
 */
rssn_
struct rssn_Expr *rssn_std_dev(const struct rssn_Expr *const *aData,
                               size_t aLen)
;

/*
 Computes a Stirling number of the second kind symbolically and returns it as an `Expr` pointer.

 Stirling numbers of the second kind \( S(n,k) \) count partitions of an \(n\)-element
 set into \(k\) non-empty unlabeled blocks.

 # Arguments

 * `n` - Total number of elements.
 * `k` - Number of non-empty blocks.

 # Returns

 A newly allocated `Expr` pointer representing \( S(n,k) \).

 # Safety

 This function is unsafe because it is exposed as an FFI entry point and returns
 ownership of a heap-allocated `Expr` to the caller.
 */
rssn_
struct rssn_Expr *rssn_stirling_number_second_kind(size_t aN,
                                                   size_t aK)
;

/*
 Represents Stokes' theorem (Handle)
 */
rssn_
struct rssn_Expr *rssn_stokes_theorem_handle(const rssn_Vector *aVectorFieldPtr,
                                             const struct rssn_Expr *aSurfacePtr)
;

/*
 Generates the Sturm sequence for a given polynomial (Handle)
 */
rssn_
struct rssn_Vec_Expr *rssn_sturm_sequence_handle(const struct rssn_Expr *aExprPtr,
                                                 const char *aVarPtr)
;

rssn_
struct rssn_Expr **rssn_su2_generators(size_t *aOutLen)
;

/*
 Substitutes a variable with an expression.
 */
rssn_
struct rssn_Expr *rssn_substitute(const struct rssn_Expr *aExpr,
                                  const char *aVar,
                                  const struct rssn_Expr *aReplacement)
;

/*
 Computes the summation of an expression.

 Takes a raw pointer to `Expr` (expression), a C-style string (variable),
 raw pointers to `Expr` (lower bound), and `Expr` (upper bound).
 Returns a raw pointer to a new `Expr` representing the summation.
 */
rssn_
struct rssn_Expr *rssn_summation_handle(const struct rssn_Expr *aExpr,
                                        const char *aVar,
                                        const struct rssn_Expr *aLower,
                                        const struct rssn_Expr *aUpper)
;

/*
 Computes the surface integral (flux) of a vector field.
 */
rssn_
char *rssn_surface_integral(const char *aFieldX,
                            const char *aFieldY,
                            const char *aFieldZ,
                            const struct rssn_ParametricSurface *aSurface)
;

/*
 Computes the surface integral (flux) of a vector field (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_surface_integral_bincode(const uint8_t *aInputPtr,
                                                        size_t aInputLen)
;

/*
 Computes the surface integral (flux) of a vector field (JSON).
 */
rssn_
char *rssn_surface_integral_json(const char *aInputJson)
;

/*
 Adds a term to a SymbolicChain
 */
rssn_
bool rssn_symbolic_chain_add_term(struct rssn_SymbolicChain *aChainPtr,
                                  const rssn_Simplex *aSimplexPtr,
                                  const struct rssn_Expr *aCoeffPtr)
;

/*
 Creates a new SymbolicChain (Handle)
 */
rssn_
struct rssn_SymbolicChain *rssn_symbolic_chain_create(size_t aDimension)
;

/*
 Frees a SymbolicChain handle
 */
rssn_
void rssn_symbolic_chain_free(struct rssn_SymbolicChain *aPtr)
;

/*
 Creates a symmetric group of degree `n` and returns a raw pointer to it.

 # Arguments
 * `n` - The number of symbols the group acts on.

 # Returns
 A raw pointer (`*mut Group`) to the newly created group, or NULL if `n` is invalid.
 */
rssn_
struct rssn_Group *rssn_symmetric_group_create(size_t aN)
;

/*
 Creates a tangent expression: tan(expr).
 */
rssn_
struct rssn_Expr *rssn_tan(const struct rssn_Expr *aExpr)
;

/*
 Creates a tangent expression from bincode: tan(expr).
 */
rssn_
struct rssn_BincodeBuffer rssn_tan_bincode(struct rssn_BincodeBuffer aExprBuffer)
;

/*
 Creates a tangent expression from JSON: tan(expr).
 */
rssn_
char *rssn_tan_json(const char *aJsonExpr)
;

/*
 Computes the Taylor series expansion of an expression.

 Takes a raw pointer to `Expr` (expression), a C-style string (variable),
 a raw pointer to `Expr` (center), and a `usize` (order).
 Returns a raw pointer to a new `Expr` representing the Taylor series.
 */
rssn_
struct rssn_Expr *rssn_taylor_series_handle(const struct rssn_Expr *aExpr,
                                            const char *aVar,
                                            const struct rssn_Expr *aCenter,
                                            size_t aOrder)
;

/*
 Performs tensor addition.

 Takes raw pointers to two `Tensor` objects as input,
 and returns a raw pointer to a new `Tensor` representing their sum.
 */
rssn_
struct rssn_Tensor *rssn_tensor_add_handle(const struct rssn_Tensor *aT1,
                                           const struct rssn_Tensor *aT2)
;

/*
 Performs tensor contraction.

 Takes a raw pointer to a `Tensor`, and two `usize` values representing the axes to contract.
 Returns a raw pointer to a new `Tensor` representing the contracted tensor.
 */
rssn_
struct rssn_Tensor *rssn_tensor_contract_handle(const struct rssn_Tensor *aT,
                                                size_t aAxis1,
                                                size_t aAxis2)
;

/*
 Computes the outer product of two tensors.

 Takes raw pointers to two `Tensor` objects as input,
 and returns a raw pointer to a new `Tensor` representing their outer product.
 */
rssn_
struct rssn_Tensor *rssn_tensor_outer_product_handle(const struct rssn_Tensor *aT1,
                                                     const struct rssn_Tensor *aT2)
;

/*
 Performs scalar multiplication on a tensor.

 Takes a raw pointer to a `Tensor` and a raw pointer to an `Expr` (scalar).
 Returns a raw pointer to a new `Tensor` representing the result.
 */
rssn_
struct rssn_Tensor *rssn_tensor_scalar_mul_handle(const struct rssn_Tensor *aT,
                                                  const struct rssn_Expr *aScalar)
;

/*
 Allocates and returns a test string ("pong") to the caller.

 This function serves as a more advanced health check for the FFI interface.
 It allows the client to verify two things:
 1. That the FFI function can be called successfully.
 2. That memory allocated in Rust can be safely passed to and then freed by the client
    by calling `free_string` on the returned pointer.

 Returns a pointer to a null-terminated C string. The caller is responsible for freeing this string.
 */
rssn_
char *rssn_test_string_passing(void)
;

/*
 Time-dependent Schrödinger equation.
 */
rssn_
struct rssn_Expr *rssn_time_dependent_schrodinger_equation(const struct rssn_Operator *aHamiltonian,
                                                           const struct rssn_Ket *aWaveFunction)
;

/*
 Converts a logical expression to Conjunctive Normal Form (CNF) using handle-based FFI.

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_
struct rssn_Expr *rssn_to_cnf_handle(const struct rssn_Expr *aExpr)
;

/*
 Converts a logical expression to Disjunctive Normal Form (DNF) using handle-based FFI.

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_
struct rssn_Expr *rssn_to_dnf_handle(const struct rssn_Expr *aExpr)
;

/*
 Calculates torque: r x F.
 */
rssn_
rssn_Vector *rssn_torque(const rssn_Vector *aR,
                         const rssn_Vector *aForce)
;

/*
 Transforms contravariant vector components between coordinate systems.

 Contravariant components transform with the Jacobian of the coordinate change, corresponding
 to vector components with upper indices.

 # Arguments

 * `comps` - Pointer to a `Vec<Expr>` containing contravariant components in the `from` system.
 * `from` - Source [`CoordinateSystem`].
 * `to` - Target [`CoordinateSystem`].

 # Returns

 A newly allocated `Vec<Expr>` pointer with contravariant components in the `to` system, or
 null on failure.

 # Safety

 This function is unsafe because it dereferences a raw pointer to a vector and returns
 ownership of a heap-allocated vector to the caller.
 */
rssn_
struct rssn_Vec_Expr *rssn_transform_contravariant_vector_handle(const struct rssn_Vec_Expr *aComps,
                                                                 enum rssn_CoordinateSystem aFrom,
                                                                 enum rssn_CoordinateSystem aTo)
;

/*
 Transforms covariant vector components between coordinate systems.

 Covariant components transform with the inverse Jacobian and correspond to components
 with lower indices (1-forms).

 # Arguments

 * `comps` - Pointer to a `Vec<Expr>` containing covariant components in the `from` system.
 * `from` - Source [`CoordinateSystem`].
 * `to` - Target [`CoordinateSystem`].

 # Returns

 A newly allocated `Vec<Expr>` pointer with covariant components in the `to` system, or
 null on failure.

 # Safety

 This function is unsafe because it dereferences a raw pointer to a vector and returns
 ownership of a heap-allocated vector to the caller.
 */
rssn_
struct rssn_Vec_Expr *rssn_transform_covariant_vector_handle(const struct rssn_Vec_Expr *aComps,
                                                             enum rssn_CoordinateSystem aFrom,
                                                             enum rssn_CoordinateSystem aTo)
;

/*
 Computes the curl of a vector field in a given coordinate system.

 The curl is computed using the metric and Levi-Civita tensor of the `from` system,
 yielding a vector-valued `Expr` representing \(\nabla \times \vec{v}\).

 # Arguments

 * `comps` - Pointer to a `Vec<Expr>` containing the vector components in the `from` system.
 * `from` - [`CoordinateSystem`] with respect to which the curl is taken.

 # Returns

 A newly allocated `Vec<Expr>` pointer representing the curl, or null on failure.

 # Safety

 This function is unsafe because it dereferences a raw vector pointer and returns
 ownership of a heap-allocated vector to the caller.
 */
rssn_
struct rssn_Vec_Expr *rssn_transform_curl_handle(const struct rssn_Vec_Expr *aComps,
                                                 enum rssn_CoordinateSystem aFrom)
;

/*
 Computes the divergence of a vector field in a given coordinate system.

 The divergence is computed using the metric and Christoffel symbols associated with
 `from`, yielding a scalar `Expr` representing \(\nabla \cdot \vec{v}\).

 # Arguments

 * `comps` - Pointer to a `Vec<Expr>` containing the vector components in the `from` system.
 * `from` - [`CoordinateSystem`] with respect to which the divergence is taken.

 # Returns

 A newly allocated `Expr` pointer representing the divergence, or null on failure.

 # Safety

 This function is unsafe because it dereferences a raw vector pointer and returns
 ownership of a heap-allocated `Expr` to the caller.
 */
rssn_
struct rssn_Expr *rssn_transform_divergence_handle(const struct rssn_Vec_Expr *aComps,
                                                   enum rssn_CoordinateSystem aFrom)
;

/*
 Transforms a scalar expression between coordinate systems.

 This replaces the variables of `expr` according to the mapping between the `from` and
 `to` coordinate systems, yielding an equivalent symbolic expression in the target system.

 # Arguments

 * `expr` - Pointer to an `Expr` representing the scalar field in the `from` system.
 * `from` - Source [`CoordinateSystem`] of the variables in `expr`.
 * `to` - Target [`CoordinateSystem`] to which the expression is transformed.

 # Returns

 A newly allocated `Expr` pointer representing the transformed expression, or null on failure.

 # Safety

 This function is unsafe because it dereferences a raw `Expr` pointer and returns
 ownership of a heap-allocated `Expr` to the caller.
 */
rssn_
struct rssn_Expr *rssn_transform_expression_handle(const struct rssn_Expr *aExpr,
                                                   enum rssn_CoordinateSystem aFrom,
                                                   enum rssn_CoordinateSystem aTo)
;

/*
 Computes the gradient of a scalar field and transforms it between coordinate systems.

 The gradient is first formed with respect to the variables `vars` in the `from` system,
 then mapped into the `to` system as a vector of symbolic components.

 # Arguments

 * `scalar` - Pointer to an `Expr` representing the scalar field.
 * `vars` - Pointer to a `Vec<String>` listing the coordinate variables.
 * `from` - Source [`CoordinateSystem`].
 * `to` - Target [`CoordinateSystem`].

 # Returns

 A newly allocated `Vec<Expr>` pointer representing the gradient components in the `to`
 system, or null on failure.

 # Safety

 This function is unsafe because it dereferences raw pointers and returns ownership
 of a heap-allocated vector to the caller.
 */
rssn_
struct rssn_Vec_Expr *rssn_transform_gradient_handle(const struct rssn_Expr *aScalar,
                                                     const struct rssn_Vec_String *aVars,
                                                     enum rssn_CoordinateSystem aFrom,
                                                     enum rssn_CoordinateSystem aTo)
;

/*
 Transforms a point between coordinate systems and returns its components in the target system.

 The point is represented as a vector of symbolic expressions (e.g., \(x,y,z\)), and the
 transformation applies the appropriate coordinate mapping (Cartesian, polar, spherical, etc.).

 # Arguments

 * `point` - Pointer to a `Vec<Expr>` containing the point coordinates in the `from` system.
 * `from` - Source [`CoordinateSystem`] in which `point` is expressed.
 * `to` - Target [`CoordinateSystem`] to which the point is transformed.

 # Returns

 A newly allocated `Vec<Expr>` pointer with the point coordinates in the `to` system, or
 null on failure.

 # Safety

 This function is unsafe because it dereferences a raw pointer and returns ownership
 of a heap-allocated vector to the caller.
 */
rssn_
struct rssn_Vec_Expr *rssn_transform_point_handle(const struct rssn_Vec_Expr *aPoint,
                                                  enum rssn_CoordinateSystem aFrom,
                                                  enum rssn_CoordinateSystem aTo)
;

/*
 Generates a 3x3 2D translation matrix.

 # Safety
 All Expr pointers must be valid.
 */
rssn_
struct rssn_Expr *rssn_translation_2d(const struct rssn_Expr *aTx,
                                      const struct rssn_Expr *aTy)
;

/*
 Generates a 4x4 3D translation matrix.
 */
rssn_
struct rssn_Expr *rssn_translation_3d(const struct rssn_Expr *aTx,
                                      const struct rssn_Expr *aTy,
                                      const struct rssn_Expr *aTz)
;

/*
 Performs a two-sample t-test.

 Takes raw pointers to two arrays of `Expr` (data sets), their lengths,
 and a raw pointer to an `Expr` (hypothesized difference in means).
 Returns a raw pointer to an `Expr` tuple containing the test statistic,
 p-value formula, and degrees of freedom.
 */
rssn_
struct rssn_Expr *rssn_two_sample_t_test(const struct rssn_Expr *const *aData1,
                                         size_t aLen1,
                                         const struct rssn_Expr *const *aData2,
                                         size_t aLen2,
                                         const struct rssn_Expr *aMuDiff)
;

/*
 Computes the uncertainty ΔA.
 */
rssn_
struct rssn_Expr *rssn_uncertainty(const struct rssn_Operator *aOp,
                                   const struct rssn_Ket *aPsi)
;

/*
 Unifies the units in a symbolic expression.

 Takes a raw pointer to an `Expr` as input,
 and returns a raw pointer to a new `Expr` representing the expression with unified units.
 */
rssn_
struct rssn_Expr *rssn_unify_expression_handle(const struct rssn_Expr *aExpr)
;

/*
 Computes the symbolic variance of a set of expressions.

 # Safety
 The caller must ensure `data` is a valid pointer to an array of `Expr` pointers of size `len`.
 */
rssn_
struct rssn_Expr *rssn_variance(const struct rssn_Expr *const *aData,
                                size_t aLen)
;

/*
 Bincode FFI for vec_add.
 */
rssn_
struct rssn_BincodeBuffer rssn_vec_add_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for vec_add.
 */
rssn_
char *rssn_vec_add_json(const char *aJsonPtr)
;

/*
 Bincode FFI for angle.
 */
rssn_
struct rssn_BincodeBuffer rssn_vec_angle_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for angle.
 */
rssn_
char *rssn_vec_angle_json(const char *aJsonPtr)
;

/*
 Bincode FFI for cosine_similarity.
 */
rssn_
struct rssn_BincodeBuffer rssn_vec_cosine_similarity_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for cosine_similarity.
 */
rssn_
char *rssn_vec_cosine_similarity_json(const char *aJsonPtr)
;

/*
 Bincode FFI for cross_product.
 */
rssn_
struct rssn_BincodeBuffer rssn_vec_cross_product_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for cross_product.
 */
rssn_
char *rssn_vec_cross_product_json(const char *aJsonPtr)
;

/*
 Bincode FFI for distance.
 */
rssn_
struct rssn_BincodeBuffer rssn_vec_distance_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for distance.
 */
rssn_
char *rssn_vec_distance_json(const char *aJsonPtr)
;

/*
 Computes the dot product of two vectors.

 # Arguments
 * `d1` - A pointer to the first element of the first vector.
 * `l1` - The length of the first vector.
 * `d2` - A pointer to the first element of the second vector.
 * `l2` - The length of the second vector.
 * `result` - A pointer to store the computed dot product.

 # Returns
 0 on success, -1 on error (e.g., null pointer or mismatched lengths).

 # Safety
 The `d1` and `d2` pointers must point to valid arrays of `l1` and `l2` f64 elements respectively.
 The `result` pointer must point to a valid f64 location.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_vec_dot_product(const double *aD1,
                             size_t aL1,
                             const double *aD2,
                             size_t aL2,
                             double *aResult)
;

/*
 Bincode FFI for dot_product.
 */
rssn_
struct rssn_BincodeBuffer rssn_vec_dot_product_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for dot_product.
 */
rssn_
char *rssn_vec_dot_product_json(const char *aJsonPtr)
;

/*
 Bincode FFI for is_orthogonal.
 */
rssn_
struct rssn_BincodeBuffer rssn_vec_is_orthogonal_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for is_orthogonal.
 */
rssn_
char *rssn_vec_is_orthogonal_json(const char *aJsonPtr)
;

/*
 Bincode FFI for is_parallel.
 */
rssn_
struct rssn_BincodeBuffer rssn_vec_is_parallel_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for is_parallel.
 */
rssn_
char *rssn_vec_is_parallel_json(const char *aJsonPtr)
;

/*
 Bincode FFI for lerp.
 */
rssn_
struct rssn_BincodeBuffer rssn_vec_lerp_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for lerp.
 */
rssn_
char *rssn_vec_lerp_json(const char *aJsonPtr)
;

/*
 Bincode FFI for lp_norm.
 */
rssn_
struct rssn_BincodeBuffer rssn_vec_lp_norm_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for lp_norm.
 */
rssn_
char *rssn_vec_lp_norm_json(const char *aJsonPtr)
;

/*
 Computes the L2 norm of a vector.

 # Arguments
 * `data` - A pointer to the first element of the vector.
 * `len` - The length of the vector.
 * `result` - A pointer to store the computed norm.

 # Returns
 0 on success, -1 on error (e.g., null pointer).

 # Safety
 The `data` pointer must point to a valid array of `len` f64 elements.
 The `result` pointer must point to a valid f64 location.
 */
rssn_
DEPRECATED_WITH_NOTE
int32_t rssn_vec_norm(const double *aData,
                      size_t aLen,
                      double *aResult)
;

/*
 Bincode FFI for norm.
 */
rssn_
struct rssn_BincodeBuffer rssn_vec_norm_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for norm ($L_2$).
 */
rssn_
char *rssn_vec_norm_json(const char *aJsonPtr)
;

/*
 Bincode FFI for normalize.
 */
rssn_
struct rssn_BincodeBuffer rssn_vec_normalize_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for normalize.
 */
rssn_
char *rssn_vec_normalize_json(const char *aJsonPtr)
;

/*
 Bincode FFI for project.
 */
rssn_
struct rssn_BincodeBuffer rssn_vec_project_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for project.
 */
rssn_
char *rssn_vec_project_json(const char *aJsonPtr)
;

/*
 Bincode FFI for reflect.
 */
rssn_
struct rssn_BincodeBuffer rssn_vec_reflect_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for reflect.
 */
rssn_
char *rssn_vec_reflect_json(const char *aJsonPtr)
;

/*
 Bincode FFI for scalar_mul.
 */
rssn_
struct rssn_BincodeBuffer rssn_vec_scalar_mul_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for scalar_mul.
 */
rssn_
char *rssn_vec_scalar_mul_json(const char *aJsonPtr)
;

/*
 Bincode FFI for vec_sub.
 */
rssn_
struct rssn_BincodeBuffer rssn_vec_sub_bincode(struct rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for vec_sub.
 */
rssn_
char *rssn_vec_sub_json(const char *aJsonPtr)
;

/*
 Computes the cross product of two vectors.

 Takes two raw pointers to `Vector` objects as input.
 Returns a raw pointer to a new `Vector` representing their cross product.
 */
rssn_
rssn_Vector *rssn_vector_cross_handle(const rssn_Vector *aV1,
                                      const rssn_Vector *aV2)
;

/*
 Computes the dot product of two vectors.

 Takes two raw pointers to `Vector` objects as input.
 Returns a raw pointer to an `Expr` representing their dot product.
 */
rssn_
struct rssn_Expr *rssn_vector_dot_handle(const rssn_Vector *aV1,
                                         const rssn_Vector *aV2)
;

/*
 Frees a Vector.
 */
rssn_
void rssn_vector_free(rssn_Vector *aVec)
;

/*
 Computes the magnitude of a vector.

 Takes a raw pointer to a `Vector` as input.
 Returns a raw pointer to an `Expr` representing its magnitude.
 */
rssn_
struct rssn_Expr *rssn_vector_magnitude_handle(const rssn_Vector *aV)
;

/*
 Normalizes a vector.

 Takes a raw pointer to a `Vector` as input.
 Returns a raw pointer to a new `Vector` representing the normalized vector.
 */
rssn_
rssn_Vector *rssn_vector_normalize_handle(const rssn_Vector *aV)
;

/*
 Verifies a definite integral (Handle)
 */
rssn_
bool rssn_verify_definite_integral_handle(const struct rssn_Expr *aIntegrandPtr,
                                          const char *aVarPtr,
                                          double aLower,
                                          double aUpper,
                                          const struct rssn_Expr *aSymbolicResultPtr)
;

/*
 Verifies a derivative (Handle)
 */
rssn_
bool rssn_verify_derivative_handle(const struct rssn_Expr *aOriginalFuncPtr,
                                   const struct rssn_Expr *aDerivativeFuncPtr,
                                   const char *aVarPtr)
;

/*
 Verifies an equation solution (Handle)
 */
rssn_
bool rssn_verify_equation_solution_handle(const struct rssn_Expr *const *aEquationsPtr,
                                          int aEquationsLen,
                                          const char *const *aSolVarsPtr,
                                          const struct rssn_Expr *const *aSolExprsPtr,
                                          int aSolLen,
                                          const char *const *aFreeVarsPtr,
                                          int aFreeVarsLen)
;

/*
 Verifies an indefinite integral (Handle)
 */
rssn_
bool rssn_verify_indefinite_integral_handle(const struct rssn_Expr *aIntegrandPtr,
                                            const struct rssn_Expr *aIntegralResultPtr,
                                            const char *aVarPtr)
;

/*
 Verifies a limit (Handle)
 */
rssn_
bool rssn_verify_limit_handle(const struct rssn_Expr *aFPtr,
                              const char *aVarPtr,
                              const struct rssn_Expr *aTargetPtr,
                              const struct rssn_Expr *aLimitValPtr)
;

/*
 Verifies a matrix inverse (Handle)
 */
rssn_
bool rssn_verify_matrix_inverse_handle(const struct rssn_Expr *aOriginalPtr,
                                       const struct rssn_Expr *aInversePtr)
;

/*
 Verifies an ODE solution (Handle)
 */
rssn_
bool rssn_verify_ode_solution_handle(const struct rssn_Expr *aOdePtr,
                                     const struct rssn_Expr *aSolutionPtr,
                                     const char *aFuncNamePtr,
                                     const char *aVarPtr)
;

/*
 Frees a Volterra integral equation.
 */
rssn_
void rssn_volterra_free(struct rssn_VolterraEquation *aPtr)
;

/*
 Creates a new Volterra integral equation.
 */
rssn_
struct rssn_VolterraEquation *rssn_volterra_new(const struct rssn_Expr *aYX,
                                                const struct rssn_Expr *aFX,
                                                const struct rssn_Expr *aLambda,
                                                const struct rssn_Expr *aKernel,
                                                const struct rssn_Expr *aLowerBound,
                                                const char *aVarX,
                                                const char *aVarT)
;

/*
 Solves a Volterra equation by differentiation.
 */
rssn_
struct rssn_Expr *rssn_volterra_solve_by_differentiation(const struct rssn_VolterraEquation *aEq)
;

/*
 Solves a Volterra equation by differentiation (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_volterra_solve_by_differentiation_bincode(const uint8_t *aInputPtr,
                                                                         size_t aInputLen)
;

/*
 Solves a Volterra equation by differentiation (JSON).
 */
rssn_
char *rssn_volterra_solve_by_differentiation_json(const char *aInputJson)
;

/*
 Solves a Volterra equation using successive approximations.
 */
rssn_
struct rssn_Expr *rssn_volterra_solve_successive(const struct rssn_VolterraEquation *aEq,
                                                 size_t aIterations)
;

/*
 Solves a Volterra equation using successive approximations (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_volterra_solve_successive_bincode(const uint8_t *aInputPtr,
                                                                 size_t aInputLen)
;

/*
 Solves a Volterra equation using successive approximations (JSON).
 */
rssn_
char *rssn_volterra_solve_successive_json(const char *aInputJson)
;

/*
 Frees a Volume handle.
 */
rssn_
void rssn_volume_free(struct rssn_Volume *aVolume)
;

/*
 Computes the volume integral of a scalar field.
 */
rssn_
char *rssn_volume_integral(const char *aScalarField,
                           const struct rssn_Volume *aVolume)
;

/*
 Computes the volume integral of a scalar field (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_volume_integral_bincode(const uint8_t *aInputPtr,
                                                       size_t aInputLen)
;

/*
 Computes the volume integral of a scalar field (JSON).
 */
rssn_
char *rssn_volume_integral_json(const char *aInputJson)
;

/*
 Creates a new Volume.
 */
rssn_
struct rssn_Volume *rssn_volume_new(const char *aZLower,
                                    const char *aZUpper,
                                    const char *aYLower,
                                    const char *aYUpper,
                                    const char *aXLower,
                                    const char *aXUpper,
                                    const char *aXVar,
                                    const char *aYVar,
                                    const char *aZVar)
;

/*
 Computes the wedge product of two differential forms (Handle)
 */
rssn_
struct rssn_DifferentialForm *rssn_wedge_product_handle(const struct rssn_DifferentialForm *aForm1Ptr,
                                                        const struct rssn_DifferentialForm *aForm2Ptr)
;

/*
 Calculates work done by a variable force field along a path.
 */
rssn_
struct rssn_Expr *rssn_work_line_integral(const rssn_Vector *aForceField,
                                          const struct rssn_ParametricCurve *aPath)
;

/*
 Applies the differentiation property of the Z-transform.

 # Safety
 Caller must ensure `f_z` is a valid pointer to an `Expr`.
 `out_var` must be a valid C string or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_z_differentiation(const struct rssn_Expr *aFZ,
                                         const char *aOutVar)
;

/*
 Applies the scaling property of the Z-transform.

 # Safety
 Caller must ensure `f_z` and `a` are valid pointers to an `Expr`.
 `out_var` must be a valid C string or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_z_scaling(const struct rssn_Expr *aFZ,
                                 const struct rssn_Expr *aA,
                                 const char *aOutVar)
;

/*
 Performs a z-test.

 Takes a raw pointer to an array of `Expr` (data), its length,
 a raw pointer to an `Expr` (target mean), and a raw pointer to an `Expr` (population standard deviation).
 Returns a raw pointer to an `Expr` tuple containing the test statistic,
 p-value formula, and a placeholder for degrees of freedom.
 */
rssn_
struct rssn_Expr *rssn_z_test(const struct rssn_Expr *const *aData,
                              size_t aLen,
                              const struct rssn_Expr *aTargetMean,
                              const struct rssn_Expr *aPopStdDev)
;

/*
 Applies the time shift property of the Z-transform.

 # Safety
 Caller must ensure `f_z` and `k` are valid pointers to an `Expr`.
 `out_var` must be a valid C string or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_z_time_shift(const struct rssn_Expr *aFZ,
                                    const struct rssn_Expr *aK,
                                    const char *aOutVar)
;

/*
 Computes the symbolic Z-transform of an expression.

 # Safety
 Caller must ensure `expr` is a valid pointer to an `Expr`.
 `in_var` and `out_var` must be valid C strings or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_z_transform(const struct rssn_Expr *aExpr,
                                   const char *aInVar,
                                   const char *aOutVar)
;

/*
 Computes the symbolic Riemann zeta function ζ(s).
 */
rssn_
struct rssn_Expr *rssn_zeta(const struct rssn_Expr *aArg)
;

/*
 Computes the Riemann zeta function ζ(s).
 */
rssn_
double rssn_zeta_numerical(double aS)
;

/*
 Computes the percentile of a dataset.

 This function is deprecated.
 */
rssn_
DEPRECATED_WITH_NOTE
char *stats_percentile(const char *aJsonPtr)
;

/*
 Performs a simple linear regression on a dataset.

 This function is deprecated.
 */
rssn_
DEPRECATED_WITH_NOTE
char *stats_simple_linear_regression(const char *aJsonPtr)
;

/*
 Computes the Fast Fourier Transform (FFT) of a sequence of complex numbers.
 */
rssn_
DEPRECATED_WITH_NOTE
char *transforms_fft(const char *aJsonPtr)
;

/*
 Computes the Inverse Fast Fourier Transform (IFFT) of a sequence of complex numbers.
 */
rssn_
DEPRECATED_WITH_NOTE
char *transforms_ifft(const char *aJsonPtr)
;

/*
 Multiplies a vector by a scalar.

 This function is deprecated.
 */
rssn_
DEPRECATED_WITH_NOTE
char *vector_scalar_mul(const char *aJsonPtr)
;

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#ifdef __cplusplus
}  // namespace rssn
#endif  // __cplusplus

#endif  /* RSSN_H */
