#ifndef RSSN_H
#define RSSN_H

/* Generated with cbindgen:0.29.2 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#ifdef __cplusplus
namespace rssn {
#endif  // __cplusplus

/*
 Represents the result of a convergence test.
 */
typedef enum rssn_ConvergenceResult {
    /*
     The series is determined to converge.
     */
    Converges,
    /*
     The series is determined to diverge.
     */
    Diverges,
    /*
     The convergence could not be determined with the available tests.
     */
    Inconclusive,
} rssn_ConvergenceResult;

/*
 Defines the monomial ordering to be used in polynomial division.
 */
typedef enum rssn_MonomialOrder {
    Lexicographical,
    GradedLexicographical,
    GradedReverseLexicographical,
} rssn_MonomialOrder;

typedef enum rssn_CoordinateSystem {
    Cartesian,
    Cylindrical,
    Spherical,
} rssn_CoordinateSystem;

typedef struct rssn_Arc_FiniteField rssn_Arc_FiniteField;

/*
 Represents a Banach space, a complete normed vector space.

 This implementation specifically models L^p([a, b]), the space of functions for which
 the p-th power of their absolute value is Lebesgue integrable.
 */
typedef struct rssn_BanachSpace rssn_BanachSpace;

/*
 Represents a complex dynamical system defined by z_{n+1} = f(z_n) + c.
 */
typedef struct rssn_ComplexDynamicalSystem rssn_ComplexDynamicalSystem;

/*
 A thread-safe cache for computation results.

 This cache stores the mapping from expressions to their computed values.
 It avoids re-computing the value of the same expression multiple times.
 */
typedef struct rssn_ComputationResultCache rssn_ComputationResultCache;

/*
 Represents a point on an elliptic curve, including the point at infinity.
 */
typedef struct rssn_CurvePoint rssn_CurvePoint;

/*
 Represents a differential k-form.

 A k-form is a mathematical object that can be integrated over a k-dimensional manifold.
 It is a sum of terms, where each term is a scalar function (coefficient) multiplied by
 a wedge product of k basis 1-forms (like dx, dy, etc.).

 For example, a 2-form in R^3 could be `f(x,y,z) dx^dy + g(x,y,z) dx^dz`.

 Here, the basis wedge products (e.g., `dx^dy`) are represented by a bitmask (`blade`).
 If `vars = ["x", "y", "z"]`, then `dx` is `1<<0`, `dy` is `1<<1`, `dz` is `1<<2`.
 The wedge product `dx^dy` corresponds to the bitmask `(1<<0) | (1<<1) = 3`.
 */
typedef struct rssn_DifferentialForm rssn_DifferentialForm;

typedef struct rssn_EcdhKeyPair rssn_EcdhKeyPair;

/*
 Represents an elliptic curve over a prime field: y^2 = x^3 + ax + b.
 */
typedef struct rssn_EllipticCurve rssn_EllipticCurve;

/*
 The central enum representing a mathematical expression in the symbolic system.

 `Expr` is an Abstract Syntax Tree (AST) that can represent a wide variety of
 mathematical objects and operations. Manual implementations for `Debug`, `Clone`,
 `PartialEq`, `Eq`, and `Hash` are provided to handle variants containing types
 that do not derive these traits automatically (e.g., `f64`, `Arc<dyn Distribution>`).
 */
typedef struct rssn_Expr rssn_Expr;

typedef struct rssn_FiniteFieldPolynomial rssn_FiniteFieldPolynomial;

/*
 Represents a Fredholm integral equation of the second kind.

 The equation has the form: `y(x) = f(x) + lambda * integral_a_b(K(x, t) * y(t) dt)`,
 where `y(x)` is the unknown function to be solved for.
 */
typedef struct rssn_FredholmEquation rssn_FredholmEquation;

/*
 Represents a group with its multiplication table.
 */
typedef struct rssn_Group rssn_Group;

/*
 Represents a Hilbert space, a complete inner product space.
 This implementation specifically models L^2([a, b]), the space of square-integrable
 complex-valued functions on an interval [a, b].
 */
typedef struct rssn_HilbertSpace rssn_HilbertSpace;

/*
 Represents an Iterated Function System (IFS).

 An IFS is a finite set of contraction mappings on a complete metric space.
 It is often used to construct fractals (e.g., Sierpinski triangle, Barnsley fern).
 */
typedef struct rssn_IteratedFunctionSystem rssn_IteratedFunctionSystem;

/*
 Represents a Lie algebra, defined by its name and basis elements.
 */
typedef struct rssn_LieAlgebra rssn_LieAlgebra;

/*
 Represents common linear operators that act on functions in a vector space.
 */
typedef struct rssn_LinearOperator rssn_LinearOperator;

/*
 Represents a Möbius transformation: f(z) = (az + b) / (cz + d)
 */
typedef struct rssn_MobiusTransformation rssn_MobiusTransformation;

/*
 Represents a multivector in a Clifford algebra.

 The basis blades are represented by a bitmask. E.g., in 3D:
 001 (1) -> e1, 010 (2) -> e2, 100 (4) -> e3
 011 (3) -> e12, 101 (5) -> e13, 110 (6) -> e23
 111 (7) -> e123 (pseudoscalar)
 */
typedef struct rssn_Multivector rssn_Multivector;

/*
 Represents a parameterized curve C given by r(t).
 */
typedef struct rssn_ParametricCurve rssn_ParametricCurve;

/*
 Represents a parameterized surface S given by r(u, v).
 */
typedef struct rssn_ParametricSurface rssn_ParametricSurface;

/*
 A thread-safe cache for parsed expressions.

 This cache stores the mapping from input strings to parsed `Expr` objects.
 It avoids re-parsing the same string multiple times.
 */
typedef struct rssn_ParsingCache rssn_ParsingCache;

/*
 Represents the analytic continuation of a function along a path.
 It is stored as a chain of series expansions, each centered at a point on the path.
 */
typedef struct rssn_PathContinuation rssn_PathContinuation;

/*
 Represents an element in a prime field GF(p), where p is the modulus.

 The value is stored as a `u64`, and all arithmetic operations are performed
 modulo the specified `modulus`.
 */
typedef struct rssn_PrimeFieldElement rssn_PrimeFieldElement;

/*
 Represents a group representation.
 */
typedef struct rssn_Representation rssn_Representation;

/*
 Represents a rewrite rule, e.g., `lhs -> rhs`.
 */
typedef struct rssn_RewriteRule rssn_RewriteRule;

/*
 Represents a k-simplex as a set of its vertex indices.
 */
typedef struct rssn_Simplex rssn_Simplex;

/*
 Represents a simplicial complex.
 */
typedef struct rssn_SimplicialComplex rssn_SimplicialComplex;

/*
 Represents a singularity type in complex analysis.
 */
typedef struct rssn_SingularityType rssn_SingularityType;

/*
 Represents the state of a computation.

 This struct holds intermediate values and other context information
 required during a computation.
 */
typedef struct rssn_State rssn_State;

/*
 Represents a k-chain as a formal linear combination of k-simplices (symbolic version).
 */
typedef struct rssn_SymbolicChain rssn_SymbolicChain;

typedef struct rssn_Tensor rssn_Tensor;

typedef struct rssn_Vec_CriticalPoint rssn_Vec_CriticalPoint;

typedef struct rssn_Vec_Expr rssn_Vec_Expr;

typedef struct rssn_Vec_FiniteFieldPolynomial rssn_Vec_FiniteFieldPolynomial;

typedef struct rssn_Vec_HashMap_Expr__Expr rssn_Vec_HashMap_Expr__Expr;

typedef struct rssn_Vec_RewriteRule rssn_Vec_RewriteRule;

typedef struct rssn_Vec_SparsePolynomial rssn_Vec_SparsePolynomial;

typedef struct rssn_Vec_String rssn_Vec_String;

/*
 Represents a symbolic vector in 3D space.
 */
typedef struct rssn_Vector rssn_Vector;

/*
 Represents a Volterra integral equation of the second kind.

 The equation has the form: `y(x) = f(x) + lambda * integral_a_x(K(x, t) * y(t) dt)`.
 It is similar to the Fredholm equation, but the upper limit of integration is the variable `x`.
 */
typedef struct rssn_VolterraEquation rssn_VolterraEquation;

/*
 Represents a volume V for triple integration.
 Defines the integration order as dz dy dx.
 */
typedef struct rssn_Volume rssn_Volume;

/*
 A buffer containing binary data from bincode serialization.

 The caller is responsible for freeing this buffer using `rssn_free_bincode_buffer`.
 */
typedef struct rssn_BincodeBuffer {
    /*
     Pointer to the binary data.
     */
    uint8_t *mData;
    /*
     Length of the binary data in bytes.
     */
    size_t mLen;
} rssn_BincodeBuffer;

/*
 Opaque type for Graph<String> to work with cbindgen
 */
typedef struct rssn_RssnGraph {
    uint8_t mPrivate[0];
} rssn_RssnGraph;

typedef struct rssn_FfiPoint {
    double mX;
    double mY;
} rssn_FfiPoint;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

rssn_
struct rssn_Expr *calculate_residue(const struct rssn_Expr *aFunc,
                                    const char *aVar,
                                    const struct rssn_Expr *aSingularity)
;

rssn_
struct rssn_BincodeBuffer calculate_residue_bincode(struct rssn_BincodeBuffer aFuncBincode,
                                                    const char *aVar,
                                                    struct rssn_BincodeBuffer aSingularityBincode)
;

rssn_
char *calculate_residue_json(const char *aFuncJson,
                             const char *aVar,
                             const char *aSingularityJson)
;

rssn_
struct rssn_Expr *cauchy_derivative_formula(const struct rssn_Expr *aFunc,
                                            const char *aVar,
                                            const struct rssn_Expr *aZ0,
                                            size_t aN)
;

rssn_
struct rssn_BincodeBuffer cauchy_derivative_formula_bincode(struct rssn_BincodeBuffer aFuncBincode,
                                                            const char *aVar,
                                                            struct rssn_BincodeBuffer aZ0Bincode,
                                                            size_t aN)
;

rssn_
char *cauchy_derivative_formula_json(const char *aFuncJson,
                                     const char *aVar,
                                     const char *aZ0Json,
                                     size_t aN)
;

rssn_
struct rssn_Expr *cauchy_integral_formula(const struct rssn_Expr *aFunc,
                                          const char *aVar,
                                          const struct rssn_Expr *aZ0)
;

rssn_
struct rssn_BincodeBuffer cauchy_integral_formula_bincode(struct rssn_BincodeBuffer aFuncBincode,
                                                          const char *aVar,
                                                          struct rssn_BincodeBuffer aZ0Bincode)
;

rssn_
char *cauchy_integral_formula_json(const char *aFuncJson,
                                   const char *aVar,
                                   const char *aZ0Json)
;

rssn_
struct rssn_SingularityType *classify_singularity(const struct rssn_Expr *aFunc,
                                                  const char *aVar,
                                                  const struct rssn_Expr *aSingularity,
                                                  size_t aOrder)
;

rssn_
struct rssn_BincodeBuffer classify_singularity_bincode(struct rssn_BincodeBuffer aFuncBincode,
                                                       const char *aVar,
                                                       struct rssn_BincodeBuffer aSingularityBincode,
                                                       size_t aOrder)
;

rssn_
char *classify_singularity_json(const char *aFuncJson,
                                const char *aVar,
                                const char *aSingularityJson,
                                size_t aOrder)
;

rssn_ struct rssn_Expr *complex_arg(const struct rssn_Expr *aZ) ;

rssn_ struct rssn_BincodeBuffer complex_arg_bincode(struct rssn_BincodeBuffer aZBincode) ;

rssn_ char *complex_arg_json(const char *aZJson) ;

rssn_ double complex_distance(const struct rssn_Expr *aP1, const struct rssn_Expr *aP2) ;

rssn_
double complex_distance_bincode(struct rssn_BincodeBuffer aP1Bincode,
                                struct rssn_BincodeBuffer aP2Bincode)
;

rssn_ double complex_distance_json(const char *aP1Json, const char *aP2Json) ;

rssn_ struct rssn_Expr *complex_exp(const struct rssn_Expr *aZ) ;

rssn_ struct rssn_BincodeBuffer complex_exp_bincode(struct rssn_BincodeBuffer aZBincode) ;

rssn_ char *complex_exp_json(const char *aZJson) ;

rssn_ struct rssn_Expr *complex_log(const struct rssn_Expr *aZ) ;

rssn_ struct rssn_BincodeBuffer complex_log_bincode(struct rssn_BincodeBuffer aZBincode) ;

rssn_ char *complex_log_json(const char *aZJson) ;

rssn_ struct rssn_Expr *complex_modulus(const struct rssn_Expr *aZ) ;

rssn_ struct rssn_BincodeBuffer complex_modulus_bincode(struct rssn_BincodeBuffer aZBincode) ;

rssn_ char *complex_modulus_json(const char *aZJson) ;

rssn_
struct rssn_Expr *contour_integral_residue_theorem(const struct rssn_Expr *aFunc,
                                                   const char *aVar,
                                                   const struct rssn_Expr *const *aSingularities,
                                                   size_t aSingularitiesLen)
;

rssn_
struct rssn_BincodeBuffer contour_integral_residue_theorem_bincode(struct rssn_BincodeBuffer aFuncBincode,
                                                                   const char *aVar,
                                                                   struct rssn_BincodeBuffer aSingularitiesBincode)
;

rssn_
char *contour_integral_residue_theorem_json(const char *aFuncJson,
                                            const char *aVar,
                                            const char *aSingularitiesJson)
;

rssn_
double estimate_radius_of_convergence(const struct rssn_Expr *aSeriesExpr,
                                      const char *aVar,
                                      const struct rssn_Expr *aCenter,
                                      size_t aOrder)
;

rssn_
double estimate_radius_of_convergence_bincode(struct rssn_BincodeBuffer aSeriesExprBincode,
                                              const char *aVar,
                                              struct rssn_BincodeBuffer aCenterBincode,
                                              size_t aOrder)
;

rssn_
double estimate_radius_of_convergence_json(const char *aSeriesExprJson,
                                           const char *aVar,
                                           const char *aCenterJson,
                                           size_t aOrder)
;

/*
 Computes the definite integral of an `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_definite_integrate(struct rssn_Expr *aHandle,
                                          const char *aVarPtr,
                                          struct rssn_Expr *aLowerHandle,
                                          struct rssn_Expr *aUpperHandle)
;

/*
 Differentiates an `Expr` and returns a handle to the new, derivative expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_differentiate(struct rssn_Expr *aHandle,
                                     const char *aVarPtr)
;

/*
 Computes the indefinite integral of an `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_integrate(struct rssn_Expr *aHandle,
                                 const char *aVarPtr)
;

/*
 Computes the limit of an `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_limit(struct rssn_Expr *aHandle,
                             const char *aVarPtr,
                             struct rssn_Expr *aToHandle)
;

/*
 Simplifies an `Expr` and returns a handle to the new, simplified expression.

 The caller is responsible for freeing the returned handle using `expr_free`.
 */
rssn_ DEPRECATED_WITH_NOTE struct rssn_Expr *expr_simplify(struct rssn_Expr *aHandle) ;

/*
 Solves an equation for a given variable and returns the solutions as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *expr_solve(struct rssn_Expr *aHandle, const char *aVarPtr) ;

/*
 Substitutes a variable in an `Expr` with another `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_substitute(struct rssn_Expr *aHandle,
                                  const char *aVarPtr,
                                  struct rssn_Expr *aReplacementHandle)
;

/*
 Converts an expression to a LaTeX string.

 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_ char *expr_to_latex(struct rssn_Expr *aHandle) ;

/*
 Converts an expression to a formatted, pretty-printed string.

 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_ char *expr_to_pretty_string(struct rssn_Expr *aHandle) ;

/*
 Returns the string representation of an `Expr` handle.

 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_ char *expr_to_string(struct rssn_Expr *aHandle) ;

/*
 Attempts to unify the units within an expression.

 Returns a JSON string representing a `FfiResult` which contains either the
 new `Expr` object in the `ok` field or an error message in the `err` field.
 The caller can then use `expr_from_json` to get a handle to the new expression.
 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_ char *expr_unify_expression(struct rssn_Expr *aHandle) ;

/*
 Frees a C string that was allocated by this library.
 */
rssn_ void free_string(char *aS) ;

/*
 Evaluates a point on a Bézier curve and returns the coordinates as a JSON string.
 */
rssn_ char *interpolate_bezier_curve(const char *aJsonPtr) ;

/*
 Computes a Lagrange interpolating polynomial and returns its coefficients as a JSON string.
 */
rssn_ char *interpolate_lagrange(const char *aJsonPtr) ;

rssn_
struct rssn_Expr *laurent_series(const struct rssn_Expr *aFunc,
                                 const char *aVar,
                                 const struct rssn_Expr *aCenter,
                                 size_t aOrder)
;

rssn_
struct rssn_BincodeBuffer laurent_series_bincode(struct rssn_BincodeBuffer aFuncBincode,
                                                 const char *aVar,
                                                 struct rssn_BincodeBuffer aCenterBincode,
                                                 size_t aOrder)
;

rssn_
char *laurent_series_json(const char *aFuncJson,
                          const char *aVar,
                          const char *aCenterJson,
                          size_t aOrder)
;

/*
 Adds two matrices and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_add(struct rssn_Expr *aH1,
                             struct rssn_Expr *aH2)
;

/*
 Computes the characteristic polynomial of a matrix and returns the result as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_characteristic_polynomial(struct rssn_Expr *aHandle,
                                       const char *aVarPtr)
;

/*
 Computes the determinant of a matrix and returns a handle to the resulting expression.
 */
rssn_ DEPRECATED_WITH_NOTE struct rssn_Expr *matrix_determinant(struct rssn_Expr *aHandle) ;

/*
 Computes the eigenvalue decomposition of a matrix and returns the eigenvalues and eigenvectors as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_eigen_decomposition(struct rssn_Expr *aHandle)
;

/*
 Creates an identity matrix of a given size and returns a handle to it.
 */
rssn_ DEPRECATED_WITH_NOTE struct rssn_Expr *matrix_identity(size_t aSize) ;

/*
 Inverts a matrix and returns a handle to the new matrix expression.
 */
rssn_ DEPRECATED_WITH_NOTE struct rssn_Expr *matrix_inverse(struct rssn_Expr *aHandle) ;

/*
 Computes the LU decomposition of a matrix and returns the L and U matrices as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *matrix_lu_decomposition(struct rssn_Expr *aHandle) ;

/*
 Multiplies two matrices and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_mul(struct rssn_Expr *aH1,
                             struct rssn_Expr *aH2)
;

/*
 Computes the null space of a matrix and returns the result as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *matrix_null_space(struct rssn_Expr *aHandle) ;

/*
 Computes the Reduced Row Echelon Form (RREF) of a matrix and returns the result as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *matrix_rref(struct rssn_Expr *aHandle) ;

/*
 Multiplies a matrix by a scalar and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_scalar_mul(struct rssn_Expr *aScalarHandle,
                                    struct rssn_Expr *aMatrixHandle)
;

/*
 Subtracts the second matrix from the first and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_sub(struct rssn_Expr *aH1,
                             struct rssn_Expr *aH2)
;

/*
 Computes the trace of a matrix and returns the result as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *matrix_trace(struct rssn_Expr *aHandle) ;

/*
 Transposes a matrix and returns a handle to the new matrix expression.
 */
rssn_ DEPRECATED_WITH_NOTE struct rssn_Expr *matrix_transpose(struct rssn_Expr *aHandle) ;

rssn_
struct rssn_Expr *mobius_transformation_apply(const struct rssn_MobiusTransformation *aMobius,
                                              const struct rssn_Expr *aZ)
;

rssn_
struct rssn_BincodeBuffer mobius_transformation_apply_bincode(struct rssn_BincodeBuffer aMobiusBincode,
                                                              struct rssn_BincodeBuffer aZBincode)
;

rssn_ char *mobius_transformation_apply_json(const char *aMobiusJson, const char *aZJson) ;

rssn_
struct rssn_MobiusTransformation *mobius_transformation_compose(const struct rssn_MobiusTransformation *aMobius1,
                                                                const struct rssn_MobiusTransformation *aMobius2)
;

rssn_
struct rssn_BincodeBuffer mobius_transformation_compose_bincode(struct rssn_BincodeBuffer aMobius1Bincode,
                                                                struct rssn_BincodeBuffer aMobius2Bincode)
;

rssn_ char *mobius_transformation_compose_json(const char *aMobius1Json, const char *aMobius2Json) ;

rssn_ struct rssn_MobiusTransformation *mobius_transformation_identity(void) ;

rssn_ struct rssn_BincodeBuffer mobius_transformation_identity_bincode(void) ;

rssn_ char *mobius_transformation_identity_json(void) ;

rssn_
struct rssn_MobiusTransformation *mobius_transformation_inverse(const struct rssn_MobiusTransformation *aMobius)
;

rssn_
struct rssn_BincodeBuffer mobius_transformation_inverse_bincode(struct rssn_BincodeBuffer aMobiusBincode)
;

rssn_ char *mobius_transformation_inverse_json(const char *aMobiusJson) ;

rssn_
struct rssn_MobiusTransformation *mobius_transformation_new(const struct rssn_Expr *aA,
                                                            const struct rssn_Expr *aB,
                                                            const struct rssn_Expr *aC,
                                                            const struct rssn_Expr *aD)
;

rssn_
struct rssn_BincodeBuffer mobius_transformation_new_bincode(struct rssn_BincodeBuffer aABincode,
                                                            struct rssn_BincodeBuffer aBBincode,
                                                            struct rssn_BincodeBuffer aCBincode,
                                                            struct rssn_BincodeBuffer aDBincode)
;

rssn_
char *mobius_transformation_new_json(const char *aAJson,
                                     const char *aBJson,
                                     const char *aCJson,
                                     const char *aDJson)
;

rssn_ DEPRECATED_WITH_NOTE char *nt_mod_inverse(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *nt_mod_pow(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *numerical_gradient(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *numerical_integrate(const char *aJsonPtr) ;

rssn_
char *path_continuation_continue_along_path(struct rssn_PathContinuation *aPc,
                                            const struct rssn_Expr *const *aPathPoints,
                                            size_t aPathPointsLen)
;

rssn_
struct rssn_BincodeBuffer path_continuation_continue_along_path_bincode(struct rssn_BincodeBuffer aPcBincode,
                                                                        struct rssn_BincodeBuffer aPathPointsBincode)
;

rssn_
char *path_continuation_continue_along_path_json(const char *aPcJson,
                                                 const char *aPathPointsJson)
;

rssn_
struct rssn_Expr *path_continuation_get_final_expression(const struct rssn_PathContinuation *aPc)
;

rssn_
struct rssn_BincodeBuffer path_continuation_get_final_expression_bincode(struct rssn_BincodeBuffer aPcBincode)
;

rssn_ char *path_continuation_get_final_expression_json(const char *aPcJson) ;

rssn_
struct rssn_PathContinuation *path_continuation_new(const struct rssn_Expr *aFunc,
                                                    const char *aVar,
                                                    const struct rssn_Expr *aStartPoint,
                                                    size_t aOrder)
;

rssn_
struct rssn_BincodeBuffer path_continuation_new_bincode(struct rssn_BincodeBuffer aFuncBincode,
                                                        const char *aVar,
                                                        struct rssn_BincodeBuffer aStartPointBincode,
                                                        size_t aOrder)
;

rssn_
char *path_continuation_new_json(const char *aFuncJson,
                                 const char *aVar,
                                 const char *aStartPointJson,
                                 size_t aOrder)
;

rssn_ DEPRECATED_WITH_NOTE char *physics_solve_advection_diffusion_1d(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE int64_t poly_degree(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE struct rssn_Expr *poly_from_coeffs_vec(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE bool poly_is_polynomial(const char *aJsonPtr) ;

rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *poly_leading_coefficient(struct rssn_Expr *aHandle,
                                           const char *aVarPtr)
;

rssn_ DEPRECATED_WITH_NOTE char *poly_long_division(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *poly_to_coeffs_vec(const char *aJsonPtr) ;

/*
 Checks if an expression contains a variable (handle-based)
 */
rssn_ bool polynomial_contains_var_handle(const struct rssn_Expr *aExprHandle, const char *aVar) ;

/*
 Computes the degree of a polynomial (handle-based)
 */
rssn_ int64_t polynomial_degree_handle(const struct rssn_Expr *aExprHandle, const char *aVar) ;

/*
 Frees an Expr handle
 */
rssn_ void polynomial_free_expr_handle(struct rssn_Expr *aExprHandle) ;

/*
 Checks if an expression is a polynomial in the given variable (handle-based)
 */
rssn_ bool polynomial_is_polynomial_handle(const struct rssn_Expr *aExprHandle, const char *aVar) ;

/*
 Finds the leading coefficient of a polynomial (handle-based)
 */
rssn_
struct rssn_Expr *polynomial_leading_coefficient_handle(const struct rssn_Expr *aExprHandle,
                                                        const char *aVar)
;

/*
 Performs polynomial long division (handle-based)
 */
rssn_
void polynomial_long_division_handle(const struct rssn_Expr *aDividendHandle,
                                     const struct rssn_Expr *aDivisorHandle,
                                     const char *aVar,
                                     struct rssn_Expr **aQuotientOut,
                                     struct rssn_Expr **aRemainderOut)
;

/*
 Computes absolute value (magnitude) of complex number (Handle)
 */
rssn_ struct rssn_Expr *rssn_abs_handle(const struct rssn_Expr *aZ) ;

rssn_
struct rssn_Expr *rssn_adjoint_representation_algebra(const struct rssn_Expr *aX,
                                                      const struct rssn_Expr *aY)
;

rssn_
struct rssn_Expr *rssn_adjoint_representation_group(const struct rssn_Expr *aG,
                                                    const struct rssn_Expr *aX)
;

rssn_
struct rssn_Expr *rssn_analytic_continuation_handle(const struct rssn_Expr *aExpr,
                                                    const char *aVar,
                                                    const struct rssn_Expr *aOrigCenter,
                                                    const struct rssn_Expr *aNewCenter,
                                                    size_t aOrder)
;

rssn_
enum rssn_ConvergenceResult rssn_analyze_convergence_handle(const struct rssn_Expr *aTerm,
                                                            const char *aVar)
;

/*
 Analyzes stability of a fixed point (Handle)
 */
rssn_
struct rssn_Expr *rssn_analyze_stability(const struct rssn_Expr *aMapPtr,
                                         const char *aVar,
                                         const struct rssn_Expr *aFixedPointPtr)
;

/*
 Applies a set of rewrite rules to an expression until a normal form is reached.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `rules` is a valid array.
 */
rssn_
struct rssn_Expr *rssn_apply_rules_to_normal_form(const struct rssn_Expr *aExpr,
                                                  const struct rssn_RewriteRule *const *aRules,
                                                  size_t aRulesLen)
;

/*
 Applies rewrite rules to an expression (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_apply_rules_to_normal_form_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Applies rewrite rules to an expression (JSON).

 Input: JSON object with "expr" and "rules" fields
 Output: JSON-serialized Expr (the normal form)
 */
rssn_ char *rssn_apply_rules_to_normal_form_json(const char *aJsonStr) ;

/*
 Checks if two graphs are potentially isomorphic using WL test.
 */
rssn_
int rssn_are_isomorphic_heuristic(const struct rssn_RssnGraph *aG1,
                                  const struct rssn_RssnGraph *aG2)
;

rssn_
bool rssn_are_orthogonal(const struct rssn_HilbertSpace *aSpace,
                         const struct rssn_Expr *aF,
                         const struct rssn_Expr *aG)
;

/*
 Computes argument (angle) of complex number (Handle)
 */
rssn_ struct rssn_Expr *rssn_arg_handle(const struct rssn_Expr *aZ) ;

rssn_
struct rssn_Expr *rssn_asymptotic_expansion_handle(const struct rssn_Expr *aExpr,
                                                   const char *aVar,
                                                   const struct rssn_Expr *aPoint,
                                                   size_t aOrder)
;

rssn_
struct rssn_Expr *rssn_banach_norm(const struct rssn_BanachSpace *aSpace,
                                   const struct rssn_Expr *aF)
;

rssn_
struct rssn_BanachSpace *rssn_banach_space_create(const char *aVar,
                                                  const struct rssn_Expr *aLowerBound,
                                                  const struct rssn_Expr *aUpperBound,
                                                  const struct rssn_Expr *aP)
;

rssn_ void rssn_banach_space_free(struct rssn_BanachSpace *aPtr) ;

rssn_ struct rssn_Expr *rssn_bell_number(size_t aN) ;

rssn_
struct rssn_Expr *rssn_bessel_differential_equation(const struct rssn_Expr *aY,
                                                    const struct rssn_Expr *aX,
                                                    const struct rssn_Expr *aN)
;

rssn_
struct rssn_Expr *rssn_bessel_j(const struct rssn_Expr *aOrder,
                                const struct rssn_Expr *aArg)
;

rssn_
struct rssn_Expr *rssn_bessel_y(const struct rssn_Expr *aOrder,
                                const struct rssn_Expr *aArg)
;

rssn_ struct rssn_Expr *rssn_beta(const struct rssn_Expr *aA, const struct rssn_Expr *aB) ;

rssn_ double rssn_beta_numerical(double aA, double aB) ;

/*
 Computes absolute value (magnitude) of complex number (Bincode)
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_abs(struct rssn_BincodeBuffer aZBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_adjoint_representation_algebra(struct rssn_BincodeBuffer aXBuf,
                                                                      struct rssn_BincodeBuffer aYBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_adjoint_representation_group(struct rssn_BincodeBuffer aGBuf,
                                                                    struct rssn_BincodeBuffer aXBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_analytic_continuation(struct rssn_BincodeBuffer aExprBuf,
                                                             struct rssn_BincodeBuffer aVarBuf,
                                                             struct rssn_BincodeBuffer aOrigCenterBuf,
                                                             struct rssn_BincodeBuffer aNewCenterBuf,
                                                             struct rssn_BincodeBuffer aOrderBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_analyze_convergence(struct rssn_BincodeBuffer aTermBuf,
                                                           struct rssn_BincodeBuffer aVarBuf)
;

/*
 Analyzes stability of a fixed point (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_analyze_stability(struct rssn_BincodeBuffer aMapBuf,
                                                         const char *aVar,
                                                         struct rssn_BincodeBuffer aFixedPointBuf)
;

/*
 Checks if two graphs are isomorphic.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_are_isomorphic_heuristic(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Computes argument (angle) of complex number (Bincode)
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_arg(struct rssn_BincodeBuffer aZBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_asymptotic_expansion(struct rssn_BincodeBuffer aExprBuf,
                                                            struct rssn_BincodeBuffer aVarBuf,
                                                            struct rssn_BincodeBuffer aPointBuf,
                                                            struct rssn_BincodeBuffer aOrderBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_bell_number(size_t aN) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_bessel_differential_equation(struct rssn_BincodeBuffer aYBuf,
                                                                    struct rssn_BincodeBuffer aXBuf,
                                                                    struct rssn_BincodeBuffer aNBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_bessel_j(struct rssn_BincodeBuffer aOrderBuf,
                                                struct rssn_BincodeBuffer aArgBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_bessel_y(struct rssn_BincodeBuffer aOrderBuf,
                                                struct rssn_BincodeBuffer aArgBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_beta(struct rssn_BincodeBuffer aABuf,
                                            struct rssn_BincodeBuffer aBBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_beta_numerical(struct rssn_BincodeBuffer aABuf,
                                                      struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes the boundary of a domain (Bincode)
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_boundary(struct rssn_BincodeBuffer aDomainBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_buchberger(struct rssn_BincodeBuffer aBasisBuf,
                                                  struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Calculates residue using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_calculate_residue(struct rssn_BincodeBuffer aExprBuf,
                                                         const char *aVar,
                                                         struct rssn_BincodeBuffer aPoleBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_catalan_number(size_t aN) ;

rssn_ struct rssn_BincodeBuffer rssn_bincode_character(struct rssn_BincodeBuffer aRepBuf) ;

/*
 Checks analytic using Bincode.
 */
rssn_ bool rssn_bincode_check_analytic(struct rssn_BincodeBuffer aExprBuf, const char *aVar) ;

rssn_ bool rssn_bincode_check_jacobi_identity(struct rssn_BincodeBuffer aAlgebraBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_chinese_remainder(struct rssn_BincodeBuffer aCongruencesBuf)
;

/*
 Exact chromatic number.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_chromatic_number_exact(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Classifies a PDE (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_classify_pde(struct rssn_BincodeBuffer aEquationBuf,
                                                    const char *aFunc,
                                                    struct rssn_BincodeBuffer aVarsBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_combinations(struct rssn_BincodeBuffer aNBuf,
                                                    struct rssn_BincodeBuffer aKBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_commutator_table(struct rssn_BincodeBuffer aAlgebraBuf)
;

/*
 Finds fixed points (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_complex_system_fixed_points(struct rssn_BincodeBuffer aSystemBuf)
;

/*
 Iterates the system once (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_complex_system_iterate(struct rssn_BincodeBuffer aSystemBuf,
                                                              struct rssn_BincodeBuffer aZBuf)
;

/*
 Creates a new Mandelbrot family system (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_complex_system_new_mandelbrot(struct rssn_BincodeBuffer aCBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_conditional_entropy(struct rssn_BincodeBuffer aJointProbsBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_convolution_fourier(struct rssn_BincodeBuffer aFBuf,
                                                           struct rssn_BincodeBuffer aGBuf,
                                                           struct rssn_BincodeBuffer aInVarBuf,
                                                           struct rssn_BincodeBuffer aOutVarBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_convolution_laplace(struct rssn_BincodeBuffer aFBuf,
                                                           struct rssn_BincodeBuffer aGBuf,
                                                           struct rssn_BincodeBuffer aInVarBuf,
                                                           struct rssn_BincodeBuffer aOutVarBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_coordinates_get_metric_tensor(struct rssn_BincodeBuffer aSystemBuf)
;

/*
 Computes the symbolic Pearson correlation coefficient using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_correlation(struct rssn_BincodeBuffer aData1Buf,
                                                   struct rssn_BincodeBuffer aData2Buf)
;

/*
 Counts the number of distinct real roots in an interval (Bincode)
 */
rssn_
int64_t rssn_bincode_count_real_roots_in_interval(struct rssn_BincodeBuffer aExprBuf,
                                                  const char *aVarPtr,
                                                  double aA,
                                                  double aB)
;

/*
 Computes the symbolic covariance of two sets of expressions using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_covariance(struct rssn_BincodeBuffer aData1Buf,
                                                  struct rssn_BincodeBuffer aData2Buf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_cross_entropy(struct rssn_BincodeBuffer aPProbsBuf,
                                                     struct rssn_BincodeBuffer aQProbsBuf)
;

/*
 Performs point addition on elliptic curve via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_curve_add(struct rssn_BincodeBuffer aABuf,
                                                 struct rssn_BincodeBuffer aBBuf,
                                                 struct rssn_BincodeBuffer aModulusBuf,
                                                 struct rssn_BincodeBuffer aP1XBuf,
                                                 struct rssn_BincodeBuffer aP1YBuf,
                                                 struct rssn_BincodeBuffer aP2XBuf,
                                                 struct rssn_BincodeBuffer aP2YBuf)
;

/*
 Performs scalar multiplication on elliptic curve via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_curve_scalar_mult(struct rssn_BincodeBuffer aABuf,
                                                         struct rssn_BincodeBuffer aBBuf,
                                                         struct rssn_BincodeBuffer aModulusBuf,
                                                         struct rssn_BincodeBuffer aKBuf,
                                                         struct rssn_BincodeBuffer aPXBuf,
                                                         struct rssn_BincodeBuffer aPYBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_cyclic_group_create(size_t aN) ;

/*
 Computes definite integral using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_definite_integrate(struct rssn_BincodeBuffer aExprBuf,
                                                          const char *aVar,
                                                          struct rssn_BincodeBuffer aLowerBuf,
                                                          struct rssn_BincodeBuffer aUpperBuf)
;

/*
 Denests a nested square root (Bincode)
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_denest_sqrt(struct rssn_BincodeBuffer aExprBuf) ;

/*
 Differentiates an expression using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_differentiate(struct rssn_BincodeBuffer aExprBuf,
                                                     const char *aVar)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_digamma(struct rssn_BincodeBuffer aArgBuf) ;

rssn_ struct rssn_BincodeBuffer rssn_bincode_dihedral_group_create(size_t aN) ;

rssn_ struct rssn_BincodeBuffer rssn_bincode_dist_bernoulli(struct rssn_BincodeBuffer aPBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_beta(struct rssn_BincodeBuffer aAlphaBuf,
                                                 struct rssn_BincodeBuffer aBetaBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_binomial(struct rssn_BincodeBuffer aNBuf,
                                                     struct rssn_BincodeBuffer aPBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_cdf(struct rssn_BincodeBuffer aDistBuf,
                                                struct rssn_BincodeBuffer aXBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_dist_expectation(struct rssn_BincodeBuffer aDistBuf) ;

rssn_ struct rssn_BincodeBuffer rssn_bincode_dist_exponential(struct rssn_BincodeBuffer aRateBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_gamma(struct rssn_BincodeBuffer aShapeBuf,
                                                  struct rssn_BincodeBuffer aRateBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_mgf(struct rssn_BincodeBuffer aDistBuf,
                                                struct rssn_BincodeBuffer aTBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_normal(struct rssn_BincodeBuffer aMeanBuf,
                                                   struct rssn_BincodeBuffer aStdDevBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_pdf(struct rssn_BincodeBuffer aDistBuf,
                                                struct rssn_BincodeBuffer aXBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_dist_poisson(struct rssn_BincodeBuffer aRateBuf) ;

rssn_ struct rssn_BincodeBuffer rssn_bincode_dist_student_t(struct rssn_BincodeBuffer aNuBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_dist_uniform(struct rssn_BincodeBuffer aMinBuf,
                                                    struct rssn_BincodeBuffer aMaxBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_dist_variance(struct rssn_BincodeBuffer aDistBuf) ;

rssn_ struct rssn_BincodeBuffer rssn_bincode_erf(struct rssn_BincodeBuffer aArgBuf) ;

rssn_ struct rssn_BincodeBuffer rssn_bincode_erf_numerical(struct rssn_BincodeBuffer aValBuf) ;

rssn_ struct rssn_BincodeBuffer rssn_bincode_erfc(struct rssn_BincodeBuffer aArgBuf) ;

rssn_ struct rssn_BincodeBuffer rssn_bincode_erfc_numerical(struct rssn_BincodeBuffer aValBuf) ;

rssn_ struct rssn_BincodeBuffer rssn_bincode_erfi(struct rssn_BincodeBuffer aArgBuf) ;

/*
 Evaluates at point using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_evaluate_at_point(struct rssn_BincodeBuffer aExprBuf,
                                                         const char *aVar,
                                                         struct rssn_BincodeBuffer aValueBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_evaluate_numerical(struct rssn_BincodeBuffer aExprBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_exponential_map(struct rssn_BincodeBuffer aXBuf,
                                                       size_t aOrder)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_extended_gcd(struct rssn_BincodeBuffer aABuf,
                                                    struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes the exterior derivative of a differential form (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_exterior_derivative(struct rssn_BincodeBuffer aFormBuf,
                                                           struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Factors a polynomial over a finite field (Bincode)
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_factor_gf(struct rssn_BincodeBuffer aPolyBuf) ;

/*
 Finds constrained extrema (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_find_constrained_extrema(struct rssn_BincodeBuffer aExprBuf,
                                                                struct rssn_BincodeBuffer aConstraintsBuf,
                                                                struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Finds extrema of a function (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_find_extrema(struct rssn_BincodeBuffer aExprBuf,
                                                    struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Finds fixed points of a 1D map (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_find_fixed_points(struct rssn_BincodeBuffer aMapBuf,
                                                         const char *aVar)
;

/*
 Finds pole order using Bincode.
 */
rssn_
size_t rssn_bincode_find_pole_order(struct rssn_BincodeBuffer aExprBuf,
                                    const char *aVar,
                                    struct rssn_BincodeBuffer aPoleBuf)
;

/*
 Finds poles using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_find_poles(struct rssn_BincodeBuffer aExprBuf,
                                                  const char *aVar)
;

/*
 Gets the degree of a finite field polynomial (Bincode)
 */
rssn_ int64_t rssn_bincode_finite_field_polynomial_degree(struct rssn_BincodeBuffer aPolyBuf) ;

/*
 Performs polynomial long division (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_finite_field_polynomial_long_division(struct rssn_BincodeBuffer aDividendBuf,
                                                                             struct rssn_BincodeBuffer aDivisorBuf)
;

/*
 Creates a new finite field polynomial (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_finite_field_polynomial_new(struct rssn_BincodeBuffer aCoeffsBuf,
                                                                   struct rssn_BincodeBuffer aModulusBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_fourier_series(struct rssn_BincodeBuffer aExprBuf,
                                                      struct rssn_BincodeBuffer aVarBuf,
                                                      struct rssn_BincodeBuffer aPeriodBuf,
                                                      struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Computes the symbolic Fourier transform via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_fourier_transform(struct rssn_BincodeBuffer aExprBuf,
                                                         struct rssn_BincodeBuffer aInVarBuf,
                                                         struct rssn_BincodeBuffer aOutVarBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_gamma(struct rssn_BincodeBuffer aArgBuf) ;

rssn_ struct rssn_BincodeBuffer rssn_bincode_gamma_numerical(struct rssn_BincodeBuffer aValBuf) ;

/*
 Represents Gauss's theorem (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_gauss_theorem(struct rssn_BincodeBuffer aVectorFieldBuf,
                                                     struct rssn_BincodeBuffer aVolumeBuf)
;

/*
 Computes general multi-valued arccos (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_arccos(struct rssn_BincodeBuffer aZBuf,
                                                      struct rssn_BincodeBuffer aKBuf,
                                                      struct rssn_BincodeBuffer aSBuf)
;

/*
 Computes general multi-valued arcsin (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_arcsin(struct rssn_BincodeBuffer aZBuf,
                                                      struct rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued arctan (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_arctan(struct rssn_BincodeBuffer aZBuf,
                                                      struct rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued logarithm (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_log(struct rssn_BincodeBuffer aZBuf,
                                                   struct rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued n-th root (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_nth_root(struct rssn_BincodeBuffer aZBuf,
                                                        struct rssn_BincodeBuffer aNBuf,
                                                        struct rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued power (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_power(struct rssn_BincodeBuffer aZBuf,
                                                     struct rssn_BincodeBuffer aWBuf,
                                                     struct rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued square root (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_sqrt(struct rssn_BincodeBuffer aZBuf,
                                                    struct rssn_BincodeBuffer aKBuf)
;

/*
 Represents the generalized Stokes' theorem (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_generalized_stokes_theorem(struct rssn_BincodeBuffer aOmegaBuf,
                                                                  struct rssn_BincodeBuffer aManifoldBuf,
                                                                  struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Gets real and imaginary parts using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_get_real_imag_parts(struct rssn_BincodeBuffer aExprBuf)
;

/*
 Performs addition in GF(2^8) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_gf256_add(struct rssn_BincodeBuffer aABuf,
                                                 struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes inverse in GF(2^8) via Bincode interface.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_gf256_inv(struct rssn_BincodeBuffer aABuf) ;

/*
 Performs multiplication in GF(2^8) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_gf256_mul(struct rssn_BincodeBuffer aABuf,
                                                 struct rssn_BincodeBuffer aBBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_gini_impurity(struct rssn_BincodeBuffer aProbsBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_gram_schmidt(struct rssn_BincodeBuffer aSpaceBuf,
                                                    struct rssn_BincodeBuffer aBasisBuf)
;

/*
 Adds an edge to the graph.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_graph_add_edge(struct rssn_BincodeBuffer aInputBuf) ;

/*
 Adds a node to the graph.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_graph_add_node(struct rssn_BincodeBuffer aInputBuf) ;

/*
 Gets the adjacency matrix.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_adjacency_matrix(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Performs BFS traversal.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_graph_bfs(struct rssn_BincodeBuffer aInputBuf) ;

/*
 Performs BFS traversal.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_graph_bfs_api(struct rssn_BincodeBuffer aInputBuf) ;

/*
 Finds maximum matching in bipartite graph.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_bipartite_maximum_matching(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Finds bridges and articulation points.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_bridges_and_articulation_points(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes the Cartesian product of two graphs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_cartesian_product(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Computes the complement of a graph.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_graph_complement(struct rssn_BincodeBuffer aGraphBuf) ;

/*
 Finds connected components.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_connected_components(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Finds connected components.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_connected_components_api(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Performs DFS traversal.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_graph_dfs(struct rssn_BincodeBuffer aInputBuf) ;

/*
 Performs DFS traversal.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_graph_dfs_api(struct rssn_BincodeBuffer aInputBuf) ;

/*
 Computes maximum flow using Dinic's algorithm.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_dinic_max_flow(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Computes the disjoint union of two graphs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_disjoint_union(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Computes maximum flow using Edmonds-Karp.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_edmonds_karp_max_flow(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Checks if graph has a cycle.
 */
rssn_ bool rssn_bincode_graph_has_cycle(struct rssn_BincodeBuffer aGraphBuf) ;

/*
 Checks if graph has a cycle.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_has_cycle_api(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Creates an induced subgraph.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_induced_subgraph(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Computes the intersection of two graphs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_intersection(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Checks if graph is bipartite.
 */
rssn_ bool rssn_bincode_graph_is_bipartite(struct rssn_BincodeBuffer aGraphBuf) ;

/*
 Checks if graph is bipartite.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_is_bipartite_api(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Checks if graph is connected.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_is_connected(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes the join of two graphs.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_graph_join(struct rssn_BincodeBuffer aInputBuf) ;

/*
 Computes MST using Kruskal's algorithm.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_kruskal_mst(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes MST using Kruskal's algorithm.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_kruskal_mst_api(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Gets the Laplacian matrix.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_laplacian_matrix(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes maximum flow.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_graph_max_flow(struct rssn_BincodeBuffer aInputBuf) ;

/*
 Creates a new graph from bincode specification.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_graph_new(struct rssn_BincodeBuffer aSpecBuf) ;

/*
 Finds strongly connected components.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_strongly_connected_components(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes the Tensor product of two graphs.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_tensor_product(struct rssn_BincodeBuffer aInputBuf)
;

/*
 Performs topological sort.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_graph_topological_sort(struct rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes the union of two graphs.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_graph_union(struct rssn_BincodeBuffer aInputBuf) ;

/*
 Greedy coloring.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_greedy_coloring(struct rssn_BincodeBuffer aGraphBuf) ;

/*
 Represents Green's theorem (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_greens_theorem(struct rssn_BincodeBuffer aPBuf,
                                                      struct rssn_BincodeBuffer aQBuf,
                                                      struct rssn_BincodeBuffer aDomainBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_group_center(struct rssn_BincodeBuffer aGroupBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_group_conjugacy_classes(struct rssn_BincodeBuffer aGroupBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_group_create(struct rssn_BincodeBuffer aBuf) ;

rssn_
size_t rssn_bincode_group_element_order(struct rssn_BincodeBuffer aGroupBuf,
                                        struct rssn_BincodeBuffer aABuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_group_inverse(struct rssn_BincodeBuffer aGroupBuf,
                                                     struct rssn_BincodeBuffer aABuf)
;

rssn_ bool rssn_bincode_group_is_abelian(struct rssn_BincodeBuffer aGroupBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_group_multiply(struct rssn_BincodeBuffer aGroupBuf,
                                                      struct rssn_BincodeBuffer aABuf,
                                                      struct rssn_BincodeBuffer aBBuf)
;

/*
 Decodes a 7-bit Hamming(7,4) codeword via Bincode interface.
 Returns tuple of (data, error_pos).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_hamming_decode(struct rssn_BincodeBuffer aCodewordBuf)
;

/*
 Encodes 4 data bits into a 7-bit Hamming(7,4) codeword via Bincode interface.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_hamming_encode(struct rssn_BincodeBuffer aDataBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_hermite_differential_equation(struct rssn_BincodeBuffer aYBuf,
                                                                     struct rssn_BincodeBuffer aXBuf,
                                                                     struct rssn_BincodeBuffer aNBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_hermite_h(struct rssn_BincodeBuffer aDegreeBuf,
                                                 struct rssn_BincodeBuffer aArgBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_hermite_rodrigues_formula(struct rssn_BincodeBuffer aNBuf,
                                                                 struct rssn_BincodeBuffer aXBuf)
;

/*
 Computes Hessian matrix (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_hessian_matrix(struct rssn_BincodeBuffer aExprBuf,
                                                      struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Simplifies an expression using the heuristic simplifier (Bincode input/output).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_heuristic_simplify(struct rssn_BincodeBuffer aExprBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_hilbert_space_create(struct rssn_BincodeBuffer aBuf) ;

/*
 Creates a new IteratedFunctionSystem (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_ifs_create(struct rssn_BincodeBuffer aFunctionsBuf,
                                                  struct rssn_BincodeBuffer aProbabilitiesBuf,
                                                  struct rssn_BincodeBuffer aVariablesBuf)
;

/*
 Calculates similarity dimension (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_ifs_similarity_dimension(struct rssn_BincodeBuffer aScalingFactorsBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_inner_product(struct rssn_BincodeBuffer aSpaceBuf,
                                                     struct rssn_BincodeBuffer aFBuf,
                                                     struct rssn_BincodeBuffer aGBuf)
;

/*
 Integrates an expression using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_integrate(struct rssn_BincodeBuffer aExprBuf,
                                                 const char *aVar)
;

/*
 Integrates a rational function (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_integrate_rational_function(struct rssn_BincodeBuffer aExprBuf,
                                                                   struct rssn_BincodeBuffer aXBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_inverse_fourier_transform(struct rssn_BincodeBuffer aExprBuf,
                                                                 struct rssn_BincodeBuffer aInVarBuf,
                                                                 struct rssn_BincodeBuffer aOutVarBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_inverse_laplace_transform(struct rssn_BincodeBuffer aExprBuf,
                                                                 struct rssn_BincodeBuffer aInVarBuf,
                                                                 struct rssn_BincodeBuffer aOutVarBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_inverse_z_transform(struct rssn_BincodeBuffer aExprBuf,
                                                           struct rssn_BincodeBuffer aInVarBuf,
                                                           struct rssn_BincodeBuffer aOutVarBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_is_prime(struct rssn_BincodeBuffer aNBuf) ;

/*
 Checks if a logical expression is satisfiable using bincode-based FFI.

 Returns a bincode buffer containing:
 - `Some(true)` if satisfiable
 - `Some(false)` if unsatisfiable
 - `None` if the expression contains quantifiers (undecidable)
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_is_satisfiable(struct rssn_BincodeBuffer aExprBuf) ;

/*
 Isolates real roots in an interval (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_isolate_real_roots(struct rssn_BincodeBuffer aExprBuf,
                                                          const char *aVarPtr,
                                                          double aPrecision)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_joint_entropy(struct rssn_BincodeBuffer aJointProbsBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_kl_divergence(struct rssn_BincodeBuffer aPProbsBuf,
                                                     struct rssn_BincodeBuffer aQProbsBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_klein_four_group_create(void) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_laguerre_differential_equation(struct rssn_BincodeBuffer aYBuf,
                                                                      struct rssn_BincodeBuffer aXBuf,
                                                                      struct rssn_BincodeBuffer aNBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_laguerre_l(struct rssn_BincodeBuffer aDegreeBuf,
                                                  struct rssn_BincodeBuffer aArgBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_laplace_transform(struct rssn_BincodeBuffer aExprBuf,
                                                         struct rssn_BincodeBuffer aInVarBuf,
                                                         struct rssn_BincodeBuffer aOutVarBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_laurent_series(struct rssn_BincodeBuffer aExprBuf,
                                                      struct rssn_BincodeBuffer aVarBuf,
                                                      struct rssn_BincodeBuffer aCenterBuf,
                                                      struct rssn_BincodeBuffer aOrderBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_legendre_differential_equation(struct rssn_BincodeBuffer aYBuf,
                                                                      struct rssn_BincodeBuffer aXBuf,
                                                                      struct rssn_BincodeBuffer aNBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_legendre_p(struct rssn_BincodeBuffer aDegreeBuf,
                                                  struct rssn_BincodeBuffer aArgBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_legendre_rodrigues_formula(struct rssn_BincodeBuffer aNBuf,
                                                                  struct rssn_BincodeBuffer aXBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_lie_algebra_so3(void) ;

rssn_ struct rssn_BincodeBuffer rssn_bincode_lie_algebra_su2(void) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_lie_bracket(struct rssn_BincodeBuffer aXBuf,
                                                   struct rssn_BincodeBuffer aYBuf)
;

/*
 Computes limit using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_limit(struct rssn_BincodeBuffer aExprBuf,
                                             const char *aVar,
                                             struct rssn_BincodeBuffer aPointBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_ln_beta_numerical(struct rssn_BincodeBuffer aABuf,
                                                         struct rssn_BincodeBuffer aBBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_ln_gamma_numerical(struct rssn_BincodeBuffer aValBuf) ;

/*
 Returns Lorenz system equations (Bincode)
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_lorenz_system(void) ;

/*
 Calculates Lyapunov exponent (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_lyapunov_exponent(struct rssn_BincodeBuffer aMapBuf,
                                                         const char *aVar,
                                                         struct rssn_BincodeBuffer aInitialXBuf,
                                                         size_t aNIterations)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_add(struct rssn_BincodeBuffer aM1Buf,
                                                  struct rssn_BincodeBuffer aM2Buf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_determinant(struct rssn_BincodeBuffer aMatrixBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_matrix_inverse(struct rssn_BincodeBuffer aMatrixBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_mul(struct rssn_BincodeBuffer aM1Buf,
                                                  struct rssn_BincodeBuffer aM2Buf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_solve_linear_system(struct rssn_BincodeBuffer aABuf,
                                                                  struct rssn_BincodeBuffer aBBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_transpose(struct rssn_BincodeBuffer aMatrixBuf)
;

/*
 Computes the symbolic mean of a set of expressions using Bincode.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_mean(struct rssn_BincodeBuffer aDataBuf) ;

/*
 Computes geometric product (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_geometric_product(struct rssn_BincodeBuffer aABuf,
                                                                     struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes grade projection (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_grade_projection(struct rssn_BincodeBuffer aMvBuf,
                                                                    uint32_t aGrade)
;

/*
 Computes inner product (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_inner_product(struct rssn_BincodeBuffer aABuf,
                                                                 struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes magnitude (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_magnitude(struct rssn_BincodeBuffer aMvBuf)
;

/*
 Computes outer product (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_outer_product(struct rssn_BincodeBuffer aABuf,
                                                                 struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes reverse (Bincode)
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_multivector_reverse(struct rssn_BincodeBuffer aMvBuf) ;

/*
 Creates a new scalar multivector (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_scalar(uint32_t aP,
                                                          uint32_t aQ,
                                                          uint32_t aR,
                                                          struct rssn_BincodeBuffer aValueBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_mutual_information(struct rssn_BincodeBuffer aJointProbsBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_nonlinear_regression(struct rssn_BincodeBuffer aDataBuf,
                                                            struct rssn_BincodeBuffer aModelBuf,
                                                            struct rssn_BincodeBuffer aVarsBuf,
                                                            struct rssn_BincodeBuffer aParamsBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_norm(struct rssn_BincodeBuffer aSpaceBuf,
                                            struct rssn_BincodeBuffer aFBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_one_sample_t_test(struct rssn_BincodeBuffer aDataBuf,
                                                         struct rssn_BincodeBuffer aTargetMeanBuf)
;

/*
 Computes path integral using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_path_integrate(struct rssn_BincodeBuffer aExprBuf,
                                                      const char *aVar,
                                                      struct rssn_BincodeBuffer aContourBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_permutations(struct rssn_BincodeBuffer aNBuf,
                                                    struct rssn_BincodeBuffer aKBuf)
;

/*
 Adds two polynomials over a general finite field via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_add_gf(struct rssn_BincodeBuffer aP1Buf,
                                                   struct rssn_BincodeBuffer aP2Buf,
                                                   struct rssn_BincodeBuffer aModulusBuf)
;

/*
 Adds two polynomials over GF(2^8) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_add_gf256(struct rssn_BincodeBuffer aP1Buf,
                                                      struct rssn_BincodeBuffer aP2Buf)
;

/*
 Computes polynomial derivative over finite field (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_derivative_gf(struct rssn_BincodeBuffer aPolyBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_division_multivariate(struct rssn_BincodeBuffer aDividendBuf,
                                                                  struct rssn_BincodeBuffer aDivisorsBuf,
                                                                  struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Evaluates a polynomial over GF(2^8) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_eval_gf256(struct rssn_BincodeBuffer aPolyBuf,
                                                       struct rssn_BincodeBuffer aXBuf)
;

/*
 Computes polynomial GCD over finite field (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_gcd_gf(struct rssn_BincodeBuffer aABuf,
                                                   struct rssn_BincodeBuffer aBBuf)
;

/*
 Multiplies two polynomials over a general finite field via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_mul_gf(struct rssn_BincodeBuffer aP1Buf,
                                                   struct rssn_BincodeBuffer aP2Buf,
                                                   struct rssn_BincodeBuffer aModulusBuf)
;

/*
 Multiplies two polynomials over GF(2^8) via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_mul_gf256(struct rssn_BincodeBuffer aP1Buf,
                                                      struct rssn_BincodeBuffer aP2Buf)
;

/*
 Checks if an expression contains a variable (bincode)
 */
rssn_
bool rssn_bincode_polynomial_contains_var(struct rssn_BincodeBuffer aExprBuf,
                                          const char *aVar)
;

/*
 Computes the degree of a polynomial (bincode)
 */
rssn_ int64_t rssn_bincode_polynomial_degree(struct rssn_BincodeBuffer aExprBuf, const char *aVar) ;

/*
 Checks if an expression is a polynomial in the given variable (bincode)
 */
rssn_
bool rssn_bincode_polynomial_is_polynomial(struct rssn_BincodeBuffer aExprBuf,
                                           const char *aVar)
;

/*
 Finds the leading coefficient of a polynomial (bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_polynomial_leading_coefficient(struct rssn_BincodeBuffer aExprBuf,
                                                                      const char *aVar)
;

/*
 Performs polynomial long division (bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_polynomial_long_division(struct rssn_BincodeBuffer aDividendBuf,
                                                                struct rssn_BincodeBuffer aDivisorBuf,
                                                                const char *aVar)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_polynomial_regression(struct rssn_BincodeBuffer aDataBuf,
                                                             size_t aDegree)
;

/*
 Converts polynomial to coefficient vector (bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_polynomial_to_coeffs_vec(struct rssn_BincodeBuffer aExprBuf,
                                                                const char *aVar)
;

/*
 Adds two prime field elements (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_prime_field_element_add(struct rssn_BincodeBuffer aABuf,
                                                               struct rssn_BincodeBuffer aBBuf)
;

/*
 Divides two prime field elements (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_prime_field_element_div(struct rssn_BincodeBuffer aABuf,
                                                               struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes the inverse of a prime field element (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_prime_field_element_inverse(struct rssn_BincodeBuffer aElemBuf)
;

/*
 Multiplies two prime field elements (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_prime_field_element_mul(struct rssn_BincodeBuffer aABuf,
                                                               struct rssn_BincodeBuffer aBBuf)
;

/*
 Creates a new prime field element (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_prime_field_element_new(struct rssn_BincodeBuffer aValueBuf,
                                                               struct rssn_BincodeBuffer aModulusBuf)
;

/*
 Subtracts two prime field elements (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_prime_field_element_sub(struct rssn_BincodeBuffer aABuf,
                                                               struct rssn_BincodeBuffer aBBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_product(struct rssn_BincodeBuffer aExprBuf,
                                               struct rssn_BincodeBuffer aVarBuf,
                                               struct rssn_BincodeBuffer aLowerBuf,
                                               struct rssn_BincodeBuffer aUpperBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_representation_create(struct rssn_BincodeBuffer aBuf) ;

rssn_
bool rssn_bincode_representation_is_valid(struct rssn_BincodeBuffer aRepBuf,
                                          struct rssn_BincodeBuffer aGroupBuf)
;

/*
 Integrates an expression using the Risch-Norman algorithm (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_risch_norman_integrate(struct rssn_BincodeBuffer aExprBuf,
                                                              struct rssn_BincodeBuffer aXBuf)
;

/*
 Decodes a Reed-Solomon codeword via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_rs_decode(struct rssn_BincodeBuffer aCodewordBuf,
                                                 struct rssn_BincodeBuffer aNSymBuf)
;

/*
 Encodes data using Reed-Solomon code via Bincode interface.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_rs_encode(struct rssn_BincodeBuffer aDataBuf,
                                                 struct rssn_BincodeBuffer aNSymBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_shannon_entropy(struct rssn_BincodeBuffer aProbsBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_simple_linear_regression(struct rssn_BincodeBuffer aDataBuf)
;

/*
 Creates a new Simplex (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_simplex_create(struct rssn_BincodeBuffer aVerticesBuf)
;

/*
 Gets the dimension of a Simplex (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_simplex_dimension(struct rssn_BincodeBuffer aSimplexBuf)
;

/*
 Adds a simplex to a SimplicialComplex (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_simplicial_complex_add_simplex(struct rssn_BincodeBuffer aComplexBuf,
                                                                      struct rssn_BincodeBuffer aVerticesBuf)
;

/*
 Applies the symbolic boundary operator to a SymbolicChain (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_simplicial_complex_apply_symbolic_boundary_operator(struct rssn_BincodeBuffer aComplexBuf,
                                                                                           struct rssn_BincodeBuffer aChainBuf)
;

/*
 Creates a new SimplicialComplex (Bincode)
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_simplicial_complex_create(void) ;

/*
 Gets the symbolic boundary matrix for dimension k (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_simplicial_complex_get_symbolic_boundary_matrix(struct rssn_BincodeBuffer aComplexBuf,
                                                                                       size_t aK)
;

/*
 Simplifies an expression using the legacy simplifier (Bincode input/output).
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_simplify(struct rssn_BincodeBuffer aExprBuf) ;

/*
 Simplifies an expression using the DAG-based simplifier (Bincode input/output).
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_simplify_dag(struct rssn_BincodeBuffer aExprBuf) ;

/*
 Simplifies a logical expression using bincode-based FFI.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_simplify_logic(struct rssn_BincodeBuffer aExprBuf) ;

/*
 Simplifies radical expressions (Bincode)
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_simplify_radicals(struct rssn_BincodeBuffer aExprBuf) ;

rssn_ struct rssn_BincodeBuffer rssn_bincode_so3_generators(void) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_solve(struct rssn_BincodeBuffer aExprBuf,
                                             struct rssn_BincodeBuffer aVarBuf)
;

/*
 Solves a Bernoulli ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_bernoulli_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                           const char *aFunc,
                                                           const char *aVar)
;

/*
 Solves by reduction of order using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_by_reduction_of_order(struct rssn_BincodeBuffer aEquationBuf,
                                                                   const char *aFunc,
                                                                   const char *aVar,
                                                                   struct rssn_BincodeBuffer aY1Buf)
;

/*
 Solves a Cauchy-Euler ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_cauchy_euler_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                              const char *aFunc,
                                                              const char *aVar)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_diophantine(struct rssn_BincodeBuffer aEquationBuf,
                                                         struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves an exact ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_exact_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                       const char *aFunc,
                                                       const char *aVar)
;

/*
 Solves a first-order linear ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_first_order_linear_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                                    const char *aFunc,
                                                                    const char *aVar)
;

/*
 Solves the 1D heat equation (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_heat_equation_1d(struct rssn_BincodeBuffer aEquationBuf,
                                                              const char *aFunc,
                                                              struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves the 2D Laplace equation (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_laplace_equation_2d(struct rssn_BincodeBuffer aEquationBuf,
                                                                 const char *aFunc,
                                                                 struct rssn_BincodeBuffer aVarsBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_linear_system(struct rssn_BincodeBuffer aSystemBuf,
                                                           struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves an ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_ode(struct rssn_BincodeBuffer aOdeBuf,
                                                 const char *aFunc,
                                                 const char *aVar)
;

/*
 Solves a PDE using Bincode with automatic method selection.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_pde(struct rssn_BincodeBuffer aPdeBuf,
                                                 const char *aFunc,
                                                 struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves a PDE using the method of characteristics (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_pde_by_characteristics(struct rssn_BincodeBuffer aEquationBuf,
                                                                    const char *aFunc,
                                                                    struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves a Riccati ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_riccati_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                         const char *aFunc,
                                                         const char *aVar,
                                                         struct rssn_BincodeBuffer aY1Buf)
;

/*
 Solves a separable ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_separable_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                           const char *aFunc,
                                                           const char *aVar)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_system(struct rssn_BincodeBuffer aEquationsBuf,
                                                    struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves the 1D wave equation (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_wave_equation_1d(struct rssn_BincodeBuffer aEquationBuf,
                                                              const char *aFunc,
                                                              struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Computes square-free factorization (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_square_free_factorization_gf(struct rssn_BincodeBuffer aPolyBuf)
;

/*
 Computes the symbolic standard deviation of a set of expressions using Bincode.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_std_dev(struct rssn_BincodeBuffer aDataBuf) ;

rssn_ struct rssn_BincodeBuffer rssn_bincode_stirling_number_second_kind(size_t aN, size_t aK) ;

/*
 Represents Stokes' theorem (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_stokes_theorem(struct rssn_BincodeBuffer aVectorFieldBuf,
                                                      struct rssn_BincodeBuffer aSurfaceBuf)
;

/*
 Generates the Sturm sequence for a given polynomial (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_sturm_sequence(struct rssn_BincodeBuffer aExprBuf,
                                                      const char *aVarPtr)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_su2_generators(void) ;

/*
 Substitutes using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_substitute(struct rssn_BincodeBuffer aExprBuf,
                                                  const char *aVar,
                                                  struct rssn_BincodeBuffer aReplacementBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_summation(struct rssn_BincodeBuffer aExprBuf,
                                                 struct rssn_BincodeBuffer aVarBuf,
                                                 struct rssn_BincodeBuffer aLowerBuf,
                                                 struct rssn_BincodeBuffer aUpperBuf)
;

/*
 Adds a term to a SymbolicChain (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_symbolic_chain_add_term(struct rssn_BincodeBuffer aChainBuf,
                                                               struct rssn_BincodeBuffer aSimplexBuf,
                                                               struct rssn_BincodeBuffer aCoeffBuf)
;

/*
 Creates a new SymbolicChain (Bincode)
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_symbolic_chain_create(size_t aDimension) ;

rssn_ struct rssn_BincodeBuffer rssn_bincode_symmetric_group_create(size_t aN) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_taylor_series(struct rssn_BincodeBuffer aExprBuf,
                                                     struct rssn_BincodeBuffer aVarBuf,
                                                     struct rssn_BincodeBuffer aCenterBuf,
                                                     struct rssn_BincodeBuffer aOrderBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_tensor_add(struct rssn_BincodeBuffer aT1Buf,
                                                  struct rssn_BincodeBuffer aT2Buf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_tensor_outer_product(struct rssn_BincodeBuffer aT1Buf,
                                                            struct rssn_BincodeBuffer aT2Buf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_tensor_scalar_mul(struct rssn_BincodeBuffer aTBuf,
                                                         struct rssn_BincodeBuffer aScalarBuf)
;

/*
 Converts a logical expression to Conjunctive Normal Form (CNF) using bincode-based FFI.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_to_cnf(struct rssn_BincodeBuffer aExprBuf) ;

/*
 Converts a logical expression to Disjunctive Normal Form (DNF) using bincode-based FFI.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_to_dnf(struct rssn_BincodeBuffer aExprBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_contravariant_vector(struct rssn_BincodeBuffer aCompsBuf,
                                                                      struct rssn_BincodeBuffer aFromBuf,
                                                                      struct rssn_BincodeBuffer aToBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_covariant_vector(struct rssn_BincodeBuffer aCompsBuf,
                                                                  struct rssn_BincodeBuffer aFromBuf,
                                                                  struct rssn_BincodeBuffer aToBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_curl(struct rssn_BincodeBuffer aCompsBuf,
                                                      struct rssn_BincodeBuffer aFromBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_divergence(struct rssn_BincodeBuffer aCompsBuf,
                                                            struct rssn_BincodeBuffer aFromBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_expression(struct rssn_BincodeBuffer aExprBuf,
                                                            struct rssn_BincodeBuffer aFromBuf,
                                                            struct rssn_BincodeBuffer aToBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_gradient(struct rssn_BincodeBuffer aScalarBuf,
                                                          struct rssn_BincodeBuffer aVarsBuf,
                                                          struct rssn_BincodeBuffer aFromBuf,
                                                          struct rssn_BincodeBuffer aToBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_point(struct rssn_BincodeBuffer aPointBuf,
                                                       struct rssn_BincodeBuffer aFromBuf,
                                                       struct rssn_BincodeBuffer aToBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_two_sample_t_test(struct rssn_BincodeBuffer aData1Buf,
                                                         struct rssn_BincodeBuffer aData2Buf,
                                                         struct rssn_BincodeBuffer aMuDiffBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_unify_expression(struct rssn_BincodeBuffer aExprBuf) ;

/*
 Computes the symbolic variance of a set of expressions using Bincode.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_variance(struct rssn_BincodeBuffer aDataBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_vector_cross(struct rssn_BincodeBuffer aV1Buf,
                                                    struct rssn_BincodeBuffer aV2Buf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_vector_dot(struct rssn_BincodeBuffer aV1Buf,
                                                  struct rssn_BincodeBuffer aV2Buf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_vector_magnitude(struct rssn_BincodeBuffer aVBuf) ;

rssn_ struct rssn_BincodeBuffer rssn_bincode_vector_normalize(struct rssn_BincodeBuffer aVBuf) ;

/*
 Computes the wedge product of two differential forms (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_wedge_product(struct rssn_BincodeBuffer aForm1Buf,
                                                     struct rssn_BincodeBuffer aForm2Buf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_z_test(struct rssn_BincodeBuffer aDataBuf,
                                              struct rssn_BincodeBuffer aTargetMeanBuf,
                                              struct rssn_BincodeBuffer aPopStdDevBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_z_transform(struct rssn_BincodeBuffer aExprBuf,
                                                   struct rssn_BincodeBuffer aInVarBuf,
                                                   struct rssn_BincodeBuffer aOutVarBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_zeta(struct rssn_BincodeBuffer aArgBuf) ;

/*
 Computes binomial coefficient C(n, k).
 */
rssn_ char *rssn_binomial_coefficient(size_t aN, size_t aK) ;

/*
 Computes binomial coefficient C(n, k) and returns as JSON string.
 */
rssn_ char *rssn_binomial_coefficient_json(size_t aN, size_t aK) ;

/*
 Computes the boundary of a domain (Handle)
 */
rssn_ struct rssn_Expr *rssn_boundary_handle(const struct rssn_Expr *aDomainPtr) ;

rssn_
struct rssn_Vec_SparsePolynomial *rssn_buchberger_handle(const struct rssn_Vec_SparsePolynomial *aBasis,
                                                         enum rssn_MonomialOrder aOrder)
;

/*
 Calculates the residue of a complex function at a given pole.
 */
rssn_
struct rssn_Expr *rssn_calculate_residue(const struct rssn_Expr *aExpr,
                                         const char *aVar,
                                         const struct rssn_Expr *aPole)
;

rssn_
int32_t rssn_calculus_definite_integrate(size_t aExprH,
                                         const char *aVar,
                                         size_t aLowerH,
                                         size_t aUpperH,
                                         size_t *aResultH)
;

rssn_ int32_t rssn_calculus_differentiate(size_t aExprH, const char *aVar, size_t *aResultH) ;

rssn_ int32_t rssn_calculus_integrate(size_t aExprH, const char *aVar, size_t *aResultH) ;

rssn_ int32_t rssn_calculus_limit(size_t aExprH, const char *aVar, size_t aToH, size_t *aResultH) ;

rssn_
int32_t rssn_calculus_substitute(size_t aExprH,
                                 const char *aVar,
                                 size_t aReplacementH,
                                 size_t *aResultH)
;

/*
 Expands an expression using algebraic rules.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_cas_expand(const struct rssn_Expr *aExpr) ;

/*
 Expands an expression using algebraic rules (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_cas_expand_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Expands an expression using algebraic rules (JSON).
 */
rssn_ char *rssn_cas_expand_json(const char *aJsonStr) ;

/*
 Factorizes an expression.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_cas_factorize(const struct rssn_Expr *aExpr) ;

/*
 Factorizes an expression (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_cas_factorize_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Factorizes an expression (JSON).
 */
rssn_ char *rssn_cas_factorize_json(const char *aJsonStr) ;

/*
 Normalizes an expression to a canonical form.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_cas_normalize(const struct rssn_Expr *aExpr) ;

/*
 Normalizes an expression to a canonical form (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_cas_normalize_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Normalizes an expression to a canonical form (JSON).
 */
rssn_ char *rssn_cas_normalize_json(const char *aJsonStr) ;

/*
 Simplifies an expression using a set of polynomial side-relations.

 # Arguments
 * `expr` - The expression to simplify.
 * `relations` - Array of pointers to relation expressions (e.g., `x^2 + y^2 - 1`).
 * `relations_len` - Number of relations.
 * `vars` - Array of C strings representing variable ordering.
 * `vars_len` - Number of variables.
 * `order_int` - Monomial ordering: 0=Lex, 1=GradedLex, 2=GradedReverseLex.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_cas_simplify_with_relations(const struct rssn_Expr *aExpr,
                                                   const struct rssn_Expr *const *aRelations,
                                                   size_t aRelationsLen,
                                                   const char *const *aVars,
                                                   size_t aVarsLen,
                                                   int32_t aOrderInt)
;

/*
 Simplifies an expression using a set of polynomial side-relations (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_cas_simplify_with_relations_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Simplifies an expression using a set of polynomial side-relations (JSON).
 */
rssn_ char *rssn_cas_simplify_with_relations_json(const char *aJsonStr) ;

rssn_ struct rssn_Expr *rssn_catalan_number(size_t aN) ;

rssn_
void rssn_character(const struct rssn_Representation *aRep,
                    size_t *aOutLen,
                    struct rssn_Expr ***aOutKeys,
                    struct rssn_Expr ***aOutValues)
;

/*
 Checks if an expression is analytic with respect to a variable.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `var` is a valid C string.
 */
rssn_ bool rssn_check_analytic(const struct rssn_Expr *aExpr, const char *aVar) ;

rssn_ bool rssn_check_jacobi_identity(const struct rssn_LieAlgebra *aAlgebra) ;

/*
 Solves a system of congruences using the Chinese Remainder Theorem.

 # Safety
 `remainders` and `moduli` must be valid pointers to arrays of `Expr` pointers of length `len`.
 */
rssn_
struct rssn_Expr *rssn_chinese_remainder_handle(const struct rssn_Expr *const *aRemainders,
                                                const struct rssn_Expr *const *aModuli,
                                                int aLen)
;

/*
 Finds the chromatic number exactly (NP-hard).
 */
rssn_ size_t rssn_chromatic_number_exact(const struct rssn_RssnGraph *aGraph) ;

/*
 Computes the number of combinations (nCk).
 */
rssn_ int32_t rssn_comb_combinations(uint64_t aN, uint64_t aK, double *aResult) ;

/*
 Computes the factorial of a number.
 */
rssn_ int32_t rssn_comb_factorial(uint64_t aN, double *aResult) ;

/*
 Computes the number of permutations (nPk).
 */
rssn_ int32_t rssn_comb_permutations(uint64_t aN, uint64_t aK, double *aResult) ;

rssn_ struct rssn_Expr *rssn_combinations(const struct rssn_Expr *aN, const struct rssn_Expr *aK) ;

rssn_
struct rssn_Expr **rssn_commutator_table(const struct rssn_LieAlgebra *aAlgebra,
                                         size_t *aOutRows,
                                         size_t *aOutCols)
;

/*
 Finds fixed points (Handle)
 */
rssn_
struct rssn_Expr **rssn_complex_system_fixed_points(const struct rssn_ComplexDynamicalSystem *aSystemPtr,
                                                    size_t *aOutLen)
;

/*
 Frees a ComplexDynamicalSystem handle
 */
rssn_ void rssn_complex_system_free(struct rssn_ComplexDynamicalSystem *aPtr) ;

/*
 Iterates the system once (Handle)
 */
rssn_
struct rssn_Expr *rssn_complex_system_iterate(const struct rssn_ComplexDynamicalSystem *aSystemPtr,
                                              const struct rssn_Expr *aZPtr)
;

/*
 Creates a new Mandelbrot family system (Handle)
 */
rssn_
struct rssn_ComplexDynamicalSystem *rssn_complex_system_new_mandelbrot(const struct rssn_Expr *aCPtr)
;

/*
 Clears a ComputationResultCache.
 */
rssn_ void rssn_computation_result_cache_clear(struct rssn_ComputationResultCache *aCache) ;

/*
 Frees a ComputationResultCache.
 */
rssn_ void rssn_computation_result_cache_free(struct rssn_ComputationResultCache *aCache) ;

/*
 Retrieves a value from the ComputationResultCache.
 Returns a C string (char*) which must be freed by the caller using rssn_free_string.
 Returns null if not found.
 */
rssn_
char *rssn_computation_result_cache_get(struct rssn_ComputationResultCache *aCache,
                                        const struct rssn_Expr *aExpr)
;

/*
 Retrieves a value from the ComputationResultCache using a bincode expression key.
 */
rssn_
struct rssn_BincodeBuffer rssn_computation_result_cache_get_bincode(struct rssn_ComputationResultCache *aCache,
                                                                    struct rssn_BincodeBuffer aExprBuffer)
;

/*
 Retrieves a value from the ComputationResultCache using a JSON expression key.
 Returns the value as a JSON string (e.g. "\"result\"").
 */
rssn_
char *rssn_computation_result_cache_get_json(struct rssn_ComputationResultCache *aCache,
                                             const char *aJsonExpr)
;

/*
 Creates a new ComputationResultCache.
 The caller is responsible for freeing the memory using rssn_computation_result_cache_free.
 */
rssn_ struct rssn_ComputationResultCache *rssn_computation_result_cache_new(void) ;

/*
 Stores a value in the ComputationResultCache.
 */
rssn_
void rssn_computation_result_cache_set(struct rssn_ComputationResultCache *aCache,
                                       const struct rssn_Expr *aExpr,
                                       const char *aValue)
;

/*
 Stores a value in the ComputationResultCache using bincode buffers.
 */
rssn_
void rssn_computation_result_cache_set_bincode(struct rssn_ComputationResultCache *aCache,
                                               struct rssn_BincodeBuffer aExprBuffer,
                                               struct rssn_BincodeBuffer aValueBuffer)
;

/*
 Stores a value in the ComputationResultCache using JSON strings.
 */
rssn_
void rssn_computation_result_cache_set_json(struct rssn_ComputationResultCache *aCache,
                                            const char *aJsonExpr,
                                            const char *aJsonValue)
;

rssn_ struct rssn_Expr *rssn_conditional_entropy(const struct rssn_Expr *aJointProbs) ;

rssn_
struct rssn_Expr *rssn_convolution_fourier(const struct rssn_Expr *aF,
                                           const struct rssn_Expr *aG,
                                           const char *aInVar,
                                           const char *aOutVar)
;

rssn_
struct rssn_Expr *rssn_convolution_laplace(const struct rssn_Expr *aF,
                                           const struct rssn_Expr *aG,
                                           const char *aInVar,
                                           const char *aOutVar)
;

rssn_
struct rssn_Expr *rssn_coordinates_get_metric_tensor_handle(enum rssn_CoordinateSystem aSystem)
;

/*
 Computes the symbolic Pearson correlation coefficient.

 # Safety
 The caller must ensure `data1` and `data2` are valid pointers to arrays of `Expr` pointers.
 */
rssn_
struct rssn_Expr *rssn_correlation(const struct rssn_Expr *const *aData1,
                                   size_t aLen1,
                                   const struct rssn_Expr *const *aData2,
                                   size_t aLen2)
;

/*
 Creates a cosine expression: cos(expr).
 */
rssn_ struct rssn_Expr *rssn_cos(const struct rssn_Expr *aExpr) ;

/*
 Creates a cosine expression from bincode: cos(expr).
 */
rssn_ struct rssn_BincodeBuffer rssn_cos_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a cosine expression from JSON: cos(expr).
 */
rssn_ char *rssn_cos_json(const char *aJsonExpr) ;

/*
 Counts the number of distinct real roots in an interval (Handle)
 */
rssn_
int64_t rssn_count_real_roots_in_interval_handle(const struct rssn_Expr *aExprPtr,
                                                 const char *aVarPtr,
                                                 double aA,
                                                 double aB)
;

/*
 Computes the symbolic covariance of two sets of expressions.

 # Safety
 The caller must ensure `data1` and `data2` are valid pointers to arrays of `Expr` pointers.
 */
rssn_
struct rssn_Expr *rssn_covariance(const struct rssn_Expr *const *aData1,
                                  size_t aLen1,
                                  const struct rssn_Expr *const *aData2,
                                  size_t aLen2)
;

/*
 Creates a grid complex
 */
rssn_ struct rssn_SimplicialComplex *rssn_create_grid_complex(size_t aWidth, size_t aHeight) ;

/*
 Creates a torus complex
 */
rssn_ struct rssn_SimplicialComplex *rssn_create_torus_complex(size_t aM, size_t aN) ;

rssn_
struct rssn_Expr *rssn_cross_entropy(const struct rssn_Expr *const *aPProbs,
                                     size_t aPLen,
                                     const struct rssn_Expr *const *aQProbs,
                                     size_t aQLen)
;

/*
 Adds two curve points.

 # Safety
 All pointers must be valid.
 */
rssn_
struct rssn_CurvePoint *rssn_curve_add(const struct rssn_EllipticCurve *aCurve,
                                       const struct rssn_CurvePoint *aP1,
                                       const struct rssn_CurvePoint *aP2)
;

/*
 Creates an affine curve point.

 # Safety
 `field` must match the curve's field.
 */
rssn_ struct rssn_CurvePoint *rssn_curve_point_affine(int64_t aX, int64_t aY, int64_t aModulus) ;

/*
 Frees a curve point handle.

 # Safety
 Caller must ensure `point` was returned by a curve point function.
 */
rssn_ void rssn_curve_point_free(struct rssn_CurvePoint *aPoint) ;

/*
 Creates the point at infinity.
 */
rssn_ struct rssn_CurvePoint *rssn_curve_point_infinity(void) ;

/*
 Performs scalar multiplication k * P on elliptic curve.

 # Safety
 All pointers must be valid.
 */
rssn_
struct rssn_CurvePoint *rssn_curve_scalar_mult(const struct rssn_EllipticCurve *aCurve,
                                               int64_t aK,
                                               const struct rssn_CurvePoint *aP)
;

rssn_ struct rssn_Group *rssn_cyclic_group_create(size_t aN) ;

/*
 Computes the definite integral of an expression.
 */
rssn_
struct rssn_Expr *rssn_definite_integrate(const struct rssn_Expr *aExpr,
                                          const char *aVar,
                                          const struct rssn_Expr *aLower,
                                          const struct rssn_Expr *aUpper)
;

/*
 Denests a nested square root (Handle)
 */
rssn_ struct rssn_Expr *rssn_denest_sqrt_handle(const struct rssn_Expr *aExpr) ;

/*
 Differentiates an expression: d/d(var) expr.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `var` is a valid C string.
 */
rssn_ struct rssn_Expr *rssn_differentiate(const struct rssn_Expr *aExpr, const char *aVar) ;

rssn_ struct rssn_Expr *rssn_digamma(const struct rssn_Expr *aArg) ;

rssn_ struct rssn_Group *rssn_dihedral_group_create(size_t aN) ;

rssn_ struct rssn_Expr *rssn_dist_bernoulli(const struct rssn_Expr *aP) ;

rssn_
struct rssn_Expr *rssn_dist_beta(const struct rssn_Expr *aAlpha,
                                 const struct rssn_Expr *aBeta)
;

rssn_ struct rssn_Expr *rssn_dist_binomial(const struct rssn_Expr *aN, const struct rssn_Expr *aP) ;

rssn_ struct rssn_Expr *rssn_dist_cdf(const struct rssn_Expr *aDist, const struct rssn_Expr *aX) ;

rssn_ struct rssn_Expr *rssn_dist_expectation(const struct rssn_Expr *aDist) ;

rssn_ struct rssn_Expr *rssn_dist_exponential(const struct rssn_Expr *aRate) ;

rssn_
struct rssn_Expr *rssn_dist_gamma(const struct rssn_Expr *aShape,
                                  const struct rssn_Expr *aRate)
;

rssn_ struct rssn_Expr *rssn_dist_mgf(const struct rssn_Expr *aDist, const struct rssn_Expr *aT) ;

rssn_
struct rssn_Expr *rssn_dist_normal(const struct rssn_Expr *aMean,
                                   const struct rssn_Expr *aStdDev)
;

rssn_ struct rssn_Expr *rssn_dist_pdf(const struct rssn_Expr *aDist, const struct rssn_Expr *aX) ;

rssn_ struct rssn_Expr *rssn_dist_poisson(const struct rssn_Expr *aRate) ;

rssn_ struct rssn_Expr *rssn_dist_student_t(const struct rssn_Expr *aNu) ;

rssn_
struct rssn_Expr *rssn_dist_uniform(const struct rssn_Expr *aMin,
                                    const struct rssn_Expr *aMax)
;

rssn_ struct rssn_Expr *rssn_dist_variance(const struct rssn_Expr *aDist) ;

/*
 Returns the symbolic representation of Euler's number (e).
 */
rssn_ struct rssn_Expr *rssn_e(void) ;

/*
 Returns Euler's number (e) as bincode.
 */
rssn_ struct rssn_BincodeBuffer rssn_e_bincode(void) ;

/*
 Returns Euler's number (e) as JSON.
 */
rssn_ char *rssn_e_json(void) ;

/*
 Frees an elliptic curve handle.

 # Safety
 Caller must ensure `curve` was returned by `rssn_elliptic_curve_new`.
 */
rssn_ void rssn_elliptic_curve_free(struct rssn_EllipticCurve *aCurve) ;

/*
 Creates a new elliptic curve over a prime field.

 # Safety
 All BigInt pointers must be valid.
 */
rssn_ struct rssn_EllipticCurve *rssn_elliptic_curve_new(int64_t aA, int64_t aB, int64_t aModulus) ;

rssn_ struct rssn_Expr *rssn_erf(const struct rssn_Expr *aArg) ;

rssn_ double rssn_erf_numerical(double aX) ;

rssn_ struct rssn_Expr *rssn_erfc(const struct rssn_Expr *aArg) ;

rssn_ double rssn_erfc_numerical(double aX) ;

rssn_ struct rssn_Expr *rssn_erfi(const struct rssn_Expr *aArg) ;

/*
 Evaluates an expression at a given point.
 */
rssn_
struct rssn_Expr *rssn_evaluate_at_point(const struct rssn_Expr *aExpr,
                                         const char *aVar,
                                         const struct rssn_Expr *aValue)
;

rssn_ double rssn_evaluate_numerical_handle(const struct rssn_Expr *aExpr) ;

/*
 Creates an exponential expression: e^(expr).
 */
rssn_ struct rssn_Expr *rssn_exp(const struct rssn_Expr *aExpr) ;

/*
 Creates an exponential expression from bincode: e^(expr).
 */
rssn_ struct rssn_BincodeBuffer rssn_exp_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates an exponential expression from JSON: e^(expr).
 */
rssn_ char *rssn_exp_json(const char *aJsonExpr) ;

/*
 Expands a symbolic expression.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_expand(const struct rssn_Expr *aExpr) ;

/*
 Expands a symbolic expression from bincode.
 */
rssn_ struct rssn_BincodeBuffer rssn_expand_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Expands a symbolic expression from JSON.
 */
rssn_ char *rssn_expand_json(const char *aJsonExpr) ;

rssn_ struct rssn_Expr *rssn_exponential_map(const struct rssn_Expr *aX, size_t aOrder) ;

/*
 Creates an expression from a JSON string and returns a thread-safe handle.

 Returns 0 if the JSON is invalid.
 */
rssn_ size_t rssn_expr_create(const char *aJsonPtr) ;

/*
 Frees the memory associated with an expression handle.
 */
rssn_ void rssn_expr_free(size_t aHandle) ;

/*
 Simplifies an expression handle and returns a handle to the new, simplified expression.

 Returns 0 on error (e.g., invalid handle).
 */
rssn_ size_t rssn_expr_simplify(const size_t *aHandle) ;

/*
 Computes the Extended GCD of two expressions.

 # Safety
 `a` and `b` must be valid pointers to `Expr`.
 */
rssn_
struct rssn_Expr *rssn_extended_gcd_handle(const struct rssn_Expr *aA,
                                           const struct rssn_Expr *aB)
;

/*
 Computes the exterior derivative of a differential form (Handle)
 */
rssn_
struct rssn_DifferentialForm *rssn_exterior_derivative_handle(const struct rssn_DifferentialForm *aFormPtr,
                                                              const char *const *aVarsPtr,
                                                              int aVarsLen)
;

/*
 Factors a polynomial over a finite field (Handle)
 */
rssn_
struct rssn_Vec_FiniteFieldPolynomial *rssn_factor_gf_handle(const struct rssn_FiniteFieldPolynomial *aPoly)
;

/*
 Computes the Fast Fourier Transform (FFT) of a sequence of complex numbers in-place.
 */
rssn_ int32_t rssn_fft(rssn_Complex<double> *aData, size_t aLen) ;

/*
 Finds constrained extrema (Handle)
 */
rssn_
struct rssn_Vec_HashMap_Expr__Expr *rssn_find_constrained_extrema_handle(const struct rssn_Expr *aExprPtr,
                                                                         const struct rssn_Vec_Expr *aConstraintsPtr,
                                                                         const char *const *aVarsPtr,
                                                                         int aVarsLen)
;

/*
 Finds extrema of a function (Handle)
 */
rssn_
struct rssn_Vec_CriticalPoint *rssn_find_extrema_handle(const struct rssn_Expr *aExprPtr,
                                                        const char *const *aVarsPtr,
                                                        int aVarsLen)
;

/*
 Finds fixed points of a 1D map (Handle)
 */
rssn_
struct rssn_Expr **rssn_find_fixed_points(const struct rssn_Expr *aMapPtr,
                                          const char *aVar,
                                          size_t *aOutLen)
;

/*
 Finds the order of a pole.
 */
rssn_
size_t rssn_find_pole_order(const struct rssn_Expr *aExpr,
                            const char *aVar,
                            const struct rssn_Expr *aPole)
;

/*
 Finds poles of an expression.
 */
rssn_ struct rssn_Vec_Expr *rssn_find_poles(const struct rssn_Expr *aExpr, const char *aVar) ;

/*
 Frees a finite field handle.

 # Safety
 Caller must ensure `field` is a valid pointer returned by `rssn_finite_field_new`.
 */
rssn_ void rssn_finite_field_free(struct rssn_Arc_FiniteField *aField) ;

/*
 Creates a new finite field GF(modulus).

 Returns an opaque handle to the field.
 */
rssn_ struct rssn_Arc_FiniteField *rssn_finite_field_new(int64_t aModulus) ;

rssn_
struct rssn_Expr *rssn_fourier_differentiation(const struct rssn_Expr *aFOmega,
                                               const char *aOutVar)
;

rssn_
struct rssn_Expr *rssn_fourier_frequency_shift(const struct rssn_Expr *aFOmega,
                                               const struct rssn_Expr *aA,
                                               const char *aOutVar)
;

rssn_
struct rssn_Expr *rssn_fourier_scaling(const struct rssn_Expr *aFOmega,
                                       const struct rssn_Expr *aA,
                                       const char *aOutVar)
;

rssn_
struct rssn_Expr *rssn_fourier_series_handle(const struct rssn_Expr *aExpr,
                                             const char *aVar,
                                             const struct rssn_Expr *aPeriod,
                                             size_t aOrder)
;

rssn_
struct rssn_Expr *rssn_fourier_time_shift(const struct rssn_Expr *aFOmega,
                                          const struct rssn_Expr *aA,
                                          const char *aOutVar)
;

/*
 Computes the symbolic Fourier transform of an expression.

 # Safety
 Caller must ensure `expr` is a valid pointer to an `Expr`.
 `in_var` and `out_var` must be valid C strings or null (defaults apply).
 */
rssn_
struct rssn_Expr *rssn_fourier_transform(const struct rssn_Expr *aExpr,
                                         const char *aInVar,
                                         const char *aOutVar)
;

/*
 Frees a Fredholm integral equation.
 */
rssn_ void rssn_fredholm_free(struct rssn_FredholmEquation *aPtr) ;

/*
 Creates a new Fredholm integral equation.
 */
rssn_
struct rssn_FredholmEquation *rssn_fredholm_new(const struct rssn_Expr *aYX,
                                                const struct rssn_Expr *aFX,
                                                const struct rssn_Expr *aLambda,
                                                const struct rssn_Expr *aKernel,
                                                const struct rssn_Expr *aLowerBound,
                                                const struct rssn_Expr *aUpperBound,
                                                const char *aVarX,
                                                const char *aVarT)
;

/*
 Solves a Fredholm equation using the Neumann series method.
 */
rssn_
struct rssn_Expr *rssn_fredholm_solve_neumann(const struct rssn_FredholmEquation *aEq,
                                              size_t aIterations)
;

/*
 Solves a Fredholm equation using the Neumann series method (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_fredholm_solve_neumann_bincode(const uint8_t *aInputPtr,
                                                              size_t aInputLen)
;

/*
 Solves a Fredholm equation using the Neumann series method (JSON).
 */
rssn_ char *rssn_fredholm_solve_neumann_json(const char *aInputJson) ;

/*
 Solves a Fredholm equation with a separable kernel.
 */
rssn_
struct rssn_Expr *rssn_fredholm_solve_separable(const struct rssn_FredholmEquation *aEq,
                                                const struct rssn_Expr *const *aAFuncs,
                                                size_t aALen,
                                                const struct rssn_Expr *const *aBFuncs,
                                                size_t aBLen)
;

/*
 Solves a Fredholm equation with a separable kernel (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_fredholm_solve_separable_bincode(const uint8_t *aInputPtr,
                                                                size_t aInputLen)
;

/*
 Solves a Fredholm equation with a separable kernel (JSON).
 */
rssn_ char *rssn_fredholm_solve_separable_json(const char *aInputJson) ;

/*
 Frees a bincode buffer allocated by an FFI function.

 # Safety
 The buffer must have been allocated by an FFI function that returns `BincodeBuffer`.
 This function should only be called once per buffer.
 */
rssn_ void rssn_free_bincode_buffer(struct rssn_BincodeBuffer aBuffer) ;

/*
 Frees a Vec<CriticalPoint> handle
 */
rssn_ void rssn_free_critical_point_vec_handle(struct rssn_Vec_CriticalPoint *aPtr) ;

/*
 Frees a DifferentialForm handle
 */
rssn_ void rssn_free_differential_form_handle(struct rssn_DifferentialForm *aPtr) ;

/*
 Frees an Expr pointer created by this module.

 # Safety
 The caller must ensure `expr` was created by this module and hasn't been freed yet.
 */
rssn_ void rssn_free_expr(struct rssn_Expr *aExpr) ;

/*
 Frees a Vec<Expr> handle
 */
rssn_ void rssn_free_expr_vec_handle(struct rssn_Vec_Expr *aPtr) ;

/*
 Frees a multivector (Handle)
 */
rssn_ void rssn_free_multivector_handle(struct rssn_Multivector *aPtr) ;

rssn_ void rssn_free_poles(struct rssn_Vec_Expr *aPoles) ;

/*
 Frees a vector of polynomials (Handle)
 */
rssn_ void rssn_free_poly_vec_handle(struct rssn_Vec_FiniteFieldPolynomial *aPtr) ;

/*
 Frees a Vec<HashMap<Expr, Expr>> handle
 */
rssn_ void rssn_free_solution_vec_handle(struct rssn_Vec_HashMap_Expr__Expr *aPtr) ;

/*
 Frees a string allocated by an FFI function.

 # Safety
 The string must have been allocated by an FFI function that returns `*mut c_char`.
 This function should only be called once per string.
 */
rssn_ void rssn_free_string(char *aS) ;

/*
 Frees a C string returned by other functions.
 */
rssn_ void rssn_free_string_api(char *aPtr) ;

rssn_ struct rssn_Expr *rssn_gamma(const struct rssn_Expr *aArg) ;

rssn_ double rssn_gamma_numerical(double aX) ;

/*
 Represents Gauss's theorem (Handle)
 */
rssn_
struct rssn_Expr *rssn_gauss_theorem_handle(const rssn_Vector *aVectorFieldPtr,
                                            const struct rssn_Expr *aVolumePtr)
;

/*
 Computes general multi-valued arccos (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_arccos_handle(const struct rssn_Expr *aZ,
                                             const struct rssn_Expr *aK,
                                             const struct rssn_Expr *aS)
;

/*
 Computes general multi-valued arcsin (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_arcsin_handle(const struct rssn_Expr *aZ,
                                             const struct rssn_Expr *aK)
;

/*
 Computes general multi-valued arctan (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_arctan_handle(const struct rssn_Expr *aZ,
                                             const struct rssn_Expr *aK)
;

/*
 Computes general multi-valued logarithm (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_log_handle(const struct rssn_Expr *aZ,
                                          const struct rssn_Expr *aK)
;

/*
 Computes general multi-valued n-th root (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_nth_root_handle(const struct rssn_Expr *aZ,
                                               const struct rssn_Expr *aN,
                                               const struct rssn_Expr *aK)
;

/*
 Computes general multi-valued power (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_power_handle(const struct rssn_Expr *aZ,
                                            const struct rssn_Expr *aW,
                                            const struct rssn_Expr *aK)
;

/*
 Computes general multi-valued square root (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_sqrt_handle(const struct rssn_Expr *aZ,
                                           const struct rssn_Expr *aK)
;

/*
 Represents the generalized Stokes' theorem (Handle)
 */
rssn_
struct rssn_Expr *rssn_generalized_stokes_theorem_handle(const struct rssn_DifferentialForm *aOmegaPtr,
                                                         const struct rssn_Expr *aManifoldPtr,
                                                         const char *const *aVarsPtr,
                                                         int aVarsLen)
;

/*
 Generates an ECDH key pair.

 # Safety
 All pointers must be valid.
 */
rssn_
struct rssn_EcdhKeyPair *rssn_generate_keypair(const struct rssn_EllipticCurve *aCurve,
                                               const struct rssn_CurvePoint *aGenerator)
;

/*
 Generates a shared secret using ECDH.

 # Safety
 All pointers must be valid.
 */
rssn_
struct rssn_CurvePoint *rssn_generate_shared_secret(const struct rssn_EllipticCurve *aCurve,
                                                    int64_t aPrivateKey,
                                                    const struct rssn_CurvePoint *aOtherPublicKey)
;

/*
 Returns the build date as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_build_date(void) ;

/*
 Returns the build date as a bincode buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_ struct rssn_BincodeBuffer rssn_get_build_date_bincode(void) ;

/*
 Returns the build date as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_build_date_json(void) ;

/*
 Returns all build information as a bincode buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_ struct rssn_BincodeBuffer rssn_get_build_info_bincode(void) ;

/*
 Returns all build information as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_build_info_json(void) ;

/*
 Returns the cargo target triple as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_cargo_target_triple(void) ;

/*
 Returns the commit SHA as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_commit_sha(void) ;

/*
 Returns the commit SHA as a bincode buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_ struct rssn_BincodeBuffer rssn_get_commit_sha_bincode(void) ;

/*
 Returns the commit SHA as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_commit_sha_json(void) ;

/*
 Retrieves the last error message set by an FFI function on the current thread.

 The returned pointer is valid until the next call to an FFI function on the same thread.
 The caller should not free this pointer.
 */
rssn_ const char *rssn_get_last_error(void) ;

/*
 Gets real and imaginary parts of an expression.
 Returns a pointer to a tuple (Expr, Expr) - represented as Vec<Expr> of size 2 for simplicity?
 Or return two out pointers?
 I'll return a Vec<Expr> of size 2.
 */
rssn_ struct rssn_Vec_Expr *rssn_get_real_imag_parts(const struct rssn_Expr *aExpr) ;

/*
 Returns the rustc version as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_rustc_version(void) ;

/*
 Returns the system info as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_system_info(void) ;

/*
 Performs addition in GF(2^8) (XOR operation).
 */
rssn_ uint8_t rssn_gf256_add(uint8_t aA, uint8_t aB) ;

/*
 Performs division in GF(2^8).
 Returns 0 if divisor is 0 (error case).
 */
rssn_ uint8_t rssn_gf256_div(uint8_t aA, uint8_t aB) ;

/*
 Computes the exponentiation (anti-logarithm) in GF(2^8).
 */
rssn_ uint8_t rssn_gf256_exp(uint8_t aLogVal) ;

/*
 Computes the multiplicative inverse in GF(2^8).
 Returns 0 if input is 0 (error case).
 */
rssn_ uint8_t rssn_gf256_inv(uint8_t aA) ;

/*
 Performs multiplication in GF(2^8).
 */
rssn_ uint8_t rssn_gf256_mul(uint8_t aA, uint8_t aB) ;

rssn_ struct rssn_Expr *rssn_gini_impurity(const struct rssn_Expr *const *aProbs, size_t aLen) ;

rssn_
struct rssn_Expr **rssn_gram_schmidt(const struct rssn_HilbertSpace *aSpace,
                                     const struct rssn_Expr *const *aBasisPtr,
                                     size_t aBasisLen,
                                     size_t *aOutLen)
;

/*
 Adds an edge to the graph.
 */
rssn_
void rssn_graph_add_edge(struct rssn_RssnGraph *aPtr,
                         const char *aFromLabel,
                         const char *aToLabel,
                         const struct rssn_Expr *aWeight)
;

/*
 Adds a node to the graph.
 */
rssn_ size_t rssn_graph_add_node(struct rssn_RssnGraph *aPtr, const char *aLabel) ;

/*
 Gets the adjacency matrix of the graph.
 */
rssn_ struct rssn_Expr *rssn_graph_adjacency_matrix(const struct rssn_RssnGraph *aPtr) ;

/*
 Performs BFS traversal from a start node.
 Returns a JSON string containing the node IDs in visit order.
 */
rssn_ char *rssn_graph_bfs(const struct rssn_RssnGraph *aPtr, size_t aStartNode) ;

/*
 Performs BFS traversal starting from a given node.
 Returns a JSON array of node indices in visit order.
 */
rssn_ char *rssn_graph_bfs_api(const struct rssn_RssnGraph *aGraph, size_t aStartNode) ;

/*
 Finds maximum matching in a bipartite graph.
 partition_json should be a JSON array of 0s and 1s indicating the partition.
 Returns a JSON array of [u, v] pairs representing the matching.
 */
rssn_
char *rssn_graph_bipartite_maximum_matching(const struct rssn_RssnGraph *aGraph,
                                            const char *aPartitionJson)
;

/*
 Finds bridges and articulation points.
 Returns a JSON object with "bridges" and "articulation_points" fields.
 */
rssn_ char *rssn_graph_bridges_and_articulation_points_api(const struct rssn_RssnGraph *aGraph) ;

/*
 Computes the Cartesian product of two graphs.
 */
rssn_
struct rssn_RssnGraph *rssn_graph_cartesian_product(const struct rssn_RssnGraph *aPtr1,
                                                    const struct rssn_RssnGraph *aPtr2)
;

/*
 Computes the complement of a graph.
 */
rssn_ struct rssn_RssnGraph *rssn_graph_complement(const struct rssn_RssnGraph *aPtr) ;

/*
 Finds connected components.
 Returns a JSON string containing the components.
 */
rssn_ char *rssn_graph_connected_components(const struct rssn_RssnGraph *aPtr) ;

/*
 Finds all connected components in an undirected graph.
 Returns a JSON array of arrays, where each inner array is a component.
 */
rssn_ char *rssn_graph_connected_components_api(const struct rssn_RssnGraph *aGraph) ;

/*
 Performs DFS traversal from a start node.
 Returns a JSON string containing the node IDs in visit order.
 */
rssn_ char *rssn_graph_dfs(const struct rssn_RssnGraph *aPtr, size_t aStartNode) ;

/*
 Performs DFS traversal starting from a given node.
 Returns a JSON array of node indices in visit order.
 */
rssn_ char *rssn_graph_dfs_api(const struct rssn_RssnGraph *aGraph, size_t aStartNode) ;

/*
 Computes maximum flow using Dinic's algorithm.
 */
rssn_
double rssn_graph_dinic_max_flow(const struct rssn_RssnGraph *aGraph,
                                 size_t aSource,
                                 size_t aSink)
;

/*
 Computes the disjoint union of two graphs.
 */
rssn_
struct rssn_RssnGraph *rssn_graph_disjoint_union(const struct rssn_RssnGraph *aPtr1,
                                                 const struct rssn_RssnGraph *aPtr2)
;

/*
 Computes maximum flow using Edmonds-Karp algorithm.
 */
rssn_
double rssn_graph_edmonds_karp_max_flow(const struct rssn_RssnGraph *aGraph,
                                        size_t aSource,
                                        size_t aSink)
;

/*
 Frees a graph.
 */
rssn_ void rssn_graph_free(struct rssn_RssnGraph *aPtr) ;

/*
 Checks if the graph has a cycle.
 */
rssn_ int rssn_graph_has_cycle(const struct rssn_RssnGraph *aPtr) ;

/*
 Checks if the graph has a cycle.
 */
rssn_ int rssn_graph_has_cycle_api(const struct rssn_RssnGraph *aGraph) ;

/*
 Gets the incidence matrix of the graph.
 */
rssn_ struct rssn_Expr *rssn_graph_incidence_matrix(const struct rssn_RssnGraph *aPtr) ;

/*
 Creates an induced subgraph.
 */
rssn_
struct rssn_RssnGraph *rssn_graph_induced_subgraph(const struct rssn_RssnGraph *aPtr,
                                                   const char *const *aNodeLabels,
                                                   size_t aCount)
;

/*
 Computes the intersection of two graphs.
 */
rssn_
struct rssn_RssnGraph *rssn_graph_intersection(const struct rssn_RssnGraph *aPtr1,
                                               const struct rssn_RssnGraph *aPtr2)
;

/*
 Checks if the graph is bipartite.
 Returns 1 if bipartite, 0 otherwise.
 */
rssn_ int rssn_graph_is_bipartite(const struct rssn_RssnGraph *aPtr) ;

/*
 Checks if a graph is bipartite.
 Returns a JSON array of partition assignments (0 or 1 for each node), or null if not bipartite.
 */
rssn_ char *rssn_graph_is_bipartite_api(const struct rssn_RssnGraph *aGraph) ;

/*
 Checks if the graph is connected.
 */
rssn_ int rssn_graph_is_connected(const struct rssn_RssnGraph *aGraph) ;

/*
 Computes the join of two graphs.
 */
rssn_
struct rssn_RssnGraph *rssn_graph_join(const struct rssn_RssnGraph *aPtr1,
                                       const struct rssn_RssnGraph *aPtr2)
;

/*
 Computes minimum spanning tree using Kruskal's algorithm.
 Returns a JSON string containing the MST edges.
 */
rssn_ char *rssn_graph_kruskal_mst(const struct rssn_RssnGraph *aPtr) ;

/*
 Computes the minimum spanning tree using Kruskal's algorithm.
 Returns a new graph containing only the MST edges.
 */
rssn_ struct rssn_RssnGraph *rssn_graph_kruskal_mst_api(const struct rssn_RssnGraph *aGraph) ;

/*
 Gets the Laplacian matrix of the graph.
 */
rssn_ struct rssn_Expr *rssn_graph_laplacian_matrix(const struct rssn_RssnGraph *aPtr) ;

/*
 Computes maximum flow using Edmonds-Karp algorithm.
 */
rssn_ double rssn_graph_max_flow(const struct rssn_RssnGraph *aPtr, size_t aSource, size_t aSink) ;

/*
 Creates a new graph.
 */
rssn_ struct rssn_RssnGraph *rssn_graph_new(int aIsDirected) ;

/*
 Gets the number of nodes in the graph.
 */
rssn_ size_t rssn_graph_node_count(const struct rssn_RssnGraph *aPtr) ;

/*
 Finds all strongly connected components in a directed graph.
 Returns a JSON array of arrays.
 */
rssn_ char *rssn_graph_strongly_connected_components(const struct rssn_RssnGraph *aGraph) ;

/*
 Computes the Tensor product of two graphs.
 */
rssn_
struct rssn_RssnGraph *rssn_graph_tensor_product(const struct rssn_RssnGraph *aPtr1,
                                                 const struct rssn_RssnGraph *aPtr2)
;

/*
 Performs topological sort on a DAG.
 Returns a JSON array of node indices in topological order, or null if the graph has a cycle.
 */
rssn_ char *rssn_graph_topological_sort(const struct rssn_RssnGraph *aGraph) ;

/*
 Computes the union of two graphs.
 */
rssn_
struct rssn_RssnGraph *rssn_graph_union(const struct rssn_RssnGraph *aPtr1,
                                        const struct rssn_RssnGraph *aPtr2)
;

/*
 Finds a valid vertex coloring using greedy heuristic.
 Returns a JSON object mapping node IDs to colors.
 */
rssn_ char *rssn_greedy_coloring(const struct rssn_RssnGraph *aGraph) ;

/*
 Represents Green's theorem (Handle)
 */
rssn_
struct rssn_Expr *rssn_greens_theorem_handle(const struct rssn_Expr *aPPtr,
                                             const struct rssn_Expr *aQPtr,
                                             const struct rssn_Expr *aDomainPtr)
;

rssn_ struct rssn_Expr **rssn_group_center(const struct rssn_Group *aGroup, size_t *aOutLen) ;

rssn_
struct rssn_Group *rssn_group_create(const struct rssn_Expr *const *aElementsPtr,
                                     size_t aElementsLen,
                                     const struct rssn_Expr *const *aKeysAPtr,
                                     const struct rssn_Expr *const *aKeysBPtr,
                                     const struct rssn_Expr *const *aValuesPtr,
                                     size_t aTableLen,
                                     const struct rssn_Expr *aIdentityPtr)
;

rssn_ size_t rssn_group_element_order(const struct rssn_Group *aGroup, const struct rssn_Expr *aA) ;

rssn_ void rssn_group_free(struct rssn_Group *aPtr) ;

rssn_
struct rssn_Expr *rssn_group_inverse(const struct rssn_Group *aGroup,
                                     const struct rssn_Expr *aA)
;

rssn_ bool rssn_group_is_abelian(const struct rssn_Group *aGroup) ;

rssn_
struct rssn_Expr *rssn_group_multiply(const struct rssn_Group *aGroup,
                                      const struct rssn_Expr *aA,
                                      const struct rssn_Expr *aB)
;

/*
 Decodes a 7-bit Hamming(7,4) codeword, correcting single-bit errors.

 # Safety
 Caller must ensure `codeword` points to 7 bytes and `data_out` points to 4 bytes.
 `error_pos` will receive the 1-based error position or 0 if no error.
 */
rssn_ int32_t rssn_hamming_decode(const uint8_t *aCodeword, uint8_t *aDataOut, uint8_t *aErrorPos) ;

/*
 Encodes 4 data bits into a 7-bit Hamming(7,4) codeword.

 # Safety
 Caller must ensure `data` points to 4 bytes and `out` points to 7 bytes of allocated memory.
 */
rssn_ int32_t rssn_hamming_encode(const uint8_t *aData, uint8_t *aOut) ;

/*
 Clears all expressions from the handle manager.

 **Warning**: This invalidates all existing handles.

 # Safety
 This function is always safe to call, but will invalidate all handles.
 */
rssn_ void rssn_handle_clear(void) ;

/*
 Clears all handles (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_handle_clear_bincode(void) ;

/*
 Clears all handles (JSON).

 Output: JSON object with "cleared" boolean field
 */
rssn_ char *rssn_handle_clear_json(void) ;

/*
 Clones an expression handle, creating a new handle pointing to the same expression.

 Returns 0 if the source handle doesn't exist.

 # Safety
 This function is safe to call with any handle value.
 */
rssn_ size_t rssn_handle_clone(size_t aHandle) ;

/*
 Clones a handle (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_handle_clone_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Clones a handle (JSON).

 Input: JSON object with "handle" field
 Output: JSON object with "new_handle" field
 */
rssn_ char *rssn_handle_clone_json(const char *aJsonStr) ;

/*
 Returns the number of expressions currently managed.

 # Safety
 This function is always safe to call.
 */
rssn_ size_t rssn_handle_count(void) ;

/*
 Checks if a handle exists in the manager.

 # Safety
 This function is safe to call with any handle value.
 */
rssn_ bool rssn_handle_exists(size_t aHandle) ;

/*
 Checks if a handle exists (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_handle_exists_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Checks if a handle exists (JSON).

 Input: JSON object with "handle" field
 Output: JSON object with "exists" boolean field
 */
rssn_ char *rssn_handle_exists_json(const char *aJsonStr) ;

/*
 Frees a handle from the manager.

 Returns true if the handle was found and freed, false otherwise.

 # Safety
 This function is safe to call with any handle value.
 */
rssn_ bool rssn_handle_free(size_t aHandle) ;

/*
 Frees a handle (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_handle_free_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Frees a handle (JSON).

 Input: JSON object with "handle" field
 Output: JSON object with "freed" boolean field
 */
rssn_ char *rssn_handle_free_json(const char *aJsonStr) ;

/*
 Retrieves an expression from the handle manager.

 Returns a new owned Expr pointer that must be freed by the caller.

 # Safety
 The caller must ensure the returned pointer is freed using `rssn_free_expr`.
 */
rssn_ struct rssn_Expr *rssn_handle_get(size_t aHandle) ;

/*
 Returns a list of all active handles as a JSON array string.

 The returned string must be freed using `rssn_free_string`.

 # Safety
 The caller must free the returned string.
 */
rssn_ char *rssn_handle_get_all(void) ;

/*
 Returns all active handles (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_handle_get_all_bincode(void) ;

/*
 Retrieves an expression by handle (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_handle_get_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Retrieves an expression by handle (JSON).

 Input: JSON object with "handle" field
 Output: JSON-serialized Expr
 */
rssn_ char *rssn_handle_get_json(const char *aJsonStr) ;

/*
 Inserts an expression into the handle manager and returns a unique handle.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ size_t rssn_handle_insert(const struct rssn_Expr *aExpr) ;

/*
 Inserts an expression (Bincode) into the handle manager.
 */
rssn_ struct rssn_BincodeBuffer rssn_handle_insert_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Inserts an expression (JSON) into the handle manager.

 Input: JSON-serialized Expr
 Output: JSON object with "handle" field
 */
rssn_ char *rssn_handle_insert_json(const char *aJsonStr) ;

/*
 Returns handle manager statistics (JSON).

 Output: JSON object with "count" and "handles" fields
 */
rssn_ char *rssn_handle_stats_json(void) ;

/*
 Converts an expression handle to a string representation.

 The returned string must be freed using `rssn_free_string`.

 # Safety
 The caller must free the returned string.
 */
rssn_ char *rssn_handle_to_string(size_t aHandle) ;

rssn_
struct rssn_Expr *rssn_hermite_differential_equation(const struct rssn_Expr *aY,
                                                     const struct rssn_Expr *aX,
                                                     const struct rssn_Expr *aN)
;

rssn_
struct rssn_Expr *rssn_hermite_h(const struct rssn_Expr *aDegree,
                                 const struct rssn_Expr *aArg)
;

rssn_
struct rssn_Expr *rssn_hermite_rodrigues_formula(const struct rssn_Expr *aN,
                                                 const struct rssn_Expr *aX)
;

/*
 Computes Hessian matrix (Handle)
 */
rssn_
struct rssn_Expr *rssn_hessian_matrix_handle(const struct rssn_Expr *aExprPtr,
                                             const char *const *aVarsPtr,
                                             int aVarsLen)
;

/*
 Simplifies an expression using the heuristic simplifier.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_heuristic_simplify(const struct rssn_Expr *aExpr) ;

rssn_
struct rssn_HilbertSpace *rssn_hilbert_space_create(const char *aVar,
                                                    const struct rssn_Expr *aLowerBound,
                                                    const struct rssn_Expr *aUpperBound)
;

rssn_ void rssn_hilbert_space_free(struct rssn_HilbertSpace *aPtr) ;

/*
 Computes the Inverse Fast Fourier Transform (IFFT) of a sequence of complex numbers in-place.
 */
rssn_ int32_t rssn_ifft(rssn_Complex<double> *aData, size_t aLen) ;

/*
 Creates a new IteratedFunctionSystem (Handle)
 */
rssn_
struct rssn_IteratedFunctionSystem *rssn_ifs_create(struct rssn_Expr *const *aFunctionsPtr,
                                                    size_t aFunctionsLen,
                                                    struct rssn_Expr *const *aProbabilitiesPtr,
                                                    size_t aProbabilitiesLen,
                                                    const char *const *aVariablesPtr,
                                                    size_t aVariablesLen)
;

/*
 Frees an IteratedFunctionSystem handle
 */
rssn_ void rssn_ifs_free(struct rssn_IteratedFunctionSystem *aPtr) ;

/*
 Calculates similarity dimension (Handle)
 */
rssn_
struct rssn_Expr *rssn_ifs_similarity_dimension(struct rssn_Expr *const *aScalingFactorsPtr,
                                                size_t aLen)
;

/*
 Initializes the plugin manager with a specified plugin directory.

 This function must be called before any plugin operations are performed.

 # Arguments
 * `plugin_dir_ptr` - A null-terminated UTF-8 string for the plugin directory path.

 # Returns
 0 on success, -1 on failure. On failure, an error message can be retrieved
 with `rssn_get_last_error`.
 */
rssn_ int32_t rssn_init_plugin_manager(const char *aPluginDirPtr) ;

rssn_
struct rssn_Expr *rssn_inner_product(const struct rssn_HilbertSpace *aSpace,
                                     const struct rssn_Expr *aF,
                                     const struct rssn_Expr *aG)
;

/*
 Integrates an expression: int(expr) d(var).

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `var` is a valid C string.
 */
rssn_ struct rssn_Expr *rssn_integrate(const struct rssn_Expr *aExpr, const char *aVar) ;

/*
 Integrates a rational function (Handle)
 */
rssn_
struct rssn_Expr *rssn_integrate_rational_function_handle(const struct rssn_Expr *aExpr,
                                                          const char *aX)
;

/*
 Evaluates a point on a Bezier curve defined by control points.
 */
rssn_
int32_t rssn_interp_bezier_curve(const struct rssn_FfiPoint *aPointsPtr,
                                 size_t aNumPoints,
                                 double aT,
                                 struct rssn_FfiPoint *aResultPtr)
;

/*
 Computes a Lagrange interpolating polynomial from a set of points.
 Returns a handle to the resulting polynomial expression.
 */
rssn_
int32_t rssn_interp_lagrange(const struct rssn_FfiPoint *aPointsPtr,
                             size_t aNumPoints,
                             size_t *aResultHandle)
;

rssn_
struct rssn_Expr *rssn_inverse_fourier_transform(const struct rssn_Expr *aExpr,
                                                 const char *aInVar,
                                                 const char *aOutVar)
;

rssn_
struct rssn_Expr *rssn_inverse_laplace_transform(const struct rssn_Expr *aExpr,
                                                 const char *aInVar,
                                                 const char *aOutVar)
;

rssn_
struct rssn_Expr *rssn_inverse_z_transform(const struct rssn_Expr *aExpr,
                                           const char *aInVar,
                                           const char *aOutVar)
;

/*
 Checks if an expression is prime.

 # Safety
 `n` must be a valid pointer to an `Expr`.
 */
rssn_ struct rssn_Expr *rssn_is_prime_handle(const struct rssn_Expr *aN) ;

/*
 Checks if a logical expression is satisfiable using handle-based FFI.

 Returns:
 - 1 if satisfiable
 - 0 if unsatisfiable
 - -1 if the expression contains quantifiers (undecidable)

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_ int32_t rssn_is_satisfiable_handle(const struct rssn_Expr *aExpr) ;

rssn_ struct rssn_Expr *rssn_joint_entropy(const struct rssn_Expr *aJointProbs) ;

/*
 Computes absolute value (magnitude) of complex number (JSON)
 */
rssn_ char *rssn_json_abs(const char *aZJson) ;

rssn_ char *rssn_json_adjoint_representation_algebra(const char *aXJson, const char *aYJson) ;

rssn_ char *rssn_json_adjoint_representation_group(const char *aGJson, const char *aXJson) ;

rssn_
char *rssn_json_analytic_continuation(const char *aExprJson,
                                      const char *aVarJson,
                                      const char *aOrigCenterJson,
                                      const char *aNewCenterJson,
                                      const char *aOrderJson)
;

rssn_ char *rssn_json_analyze_convergence(const char *aTermJson, const char *aVarJson) ;

/*
 Analyzes stability of a fixed point (JSON)
 */
rssn_
char *rssn_json_analyze_stability(const char *aMapJson,
                                  const char *aVar,
                                  const char *aFixedPointJson)
;

/*
 Checks if two graphs are isomorphic.
 Input: {"g1": Graph, "g2": Graph}
 Output: bool
 */
rssn_ char *rssn_json_are_isomorphic_heuristic(const char *aJson) ;

/*
 Computes argument (angle) of complex number (JSON)
 */
rssn_ char *rssn_json_arg(const char *aZJson) ;

rssn_
char *rssn_json_asymptotic_expansion(const char *aExprJson,
                                     const char *aVarJson,
                                     const char *aPointJson,
                                     const char *aOrderJson)
;

rssn_ char *rssn_json_bell_number(size_t aN) ;

rssn_
char *rssn_json_bessel_differential_equation(const char *aYJson,
                                             const char *aXJson,
                                             const char *aNJson)
;

rssn_ char *rssn_json_bessel_j(const char *aOrderJson, const char *aArgJson) ;

rssn_ char *rssn_json_bessel_y(const char *aOrderJson, const char *aArgJson) ;

rssn_ char *rssn_json_beta(const char *aAJson, const char *aBJson) ;

rssn_ char *rssn_json_beta_numerical(const char *aAJson, const char *aBJson) ;

/*
 Computes the boundary of a domain (JSON)
 */
rssn_ char *rssn_json_boundary(const char *aDomainJson) ;

rssn_ char *rssn_json_buchberger(const char *aBasisJson, const char *aOrderJson) ;

/*
 Calculates residue using JSON.
 */
rssn_
char *rssn_json_calculate_residue(const char *aExprJson,
                                  const char *aVar,
                                  const char *aPoleJson)
;

rssn_ char *rssn_json_catalan_number(size_t aN) ;

rssn_ char *rssn_json_character(const char *aRepJson) ;

/*
 Checks analytic using JSON.
 */
rssn_ bool rssn_json_check_analytic(const char *aExprJson, const char *aVar) ;

rssn_ bool rssn_json_check_jacobi_identity(const char *aAlgebraJson) ;

rssn_ char *rssn_json_chinese_remainder(const char *aCongruencesJson) ;

/*
 Exact chromatic number.
 Input: Graph
 Output: usize
 */
rssn_ char *rssn_json_chromatic_number_exact(const char *aJson) ;

/*
 Classifies a PDE and suggests solution methods (JSON).
 */
rssn_
char *rssn_json_classify_pde(const char *aEquationJson,
                             const char *aFunc,
                             const char *aVarsJson)
;

rssn_ char *rssn_json_combinations(const char *aNJson, const char *aKJson) ;

rssn_ char *rssn_json_commutator_table(const char *aAlgebraJson) ;

/*
 Finds fixed points (JSON)
 */
rssn_ char *rssn_json_complex_system_fixed_points(const char *aSystemJson) ;

/*
 Iterates the system once (JSON)
 */
rssn_ char *rssn_json_complex_system_iterate(const char *aSystemJson, const char *aZJson) ;

/*
 Creates a new Mandelbrot family system (JSON)
 */
rssn_ char *rssn_json_complex_system_new_mandelbrot(const char *aCJson) ;

rssn_ char *rssn_json_conditional_entropy(const char *aJointProbsJson) ;

rssn_
char *rssn_json_convolution_fourier(const char *aFJson,
                                    const char *aGJson,
                                    const char *aInVarJson,
                                    const char *aOutVarJson)
;

rssn_
char *rssn_json_convolution_laplace(const char *aFJson,
                                    const char *aGJson,
                                    const char *aInVarJson,
                                    const char *aOutVarJson)
;

rssn_ char *rssn_json_coordinates_get_metric_tensor(enum rssn_CoordinateSystem aSystem) ;

/*
 Computes the symbolic Pearson correlation coefficient using JSON.
 */
rssn_ char *rssn_json_correlation(const char *aData1Json, const char *aData2Json) ;

/*
 Counts the number of distinct real roots in an interval (JSON)
 */
rssn_
int64_t rssn_json_count_real_roots_in_interval(const char *aExprJson,
                                               const char *aVarPtr,
                                               double aA,
                                               double aB)
;

/*
 Computes the symbolic covariance of two sets of expressions using JSON.
 */
rssn_ char *rssn_json_covariance(const char *aData1Json, const char *aData2Json) ;

rssn_ char *rssn_json_cross_entropy(const char *aPProbsJson, const char *aQProbsJson) ;

/*
 Creates an elliptic curve and performs point addition via JSON interface.
 Input: {"a": int, "b": int, "modulus": int, "p1": {x, y}, "p2": {x, y}}
 */
rssn_
char *rssn_json_curve_add(const char *aAJson,
                          const char *aBJson,
                          const char *aModulusJson,
                          const char *aP1XJson,
                          const char *aP1YJson,
                          const char *aP2XJson,
                          const char *aP2YJson)
;

/*
 Performs scalar multiplication via JSON interface.
 */
rssn_
char *rssn_json_curve_scalar_mult(const char *aAJson,
                                  const char *aBJson,
                                  const char *aModulusJson,
                                  const char *aKJson,
                                  const char *aPXJson,
                                  const char *aPYJson)
;

rssn_ char *rssn_json_cyclic_group_create(size_t aN) ;

/*
 Computes definite integral using JSON.
 */
rssn_
char *rssn_json_definite_integrate(const char *aExprJson,
                                   const char *aVar,
                                   const char *aLowerJson,
                                   const char *aUpperJson)
;

/*
 Denests a nested square root (JSON)
 */
rssn_ char *rssn_json_denest_sqrt(const char *aExprJson) ;

/*
 Differentiates an expression using JSON.
 */
rssn_ char *rssn_json_differentiate(const char *aExprJson, const char *aVar) ;

rssn_ char *rssn_json_digamma(const char *aArgJson) ;

rssn_ char *rssn_json_dihedral_group_create(size_t aN) ;

rssn_ char *rssn_json_dist_bernoulli(const char *aPJson) ;

rssn_ char *rssn_json_dist_beta(const char *aAlphaJson, const char *aBetaJson) ;

rssn_ char *rssn_json_dist_binomial(const char *aNJson, const char *aPJson) ;

rssn_ char *rssn_json_dist_cdf(const char *aDistJson, const char *aXJson) ;

rssn_ char *rssn_json_dist_expectation(const char *aDistJson) ;

rssn_ char *rssn_json_dist_exponential(const char *aRateJson) ;

rssn_ char *rssn_json_dist_gamma(const char *aShapeJson, const char *aRateJson) ;

rssn_ char *rssn_json_dist_mgf(const char *aDistJson, const char *aTJson) ;

rssn_ char *rssn_json_dist_normal(const char *aMeanJson, const char *aStdDevJson) ;

rssn_ char *rssn_json_dist_pdf(const char *aDistJson, const char *aXJson) ;

rssn_ char *rssn_json_dist_poisson(const char *aRateJson) ;

rssn_ char *rssn_json_dist_student_t(const char *aNuJson) ;

rssn_ char *rssn_json_dist_uniform(const char *aMinJson, const char *aMaxJson) ;

rssn_ char *rssn_json_dist_variance(const char *aDistJson) ;

rssn_ char *rssn_json_erf(const char *aArgJson) ;

rssn_ char *rssn_json_erf_numerical(const char *aXJson) ;

rssn_ char *rssn_json_erfc(const char *aArgJson) ;

rssn_ char *rssn_json_erfc_numerical(const char *aXJson) ;

rssn_ char *rssn_json_erfi(const char *aArgJson) ;

/*
 Evaluates at point using JSON.
 */
rssn_
char *rssn_json_evaluate_at_point(const char *aExprJson,
                                  const char *aVar,
                                  const char *aValueJson)
;

rssn_ char *rssn_json_evaluate_numerical(const char *aExprJson) ;

rssn_ char *rssn_json_exponential_map(const char *aXJson, size_t aOrder) ;

rssn_ char *rssn_json_extended_gcd(const char *aAJson, const char *aBJson) ;

/*
 Computes the exterior derivative of a differential form (JSON)
 */
rssn_ char *rssn_json_exterior_derivative(const char *aFormJson, const char *aVarsJson) ;

/*
 Factors a polynomial over a finite field (JSON)
 */
rssn_ char *rssn_json_factor_gf(const char *aPolyJson) ;

/*
 Finds constrained extrema (JSON)
 */
rssn_
char *rssn_json_find_constrained_extrema(const char *aExprJson,
                                         const char *aConstraintsJson,
                                         const char *aVarsJson)
;

/*
 Finds extrema of a function (JSON)
 */
rssn_ char *rssn_json_find_extrema(const char *aExprJson, const char *aVarsJson) ;

/*
 Finds fixed points of a 1D map (JSON)
 */
rssn_ char *rssn_json_find_fixed_points(const char *aMapJson, const char *aVar) ;

/*
 Finds pole order using JSON.
 */
rssn_
size_t rssn_json_find_pole_order(const char *aExprJson,
                                 const char *aVar,
                                 const char *aPoleJson)
;

/*
 Finds poles using JSON.
 */
rssn_ char *rssn_json_find_poles(const char *aExprJson, const char *aVar) ;

/*
 Gets the degree of a finite field polynomial (JSON)
 */
rssn_ int64_t rssn_json_finite_field_polynomial_degree(const char *aPolyJson) ;

/*
 Performs polynomial long division (JSON)
 */
rssn_
char *rssn_json_finite_field_polynomial_long_division(const char *aDividendJson,
                                                      const char *aDivisorJson)
;

/*
 Creates a new finite field polynomial (JSON)
 */
rssn_
char *rssn_json_finite_field_polynomial_new(const char *aCoeffsJson,
                                            const char *aModulusJson)
;

rssn_
char *rssn_json_fourier_series(const char *aExprJson,
                               const char *aVarJson,
                               const char *aPeriodJson,
                               const char *aOrderJson)
;

/*
 Computes the symbolic Fourier transform via JSON interface.
 */
rssn_
char *rssn_json_fourier_transform(const char *aExprJson,
                                  const char *aInVarJson,
                                  const char *aOutVarJson)
;

rssn_ char *rssn_json_gamma(const char *aArgJson) ;

rssn_ char *rssn_json_gamma_numerical(const char *aXJson) ;

/*
 Represents Gauss's theorem (JSON)
 */
rssn_ char *rssn_json_gauss_theorem(const char *aVectorFieldJson, const char *aVolumeJson) ;

/*
 Computes general multi-valued arccos (JSON)
 */
rssn_ char *rssn_json_general_arccos(const char *aZJson, const char *aKJson, const char *aSJson) ;

/*
 Computes general multi-valued arcsin (JSON)
 */
rssn_ char *rssn_json_general_arcsin(const char *aZJson, const char *aKJson) ;

/*
 Computes general multi-valued arctan (JSON)
 */
rssn_ char *rssn_json_general_arctan(const char *aZJson, const char *aKJson) ;

/*
 Computes general multi-valued logarithm (JSON)
 */
rssn_ char *rssn_json_general_log(const char *aZJson, const char *aKJson) ;

/*
 Computes general multi-valued n-th root (JSON)
 */
rssn_ char *rssn_json_general_nth_root(const char *aZJson, const char *aNJson, const char *aKJson) ;

/*
 Computes general multi-valued power (JSON)
 */
rssn_ char *rssn_json_general_power(const char *aZJson, const char *aWJson, const char *aKJson) ;

/*
 Computes general multi-valued square root (JSON)
 */
rssn_ char *rssn_json_general_sqrt(const char *aZJson, const char *aKJson) ;

/*
 Represents the generalized Stokes' theorem (JSON)
 */
rssn_
char *rssn_json_generalized_stokes_theorem(const char *aOmegaJson,
                                           const char *aManifoldJson,
                                           const char *aVarsJson)
;

/*
 Gets real and imaginary parts using JSON.
 */
rssn_ char *rssn_json_get_real_imag_parts(const char *aExprJson) ;

/*
 Performs addition in GF(2^8) via JSON interface.
 */
rssn_ char *rssn_json_gf256_add(const char *aAJson, const char *aBJson) ;

/*
 Computes inverse in GF(2^8) via JSON interface.
 */
rssn_ char *rssn_json_gf256_inv(const char *aAJson) ;

/*
 Performs multiplication in GF(2^8) via JSON interface.
 */
rssn_ char *rssn_json_gf256_mul(const char *aAJson, const char *aBJson) ;

rssn_ char *rssn_json_gini_impurity(const char *aProbsJson) ;

rssn_ char *rssn_json_gram_schmidt(const char *aSpaceJson, const char *aBasisJson) ;

/*
 Adds an edge to the graph.
 Input JSON: {"graph": <graph>, "from": "label1", "to": "label2", "weight": <expr>}
 */
rssn_ char *rssn_json_graph_add_edge(const char *aJson) ;

/*
 Adds a node to the graph.
 Input JSON: {"graph": <graph>, "label": "node_label"}
 Returns updated graph as JSON.
 */
rssn_ char *rssn_json_graph_add_node(const char *aJson) ;

/*
 Gets the adjacency matrix of the graph.
 Input JSON: <graph>
 Returns Expr (matrix) as JSON.
 */
rssn_ char *rssn_json_graph_adjacency_matrix(const char *aJson) ;

/*
 Performs BFS traversal.
 Input JSON: {"graph": <graph>, "start_node": <index>}
 */
rssn_ char *rssn_json_graph_bfs(const char *aJson) ;

/*
 Performs BFS traversal.
 Input: {"graph": Graph, "start_node": usize}
 Output: [usize]
 */
rssn_ char *rssn_json_graph_bfs_api(const char *aJson) ;

/*
 Finds maximum matching in bipartite graph.
 Input: {"graph": Graph, "partition": [i8]}
 Output: [(usize, usize)]
 */
rssn_ char *rssn_json_graph_bipartite_maximum_matching(const char *aJson) ;

/*
 Finds bridges and articulation points.
 Input: Graph
 Output: {"bridges": [(usize, usize)], "articulation_points": [usize]}
 */
rssn_ char *rssn_json_graph_bridges_and_articulation_points(const char *aJson) ;

/*
 Computes the Cartesian product of two graphs.
 */
rssn_ char *rssn_json_graph_cartesian_product(const char *aJson) ;

/*
 Computes the complement of a graph.
 */
rssn_ char *rssn_json_graph_complement(const char *aJson) ;

/*
 Finds connected components.
 */
rssn_ char *rssn_json_graph_connected_components(const char *aJson) ;

/*
 Finds connected components.
 Input: Graph
 Output: [[usize]] (array of arrays)
 */
rssn_ char *rssn_json_graph_connected_components_api(const char *aJson) ;

/*
 Performs DFS traversal.
 */
rssn_ char *rssn_json_graph_dfs(const char *aJson) ;

/*
 Performs DFS traversal.
 Input: {"graph": Graph, "start_node": usize}
 Output: [usize] (array of node indices)
 */
rssn_ char *rssn_json_graph_dfs_api(const char *aJson) ;

/*
 Computes maximum flow using Dinic's algorithm.
 Input: {"graph": Graph, "source": usize, "sink": usize}
 Output: f64
 */
rssn_ char *rssn_json_graph_dinic_max_flow(const char *aJson) ;

/*
 Computes the disjoint union of two graphs.
 */
rssn_ char *rssn_json_graph_disjoint_union(const char *aJson) ;

/*
 Computes maximum flow using Edmonds-Karp.
 Input: {"graph": Graph, "source": usize, "sink": usize}
 Output: f64
 */
rssn_ char *rssn_json_graph_edmonds_karp_max_flow(const char *aJson) ;

/*
 Checks if graph has a cycle.
 */
rssn_ char *rssn_json_graph_has_cycle(const char *aJson) ;

/*
 Checks if graph has a cycle.
 Input: Graph
 Output: bool
 */
rssn_ char *rssn_json_graph_has_cycle_api(const char *aJson) ;

/*
 Creates an induced subgraph.
 Input JSON: {"graph": <graph>, "nodes": ["label1", "label2"]}
 */
rssn_ char *rssn_json_graph_induced_subgraph(const char *aJson) ;

/*
 Computes the intersection of two graphs.
 */
rssn_ char *rssn_json_graph_intersection(const char *aJson) ;

/*
 Checks if graph is bipartite.
 */
rssn_ char *rssn_json_graph_is_bipartite(const char *aJson) ;

/*
 Checks if graph is bipartite.
 Input: Graph
 Output: [i8] or null
 */
rssn_ char *rssn_json_graph_is_bipartite_api(const char *aJson) ;

/*
 Checks if graph is connected.
 Input: Graph
 Output: bool
 */
rssn_ char *rssn_json_graph_is_connected(const char *aJson) ;

/*
 Computes the join of two graphs.
 */
rssn_ char *rssn_json_graph_join(const char *aJson) ;

/*
 Computes MST using Kruskal's algorithm.
 */
rssn_ char *rssn_json_graph_kruskal_mst(const char *aJson) ;

/*
 Computes MST using Kruskal's algorithm.
 Input: Graph
 Output: Graph (MST)
 */
rssn_ char *rssn_json_graph_kruskal_mst_api(const char *aJson) ;

/*
 Gets the Laplacian matrix of the graph.
 */
rssn_ char *rssn_json_graph_laplacian_matrix(const char *aJson) ;

/*
 Computes maximum flow.
 Input JSON: {"graph": <graph>, "source": <index>, "sink": <index>}
 */
rssn_ char *rssn_json_graph_max_flow(const char *aJson) ;

/*
 Creates a new graph from JSON specification.
 JSON format: {"is_directed": true/false}
 */
rssn_ char *rssn_json_graph_new(const char *aJson) ;

/*
 Finds strongly connected components.
 Input: Graph
 Output: [[usize]]
 */
rssn_ char *rssn_json_graph_strongly_connected_components(const char *aJson) ;

/*
 Computes the Tensor product of two graphs.
 */
rssn_ char *rssn_json_graph_tensor_product(const char *aJson) ;

/*
 Performs topological sort.
 Input: Graph
 Output: [usize] or null
 */
rssn_ char *rssn_json_graph_topological_sort(const char *aJson) ;

/*
 Computes the union of two graphs.
 Input JSON: {"g1": <graph>, "g2": <graph>}
 */
rssn_ char *rssn_json_graph_union(const char *aJson) ;

/*
 Greedy coloring.
 Input: Graph
 Output: {node_id: color_id}
 */
rssn_ char *rssn_json_greedy_coloring(const char *aJson) ;

/*
 Represents Green's theorem (JSON)
 */
rssn_
char *rssn_json_greens_theorem(const char *aPJson,
                               const char *aQJson,
                               const char *aDomainJson)
;

rssn_ char *rssn_json_group_center(const char *aGroupJson) ;

rssn_ char *rssn_json_group_conjugacy_classes(const char *aGroupJson) ;

rssn_ char *rssn_json_group_create(const char *aJsonStr) ;

rssn_ size_t rssn_json_group_element_order(const char *aGroupJson, const char *aAJson) ;

rssn_ char *rssn_json_group_inverse(const char *aGroupJson, const char *aAJson) ;

rssn_ bool rssn_json_group_is_abelian(const char *aGroupJson) ;

rssn_
char *rssn_json_group_multiply(const char *aGroupJson,
                               const char *aAJson,
                               const char *aBJson)
;

/*
 Decodes a 7-bit Hamming(7,4) codeword via JSON interface.
 Returns JSON object with "data" and "error_pos" fields.
 */
rssn_ char *rssn_json_hamming_decode(const char *aCodewordJson) ;

/*
 Encodes 4 data bits into a 7-bit Hamming(7,4) codeword via JSON interface.
 */
rssn_ char *rssn_json_hamming_encode(const char *aDataJson) ;

rssn_
char *rssn_json_hermite_differential_equation(const char *aYJson,
                                              const char *aXJson,
                                              const char *aNJson)
;

rssn_ char *rssn_json_hermite_h(const char *aDegreeJson, const char *aArgJson) ;

rssn_ char *rssn_json_hermite_rodrigues_formula(const char *aNJson, const char *aXJson) ;

/*
 Computes Hessian matrix (JSON)
 */
rssn_ char *rssn_json_hessian_matrix(const char *aExprJson, const char *aVarsJson) ;

/*
 Simplifies an expression using the heuristic simplifier (JSON input/output).
 */
rssn_ char *rssn_json_heuristic_simplify(const char *aExprJson) ;

rssn_ char *rssn_json_hilbert_space_create(const char *aJsonStr) ;

/*
 Creates a new IteratedFunctionSystem (JSON)
 */
rssn_
char *rssn_json_ifs_create(const char *aFunctionsJson,
                           const char *aProbabilitiesJson,
                           const char *aVariablesJson)
;

/*
 Calculates similarity dimension (JSON)
 */
rssn_ char *rssn_json_ifs_similarity_dimension(const char *aScalingFactorsJson) ;

rssn_
char *rssn_json_inner_product(const char *aSpaceJson,
                              const char *aFJson,
                              const char *aGJson)
;

/*
 Integrates an expression using JSON.
 */
rssn_ char *rssn_json_integrate(const char *aExprJson, const char *aVar) ;

/*
 Integrates a rational function (JSON)
 */
rssn_ char *rssn_json_integrate_rational_function(const char *aExprJson, const char *aXJson) ;

rssn_
char *rssn_json_inverse_fourier_transform(const char *aExprJson,
                                          const char *aInVarJson,
                                          const char *aOutVarJson)
;

rssn_
char *rssn_json_inverse_laplace_transform(const char *aExprJson,
                                          const char *aInVarJson,
                                          const char *aOutVarJson)
;

rssn_
char *rssn_json_inverse_z_transform(const char *aExprJson,
                                    const char *aInVarJson,
                                    const char *aOutVarJson)
;

rssn_ char *rssn_json_is_prime(const char *aNJson) ;

/*
 Checks if a logical expression is satisfiable using JSON-based FFI.

 Returns a JSON string containing:
 - `{"result": "satisfiable"}` if satisfiable
 - `{"result": "unsatisfiable"}` if unsatisfiable
 - `{"result": "undecidable"}` if the expression contains quantifiers
 */
rssn_ char *rssn_json_is_satisfiable(const char *aExprJson) ;

/*
 Isolates real roots in an interval (JSON)
 */
rssn_
char *rssn_json_isolate_real_roots(const char *aExprJson,
                                   const char *aVarPtr,
                                   double aPrecision)
;

rssn_ char *rssn_json_joint_entropy(const char *aJointProbsJson) ;

rssn_ char *rssn_json_kl_divergence(const char *aPProbsJson, const char *aQProbsJson) ;

rssn_ char *rssn_json_klein_four_group_create(void) ;

rssn_
char *rssn_json_laguerre_differential_equation(const char *aYJson,
                                               const char *aXJson,
                                               const char *aNJson)
;

rssn_ char *rssn_json_laguerre_l(const char *aDegreeJson, const char *aArgJson) ;

rssn_
char *rssn_json_laplace_transform(const char *aExprJson,
                                  const char *aInVarJson,
                                  const char *aOutVarJson)
;

rssn_
char *rssn_json_laurent_series(const char *aExprJson,
                               const char *aVarJson,
                               const char *aCenterJson,
                               const char *aOrderJson)
;

rssn_
char *rssn_json_legendre_differential_equation(const char *aYJson,
                                               const char *aXJson,
                                               const char *aNJson)
;

rssn_ char *rssn_json_legendre_p(const char *aDegreeJson, const char *aArgJson) ;

rssn_ char *rssn_json_legendre_rodrigues_formula(const char *aNJson, const char *aXJson) ;

rssn_ char *rssn_json_lie_algebra_so3(void) ;

rssn_ char *rssn_json_lie_algebra_su2(void) ;

rssn_ char *rssn_json_lie_bracket(const char *aXJson, const char *aYJson) ;

/*
 Computes limit using JSON.
 */
rssn_ char *rssn_json_limit(const char *aExprJson, const char *aVar, const char *aPointJson) ;

rssn_ char *rssn_json_ln_beta_numerical(const char *aAJson, const char *aBJson) ;

rssn_ char *rssn_json_ln_gamma_numerical(const char *aXJson) ;

/*
 Returns Lorenz system equations (JSON)
 */
rssn_ char *rssn_json_lorenz_system(void) ;

/*
 Calculates Lyapunov exponent (JSON)
 */
rssn_
char *rssn_json_lyapunov_exponent(const char *aMapJson,
                                  const char *aVar,
                                  const char *aInitialXJson,
                                  size_t aNIterations)
;

rssn_ char *rssn_json_matrix_add(const char *aM1Json, const char *aM2Json) ;

rssn_ char *rssn_json_matrix_determinant(const char *aMatrixJson) ;

rssn_ char *rssn_json_matrix_inverse(const char *aMatrixJson) ;

rssn_ char *rssn_json_matrix_mul(const char *aM1Json, const char *aM2Json) ;

rssn_ char *rssn_json_matrix_solve_linear_system(const char *aAJson, const char *aBJson) ;

rssn_ char *rssn_json_matrix_transpose(const char *aMatrixJson) ;

/*
 Computes the symbolic mean of a set of expressions using JSON.
 */
rssn_ char *rssn_json_mean(const char *aDataJson) ;

/*
 Computes geometric product (JSON)
 */
rssn_ char *rssn_json_multivector_geometric_product(const char *aAJson, const char *aBJson) ;

/*
 Computes grade projection (JSON)
 */
rssn_ char *rssn_json_multivector_grade_projection(const char *aMvJson, uint32_t aGrade) ;

/*
 Computes inner product (JSON)
 */
rssn_ char *rssn_json_multivector_inner_product(const char *aAJson, const char *aBJson) ;

/*
 Computes magnitude (JSON)
 */
rssn_ char *rssn_json_multivector_magnitude(const char *aMvJson) ;

/*
 Computes outer product (JSON)
 */
rssn_ char *rssn_json_multivector_outer_product(const char *aAJson, const char *aBJson) ;

/*
 Computes reverse (JSON)
 */
rssn_ char *rssn_json_multivector_reverse(const char *aMvJson) ;

/*
 Creates a new scalar multivector (JSON)
 */
rssn_
char *rssn_json_multivector_scalar(uint32_t aP,
                                   uint32_t aQ,
                                   uint32_t aR,
                                   const char *aValueJson)
;

rssn_ char *rssn_json_mutual_information(const char *aJointProbsJson) ;

rssn_
char *rssn_json_nonlinear_regression(const char *aDataJson,
                                     const char *aModelJson,
                                     const char *aVarsJson,
                                     const char *aParamsJson)
;

rssn_ char *rssn_json_norm(const char *aSpaceJson, const char *aFJson) ;

rssn_ char *rssn_json_one_sample_t_test(const char *aDataJson, const char *aTargetMeanJson) ;

/*
 Computes path integral using JSON.
 */
rssn_
char *rssn_json_path_integrate(const char *aExprJson,
                               const char *aVar,
                               const char *aContourJson)
;

rssn_ char *rssn_json_permutations(const char *aNJson, const char *aKJson) ;

/*
 Adds two polynomials over a general finite field via JSON interface.
 */
rssn_
char *rssn_json_poly_add_gf(const char *aP1Json,
                            const char *aP2Json,
                            const char *aModulusJson)
;

/*
 Adds two polynomials over GF(2^8) via JSON interface.
 */
rssn_ char *rssn_json_poly_add_gf256(const char *aP1Json, const char *aP2Json) ;

/*
 Computes polynomial derivative over finite field (JSON)
 */
rssn_ char *rssn_json_poly_derivative_gf(const char *aPolyJson) ;

rssn_
char *rssn_json_poly_division_multivariate(const char *aDividendJson,
                                           const char *aDivisorsJson,
                                           const char *aOrderJson)
;

/*
 Evaluates a polynomial over GF(2^8) via JSON interface.
 */
rssn_ char *rssn_json_poly_eval_gf256(const char *aPolyJson, const char *aXJson) ;

/*
 Computes polynomial GCD over finite field (JSON)
 */
rssn_ char *rssn_json_poly_gcd_gf(const char *aAJson, const char *aBJson) ;

/*
 Multiplies two polynomials over a general finite field via JSON interface.
 */
rssn_
char *rssn_json_poly_mul_gf(const char *aP1Json,
                            const char *aP2Json,
                            const char *aModulusJson)
;

/*
 Multiplies two polynomials over GF(2^8) via JSON interface.
 */
rssn_ char *rssn_json_poly_mul_gf256(const char *aP1Json, const char *aP2Json) ;

/*
 Checks if an expression contains a variable (JSON)
 */
rssn_ bool rssn_json_polynomial_contains_var(const char *aExprJson, const char *aVar) ;

/*
 Computes the degree of a polynomial (JSON)
 */
rssn_ int64_t rssn_json_polynomial_degree(const char *aExprJson, const char *aVar) ;

/*
 Checks if an expression is a polynomial in the given variable (JSON)
 */
rssn_ bool rssn_json_polynomial_is_polynomial(const char *aExprJson, const char *aVar) ;

/*
 Finds the leading coefficient of a polynomial (JSON)
 */
rssn_ char *rssn_json_polynomial_leading_coefficient(const char *aExprJson, const char *aVar) ;

/*
 Performs polynomial long division (JSON)
 */
rssn_
char *rssn_json_polynomial_long_division(const char *aDividendJson,
                                         const char *aDivisorJson,
                                         const char *aVar)
;

rssn_ char *rssn_json_polynomial_regression(const char *aDataJson, size_t aDegree) ;

/*
 Converts polynomial to coefficient vector (JSON)
 */
rssn_ char *rssn_json_polynomial_to_coeffs_vec(const char *aExprJson, const char *aVar) ;

/*
 Adds two prime field elements (JSON)
 */
rssn_ char *rssn_json_prime_field_element_add(const char *aAJson, const char *aBJson) ;

/*
 Divides two prime field elements (JSON)
 */
rssn_ char *rssn_json_prime_field_element_div(const char *aAJson, const char *aBJson) ;

/*
 Computes the inverse of a prime field element (JSON)
 */
rssn_ char *rssn_json_prime_field_element_inverse(const char *aElemJson) ;

/*
 Multiplies two prime field elements (JSON)
 */
rssn_ char *rssn_json_prime_field_element_mul(const char *aAJson, const char *aBJson) ;

/*
 Creates a new prime field element (JSON)
 */
rssn_ char *rssn_json_prime_field_element_new(const char *aValueJson, const char *aModulusJson) ;

/*
 Subtracts two prime field elements (JSON)
 */
rssn_ char *rssn_json_prime_field_element_sub(const char *aAJson, const char *aBJson) ;

rssn_
char *rssn_json_product(const char *aExprJson,
                        const char *aVarJson,
                        const char *aLowerJson,
                        const char *aUpperJson)
;

rssn_ char *rssn_json_representation_create(const char *aJsonStr) ;

rssn_ bool rssn_json_representation_is_valid(const char *aRepJson, const char *aGroupJson) ;

/*
 Integrates an expression using the Risch-Norman algorithm (JSON)
 */
rssn_ char *rssn_json_risch_norman_integrate(const char *aExprJson, const char *aXJson) ;

/*
 Decodes a Reed-Solomon codeword via JSON interface.
 */
rssn_ char *rssn_json_rs_decode(const char *aCodewordJson, const char *aNSymJson) ;

/*
 Encodes data using Reed-Solomon code via JSON interface.
 Input: {"data": [bytes], "n_sym": number}
 */
rssn_ char *rssn_json_rs_encode(const char *aDataJson, const char *aNSymJson) ;

rssn_ char *rssn_json_shannon_entropy(const char *aProbsJson) ;

rssn_ char *rssn_json_simple_linear_regression(const char *aDataJson) ;

/*
 Creates a new Simplex (JSON)
 */
rssn_ char *rssn_json_simplex_create(const char *aVerticesJson) ;

/*
 Gets the dimension of a Simplex (JSON)
 */
rssn_ char *rssn_json_simplex_dimension(const char *aSimplexJson) ;

/*
 Adds a simplex to a SimplicialComplex (JSON)
 */
rssn_
char *rssn_json_simplicial_complex_add_simplex(const char *aComplexJson,
                                               const char *aVerticesJson)
;

/*
 Applies the symbolic boundary operator to a SymbolicChain (JSON)
 */
rssn_
char *rssn_json_simplicial_complex_apply_symbolic_boundary_operator(const char *aComplexJson,
                                                                    const char *aChainJson)
;

/*
 Creates a new SimplicialComplex (JSON)
 */
rssn_ char *rssn_json_simplicial_complex_create(void) ;

/*
 Gets the symbolic boundary matrix for dimension k (JSON)
 */
rssn_
char *rssn_json_simplicial_complex_get_symbolic_boundary_matrix(const char *aComplexJson,
                                                                size_t aK)
;

/*
 Simplifies an expression using the legacy simplifier (JSON input/output).
 */
rssn_ char *rssn_json_simplify(const char *aExprJson) ;

/*
 Simplifies an expression using the DAG-based simplifier (JSON input/output).
 */
rssn_ char *rssn_json_simplify_dag(const char *aExprJson) ;

/*
 Simplifies a logical expression using JSON-based FFI.
 */
rssn_ char *rssn_json_simplify_logic(const char *aExprJson) ;

/*
 Simplifies radical expressions (JSON)
 */
rssn_ char *rssn_json_simplify_radicals(const char *aExprJson) ;

rssn_ char *rssn_json_so3_generators(void) ;

rssn_ char *rssn_json_solve(const char *aExprJson, const char *aVarJson) ;

/*
 Solves a Bernoulli ODE using JSON.
 */
rssn_
char *rssn_json_solve_bernoulli_ode(const char *aEquationJson,
                                    const char *aFunc,
                                    const char *aVar)
;

/*
 Solves by reduction of order using JSON.
 */
rssn_
char *rssn_json_solve_by_reduction_of_order(const char *aEquationJson,
                                            const char *aFunc,
                                            const char *aVar,
                                            const char *aY1Json)
;

/*
 Solves a Cauchy-Euler ODE using JSON.
 */
rssn_
char *rssn_json_solve_cauchy_euler_ode(const char *aEquationJson,
                                       const char *aFunc,
                                       const char *aVar)
;

rssn_ char *rssn_json_solve_diophantine(const char *aEquationJson, const char *aVarsJson) ;

/*
 Solves an exact ODE using JSON.
 */
rssn_
char *rssn_json_solve_exact_ode(const char *aEquationJson,
                                const char *aFunc,
                                const char *aVar)
;

/*
 Solves a first-order linear ODE using JSON.
 */
rssn_
char *rssn_json_solve_first_order_linear_ode(const char *aEquationJson,
                                             const char *aFunc,
                                             const char *aVar)
;

/*
 Solves the 1D heat equation (JSON).
 */
rssn_
char *rssn_json_solve_heat_equation_1d(const char *aEquationJson,
                                       const char *aFunc,
                                       const char *aVarsJson)
;

/*
 Solves the 2D Laplace equation (JSON).
 */
rssn_
char *rssn_json_solve_laplace_equation_2d(const char *aEquationJson,
                                          const char *aFunc,
                                          const char *aVarsJson)
;

rssn_ char *rssn_json_solve_linear_system(const char *aSystemJson, const char *aVarsJson) ;

/*
 Solves an ODE using JSON.
 */
rssn_ char *rssn_json_solve_ode(const char *aOdeJson, const char *aFunc, const char *aVar) ;

/*
 Solves a PDE using JSON with automatic method selection.
 */
rssn_ char *rssn_json_solve_pde(const char *aPdeJson, const char *aFunc, const char *aVarsJson) ;

/*
 Solves a PDE using the method of characteristics (JSON).
 */
rssn_
char *rssn_json_solve_pde_by_characteristics(const char *aEquationJson,
                                             const char *aFunc,
                                             const char *aVarsJson)
;

/*
 Solves the 2D Poisson equation (JSON).
 */
rssn_
char *rssn_json_solve_poisson_equation_2d(const char *aEquationJson,
                                          const char *aFunc,
                                          const char *aVarsJson)
;

/*
 Solves a Riccati ODE using JSON.
 */
rssn_
char *rssn_json_solve_riccati_ode(const char *aEquationJson,
                                  const char *aFunc,
                                  const char *aVar,
                                  const char *aY1Json)
;

/*
 Solves a separable ODE using JSON.
 */
rssn_
char *rssn_json_solve_separable_ode(const char *aEquationJson,
                                    const char *aFunc,
                                    const char *aVar)
;

rssn_ char *rssn_json_solve_system(const char *aEquationsJson, const char *aVarsJson) ;

/*
 Solves the 1D wave equation using D'Alembert's formula (JSON).
 */
rssn_
char *rssn_json_solve_wave_equation_1d(const char *aEquationJson,
                                       const char *aFunc,
                                       const char *aVarsJson)
;

/*
 Computes square-free factorization (JSON)
 */
rssn_ char *rssn_json_square_free_factorization_gf(const char *aPolyJson) ;

/*
 Computes the symbolic standard deviation of a set of expressions using JSON.
 */
rssn_ char *rssn_json_std_dev(const char *aDataJson) ;

rssn_ char *rssn_json_stirling_number_second_kind(size_t aN, size_t aK) ;

/*
 Represents Stokes' theorem (JSON)
 */
rssn_ char *rssn_json_stokes_theorem(const char *aVectorFieldJson, const char *aSurfaceJson) ;

/*
 Generates the Sturm sequence for a given polynomial (JSON)
 */
rssn_ char *rssn_json_sturm_sequence(const char *aExprJson, const char *aVarPtr) ;

rssn_ char *rssn_json_su2_generators(void) ;

/*
 Substitutes using JSON.
 */
rssn_
char *rssn_json_substitute(const char *aExprJson,
                           const char *aVar,
                           const char *aReplacementJson)
;

rssn_
char *rssn_json_summation(const char *aExprJson,
                          const char *aVarJson,
                          const char *aLowerJson,
                          const char *aUpperJson)
;

/*
 Adds a term to a SymbolicChain (JSON)
 */
rssn_
char *rssn_json_symbolic_chain_add_term(const char *aChainJson,
                                        const char *aSimplexJson,
                                        const char *aCoeffJson)
;

/*
 Creates a new SymbolicChain (JSON)
 */
rssn_ char *rssn_json_symbolic_chain_create(size_t aDimension) ;

rssn_ char *rssn_json_symmetric_group_create(size_t aN) ;

rssn_
char *rssn_json_taylor_series(const char *aExprJson,
                              const char *aVarJson,
                              const char *aCenterJson,
                              const char *aOrderJson)
;

rssn_ char *rssn_json_tensor_add(const char *aT1Json, const char *aT2Json) ;

rssn_ char *rssn_json_tensor_contract(const char *aTJson, size_t aAxis1, size_t aAxis2) ;

rssn_ char *rssn_json_tensor_outer_product(const char *aT1Json, const char *aT2Json) ;

rssn_ char *rssn_json_tensor_scalar_mul(const char *aTJson, const char *aScalarJson) ;

/*
 Converts a logical expression to Conjunctive Normal Form (CNF) using JSON-based FFI.
 */
rssn_ char *rssn_json_to_cnf(const char *aExprJson) ;

/*
 Converts a logical expression to Disjunctive Normal Form (DNF) using JSON-based FFI.
 */
rssn_ char *rssn_json_to_dnf(const char *aExprJson) ;

rssn_
char *rssn_json_transform_contravariant_vector(const char *aCompsJson,
                                               enum rssn_CoordinateSystem aFrom,
                                               enum rssn_CoordinateSystem aTo)
;

rssn_
char *rssn_json_transform_covariant_vector(const char *aCompsJson,
                                           enum rssn_CoordinateSystem aFrom,
                                           enum rssn_CoordinateSystem aTo)
;

rssn_ char *rssn_json_transform_curl(const char *aCompsJson, enum rssn_CoordinateSystem aFrom) ;

rssn_
char *rssn_json_transform_divergence(const char *aCompsJson,
                                     enum rssn_CoordinateSystem aFrom)
;

rssn_
char *rssn_json_transform_expression(const char *aExprJson,
                                     enum rssn_CoordinateSystem aFrom,
                                     enum rssn_CoordinateSystem aTo)
;

rssn_
char *rssn_json_transform_gradient(const char *aScalarJson,
                                   const char *aVarsJson,
                                   enum rssn_CoordinateSystem aFrom,
                                   enum rssn_CoordinateSystem aTo)
;

rssn_
char *rssn_json_transform_point(const char *aPointJson,
                                enum rssn_CoordinateSystem aFrom,
                                enum rssn_CoordinateSystem aTo)
;

rssn_
char *rssn_json_two_sample_t_test(const char *aData1Json,
                                  const char *aData2Json,
                                  const char *aMuDiffJson)
;

rssn_ char *rssn_json_unify_expression(const char *aExprJson) ;

/*
 Computes the symbolic variance of a set of expressions using JSON.
 */
rssn_ char *rssn_json_variance(const char *aDataJson) ;

rssn_ char *rssn_json_vector_cross(const char *aV1Json, const char *aV2Json) ;

rssn_
char *rssn_json_vector_curl(const char *aVJson,
                            const char *aXVar,
                            const char *aYVar,
                            const char *aZVar)
;

rssn_
char *rssn_json_vector_divergence(const char *aVJson,
                                  const char *aXVar,
                                  const char *aYVar,
                                  const char *aZVar)
;

rssn_ char *rssn_json_vector_dot(const char *aV1Json, const char *aV2Json) ;

rssn_
char *rssn_json_vector_gradient(const char *aScalarFieldJson,
                                const char *aXVar,
                                const char *aYVar,
                                const char *aZVar)
;

rssn_ char *rssn_json_vector_magnitude(const char *aVJson) ;

rssn_ char *rssn_json_vector_normalize(const char *aVJson) ;

/*
 Computes the wedge product of two differential forms (JSON)
 */
rssn_ char *rssn_json_wedge_product(const char *aForm1Json, const char *aForm2Json) ;

rssn_
char *rssn_json_z_test(const char *aDataJson,
                       const char *aTargetMeanJson,
                       const char *aPopStdDevJson)
;

rssn_
char *rssn_json_z_transform(const char *aExprJson,
                            const char *aInVarJson,
                            const char *aOutVarJson)
;

rssn_ char *rssn_json_zeta(const char *aArgJson) ;

/*
 Frees an ECDH key pair.

 # Safety
 Caller must ensure `keypair` was returned by `rssn_generate_keypair`.
 */
rssn_ void rssn_keypair_free(struct rssn_EcdhKeyPair *aKeypair) ;

rssn_
struct rssn_Expr *rssn_kl_divergence(const struct rssn_Expr *const *aPProbs,
                                     size_t aPLen,
                                     const struct rssn_Expr *const *aQProbs,
                                     size_t aQLen)
;

rssn_ struct rssn_Group *rssn_klein_four_group_create(void) ;

/*
 Applies the Knuth-Bendix completion algorithm to a set of equations.

 Returns a pointer to a Vec<RewriteRule> on success, or null on failure.

 # Safety
 The caller must ensure `equations` is a valid array of Expr pointers.
 */
rssn_
struct rssn_Vec_RewriteRule *rssn_knuth_bendix(const struct rssn_Expr *const *aEquations,
                                               size_t aEquationsLen)
;

/*
 Applies the Knuth-Bendix completion algorithm (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_knuth_bendix_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Applies the Knuth-Bendix completion algorithm (JSON).

 Input: JSON array of equations (Expr::Eq)
 Output: JSON array of RewriteRule objects
 */
rssn_ char *rssn_knuth_bendix_json(const char *aJsonStr) ;

rssn_
struct rssn_Expr *rssn_laguerre_differential_equation(const struct rssn_Expr *aY,
                                                      const struct rssn_Expr *aX,
                                                      const struct rssn_Expr *aN)
;

rssn_
struct rssn_Expr *rssn_laguerre_l(const struct rssn_Expr *aDegree,
                                  const struct rssn_Expr *aArg)
;

rssn_
struct rssn_Expr *rssn_laplace_differentiation(const struct rssn_Expr *aFS,
                                               const char *aOutVar,
                                               const struct rssn_Expr *aFZero)
;

rssn_
struct rssn_Expr *rssn_laplace_time_shift(const struct rssn_Expr *aFS,
                                          const struct rssn_Expr *aA,
                                          const char *aOutVar)
;

rssn_
struct rssn_Expr *rssn_laplace_transform(const struct rssn_Expr *aExpr,
                                         const char *aInVar,
                                         const char *aOutVar)
;

rssn_
struct rssn_Expr *rssn_laurent_series_handle(const struct rssn_Expr *aExpr,
                                             const char *aVar,
                                             const struct rssn_Expr *aCenter,
                                             size_t aOrder)
;

rssn_
struct rssn_Expr *rssn_legendre_differential_equation(const struct rssn_Expr *aY,
                                                      const struct rssn_Expr *aX,
                                                      const struct rssn_Expr *aN)
;

rssn_
struct rssn_Expr *rssn_legendre_p(const struct rssn_Expr *aDegree,
                                  const struct rssn_Expr *aArg)
;

rssn_
struct rssn_Expr *rssn_legendre_rodrigues_formula(const struct rssn_Expr *aN,
                                                  const struct rssn_Expr *aX)
;

rssn_ void rssn_lie_algebra_free(struct rssn_LieAlgebra *aPtr) ;

rssn_
struct rssn_Expr *rssn_lie_algebra_get_basis_element(const struct rssn_LieAlgebra *aPtr,
                                                     size_t aIndex)
;

rssn_ size_t rssn_lie_algebra_get_dimension(const struct rssn_LieAlgebra *aPtr) ;

rssn_ char *rssn_lie_algebra_get_name(const struct rssn_LieAlgebra *aPtr) ;

rssn_ struct rssn_LieAlgebra *rssn_lie_algebra_so3_create(void) ;

rssn_ struct rssn_LieAlgebra *rssn_lie_algebra_su2_create(void) ;

rssn_ struct rssn_Expr *rssn_lie_bracket(const struct rssn_Expr *aX, const struct rssn_Expr *aY) ;

/*
 Computes the limit of an expression: limit(expr, var -> point).

 # Safety
 The caller must ensure `expr` and `point` are valid Expr pointers and `var` is a valid C string.
 */
rssn_
struct rssn_Expr *rssn_limit(const struct rssn_Expr *aExpr,
                             const char *aVar,
                             const struct rssn_Expr *aPoint)
;

/*
 Computes the line integral of a scalar field along a curve.
 */
rssn_
char *rssn_line_integral_scalar(const char *aScalarField,
                                const struct rssn_ParametricCurve *aCurve)
;

/*
 Computes the line integral of a scalar field (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_line_integral_scalar_bincode(const uint8_t *aInputPtr,
                                                            size_t aInputLen)
;

/*
 Computes the line integral of a scalar field (JSON).
 */
rssn_ char *rssn_line_integral_scalar_json(const char *aInputJson) ;

/*
 Computes the line integral of a vector field along a curve.
 */
rssn_
char *rssn_line_integral_vector(const char *aFieldX,
                                const char *aFieldY,
                                const char *aFieldZ,
                                const struct rssn_ParametricCurve *aCurve)
;

/*
 Computes the line integral of a vector field (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_line_integral_vector_bincode(const uint8_t *aInputPtr,
                                                            size_t aInputLen)
;

/*
 Computes the line integral of a vector field (JSON).
 */
rssn_ char *rssn_line_integral_vector_json(const char *aInputJson) ;

rssn_
struct rssn_Expr *rssn_linear_operator_apply(const struct rssn_LinearOperator *aOp,
                                             const struct rssn_Expr *aExpr)
;

rssn_ struct rssn_LinearOperator *rssn_linear_operator_derivative_create(const char *aVar) ;

rssn_ void rssn_linear_operator_free(struct rssn_LinearOperator *aPtr) ;

rssn_
struct rssn_LinearOperator *rssn_linear_operator_integral_create(const struct rssn_Expr *aLowerBound,
                                                                 const char *aVar)
;

/*
 Creates a natural logarithm expression: ln(expr).
 */
rssn_ struct rssn_Expr *rssn_ln(const struct rssn_Expr *aExpr) ;

rssn_ double rssn_ln_beta_numerical(double aA, double aB) ;

/*
 Creates a natural logarithm expression from bincode: ln(expr).
 */
rssn_ struct rssn_BincodeBuffer rssn_ln_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

rssn_ double rssn_ln_gamma_numerical(double aX) ;

/*
 Creates a natural logarithm expression from JSON: ln(expr).
 */
rssn_ char *rssn_ln_json(const char *aJsonExpr) ;

/*
 Returns Lorenz system equations (Handle)
 */
rssn_
bool rssn_lorenz_system(struct rssn_Expr **aDxOut,
                        struct rssn_Expr **aDyOut,
                        struct rssn_Expr **aDzOut)
;

/*
 Calculates Lyapunov exponent (Handle)
 */
rssn_
struct rssn_Expr *rssn_lyapunov_exponent(const struct rssn_Expr *aMapPtr,
                                         const char *aVar,
                                         const struct rssn_Expr *aInitialXPtr,
                                         size_t aNIterations)
;

rssn_ int32_t rssn_matrix_add(size_t aH1, size_t aH2, size_t *aResultH) ;

rssn_
struct rssn_Expr *rssn_matrix_add_handle(const struct rssn_Expr *aM1,
                                         const struct rssn_Expr *aM2)
;

rssn_ int32_t rssn_matrix_determinant(size_t aH, size_t *aResultH) ;

rssn_ struct rssn_Expr *rssn_matrix_determinant_handle(const struct rssn_Expr *aMatrix) ;

rssn_ int32_t rssn_matrix_identity(size_t aSize, size_t *aResultH) ;

rssn_ int32_t rssn_matrix_inverse(size_t aH, size_t *aResultH) ;

rssn_ struct rssn_Expr *rssn_matrix_inverse_handle(const struct rssn_Expr *aMatrix) ;

rssn_ int32_t rssn_matrix_mul(size_t aH1, size_t aH2, size_t *aResultH) ;

rssn_
struct rssn_Expr *rssn_matrix_mul_handle(const struct rssn_Expr *aM1,
                                         const struct rssn_Expr *aM2)
;

rssn_ int32_t rssn_matrix_scalar_mul(size_t aScalarH, size_t aMatrixH, size_t *aResultH) ;

rssn_
struct rssn_Expr *rssn_matrix_solve_linear_system_handle(const struct rssn_Expr *aA,
                                                         const struct rssn_Expr *aB)
;

rssn_ int32_t rssn_matrix_sub(size_t aH1, size_t aH2, size_t *aResultH) ;

rssn_ int32_t rssn_matrix_transpose(size_t aH, size_t *aResultH) ;

rssn_ struct rssn_Expr *rssn_matrix_transpose_handle(const struct rssn_Expr *aMatrix) ;

/*
 Computes the symbolic mean of a set of expressions.

 # Safety
 The caller must ensure `data` is a valid pointer to an array of `Expr` pointers of size `len`.
 */
rssn_ struct rssn_Expr *rssn_mean(const struct rssn_Expr *const *aData, size_t aLen) ;

/*
 Computes geometric product (Handle)
 */
rssn_
struct rssn_Multivector *rssn_multivector_geometric_product_handle(const struct rssn_Multivector *aA,
                                                                   const struct rssn_Multivector *aB)
;

/*
 Computes grade projection (Handle)
 */
rssn_
struct rssn_Multivector *rssn_multivector_grade_projection_handle(const struct rssn_Multivector *aMv,
                                                                  uint32_t aGrade)
;

/*
 Computes inner product (Handle)
 */
rssn_
struct rssn_Multivector *rssn_multivector_inner_product_handle(const struct rssn_Multivector *aA,
                                                               const struct rssn_Multivector *aB)
;

/*
 Computes magnitude (Handle)
 */
rssn_ struct rssn_Expr *rssn_multivector_magnitude_handle(const struct rssn_Multivector *aMv) ;

/*
 Computes outer product (Handle)
 */
rssn_
struct rssn_Multivector *rssn_multivector_outer_product_handle(const struct rssn_Multivector *aA,
                                                               const struct rssn_Multivector *aB)
;

/*
 Computes reverse (Handle)
 */
rssn_ struct rssn_Multivector *rssn_multivector_reverse_handle(const struct rssn_Multivector *aMv) ;

/*
 Creates a new scalar multivector (Handle)
 */
rssn_
struct rssn_Multivector *rssn_multivector_scalar_handle(uint32_t aP,
                                                        uint32_t aQ,
                                                        uint32_t aR,
                                                        const struct rssn_Expr *aValue)
;

rssn_ struct rssn_Expr *rssn_mutual_information(const struct rssn_Expr *aJointProbs) ;

rssn_
struct rssn_Expr *rssn_nonlinear_regression(const struct rssn_Expr *const *aXData,
                                            const struct rssn_Expr *const *aYData,
                                            size_t aLen,
                                            const struct rssn_Expr *aModel,
                                            const char *const *aVars,
                                            size_t aVarsLen,
                                            const char *const *aParams,
                                            size_t aParamsLen)
;

rssn_
struct rssn_Expr *rssn_norm(const struct rssn_HilbertSpace *aSpace,
                            const struct rssn_Expr *aF)
;

/*
 Computes the greatest common divisor (GCD) of two numbers.

 Returns 0 on success, -1 on error.
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_ int32_t rssn_nt_gcd(uint64_t aA, uint64_t aB, uint64_t *aResult) ;

/*
 Checks if a number is prime using the Miller-Rabin test.

 Returns 0 on success, -1 on error.
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_ int32_t rssn_nt_is_prime(uint64_t aN, bool *aResult) ;

/*
 Computes the modular multiplicative inverse.

 Returns 0 on success, -1 on error (e.g., if no inverse exists).
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_ int32_t rssn_nt_mod_inverse(int64_t aA, int64_t aB, int64_t *aResult) ;

/*
 Computes modular exponentiation (base^exp % modulus).

 Returns 0 on success, -1 on error.
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_ int32_t rssn_nt_mod_pow(uint64_t aBase, uint64_t aExp, uint64_t aModulus, uint64_t *aResult) ;

rssn_
int32_t rssn_numerical_gradient(size_t aExprH,
                                const char *const *aVars,
                                size_t aNumVars,
                                const double *aPoint,
                                size_t aPointLen,
                                double *aResultVec)
;

rssn_
int32_t rssn_numerical_integrate(size_t aExprH,
                                 const char *aVar,
                                 double aStart,
                                 double aEnd,
                                 size_t aNSteps,
                                 uint32_t aMethod,
                                 double *aResult)
;

rssn_
struct rssn_Expr *rssn_one_sample_t_test(const struct rssn_Expr *const *aData,
                                         size_t aLen,
                                         const struct rssn_Expr *aTargetMean)
;

/*
 Frees a ParametricCurve handle.
 */
rssn_ void rssn_parametric_curve_free(struct rssn_ParametricCurve *aCurve) ;

/*
 Creates a new ParametricCurve.
 */
rssn_
struct rssn_ParametricCurve *rssn_parametric_curve_new(const char *aRX,
                                                       const char *aRY,
                                                       const char *aRZ,
                                                       const char *aTVar,
                                                       const char *aTLower,
                                                       const char *aTUpper)
;

/*
 Frees a ParametricSurface handle.
 */
rssn_ void rssn_parametric_surface_free(struct rssn_ParametricSurface *aSurface) ;

/*
 Creates a new ParametricSurface.
 */
rssn_
struct rssn_ParametricSurface *rssn_parametric_surface_new(const char *aRX,
                                                           const char *aRY,
                                                           const char *aRZ,
                                                           const char *aUVar,
                                                           const char *aULower,
                                                           const char *aUUpper,
                                                           const char *aVVar,
                                                           const char *aVLower,
                                                           const char *aVUpper)
;

/*
 Clears a ParsingCache.
 */
rssn_ void rssn_parsing_cache_clear(struct rssn_ParsingCache *aCache) ;

/*
 Frees a ParsingCache.
 */
rssn_ void rssn_parsing_cache_free(struct rssn_ParsingCache *aCache) ;

/*
 Retrieves an expression from the ParsingCache.
 Returns a pointer to the Expr (Arc<Expr> with incremented refcount), or null if not found.
 The caller is responsible for freeing the returned Expr (using the appropriate Expr free function).
 */
rssn_
struct rssn_Expr *rssn_parsing_cache_get(struct rssn_ParsingCache *aCache,
                                         const char *aInput)
;

/*
 Retrieves an expression from the ParsingCache as a bincode buffer.
 */
rssn_
struct rssn_BincodeBuffer rssn_parsing_cache_get_bincode(struct rssn_ParsingCache *aCache,
                                                         const char *aInput)
;

/*
 Retrieves an expression from the ParsingCache as a JSON string.
 Returns null if not found or error.
 */
rssn_ char *rssn_parsing_cache_get_json(struct rssn_ParsingCache *aCache, const char *aInput) ;

/*
 Creates a new ParsingCache.
 The caller is responsible for freeing the memory using rssn_parsing_cache_free.
 */
rssn_ struct rssn_ParsingCache *rssn_parsing_cache_new(void) ;

/*
 Stores an expression in the ParsingCache.
 The expr pointer is cloned (deep copy of the structure, but DAG nodes are shared).
 */
rssn_
void rssn_parsing_cache_set(struct rssn_ParsingCache *aCache,
                            const char *aInput,
                            const struct rssn_Expr *aExpr)
;

/*
 Stores an expression in the ParsingCache from a bincode buffer.
 */
rssn_
void rssn_parsing_cache_set_bincode(struct rssn_ParsingCache *aCache,
                                    const char *aInput,
                                    struct rssn_BincodeBuffer aBuffer)
;

/*
 Stores an expression in the ParsingCache from a JSON string.
 */
rssn_
void rssn_parsing_cache_set_json(struct rssn_ParsingCache *aCache,
                                 const char *aInput,
                                 const char *aJsonExpr)
;

/*
 Computes a path integral.
 */
rssn_
struct rssn_Expr *rssn_path_integrate(const struct rssn_Expr *aExpr,
                                      const char *aVar,
                                      const struct rssn_Expr *aContour)
;

rssn_ struct rssn_Expr *rssn_permutations(const struct rssn_Expr *aN, const struct rssn_Expr *aK) ;

rssn_
int32_t rssn_physics_advection_diffusion_1d(const double *aInitialCond,
                                            size_t aLen,
                                            double aDx,
                                            double aC,
                                            double aD,
                                            double aDt,
                                            size_t aSteps,
                                            double *aResultPtr)
;

/*
 Returns the symbolic representation of Pi.
 */
rssn_ struct rssn_Expr *rssn_pi(void) ;

/*
 Returns Pi as bincode.
 */
rssn_ struct rssn_BincodeBuffer rssn_pi_bincode(void) ;

/*
 Returns Pi as JSON.
 */
rssn_ char *rssn_pi_json(void) ;

/*
 Executes a command on a loaded plugin.

 # Arguments
 * `plugin_name_ptr` - A null-terminated UTF-8 string representing the plugin's name.
 * `command_ptr` - A null-terminated UTF-8 string for the command to execute.
 * `args_handle` - A handle to the `Expr` object to be passed as an argument.

 # Returns
 A handle to the resulting `Expr` object on success, or 0 on failure.
 On failure, an error message can be retrieved with `rssn_get_last_error`.
 */
rssn_
size_t rssn_plugin_execute(const char *aPluginNamePtr,
                           const char *aCommandPtr,
                           size_t aArgsHandle)
;

rssn_ struct rssn_Expr *rssn_poles_get(const struct rssn_Vec_Expr *aPoles, size_t aIndex) ;

rssn_ size_t rssn_poles_len(const struct rssn_Vec_Expr *aPoles) ;

/*
 Adds two polynomials over a general finite field.

 # Safety
 Caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_poly_add_gf(const struct rssn_Expr *aP1,
                                   const struct rssn_Expr *aP2,
                                   const struct rssn_Arc_FiniteField *aField)
;

/*
 Adds two polynomials over GF(2^8).

 # Safety
 Caller must ensure pointers are valid. Result is allocated and must be freed.
 */
rssn_
uint8_t *rssn_poly_add_gf256(const uint8_t *aP1,
                             size_t aP1Len,
                             const uint8_t *aP2,
                             size_t aP2Len,
                             size_t *aOutLen)
;

rssn_ int32_t rssn_poly_degree(size_t aExprHandle, const char *aVarPtr, int64_t *aResult) ;

/*
 Computes polynomial derivative over finite field (Handle)
 */
rssn_
struct rssn_FiniteFieldPolynomial *rssn_poly_derivative_gf_handle(const struct rssn_FiniteFieldPolynomial *aPoly)
;

/*
 Evaluates a polynomial over GF(2^8) at point x.

 # Safety
 Caller must ensure `poly` is a valid pointer to an array of `len` bytes.
 */
rssn_ uint8_t rssn_poly_eval_gf256(const uint8_t *aPoly, size_t aLen, uint8_t aX) ;

/*
 Computes polynomial GCD over finite field (Handle)
 */
rssn_
struct rssn_FiniteFieldPolynomial *rssn_poly_gcd_gf_handle(const struct rssn_FiniteFieldPolynomial *aA,
                                                           const struct rssn_FiniteFieldPolynomial *aB)
;

rssn_ int32_t rssn_poly_is_polynomial(size_t aExprHandle, const char *aVarPtr, bool *aResult) ;

rssn_
int32_t rssn_poly_long_division(size_t aNHandle,
                                size_t aDHandle,
                                const char *aVarPtr,
                                size_t *aQHandle,
                                size_t *aRHandle)
;

/*
 Multiplies two polynomials over a general finite field.

 # Safety
 Caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_poly_mul_gf(const struct rssn_Expr *aP1,
                                   const struct rssn_Expr *aP2,
                                   const struct rssn_Arc_FiniteField *aField)
;

/*
 Multiplies two polynomials over GF(2^8).

 # Safety
 Caller must ensure pointers are valid. Result is allocated and must be freed.
 */
rssn_
uint8_t *rssn_poly_mul_gf256(const uint8_t *aP1,
                             size_t aP1Len,
                             const uint8_t *aP2,
                             size_t aP2Len,
                             size_t *aOutLen)
;

rssn_
struct rssn_Expr *rssn_polynomial_regression(const struct rssn_Expr *const *aXData,
                                             const struct rssn_Expr *const *aYData,
                                             size_t aLen,
                                             size_t aDegree)
;

/*
 Creates a power expression: base^exp.
 */
rssn_ struct rssn_Expr *rssn_pow(const struct rssn_Expr *aBase, const struct rssn_Expr *aExp) ;

/*
 Creates a power expression from bincode: base^exp.

 # Arguments
 * `base_buffer` - Bincode-serialized base Expr
 * `exp_buffer` - Bincode-serialized exponent Expr
 */
rssn_
struct rssn_BincodeBuffer rssn_pow_bincode(struct rssn_BincodeBuffer aBaseBuffer,
                                           struct rssn_BincodeBuffer aExpBuffer)
;

/*
 Creates a power expression from JSON: base^exp.

 # Arguments
 * `json_base` - JSON-serialized base Expr
 * `json_exp` - JSON-serialized exponent Expr
 */
rssn_ char *rssn_pow_json(const char *aJsonBase, const char *aJsonExp) ;

/*
 Adds two prime field elements (Handle)
 */
rssn_
struct rssn_PrimeFieldElement *rssn_prime_field_element_add_handle(const struct rssn_PrimeFieldElement *aA,
                                                                   const struct rssn_PrimeFieldElement *aB)
;

/*
 Frees a prime field element (Handle)
 */
rssn_ void rssn_prime_field_element_free_handle(struct rssn_PrimeFieldElement *aElem) ;

/*
 Computes the inverse of a prime field element (Handle)
 */
rssn_
struct rssn_PrimeFieldElement *rssn_prime_field_element_inverse_handle(const struct rssn_PrimeFieldElement *aElem)
;

/*
 Multiplies two prime field elements (Handle)
 */
rssn_
struct rssn_PrimeFieldElement *rssn_prime_field_element_mul_handle(const struct rssn_PrimeFieldElement *aA,
                                                                   const struct rssn_PrimeFieldElement *aB)
;

/*
 Creates a new prime field element (Handle)
 Returns a boxed pointer to the element
 */
rssn_
struct rssn_PrimeFieldElement *rssn_prime_field_element_new_handle(const rssn_BigInt *aValue,
                                                                   const rssn_BigInt *aModulus)
;

rssn_
struct rssn_Expr *rssn_product_handle(const struct rssn_Expr *aExpr,
                                      const char *aVar,
                                      const struct rssn_Expr *aLower,
                                      const struct rssn_Expr *aUpper)
;

rssn_
struct rssn_Expr *rssn_project(const struct rssn_HilbertSpace *aSpace,
                               const struct rssn_Expr *aF,
                               const struct rssn_Expr *aG)
;

rssn_
struct rssn_Representation *rssn_representation_create(const struct rssn_Expr *const *aElementsPtr,
                                                       size_t aElementsLen,
                                                       const struct rssn_Expr *const *aKeysPtr,
                                                       const struct rssn_Expr *const *aValuesPtr,
                                                       size_t aMapLen)
;

rssn_ void rssn_representation_free(struct rssn_Representation *aPtr) ;

rssn_
bool rssn_representation_is_valid(const struct rssn_Representation *aRep,
                                  const struct rssn_Group *aGroup)
;

/*
 Frees a rewrite rule.

 # Safety
 The caller must ensure `rule` was created by this module and hasn't been freed yet.
 */
rssn_ void rssn_rewrite_rule_free(struct rssn_RewriteRule *aRule) ;

/*
 Gets the LHS of a rewrite rule.

 Returns a new owned Expr pointer that must be freed by the caller.

 # Safety
 The caller must ensure `rule` is a valid RewriteRule pointer.
 */
rssn_ struct rssn_Expr *rssn_rewrite_rule_get_lhs(const struct rssn_RewriteRule *aRule) ;

/*
 Gets the RHS of a rewrite rule.

 Returns a new owned Expr pointer that must be freed by the caller.

 # Safety
 The caller must ensure `rule` is a valid RewriteRule pointer.
 */
rssn_ struct rssn_Expr *rssn_rewrite_rule_get_rhs(const struct rssn_RewriteRule *aRule) ;

/*
 Creates a new rewrite rule from lhs and rhs expressions.

 # Safety
 The caller must ensure `lhs` and `rhs` are valid Expr pointers.
 */
rssn_
struct rssn_RewriteRule *rssn_rewrite_rule_new(const struct rssn_Expr *aLhs,
                                               const struct rssn_Expr *aRhs)
;

/*
 Creates a rewrite rule from Bincode.
 */
rssn_ struct rssn_BincodeBuffer rssn_rewrite_rule_new_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Creates a rewrite rule from JSON.

 Input: JSON object with "lhs" and "rhs" fields (both Expr)
 Output: JSON-serialized RewriteRule
 */
rssn_ char *rssn_rewrite_rule_new_json(const char *aJsonStr) ;

/*
 Converts a rewrite rule to a string representation.

 The returned string must be freed using `rssn_free_string`.

 # Safety
 The caller must free the returned string.
 */
rssn_ char *rssn_rewrite_rule_to_string(const struct rssn_RewriteRule *aRule) ;

/*
 Converts a rewrite rule to a human-readable string (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_rewrite_rule_to_string_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Converts a rewrite rule to a human-readable string (JSON).

 Input: JSON-serialized RewriteRule
 Output: JSON object with "string" field
 */
rssn_ char *rssn_rewrite_rule_to_string_json(const char *aJsonStr) ;

/*
 Integrates an expression using the Risch-Norman algorithm (Handle)
 */
rssn_
struct rssn_Expr *rssn_risch_norman_integrate_handle(const struct rssn_Expr *aExpr,
                                                     const char *aX)
;

/*
 Decodes a Reed-Solomon codeword, correcting errors if possible.

 # Safety
 Caller must ensure `codeword` is valid. Returns allocated memory that must be freed.
 */
rssn_
uint8_t *rssn_rs_decode(const uint8_t *aCodeword,
                        size_t aCodewordLen,
                        size_t aNSym,
                        size_t *aOutLen)
;

/*
 Encodes data using Reed-Solomon code with n_sym error correction symbols.

 # Safety
 Caller must ensure `data` is valid. Returns allocated memory that must be freed.
 */
rssn_
uint8_t *rssn_rs_encode(const uint8_t *aData,
                        size_t aDataLen,
                        size_t aNSym,
                        size_t *aOutLen)
;

/*
 Frees memory allocated by rs_encode or rs_decode.

 # Safety
 Caller must ensure `ptr` was returned by rssn_rs_encode or rssn_rs_decode.
 */
rssn_ void rssn_rs_free(uint8_t *aPtr, size_t aLen) ;

/*
 Frees a rules vector.

 # Safety
 The caller must ensure `rules` was created by this module and hasn't been freed yet.
 */
rssn_ void rssn_rules_vec_free(struct rssn_Vec_RewriteRule *aRules) ;

/*
 Gets a rule from a rules vector by index.

 Returns a new owned RewriteRule pointer that must be freed by the caller.

 # Safety
 The caller must ensure `rules` is a valid Vec<RewriteRule> pointer.
 */
rssn_
struct rssn_RewriteRule *rssn_rules_vec_get(const struct rssn_Vec_RewriteRule *aRules,
                                            size_t aIndex)
;

/*
 Gets the length of a rules vector.

 # Safety
 The caller must ensure `rules` is a valid Vec<RewriteRule> pointer.
 */
rssn_ size_t rssn_rules_vec_len(const struct rssn_Vec_RewriteRule *aRules) ;

rssn_
enum rssn_ConvergenceResult *rssn_series_analyze_convergence_handle(const struct rssn_Expr *aSeries,
                                                                    const char *aVar)
;

rssn_
struct rssn_BincodeBuffer rssn_series_bincode_analyze_convergence(struct rssn_BincodeBuffer aSeriesBuf,
                                                                  struct rssn_BincodeBuffer aVarBuf)
;

rssn_ char *rssn_series_json_analyze_convergence(const char *aSeriesJson, const char *aVarJson) ;

rssn_ struct rssn_Expr *rssn_shannon_entropy(const struct rssn_Expr *const *aProbs, size_t aLen) ;

rssn_
struct rssn_Expr *rssn_simple_linear_regression(const struct rssn_Expr *const *aXData,
                                                const struct rssn_Expr *const *aYData,
                                                size_t aLen)
;

/*
 Creates a new Simplex (Handle)
 */
rssn_ rssn_Simplex *rssn_simplex_create(const size_t *aVerticesPtr, size_t aLen) ;

/*
 Gets the dimension of a Simplex
 */
rssn_ size_t rssn_simplex_dimension(const rssn_Simplex *aPtr) ;

/*
 Frees a Simplex handle
 */
rssn_ void rssn_simplex_free(rssn_Simplex *aPtr) ;

/*
 Adds a simplex to a SimplicialComplex
 */
rssn_
void rssn_simplicial_complex_add_simplex(struct rssn_SimplicialComplex *aComplexPtr,
                                         const size_t *aVerticesPtr,
                                         size_t aLen)
;

/*
 Applies the symbolic boundary operator to a SymbolicChain
 */
rssn_
struct rssn_SymbolicChain *rssn_simplicial_complex_apply_symbolic_boundary_operator(const struct rssn_SimplicialComplex *aComplexPtr,
                                                                                    const struct rssn_SymbolicChain *aChainPtr)
;

/*
 Creates a new SimplicialComplex (Handle)
 */
rssn_ struct rssn_SimplicialComplex *rssn_simplicial_complex_create(void) ;

/*
 Gets the dimension of a SimplicialComplex
 */
rssn_ int rssn_simplicial_complex_dimension(const struct rssn_SimplicialComplex *aPtr) ;

/*
 Computes the Euler characteristic
 */
rssn_
ptrdiff_t rssn_simplicial_complex_euler_characteristic(const struct rssn_SimplicialComplex *aPtr)
;

/*
 Frees a SimplicialComplex handle
 */
rssn_ void rssn_simplicial_complex_free(struct rssn_SimplicialComplex *aPtr) ;

/*
 Gets the symbolic boundary matrix for dimension k
 */
rssn_
struct rssn_Expr *rssn_simplicial_complex_get_symbolic_boundary_matrix(const struct rssn_SimplicialComplex *aComplexPtr,
                                                                       size_t aK)
;

/*
 Simplifies an expression using the legacy simplifier.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_simplify(const struct rssn_Expr *aExpr) ;

/*
 Simplifies an expression using the DAG-based simplifier.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_simplify_dag(const struct rssn_Expr *aExpr) ;

/*
 Simplifies a logical expression using handle-based FFI.

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_ struct rssn_Expr *rssn_simplify_logic_handle(const struct rssn_Expr *aExpr) ;

/*
 Simplifies radical expressions (Handle)
 */
rssn_ struct rssn_Expr *rssn_simplify_radicals_handle(const struct rssn_Expr *aExpr) ;

/*
 Creates a sine expression: sin(expr).

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_sin(const struct rssn_Expr *aExpr) ;

/*
 Creates a sine expression from bincode: sin(expr).

 # Arguments
 * `expr_buffer` - Bincode-serialized Expr

 # Returns
 Bincode-serialized Expr
 */
rssn_ struct rssn_BincodeBuffer rssn_sin_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a sine expression from JSON: sin(expr).

 # Arguments
 * `json_expr` - JSON-serialized Expr

 # Returns
 JSON-serialized Expr or null on error
 */
rssn_ char *rssn_sin_json(const char *aJsonExpr) ;

rssn_ struct rssn_Expr **rssn_so3_generators(size_t *aOutLen) ;

rssn_ int32_t rssn_solve(size_t aExprH, const char *aVar, size_t *aResultH) ;

/*
 Solves the airfoil singular integral equation.
 */
rssn_
struct rssn_Expr *rssn_solve_airfoil_equation(const struct rssn_Expr *aFX,
                                              const char *aVarX,
                                              const char *aVarT)
;

/*
 Solves the airfoil singular integral equation (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_solve_airfoil_equation_bincode(const uint8_t *aInputPtr,
                                                              size_t aInputLen)
;

/*
 Solves the airfoil singular integral equation (JSON).
 */
rssn_ char *rssn_solve_airfoil_equation_json(const char *aInputJson) ;

/*
 Solves a Bernoulli ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_bernoulli_ode(const struct rssn_Expr *aEquation,
                                           const char *aFunc,
                                           const char *aVar)
;

/*
 Solves a second-order ODE by reduction of order with a known solution.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_by_reduction_of_order(const struct rssn_Expr *aEquation,
                                                   const char *aFunc,
                                                   const char *aVar,
                                                   const struct rssn_Expr *aY1)
;

/*
 Solves a Cauchy-Euler ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_cauchy_euler_ode(const struct rssn_Expr *aEquation,
                                              const char *aFunc,
                                              const char *aVar)
;

/*
 Solves a Diophantine equation.

 # Safety
 `equation` must be a valid pointer to an `Expr`.
 `vars_ptr` must be a valid pointer to an array of C strings of length `vars_len`.
 */
rssn_
struct rssn_Expr *rssn_solve_diophantine_handle(const struct rssn_Expr *aEquation,
                                                const char *const *aVarsPtr,
                                                int aVarsLen)
;

/*
 Solves an exact ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_exact_ode(const struct rssn_Expr *aEquation,
                                       const char *aFunc,
                                       const char *aVar)
;

/*
 Solves a first-order linear ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_first_order_linear_ode(const struct rssn_Expr *aEquation,
                                                    const char *aFunc,
                                                    const char *aVar)
;

rssn_ struct rssn_Vec_Expr *rssn_solve_handle(const struct rssn_Expr *aExpr, const char *aVar) ;

/*
 Solves the 1D heat equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_heat_equation_1d(const struct rssn_Expr *aEquation,
                                              const char *aFunc,
                                              const char *const *aVars,
                                              size_t aVarsLen)
;

/*
 Solves the Helmholtz equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_helmholtz_equation(const struct rssn_Expr *aEquation,
                                                const char *aFunc,
                                                const char *const *aVars,
                                                size_t aVarsLen)
;

/*
 Solves the Klein-Gordon equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_klein_gordon_equation(const struct rssn_Expr *aEquation,
                                                   const char *aFunc,
                                                   const char *const *aVars,
                                                   size_t aVarsLen)
;

/*
 Solves the 2D Laplace equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_laplace_equation_2d(const struct rssn_Expr *aEquation,
                                                 const char *aFunc,
                                                 const char *const *aVars,
                                                 size_t aVarsLen)
;

rssn_
struct rssn_Vec_Expr *rssn_solve_linear_system_handle(const struct rssn_Expr *aSystem,
                                                      const struct rssn_Vec_String *aVars)
;

/*
 Solves an ordinary differential equation.

 # Safety
 The caller must ensure `ode_expr` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_ode(const struct rssn_Expr *aOdeExpr,
                                 const char *aFunc,
                                 const char *aVar)
;

/*
 Solves a partial differential equation using automatic method selection.

 # Safety
 The caller must ensure `pde_expr` is a valid Expr pointer, `func` and `vars` are valid C strings,
 and `vars_len` accurately represents the number of variables.
 */
rssn_
struct rssn_Expr *rssn_solve_pde(const struct rssn_Expr *aPdeExpr,
                                 const char *aFunc,
                                 const char *const *aVars,
                                 size_t aVarsLen)
;

/*
 Solves a PDE using the method of characteristics.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_pde_by_characteristics(const struct rssn_Expr *aEquation,
                                                    const char *aFunc,
                                                    const char *const *aVars,
                                                    size_t aVarsLen)
;

/*
 Solves the 2D Poisson equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_poisson_equation_2d(const struct rssn_Expr *aEquation,
                                                 const char *aFunc,
                                                 const char *const *aVars,
                                                 size_t aVarsLen)
;

/*
 Solves a Riccati ODE with a known particular solution.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_riccati_ode(const struct rssn_Expr *aEquation,
                                         const char *aFunc,
                                         const char *aVar,
                                         const struct rssn_Expr *aY1)
;

/*
 Solves the Schrödinger equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_schrodinger_equation(const struct rssn_Expr *aEquation,
                                                  const char *aFunc,
                                                  const char *const *aVars,
                                                  size_t aVarsLen)
;

/*
 Solves a separable ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_separable_ode(const struct rssn_Expr *aEquation,
                                           const char *aFunc,
                                           const char *aVar)
;

/*
 Solves the 1D wave equation using D'Alembert's formula.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_wave_equation_1d_dalembert(const struct rssn_Expr *aEquation,
                                                        const char *aFunc,
                                                        const char *const *aVars,
                                                        size_t aVarsLen)
;

/*
 Creates a square root expression: sqrt(expr).
 */
rssn_ struct rssn_Expr *rssn_sqrt(const struct rssn_Expr *aExpr) ;

/*
 Creates a square root expression from bincode: sqrt(expr).
 */
rssn_ struct rssn_BincodeBuffer rssn_sqrt_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a square root expression from JSON: sqrt(expr).
 */
rssn_ char *rssn_sqrt_json(const char *aJsonExpr) ;

/*
 Frees a State.
 */
rssn_ void rssn_state_free(struct rssn_State *aState) ;

/*
 Gets the intermediate value from the state.
 The returned string must be freed by the caller using rssn_free_string.
 */
rssn_ char *rssn_state_get_intermediate_value(const struct rssn_State *aState) ;

/*
 Gets the intermediate value from a bincode state buffer.
 Returns the value as a bincode buffer containing a String.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
struct rssn_BincodeBuffer rssn_state_get_intermediate_value_bincode(struct rssn_BincodeBuffer aStateBuffer)
;

/*
 Gets the intermediate value from a JSON state string.
 Returns the value as a plain string (not JSON-encoded).
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_state_get_intermediate_value_json(const char *aJsonState) ;

/*
 Creates a new State.
 The caller is responsible for freeing the memory using rssn_state_free.
 */
rssn_ struct rssn_State *rssn_state_new(void) ;

/*
 Creates a new State and returns it as a bincode buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_ struct rssn_BincodeBuffer rssn_state_new_bincode(void) ;

/*
 Creates a new State and returns it as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_state_new_json(void) ;

/*
 Sets the intermediate value in the state.
 */
rssn_ void rssn_state_set_intermediate_value(struct rssn_State *aState, const char *aValue) ;

/*
 Sets the intermediate value in a bincode state buffer and returns the updated buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
struct rssn_BincodeBuffer rssn_state_set_intermediate_value_bincode(struct rssn_BincodeBuffer aStateBuffer,
                                                                    struct rssn_BincodeBuffer aValueBuffer)
;

/*
 Sets the intermediate value in a JSON state string and returns the updated JSON.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_state_set_intermediate_value_json(const char *aJsonState, const char *aValue) ;

rssn_
int32_t rssn_stats_covariance(const double *aD1,
                              const double *aD2,
                              size_t aLen,
                              double *aResult)
;

rssn_ int32_t rssn_stats_mean(const double *aData, size_t aLen, double *aResult) ;

rssn_ int32_t rssn_stats_std_dev(const double *aData, size_t aLen, double *aResult) ;

rssn_ int32_t rssn_stats_variance(const double *aData, size_t aLen, double *aResult) ;

/*
 Computes the symbolic standard deviation of a set of expressions.

 # Safety
 The caller must ensure `data` is a valid pointer to an array of `Expr` pointers of size `len`.
 */
rssn_ struct rssn_Expr *rssn_std_dev(const struct rssn_Expr *const *aData, size_t aLen) ;

rssn_ struct rssn_Expr *rssn_stirling_number_second_kind(size_t aN, size_t aK) ;

/*
 Represents Stokes' theorem (Handle)
 */
rssn_
struct rssn_Expr *rssn_stokes_theorem_handle(const rssn_Vector *aVectorFieldPtr,
                                             const struct rssn_Expr *aSurfacePtr)
;

/*
 Generates the Sturm sequence for a given polynomial (Handle)
 */
rssn_
struct rssn_Vec_Expr *rssn_sturm_sequence_handle(const struct rssn_Expr *aExprPtr,
                                                 const char *aVarPtr)
;

rssn_ struct rssn_Expr **rssn_su2_generators(size_t *aOutLen) ;

/*
 Substitutes a variable with an expression.
 */
rssn_
struct rssn_Expr *rssn_substitute(const struct rssn_Expr *aExpr,
                                  const char *aVar,
                                  const struct rssn_Expr *aReplacement)
;

rssn_
struct rssn_Expr *rssn_summation_handle(const struct rssn_Expr *aExpr,
                                        const char *aVar,
                                        const struct rssn_Expr *aLower,
                                        const struct rssn_Expr *aUpper)
;

/*
 Computes the surface integral (flux) of a vector field.
 */
rssn_
char *rssn_surface_integral(const char *aFieldX,
                            const char *aFieldY,
                            const char *aFieldZ,
                            const struct rssn_ParametricSurface *aSurface)
;

/*
 Computes the surface integral (flux) of a vector field (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_surface_integral_bincode(const uint8_t *aInputPtr,
                                                        size_t aInputLen)
;

/*
 Computes the surface integral (flux) of a vector field (JSON).
 */
rssn_ char *rssn_surface_integral_json(const char *aInputJson) ;

/*
 Adds a term to a SymbolicChain
 */
rssn_
bool rssn_symbolic_chain_add_term(struct rssn_SymbolicChain *aChainPtr,
                                  const rssn_Simplex *aSimplexPtr,
                                  const struct rssn_Expr *aCoeffPtr)
;

/*
 Creates a new SymbolicChain (Handle)
 */
rssn_ struct rssn_SymbolicChain *rssn_symbolic_chain_create(size_t aDimension) ;

/*
 Frees a SymbolicChain handle
 */
rssn_ void rssn_symbolic_chain_free(struct rssn_SymbolicChain *aPtr) ;

rssn_ struct rssn_Group *rssn_symmetric_group_create(size_t aN) ;

/*
 Creates a tangent expression: tan(expr).
 */
rssn_ struct rssn_Expr *rssn_tan(const struct rssn_Expr *aExpr) ;

/*
 Creates a tangent expression from bincode: tan(expr).
 */
rssn_ struct rssn_BincodeBuffer rssn_tan_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a tangent expression from JSON: tan(expr).
 */
rssn_ char *rssn_tan_json(const char *aJsonExpr) ;

rssn_
struct rssn_Expr *rssn_taylor_series_handle(const struct rssn_Expr *aExpr,
                                            const char *aVar,
                                            const struct rssn_Expr *aCenter,
                                            size_t aOrder)
;

rssn_
struct rssn_Tensor *rssn_tensor_add_handle(const struct rssn_Tensor *aT1,
                                           const struct rssn_Tensor *aT2)
;

rssn_
struct rssn_Tensor *rssn_tensor_contract_handle(const struct rssn_Tensor *aT,
                                                size_t aAxis1,
                                                size_t aAxis2)
;

rssn_
struct rssn_Tensor *rssn_tensor_outer_product_handle(const struct rssn_Tensor *aT1,
                                                     const struct rssn_Tensor *aT2)
;

rssn_
struct rssn_Tensor *rssn_tensor_scalar_mul_handle(const struct rssn_Tensor *aT,
                                                  const struct rssn_Expr *aScalar)
;

/*
 Allocates and returns a test string ("pong") to the caller.

 This function serves as a more advanced health check for the FFI interface.
 It allows the client to verify two things:
 1. That the FFI function can be called successfully.
 2. That memory allocated in Rust can be safely passed to and then freed by the client
    by calling `free_string` on the returned pointer.

 Returns a pointer to a null-terminated C string. The caller is responsible for freeing this string.
 */
rssn_ char *rssn_test_string_passing(void) ;

/*
 Converts a logical expression to Conjunctive Normal Form (CNF) using handle-based FFI.

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_ struct rssn_Expr *rssn_to_cnf_handle(const struct rssn_Expr *aExpr) ;

/*
 Converts a logical expression to Disjunctive Normal Form (DNF) using handle-based FFI.

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_ struct rssn_Expr *rssn_to_dnf_handle(const struct rssn_Expr *aExpr) ;

rssn_
struct rssn_Vec_Expr *rssn_transform_contravariant_vector_handle(const struct rssn_Vec_Expr *aComps,
                                                                 enum rssn_CoordinateSystem aFrom,
                                                                 enum rssn_CoordinateSystem aTo)
;

rssn_
struct rssn_Vec_Expr *rssn_transform_covariant_vector_handle(const struct rssn_Vec_Expr *aComps,
                                                             enum rssn_CoordinateSystem aFrom,
                                                             enum rssn_CoordinateSystem aTo)
;

rssn_
struct rssn_Vec_Expr *rssn_transform_curl_handle(const struct rssn_Vec_Expr *aComps,
                                                 enum rssn_CoordinateSystem aFrom)
;

rssn_
struct rssn_Expr *rssn_transform_divergence_handle(const struct rssn_Vec_Expr *aComps,
                                                   enum rssn_CoordinateSystem aFrom)
;

rssn_
struct rssn_Expr *rssn_transform_expression_handle(const struct rssn_Expr *aExpr,
                                                   enum rssn_CoordinateSystem aFrom,
                                                   enum rssn_CoordinateSystem aTo)
;

rssn_
struct rssn_Vec_Expr *rssn_transform_gradient_handle(const struct rssn_Expr *aScalar,
                                                     const struct rssn_Vec_String *aVars,
                                                     enum rssn_CoordinateSystem aFrom,
                                                     enum rssn_CoordinateSystem aTo)
;

rssn_
struct rssn_Vec_Expr *rssn_transform_point_handle(const struct rssn_Vec_Expr *aPoint,
                                                  enum rssn_CoordinateSystem aFrom,
                                                  enum rssn_CoordinateSystem aTo)
;

rssn_
struct rssn_Expr *rssn_two_sample_t_test(const struct rssn_Expr *const *aData1,
                                         size_t aLen1,
                                         const struct rssn_Expr *const *aData2,
                                         size_t aLen2,
                                         const struct rssn_Expr *aMuDiff)
;

rssn_ struct rssn_Expr *rssn_unify_expression_handle(const struct rssn_Expr *aExpr) ;

/*
 Computes the symbolic variance of a set of expressions.

 # Safety
 The caller must ensure `data` is a valid pointer to an array of `Expr` pointers of size `len`.
 */
rssn_ struct rssn_Expr *rssn_variance(const struct rssn_Expr *const *aData, size_t aLen) ;

/*
 Computes the dot product of two vectors.
 */
rssn_
int32_t rssn_vec_dot_product(const double *aD1,
                             size_t aL1,
                             const double *aD2,
                             size_t aL2,
                             double *aResult)
;

/*
 Computes the L2 norm of a vector.
 */
rssn_ int32_t rssn_vec_norm(const double *aData, size_t aLen, double *aResult) ;

rssn_ rssn_Vector *rssn_vector_cross_handle(const rssn_Vector *aV1, const rssn_Vector *aV2) ;

rssn_ struct rssn_Expr *rssn_vector_dot_handle(const rssn_Vector *aV1, const rssn_Vector *aV2) ;

rssn_ struct rssn_Expr *rssn_vector_magnitude_handle(const rssn_Vector *aV) ;

rssn_ rssn_Vector *rssn_vector_normalize_handle(const rssn_Vector *aV) ;

/*
 Frees a Volterra integral equation.
 */
rssn_ void rssn_volterra_free(struct rssn_VolterraEquation *aPtr) ;

/*
 Creates a new Volterra integral equation.
 */
rssn_
struct rssn_VolterraEquation *rssn_volterra_new(const struct rssn_Expr *aYX,
                                                const struct rssn_Expr *aFX,
                                                const struct rssn_Expr *aLambda,
                                                const struct rssn_Expr *aKernel,
                                                const struct rssn_Expr *aLowerBound,
                                                const char *aVarX,
                                                const char *aVarT)
;

/*
 Solves a Volterra equation by differentiation.
 */
rssn_
struct rssn_Expr *rssn_volterra_solve_by_differentiation(const struct rssn_VolterraEquation *aEq)
;

/*
 Solves a Volterra equation by differentiation (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_volterra_solve_by_differentiation_bincode(const uint8_t *aInputPtr,
                                                                         size_t aInputLen)
;

/*
 Solves a Volterra equation by differentiation (JSON).
 */
rssn_ char *rssn_volterra_solve_by_differentiation_json(const char *aInputJson) ;

/*
 Solves a Volterra equation using successive approximations.
 */
rssn_
struct rssn_Expr *rssn_volterra_solve_successive(const struct rssn_VolterraEquation *aEq,
                                                 size_t aIterations)
;

/*
 Solves a Volterra equation using successive approximations (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_volterra_solve_successive_bincode(const uint8_t *aInputPtr,
                                                                 size_t aInputLen)
;

/*
 Solves a Volterra equation using successive approximations (JSON).
 */
rssn_ char *rssn_volterra_solve_successive_json(const char *aInputJson) ;

/*
 Frees a Volume handle.
 */
rssn_ void rssn_volume_free(struct rssn_Volume *aVolume) ;

/*
 Computes the volume integral of a scalar field.
 */
rssn_ char *rssn_volume_integral(const char *aScalarField, const struct rssn_Volume *aVolume) ;

/*
 Computes the volume integral of a scalar field (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_volume_integral_bincode(const uint8_t *aInputPtr,
                                                       size_t aInputLen)
;

/*
 Computes the volume integral of a scalar field (JSON).
 */
rssn_ char *rssn_volume_integral_json(const char *aInputJson) ;

/*
 Creates a new Volume.
 */
rssn_
struct rssn_Volume *rssn_volume_new(const char *aZLower,
                                    const char *aZUpper,
                                    const char *aYLower,
                                    const char *aYUpper,
                                    const char *aXLower,
                                    const char *aXUpper,
                                    const char *aXVar,
                                    const char *aYVar,
                                    const char *aZVar)
;

/*
 Computes the wedge product of two differential forms (Handle)
 */
rssn_
struct rssn_DifferentialForm *rssn_wedge_product_handle(const struct rssn_DifferentialForm *aForm1Ptr,
                                                        const struct rssn_DifferentialForm *aForm2Ptr)
;

rssn_
struct rssn_Expr *rssn_z_test(const struct rssn_Expr *const *aData,
                              size_t aLen,
                              const struct rssn_Expr *aTargetMean,
                              const struct rssn_Expr *aPopStdDev)
;

rssn_
struct rssn_Expr *rssn_z_transform(const struct rssn_Expr *aExpr,
                                   const char *aInVar,
                                   const char *aOutVar)
;

rssn_ struct rssn_Expr *rssn_zeta(const struct rssn_Expr *aArg) ;

rssn_ DEPRECATED_WITH_NOTE char *stats_percentile(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *stats_simple_linear_regression(const char *aJsonPtr) ;

/*
 Computes the Fast Fourier Transform (FFT) of a sequence of complex numbers.
 */
rssn_ DEPRECATED_WITH_NOTE char *transforms_fft(const char *aJsonPtr) ;

/*
 Computes the Inverse Fast Fourier Transform (IFFT) of a sequence of complex numbers.
 */
rssn_ DEPRECATED_WITH_NOTE char *transforms_ifft(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *vector_scalar_mul(const char *aJsonPtr) ;

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#ifdef __cplusplus
}  // namespace rssn
#endif  // __cplusplus

#endif  /* RSSN_H */
