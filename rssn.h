#ifndef RSSN_H
#define RSSN_H

/* Generated with cbindgen:0.29.2 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#ifdef __cplusplus
namespace rssn {
#endif  // __cplusplus

/*
 Represents the result of a convergence test.
 */
typedef enum rssn_ConvergenceResult {
    /*
     The series is determined to converge.
     */
    Converges,
    /*
     The series is determined to diverge.
     */
    Diverges,
    /*
     The convergence could not be determined with the available tests.
     */
    Inconclusive,
} rssn_ConvergenceResult;

/*
 Defines the monomial ordering to be used in polynomial division.
 */
typedef enum rssn_MonomialOrder {
    Lexicographical,
    GradedLexicographical,
    GradedReverseLexicographical,
} rssn_MonomialOrder;

typedef enum rssn_CoordinateSystem {
    Cartesian,
    Cylindrical,
    Spherical,
} rssn_CoordinateSystem;

/*
 A thread-safe cache for computation results.

 This cache stores the mapping from expressions to their computed values.
 It avoids re-computing the value of the same expression multiple times.
 */
typedef struct rssn_ComputationResultCache rssn_ComputationResultCache;

/*
 The central enum representing a mathematical expression in the symbolic system.

 `Expr` is an Abstract Syntax Tree (AST) that can represent a wide variety of
 mathematical objects and operations. Manual implementations for `Debug`, `Clone`,
 `PartialEq`, `Eq`, and `Hash` are provided to handle variants containing types
 that do not derive these traits automatically (e.g., `f64`, `Arc<dyn Distribution>`).
 */
typedef struct rssn_Expr rssn_Expr;

typedef struct rssn_FiniteFieldPolynomial rssn_FiniteFieldPolynomial;

/*
 Represents a Fredholm integral equation of the second kind.

 The equation has the form: `y(x) = f(x) + lambda * integral_a_b(K(x, t) * y(t) dt)`,
 where `y(x)` is the unknown function to be solved for.
 */
typedef struct rssn_FredholmEquation rssn_FredholmEquation;

/*
 Represents a multivector in a Clifford algebra.

 The basis blades are represented by a bitmask. E.g., in 3D:
 001 (1) -> e1, 010 (2) -> e2, 100 (4) -> e3
 011 (3) -> e12, 101 (5) -> e13, 110 (6) -> e23
 111 (7) -> e123 (pseudoscalar)
 */
typedef struct rssn_Multivector rssn_Multivector;

/*
 Represents a parameterized curve C given by r(t).
 */
typedef struct rssn_ParametricCurve rssn_ParametricCurve;

/*
 Represents a parameterized surface S given by r(u, v).
 */
typedef struct rssn_ParametricSurface rssn_ParametricSurface;

/*
 A thread-safe cache for parsed expressions.

 This cache stores the mapping from input strings to parsed `Expr` objects.
 It avoids re-parsing the same string multiple times.
 */
typedef struct rssn_ParsingCache rssn_ParsingCache;

/*
 Represents an element in a prime field GF(p), where p is the modulus.

 The value is stored as a `u64`, and all arithmetic operations are performed
 modulo the specified `modulus`.
 */
typedef struct rssn_PrimeFieldElement rssn_PrimeFieldElement;

/*
 Represents a rewrite rule, e.g., `lhs -> rhs`.
 */
typedef struct rssn_RewriteRule rssn_RewriteRule;

/*
 Represents the state of a computation.

 This struct holds intermediate values and other context information
 required during a computation.
 */
typedef struct rssn_State rssn_State;

typedef struct rssn_Tensor rssn_Tensor;

typedef struct rssn_Vec_Expr rssn_Vec_Expr;

typedef struct rssn_Vec_FiniteFieldPolynomial rssn_Vec_FiniteFieldPolynomial;

typedef struct rssn_Vec_RewriteRule rssn_Vec_RewriteRule;

typedef struct rssn_Vec_SparsePolynomial rssn_Vec_SparsePolynomial;

typedef struct rssn_Vec_String rssn_Vec_String;

/*
 Represents a symbolic vector in 3D space.
 */
typedef struct rssn_Vector rssn_Vector;

/*
 Represents a Volterra integral equation of the second kind.

 The equation has the form: `y(x) = f(x) + lambda * integral_a_x(K(x, t) * y(t) dt)`.
 It is similar to the Fredholm equation, but the upper limit of integration is the variable `x`.
 */
typedef struct rssn_VolterraEquation rssn_VolterraEquation;

/*
 Represents a volume V for triple integration.
 Defines the integration order as dz dy dx.
 */
typedef struct rssn_Volume rssn_Volume;

/*
 A buffer containing binary data from bincode serialization.

 The caller is responsible for freeing this buffer using `rssn_free_bincode_buffer`.
 */
typedef struct rssn_BincodeBuffer {
    /*
     Pointer to the binary data.
     */
    uint8_t *mData;
    /*
     Length of the binary data in bytes.
     */
    size_t mLen;
} rssn_BincodeBuffer;

typedef struct rssn_FfiPoint {
    double mX;
    double mY;
} rssn_FfiPoint;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/*
 Computes the definite integral of an `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_definite_integrate(struct rssn_Expr *aHandle,
                                          const char *aVarPtr,
                                          struct rssn_Expr *aLowerHandle,
                                          struct rssn_Expr *aUpperHandle)
;

/*
 Differentiates an `Expr` and returns a handle to the new, derivative expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_differentiate(struct rssn_Expr *aHandle,
                                     const char *aVarPtr)
;

/*
 Computes the indefinite integral of an `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_integrate(struct rssn_Expr *aHandle,
                                 const char *aVarPtr)
;

/*
 Computes the limit of an `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_limit(struct rssn_Expr *aHandle,
                             const char *aVarPtr,
                             struct rssn_Expr *aToHandle)
;

/*
 Simplifies an `Expr` and returns a handle to the new, simplified expression.

 The caller is responsible for freeing the returned handle using `expr_free`.
 */
rssn_ DEPRECATED_WITH_NOTE struct rssn_Expr *expr_simplify(struct rssn_Expr *aHandle) ;

/*
 Solves an equation for a given variable and returns the solutions as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *expr_solve(struct rssn_Expr *aHandle, const char *aVarPtr) ;

/*
 Substitutes a variable in an `Expr` with another `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_substitute(struct rssn_Expr *aHandle,
                                  const char *aVarPtr,
                                  struct rssn_Expr *aReplacementHandle)
;

/*
 Converts an expression to a LaTeX string.

 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_ char *expr_to_latex(struct rssn_Expr *aHandle) ;

/*
 Converts an expression to a formatted, pretty-printed string.

 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_ char *expr_to_pretty_string(struct rssn_Expr *aHandle) ;

/*
 Returns the string representation of an `Expr` handle.

 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_ char *expr_to_string(struct rssn_Expr *aHandle) ;

/*
 Attempts to unify the units within an expression.

 Returns a JSON string representing a `FfiResult` which contains either the
 new `Expr` object in the `ok` field or an error message in the `err` field.
 The caller can then use `expr_from_json` to get a handle to the new expression.
 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_ char *expr_unify_expression(struct rssn_Expr *aHandle) ;

/*
 Frees a C string that was allocated by this library.
 */
rssn_ void free_string(char *aS) ;

/*
 Evaluates a point on a BÃ©zier curve and returns the coordinates as a JSON string.
 */
rssn_ char *interpolate_bezier_curve(const char *aJsonPtr) ;

/*
 Computes a Lagrange interpolating polynomial and returns its coefficients as a JSON string.
 */
rssn_ char *interpolate_lagrange(const char *aJsonPtr) ;

/*
 Adds two matrices and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_add(struct rssn_Expr *aH1,
                             struct rssn_Expr *aH2)
;

/*
 Computes the characteristic polynomial of a matrix and returns the result as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_characteristic_polynomial(struct rssn_Expr *aHandle,
                                       const char *aVarPtr)
;

/*
 Computes the determinant of a matrix and returns a handle to the resulting expression.
 */
rssn_ DEPRECATED_WITH_NOTE struct rssn_Expr *matrix_determinant(struct rssn_Expr *aHandle) ;

/*
 Computes the eigenvalue decomposition of a matrix and returns the eigenvalues and eigenvectors as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_eigen_decomposition(struct rssn_Expr *aHandle)
;

/*
 Creates an identity matrix of a given size and returns a handle to it.
 */
rssn_ DEPRECATED_WITH_NOTE struct rssn_Expr *matrix_identity(size_t aSize) ;

/*
 Inverts a matrix and returns a handle to the new matrix expression.
 */
rssn_ DEPRECATED_WITH_NOTE struct rssn_Expr *matrix_inverse(struct rssn_Expr *aHandle) ;

/*
 Computes the LU decomposition of a matrix and returns the L and U matrices as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *matrix_lu_decomposition(struct rssn_Expr *aHandle) ;

/*
 Multiplies two matrices and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_mul(struct rssn_Expr *aH1,
                             struct rssn_Expr *aH2)
;

/*
 Computes the null space of a matrix and returns the result as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *matrix_null_space(struct rssn_Expr *aHandle) ;

/*
 Computes the Reduced Row Echelon Form (RREF) of a matrix and returns the result as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *matrix_rref(struct rssn_Expr *aHandle) ;

/*
 Multiplies a matrix by a scalar and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_scalar_mul(struct rssn_Expr *aScalarHandle,
                                    struct rssn_Expr *aMatrixHandle)
;

/*
 Subtracts the second matrix from the first and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_sub(struct rssn_Expr *aH1,
                             struct rssn_Expr *aH2)
;

/*
 Computes the trace of a matrix and returns the result as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *matrix_trace(struct rssn_Expr *aHandle) ;

/*
 Transposes a matrix and returns a handle to the new matrix expression.
 */
rssn_ DEPRECATED_WITH_NOTE struct rssn_Expr *matrix_transpose(struct rssn_Expr *aHandle) ;

rssn_ DEPRECATED_WITH_NOTE char *nt_mod_inverse(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *nt_mod_pow(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *numerical_gradient(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *numerical_integrate(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *physics_solve_advection_diffusion_1d(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE int64_t poly_degree(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE struct rssn_Expr *poly_from_coeffs_vec(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE bool poly_is_polynomial(const char *aJsonPtr) ;

rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *poly_leading_coefficient(struct rssn_Expr *aHandle,
                                           const char *aVarPtr)
;

rssn_ DEPRECATED_WITH_NOTE char *poly_long_division(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *poly_to_coeffs_vec(const char *aJsonPtr) ;

/*
 Checks if an expression contains a variable (handle-based)
 */
rssn_ bool polynomial_contains_var_handle(const struct rssn_Expr *aExprHandle, const char *aVar) ;

/*
 Computes the degree of a polynomial (handle-based)
 */
rssn_ int64_t polynomial_degree_handle(const struct rssn_Expr *aExprHandle, const char *aVar) ;

/*
 Frees an Expr handle
 */
rssn_ void polynomial_free_expr_handle(struct rssn_Expr *aExprHandle) ;

/*
 Checks if an expression is a polynomial in the given variable (handle-based)
 */
rssn_ bool polynomial_is_polynomial_handle(const struct rssn_Expr *aExprHandle, const char *aVar) ;

/*
 Finds the leading coefficient of a polynomial (handle-based)
 */
rssn_
struct rssn_Expr *polynomial_leading_coefficient_handle(const struct rssn_Expr *aExprHandle,
                                                        const char *aVar)
;

/*
 Performs polynomial long division (handle-based)
 */
rssn_
void polynomial_long_division_handle(const struct rssn_Expr *aDividendHandle,
                                     const struct rssn_Expr *aDivisorHandle,
                                     const char *aVar,
                                     struct rssn_Expr **aQuotientOut,
                                     struct rssn_Expr **aRemainderOut)
;

/*
 Computes absolute value (magnitude) of complex number (Handle)
 */
rssn_ struct rssn_Expr *rssn_abs_handle(const struct rssn_Expr *aZ) ;

rssn_
struct rssn_Expr *rssn_analytic_continuation_handle(const struct rssn_Expr *aExpr,
                                                    const char *aVar,
                                                    const struct rssn_Expr *aOrigCenter,
                                                    const struct rssn_Expr *aNewCenter,
                                                    size_t aOrder)
;

rssn_
enum rssn_ConvergenceResult rssn_analyze_convergence_handle(const struct rssn_Expr *aTerm,
                                                            const char *aVar)
;

/*
 Applies a set of rewrite rules to an expression until a normal form is reached.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `rules` is a valid array.
 */
rssn_
struct rssn_Expr *rssn_apply_rules_to_normal_form(const struct rssn_Expr *aExpr,
                                                  const struct rssn_RewriteRule *const *aRules,
                                                  size_t aRulesLen)
;

/*
 Applies rewrite rules to an expression (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_apply_rules_to_normal_form_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Applies rewrite rules to an expression (JSON).

 Input: JSON object with "expr" and "rules" fields
 Output: JSON-serialized Expr (the normal form)
 */
rssn_ char *rssn_apply_rules_to_normal_form_json(const char *aJsonStr) ;

/*
 Computes argument (angle) of complex number (Handle)
 */
rssn_ struct rssn_Expr *rssn_arg_handle(const struct rssn_Expr *aZ) ;

rssn_
struct rssn_Expr *rssn_asymptotic_expansion_handle(const struct rssn_Expr *aExpr,
                                                   const char *aVar,
                                                   const struct rssn_Expr *aPoint,
                                                   size_t aOrder)
;

/*
 Computes absolute value (magnitude) of complex number (Bincode)
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_abs(struct rssn_BincodeBuffer aZBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_analytic_continuation(struct rssn_BincodeBuffer aExprBuf,
                                                             struct rssn_BincodeBuffer aVarBuf,
                                                             struct rssn_BincodeBuffer aOrigCenterBuf,
                                                             struct rssn_BincodeBuffer aNewCenterBuf,
                                                             struct rssn_BincodeBuffer aOrderBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_analyze_convergence(struct rssn_BincodeBuffer aTermBuf,
                                                           struct rssn_BincodeBuffer aVarBuf)
;

/*
 Computes argument (angle) of complex number (Bincode)
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_arg(struct rssn_BincodeBuffer aZBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_asymptotic_expansion(struct rssn_BincodeBuffer aExprBuf,
                                                            struct rssn_BincodeBuffer aVarBuf,
                                                            struct rssn_BincodeBuffer aPointBuf,
                                                            struct rssn_BincodeBuffer aOrderBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_buchberger(struct rssn_BincodeBuffer aBasisBuf,
                                                  struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Calculates residue using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_calculate_residue(struct rssn_BincodeBuffer aExprBuf,
                                                         const char *aVar,
                                                         struct rssn_BincodeBuffer aPoleBuf)
;

/*
 Checks analytic using Bincode.
 */
rssn_ bool rssn_bincode_check_analytic(struct rssn_BincodeBuffer aExprBuf, const char *aVar) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_chinese_remainder(struct rssn_BincodeBuffer aCongruencesBuf)
;

/*
 Classifies a PDE (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_classify_pde(struct rssn_BincodeBuffer aEquationBuf,
                                                    const char *aFunc,
                                                    struct rssn_BincodeBuffer aVarsBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_coordinates_get_metric_tensor(struct rssn_BincodeBuffer aSystemBuf)
;

/*
 Computes definite integral using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_definite_integrate(struct rssn_BincodeBuffer aExprBuf,
                                                          const char *aVar,
                                                          struct rssn_BincodeBuffer aLowerBuf,
                                                          struct rssn_BincodeBuffer aUpperBuf)
;

/*
 Denests a nested square root (Bincode)
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_denest_sqrt(struct rssn_BincodeBuffer aExprBuf) ;

/*
 Differentiates an expression using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_differentiate(struct rssn_BincodeBuffer aExprBuf,
                                                     const char *aVar)
;

/*
 Evaluates at point using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_evaluate_at_point(struct rssn_BincodeBuffer aExprBuf,
                                                         const char *aVar,
                                                         struct rssn_BincodeBuffer aValueBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_evaluate_numerical(struct rssn_BincodeBuffer aExprBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_extended_gcd(struct rssn_BincodeBuffer aABuf,
                                                    struct rssn_BincodeBuffer aBBuf)
;

/*
 Factors a polynomial over a finite field (Bincode)
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_factor_gf(struct rssn_BincodeBuffer aPolyBuf) ;

/*
 Finds pole order using Bincode.
 */
rssn_
size_t rssn_bincode_find_pole_order(struct rssn_BincodeBuffer aExprBuf,
                                    const char *aVar,
                                    struct rssn_BincodeBuffer aPoleBuf)
;

/*
 Finds poles using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_find_poles(struct rssn_BincodeBuffer aExprBuf,
                                                  const char *aVar)
;

/*
 Gets the degree of a finite field polynomial (Bincode)
 */
rssn_ int64_t rssn_bincode_finite_field_polynomial_degree(struct rssn_BincodeBuffer aPolyBuf) ;

/*
 Performs polynomial long division (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_finite_field_polynomial_long_division(struct rssn_BincodeBuffer aDividendBuf,
                                                                             struct rssn_BincodeBuffer aDivisorBuf)
;

/*
 Creates a new finite field polynomial (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_finite_field_polynomial_new(struct rssn_BincodeBuffer aCoeffsBuf,
                                                                   struct rssn_BincodeBuffer aModulusBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_fourier_series(struct rssn_BincodeBuffer aExprBuf,
                                                      struct rssn_BincodeBuffer aVarBuf,
                                                      struct rssn_BincodeBuffer aPeriodBuf,
                                                      struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Computes general multi-valued arccos (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_arccos(struct rssn_BincodeBuffer aZBuf,
                                                      struct rssn_BincodeBuffer aKBuf,
                                                      struct rssn_BincodeBuffer aSBuf)
;

/*
 Computes general multi-valued arcsin (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_arcsin(struct rssn_BincodeBuffer aZBuf,
                                                      struct rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued arctan (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_arctan(struct rssn_BincodeBuffer aZBuf,
                                                      struct rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued logarithm (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_log(struct rssn_BincodeBuffer aZBuf,
                                                   struct rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued n-th root (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_nth_root(struct rssn_BincodeBuffer aZBuf,
                                                        struct rssn_BincodeBuffer aNBuf,
                                                        struct rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued power (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_power(struct rssn_BincodeBuffer aZBuf,
                                                     struct rssn_BincodeBuffer aWBuf,
                                                     struct rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued square root (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_general_sqrt(struct rssn_BincodeBuffer aZBuf,
                                                    struct rssn_BincodeBuffer aKBuf)
;

/*
 Gets real and imaginary parts using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_get_real_imag_parts(struct rssn_BincodeBuffer aExprBuf)
;

/*
 Simplifies an expression using the heuristic simplifier (Bincode input/output).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_heuristic_simplify(struct rssn_BincodeBuffer aExprBuf)
;

/*
 Integrates an expression using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_integrate(struct rssn_BincodeBuffer aExprBuf,
                                                 const char *aVar)
;

/*
 Integrates a rational function (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_integrate_rational_function(struct rssn_BincodeBuffer aExprBuf,
                                                                   struct rssn_BincodeBuffer aXBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_is_prime(struct rssn_BincodeBuffer aNBuf) ;

/*
 Checks if a logical expression is satisfiable using bincode-based FFI.

 Returns a bincode buffer containing:
 - `Some(true)` if satisfiable
 - `Some(false)` if unsatisfiable
 - `None` if the expression contains quantifiers (undecidable)
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_is_satisfiable(struct rssn_BincodeBuffer aExprBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_laurent_series(struct rssn_BincodeBuffer aExprBuf,
                                                      struct rssn_BincodeBuffer aVarBuf,
                                                      struct rssn_BincodeBuffer aCenterBuf,
                                                      struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Computes limit using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_limit(struct rssn_BincodeBuffer aExprBuf,
                                             const char *aVar,
                                             struct rssn_BincodeBuffer aPointBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_add(struct rssn_BincodeBuffer aM1Buf,
                                                  struct rssn_BincodeBuffer aM2Buf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_determinant(struct rssn_BincodeBuffer aMatrixBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_matrix_inverse(struct rssn_BincodeBuffer aMatrixBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_mul(struct rssn_BincodeBuffer aM1Buf,
                                                  struct rssn_BincodeBuffer aM2Buf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_solve_linear_system(struct rssn_BincodeBuffer aABuf,
                                                                  struct rssn_BincodeBuffer aBBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_transpose(struct rssn_BincodeBuffer aMatrixBuf)
;

/*
 Computes geometric product (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_geometric_product(struct rssn_BincodeBuffer aABuf,
                                                                     struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes grade projection (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_grade_projection(struct rssn_BincodeBuffer aMvBuf,
                                                                    uint32_t aGrade)
;

/*
 Computes inner product (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_inner_product(struct rssn_BincodeBuffer aABuf,
                                                                 struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes magnitude (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_magnitude(struct rssn_BincodeBuffer aMvBuf)
;

/*
 Computes outer product (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_outer_product(struct rssn_BincodeBuffer aABuf,
                                                                 struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes reverse (Bincode)
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_multivector_reverse(struct rssn_BincodeBuffer aMvBuf) ;

/*
 Creates a new scalar multivector (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_multivector_scalar(uint32_t aP,
                                                          uint32_t aQ,
                                                          uint32_t aR,
                                                          struct rssn_BincodeBuffer aValueBuf)
;

/*
 Computes path integral using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_path_integrate(struct rssn_BincodeBuffer aExprBuf,
                                                      const char *aVar,
                                                      struct rssn_BincodeBuffer aContourBuf)
;

/*
 Computes polynomial derivative over finite field (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_derivative_gf(struct rssn_BincodeBuffer aPolyBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_division_multivariate(struct rssn_BincodeBuffer aDividendBuf,
                                                                  struct rssn_BincodeBuffer aDivisorsBuf,
                                                                  struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Computes polynomial GCD over finite field (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_gcd_gf(struct rssn_BincodeBuffer aABuf,
                                                   struct rssn_BincodeBuffer aBBuf)
;

/*
 Checks if an expression contains a variable (bincode)
 */
rssn_
bool rssn_bincode_polynomial_contains_var(struct rssn_BincodeBuffer aExprBuf,
                                          const char *aVar)
;

/*
 Computes the degree of a polynomial (bincode)
 */
rssn_ int64_t rssn_bincode_polynomial_degree(struct rssn_BincodeBuffer aExprBuf, const char *aVar) ;

/*
 Checks if an expression is a polynomial in the given variable (bincode)
 */
rssn_
bool rssn_bincode_polynomial_is_polynomial(struct rssn_BincodeBuffer aExprBuf,
                                           const char *aVar)
;

/*
 Finds the leading coefficient of a polynomial (bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_polynomial_leading_coefficient(struct rssn_BincodeBuffer aExprBuf,
                                                                      const char *aVar)
;

/*
 Performs polynomial long division (bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_polynomial_long_division(struct rssn_BincodeBuffer aDividendBuf,
                                                                struct rssn_BincodeBuffer aDivisorBuf,
                                                                const char *aVar)
;

/*
 Converts polynomial to coefficient vector (bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_polynomial_to_coeffs_vec(struct rssn_BincodeBuffer aExprBuf,
                                                                const char *aVar)
;

/*
 Adds two prime field elements (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_prime_field_element_add(struct rssn_BincodeBuffer aABuf,
                                                               struct rssn_BincodeBuffer aBBuf)
;

/*
 Divides two prime field elements (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_prime_field_element_div(struct rssn_BincodeBuffer aABuf,
                                                               struct rssn_BincodeBuffer aBBuf)
;

/*
 Computes the inverse of a prime field element (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_prime_field_element_inverse(struct rssn_BincodeBuffer aElemBuf)
;

/*
 Multiplies two prime field elements (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_prime_field_element_mul(struct rssn_BincodeBuffer aABuf,
                                                               struct rssn_BincodeBuffer aBBuf)
;

/*
 Creates a new prime field element (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_prime_field_element_new(struct rssn_BincodeBuffer aValueBuf,
                                                               struct rssn_BincodeBuffer aModulusBuf)
;

/*
 Subtracts two prime field elements (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_prime_field_element_sub(struct rssn_BincodeBuffer aABuf,
                                                               struct rssn_BincodeBuffer aBBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_product(struct rssn_BincodeBuffer aExprBuf,
                                               struct rssn_BincodeBuffer aVarBuf,
                                               struct rssn_BincodeBuffer aLowerBuf,
                                               struct rssn_BincodeBuffer aUpperBuf)
;

/*
 Integrates an expression using the Risch-Norman algorithm (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_risch_norman_integrate(struct rssn_BincodeBuffer aExprBuf,
                                                              struct rssn_BincodeBuffer aXBuf)
;

/*
 Simplifies an expression using the legacy simplifier (Bincode input/output).
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_simplify(struct rssn_BincodeBuffer aExprBuf) ;

/*
 Simplifies an expression using the DAG-based simplifier (Bincode input/output).
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_simplify_dag(struct rssn_BincodeBuffer aExprBuf) ;

/*
 Simplifies a logical expression using bincode-based FFI.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_simplify_logic(struct rssn_BincodeBuffer aExprBuf) ;

/*
 Simplifies radical expressions (Bincode)
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_simplify_radicals(struct rssn_BincodeBuffer aExprBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_solve(struct rssn_BincodeBuffer aExprBuf,
                                             struct rssn_BincodeBuffer aVarBuf)
;

/*
 Solves a Bernoulli ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_bernoulli_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                           const char *aFunc,
                                                           const char *aVar)
;

/*
 Solves by reduction of order using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_by_reduction_of_order(struct rssn_BincodeBuffer aEquationBuf,
                                                                   const char *aFunc,
                                                                   const char *aVar,
                                                                   struct rssn_BincodeBuffer aY1Buf)
;

/*
 Solves a Cauchy-Euler ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_cauchy_euler_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                              const char *aFunc,
                                                              const char *aVar)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_diophantine(struct rssn_BincodeBuffer aEquationBuf,
                                                         struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves an exact ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_exact_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                       const char *aFunc,
                                                       const char *aVar)
;

/*
 Solves a first-order linear ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_first_order_linear_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                                    const char *aFunc,
                                                                    const char *aVar)
;

/*
 Solves the 1D heat equation (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_heat_equation_1d(struct rssn_BincodeBuffer aEquationBuf,
                                                              const char *aFunc,
                                                              struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves the 2D Laplace equation (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_laplace_equation_2d(struct rssn_BincodeBuffer aEquationBuf,
                                                                 const char *aFunc,
                                                                 struct rssn_BincodeBuffer aVarsBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_linear_system(struct rssn_BincodeBuffer aSystemBuf,
                                                           struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves an ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_ode(struct rssn_BincodeBuffer aOdeBuf,
                                                 const char *aFunc,
                                                 const char *aVar)
;

/*
 Solves a PDE using Bincode with automatic method selection.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_pde(struct rssn_BincodeBuffer aPdeBuf,
                                                 const char *aFunc,
                                                 struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves a PDE using the method of characteristics (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_pde_by_characteristics(struct rssn_BincodeBuffer aEquationBuf,
                                                                    const char *aFunc,
                                                                    struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves a Riccati ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_riccati_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                         const char *aFunc,
                                                         const char *aVar,
                                                         struct rssn_BincodeBuffer aY1Buf)
;

/*
 Solves a separable ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_separable_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                           const char *aFunc,
                                                           const char *aVar)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_system(struct rssn_BincodeBuffer aEquationsBuf,
                                                    struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves the 1D wave equation (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_wave_equation_1d(struct rssn_BincodeBuffer aEquationBuf,
                                                              const char *aFunc,
                                                              struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Computes square-free factorization (Bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_square_free_factorization_gf(struct rssn_BincodeBuffer aPolyBuf)
;

/*
 Substitutes using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_substitute(struct rssn_BincodeBuffer aExprBuf,
                                                  const char *aVar,
                                                  struct rssn_BincodeBuffer aReplacementBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_summation(struct rssn_BincodeBuffer aExprBuf,
                                                 struct rssn_BincodeBuffer aVarBuf,
                                                 struct rssn_BincodeBuffer aLowerBuf,
                                                 struct rssn_BincodeBuffer aUpperBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_taylor_series(struct rssn_BincodeBuffer aExprBuf,
                                                     struct rssn_BincodeBuffer aVarBuf,
                                                     struct rssn_BincodeBuffer aCenterBuf,
                                                     struct rssn_BincodeBuffer aOrderBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_tensor_add(struct rssn_BincodeBuffer aT1Buf,
                                                  struct rssn_BincodeBuffer aT2Buf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_tensor_outer_product(struct rssn_BincodeBuffer aT1Buf,
                                                            struct rssn_BincodeBuffer aT2Buf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_tensor_scalar_mul(struct rssn_BincodeBuffer aTBuf,
                                                         struct rssn_BincodeBuffer aScalarBuf)
;

/*
 Converts a logical expression to Conjunctive Normal Form (CNF) using bincode-based FFI.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_to_cnf(struct rssn_BincodeBuffer aExprBuf) ;

/*
 Converts a logical expression to Disjunctive Normal Form (DNF) using bincode-based FFI.
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_to_dnf(struct rssn_BincodeBuffer aExprBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_contravariant_vector(struct rssn_BincodeBuffer aCompsBuf,
                                                                      struct rssn_BincodeBuffer aFromBuf,
                                                                      struct rssn_BincodeBuffer aToBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_covariant_vector(struct rssn_BincodeBuffer aCompsBuf,
                                                                  struct rssn_BincodeBuffer aFromBuf,
                                                                  struct rssn_BincodeBuffer aToBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_curl(struct rssn_BincodeBuffer aCompsBuf,
                                                      struct rssn_BincodeBuffer aFromBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_divergence(struct rssn_BincodeBuffer aCompsBuf,
                                                            struct rssn_BincodeBuffer aFromBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_expression(struct rssn_BincodeBuffer aExprBuf,
                                                            struct rssn_BincodeBuffer aFromBuf,
                                                            struct rssn_BincodeBuffer aToBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_gradient(struct rssn_BincodeBuffer aScalarBuf,
                                                          struct rssn_BincodeBuffer aVarsBuf,
                                                          struct rssn_BincodeBuffer aFromBuf,
                                                          struct rssn_BincodeBuffer aToBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_point(struct rssn_BincodeBuffer aPointBuf,
                                                       struct rssn_BincodeBuffer aFromBuf,
                                                       struct rssn_BincodeBuffer aToBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_unify_expression(struct rssn_BincodeBuffer aExprBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_vector_cross(struct rssn_BincodeBuffer aV1Buf,
                                                    struct rssn_BincodeBuffer aV2Buf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_vector_dot(struct rssn_BincodeBuffer aV1Buf,
                                                  struct rssn_BincodeBuffer aV2Buf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_vector_magnitude(struct rssn_BincodeBuffer aVBuf) ;

rssn_ struct rssn_BincodeBuffer rssn_bincode_vector_normalize(struct rssn_BincodeBuffer aVBuf) ;

/*
 Computes binomial coefficient C(n, k).
 */
rssn_ char *rssn_binomial_coefficient(size_t aN, size_t aK) ;

/*
 Computes binomial coefficient C(n, k) and returns as JSON string.
 */
rssn_ char *rssn_binomial_coefficient_json(size_t aN, size_t aK) ;

rssn_
struct rssn_Vec_SparsePolynomial *rssn_buchberger_handle(const struct rssn_Vec_SparsePolynomial *aBasis,
                                                         enum rssn_MonomialOrder aOrder)
;

/*
 Calculates the residue of a complex function at a given pole.
 */
rssn_
struct rssn_Expr *rssn_calculate_residue(const struct rssn_Expr *aExpr,
                                         const char *aVar,
                                         const struct rssn_Expr *aPole)
;

rssn_
int32_t rssn_calculus_definite_integrate(size_t aExprH,
                                         const char *aVar,
                                         size_t aLowerH,
                                         size_t aUpperH,
                                         size_t *aResultH)
;

rssn_ int32_t rssn_calculus_differentiate(size_t aExprH, const char *aVar, size_t *aResultH) ;

rssn_ int32_t rssn_calculus_integrate(size_t aExprH, const char *aVar, size_t *aResultH) ;

rssn_ int32_t rssn_calculus_limit(size_t aExprH, const char *aVar, size_t aToH, size_t *aResultH) ;

rssn_
int32_t rssn_calculus_substitute(size_t aExprH,
                                 const char *aVar,
                                 size_t aReplacementH,
                                 size_t *aResultH)
;

/*
 Expands an expression using algebraic rules.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_cas_expand(const struct rssn_Expr *aExpr) ;

/*
 Expands an expression using algebraic rules (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_cas_expand_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Expands an expression using algebraic rules (JSON).
 */
rssn_ char *rssn_cas_expand_json(const char *aJsonStr) ;

/*
 Factorizes an expression.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_cas_factorize(const struct rssn_Expr *aExpr) ;

/*
 Factorizes an expression (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_cas_factorize_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Factorizes an expression (JSON).
 */
rssn_ char *rssn_cas_factorize_json(const char *aJsonStr) ;

/*
 Normalizes an expression to a canonical form.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_cas_normalize(const struct rssn_Expr *aExpr) ;

/*
 Normalizes an expression to a canonical form (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_cas_normalize_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Normalizes an expression to a canonical form (JSON).
 */
rssn_ char *rssn_cas_normalize_json(const char *aJsonStr) ;

/*
 Simplifies an expression using a set of polynomial side-relations.

 # Arguments
 * `expr` - The expression to simplify.
 * `relations` - Array of pointers to relation expressions (e.g., `x^2 + y^2 - 1`).
 * `relations_len` - Number of relations.
 * `vars` - Array of C strings representing variable ordering.
 * `vars_len` - Number of variables.
 * `order_int` - Monomial ordering: 0=Lex, 1=GradedLex, 2=GradedReverseLex.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_cas_simplify_with_relations(const struct rssn_Expr *aExpr,
                                                   const struct rssn_Expr *const *aRelations,
                                                   size_t aRelationsLen,
                                                   const char *const *aVars,
                                                   size_t aVarsLen,
                                                   int32_t aOrderInt)
;

/*
 Simplifies an expression using a set of polynomial side-relations (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_cas_simplify_with_relations_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Simplifies an expression using a set of polynomial side-relations (JSON).
 */
rssn_ char *rssn_cas_simplify_with_relations_json(const char *aJsonStr) ;

/*
 Checks if an expression is analytic with respect to a variable.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `var` is a valid C string.
 */
rssn_ bool rssn_check_analytic(const struct rssn_Expr *aExpr, const char *aVar) ;

/*
 Solves a system of congruences using the Chinese Remainder Theorem.

 # Safety
 `remainders` and `moduli` must be valid pointers to arrays of `Expr` pointers of length `len`.
 */
rssn_
struct rssn_Expr *rssn_chinese_remainder_handle(const struct rssn_Expr *const *aRemainders,
                                                const struct rssn_Expr *const *aModuli,
                                                int aLen)
;

/*
 Computes the number of combinations (nCk).
 */
rssn_ int32_t rssn_comb_combinations(uint64_t aN, uint64_t aK, double *aResult) ;

/*
 Computes the factorial of a number.
 */
rssn_ int32_t rssn_comb_factorial(uint64_t aN, double *aResult) ;

/*
 Computes the number of permutations (nPk).
 */
rssn_ int32_t rssn_comb_permutations(uint64_t aN, uint64_t aK, double *aResult) ;

/*
 Clears a ComputationResultCache.
 */
rssn_ void rssn_computation_result_cache_clear(struct rssn_ComputationResultCache *aCache) ;

/*
 Frees a ComputationResultCache.
 */
rssn_ void rssn_computation_result_cache_free(struct rssn_ComputationResultCache *aCache) ;

/*
 Retrieves a value from the ComputationResultCache.
 Returns a C string (char*) which must be freed by the caller using rssn_free_string.
 Returns null if not found.
 */
rssn_
char *rssn_computation_result_cache_get(struct rssn_ComputationResultCache *aCache,
                                        const struct rssn_Expr *aExpr)
;

/*
 Retrieves a value from the ComputationResultCache using a bincode expression key.
 */
rssn_
struct rssn_BincodeBuffer rssn_computation_result_cache_get_bincode(struct rssn_ComputationResultCache *aCache,
                                                                    struct rssn_BincodeBuffer aExprBuffer)
;

/*
 Retrieves a value from the ComputationResultCache using a JSON expression key.
 Returns the value as a JSON string (e.g. "\"result\"").
 */
rssn_
char *rssn_computation_result_cache_get_json(struct rssn_ComputationResultCache *aCache,
                                             const char *aJsonExpr)
;

/*
 Creates a new ComputationResultCache.
 The caller is responsible for freeing the memory using rssn_computation_result_cache_free.
 */
rssn_ struct rssn_ComputationResultCache *rssn_computation_result_cache_new(void) ;

/*
 Stores a value in the ComputationResultCache.
 */
rssn_
void rssn_computation_result_cache_set(struct rssn_ComputationResultCache *aCache,
                                       const struct rssn_Expr *aExpr,
                                       const char *aValue)
;

/*
 Stores a value in the ComputationResultCache using bincode buffers.
 */
rssn_
void rssn_computation_result_cache_set_bincode(struct rssn_ComputationResultCache *aCache,
                                               struct rssn_BincodeBuffer aExprBuffer,
                                               struct rssn_BincodeBuffer aValueBuffer)
;

/*
 Stores a value in the ComputationResultCache using JSON strings.
 */
rssn_
void rssn_computation_result_cache_set_json(struct rssn_ComputationResultCache *aCache,
                                            const char *aJsonExpr,
                                            const char *aJsonValue)
;

rssn_
struct rssn_Expr *rssn_coordinates_get_metric_tensor_handle(enum rssn_CoordinateSystem aSystem)
;

/*
 Creates a cosine expression: cos(expr).
 */
rssn_ struct rssn_Expr *rssn_cos(const struct rssn_Expr *aExpr) ;

/*
 Creates a cosine expression from bincode: cos(expr).
 */
rssn_ struct rssn_BincodeBuffer rssn_cos_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a cosine expression from JSON: cos(expr).
 */
rssn_ char *rssn_cos_json(const char *aJsonExpr) ;

/*
 Computes the definite integral of an expression.
 */
rssn_
struct rssn_Expr *rssn_definite_integrate(const struct rssn_Expr *aExpr,
                                          const char *aVar,
                                          const struct rssn_Expr *aLower,
                                          const struct rssn_Expr *aUpper)
;

/*
 Denests a nested square root (Handle)
 */
rssn_ struct rssn_Expr *rssn_denest_sqrt_handle(const struct rssn_Expr *aExpr) ;

/*
 Differentiates an expression: d/d(var) expr.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `var` is a valid C string.
 */
rssn_ struct rssn_Expr *rssn_differentiate(const struct rssn_Expr *aExpr, const char *aVar) ;

/*
 Returns the symbolic representation of Euler's number (e).
 */
rssn_ struct rssn_Expr *rssn_e(void) ;

/*
 Returns Euler's number (e) as bincode.
 */
rssn_ struct rssn_BincodeBuffer rssn_e_bincode(void) ;

/*
 Returns Euler's number (e) as JSON.
 */
rssn_ char *rssn_e_json(void) ;

/*
 Evaluates an expression at a given point.
 */
rssn_
struct rssn_Expr *rssn_evaluate_at_point(const struct rssn_Expr *aExpr,
                                         const char *aVar,
                                         const struct rssn_Expr *aValue)
;

rssn_ double rssn_evaluate_numerical_handle(const struct rssn_Expr *aExpr) ;

/*
 Creates an exponential expression: e^(expr).
 */
rssn_ struct rssn_Expr *rssn_exp(const struct rssn_Expr *aExpr) ;

/*
 Creates an exponential expression from bincode: e^(expr).
 */
rssn_ struct rssn_BincodeBuffer rssn_exp_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates an exponential expression from JSON: e^(expr).
 */
rssn_ char *rssn_exp_json(const char *aJsonExpr) ;

/*
 Expands a symbolic expression.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_expand(const struct rssn_Expr *aExpr) ;

/*
 Expands a symbolic expression from bincode.
 */
rssn_ struct rssn_BincodeBuffer rssn_expand_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Expands a symbolic expression from JSON.
 */
rssn_ char *rssn_expand_json(const char *aJsonExpr) ;

/*
 Creates an expression from a JSON string and returns a thread-safe handle.

 Returns 0 if the JSON is invalid.
 */
rssn_ size_t rssn_expr_create(const char *aJsonPtr) ;

/*
 Frees the memory associated with an expression handle.
 */
rssn_ void rssn_expr_free(size_t aHandle) ;

/*
 Simplifies an expression handle and returns a handle to the new, simplified expression.

 Returns 0 on error (e.g., invalid handle).
 */
rssn_ size_t rssn_expr_simplify(const size_t *aHandle) ;

/*
 Computes the Extended GCD of two expressions.

 # Safety
 `a` and `b` must be valid pointers to `Expr`.
 */
rssn_
struct rssn_Expr *rssn_extended_gcd_handle(const struct rssn_Expr *aA,
                                           const struct rssn_Expr *aB)
;

/*
 Factors a polynomial over a finite field (Handle)
 */
rssn_
struct rssn_Vec_FiniteFieldPolynomial *rssn_factor_gf_handle(const struct rssn_FiniteFieldPolynomial *aPoly)
;

/*
 Computes the Fast Fourier Transform (FFT) of a sequence of complex numbers in-place.
 */
rssn_ int32_t rssn_fft(rssn_Complex<double> *aData, size_t aLen) ;

/*
 Finds the order of a pole.
 */
rssn_
size_t rssn_find_pole_order(const struct rssn_Expr *aExpr,
                            const char *aVar,
                            const struct rssn_Expr *aPole)
;

/*
 Finds poles of an expression.
 */
rssn_ struct rssn_Vec_Expr *rssn_find_poles(const struct rssn_Expr *aExpr, const char *aVar) ;

rssn_
struct rssn_Expr *rssn_fourier_series_handle(const struct rssn_Expr *aExpr,
                                             const char *aVar,
                                             const struct rssn_Expr *aPeriod,
                                             size_t aOrder)
;

/*
 Frees a Fredholm integral equation.
 */
rssn_ void rssn_fredholm_free(struct rssn_FredholmEquation *aPtr) ;

/*
 Creates a new Fredholm integral equation.
 */
rssn_
struct rssn_FredholmEquation *rssn_fredholm_new(const struct rssn_Expr *aYX,
                                                const struct rssn_Expr *aFX,
                                                const struct rssn_Expr *aLambda,
                                                const struct rssn_Expr *aKernel,
                                                const struct rssn_Expr *aLowerBound,
                                                const struct rssn_Expr *aUpperBound,
                                                const char *aVarX,
                                                const char *aVarT)
;

/*
 Solves a Fredholm equation using the Neumann series method.
 */
rssn_
struct rssn_Expr *rssn_fredholm_solve_neumann(const struct rssn_FredholmEquation *aEq,
                                              size_t aIterations)
;

/*
 Solves a Fredholm equation using the Neumann series method (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_fredholm_solve_neumann_bincode(const uint8_t *aInputPtr,
                                                              size_t aInputLen)
;

/*
 Solves a Fredholm equation using the Neumann series method (JSON).
 */
rssn_ char *rssn_fredholm_solve_neumann_json(const char *aInputJson) ;

/*
 Solves a Fredholm equation with a separable kernel.
 */
rssn_
struct rssn_Expr *rssn_fredholm_solve_separable(const struct rssn_FredholmEquation *aEq,
                                                const struct rssn_Expr *const *aAFuncs,
                                                size_t aALen,
                                                const struct rssn_Expr *const *aBFuncs,
                                                size_t aBLen)
;

/*
 Solves a Fredholm equation with a separable kernel (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_fredholm_solve_separable_bincode(const uint8_t *aInputPtr,
                                                                size_t aInputLen)
;

/*
 Solves a Fredholm equation with a separable kernel (JSON).
 */
rssn_ char *rssn_fredholm_solve_separable_json(const char *aInputJson) ;

/*
 Frees a bincode buffer allocated by an FFI function.

 # Safety
 The buffer must have been allocated by an FFI function that returns `BincodeBuffer`.
 This function should only be called once per buffer.
 */
rssn_ void rssn_free_bincode_buffer(struct rssn_BincodeBuffer aBuffer) ;

/*
 Frees an Expr pointer created by this module.

 # Safety
 The caller must ensure `expr` was created by this module and hasn't been freed yet.
 */
rssn_ void rssn_free_expr(struct rssn_Expr *aExpr) ;

/*
 Frees a multivector (Handle)
 */
rssn_ void rssn_free_multivector_handle(struct rssn_Multivector *aPtr) ;

rssn_ void rssn_free_poles(struct rssn_Vec_Expr *aPoles) ;

/*
 Frees a vector of polynomials (Handle)
 */
rssn_ void rssn_free_poly_vec_handle(struct rssn_Vec_FiniteFieldPolynomial *aPtr) ;

/*
 Frees a string allocated by an FFI function.

 # Safety
 The string must have been allocated by an FFI function that returns `*mut c_char`.
 This function should only be called once per string.
 */
rssn_ void rssn_free_string(char *aS) ;

/*
 Computes general multi-valued arccos (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_arccos_handle(const struct rssn_Expr *aZ,
                                             const struct rssn_Expr *aK,
                                             const struct rssn_Expr *aS)
;

/*
 Computes general multi-valued arcsin (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_arcsin_handle(const struct rssn_Expr *aZ,
                                             const struct rssn_Expr *aK)
;

/*
 Computes general multi-valued arctan (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_arctan_handle(const struct rssn_Expr *aZ,
                                             const struct rssn_Expr *aK)
;

/*
 Computes general multi-valued logarithm (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_log_handle(const struct rssn_Expr *aZ,
                                          const struct rssn_Expr *aK)
;

/*
 Computes general multi-valued n-th root (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_nth_root_handle(const struct rssn_Expr *aZ,
                                               const struct rssn_Expr *aN,
                                               const struct rssn_Expr *aK)
;

/*
 Computes general multi-valued power (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_power_handle(const struct rssn_Expr *aZ,
                                            const struct rssn_Expr *aW,
                                            const struct rssn_Expr *aK)
;

/*
 Computes general multi-valued square root (Handle)
 */
rssn_
struct rssn_Expr *rssn_general_sqrt_handle(const struct rssn_Expr *aZ,
                                           const struct rssn_Expr *aK)
;

/*
 Returns the build date as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_build_date(void) ;

/*
 Returns the build date as a bincode buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_ struct rssn_BincodeBuffer rssn_get_build_date_bincode(void) ;

/*
 Returns the build date as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_build_date_json(void) ;

/*
 Returns all build information as a bincode buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_ struct rssn_BincodeBuffer rssn_get_build_info_bincode(void) ;

/*
 Returns all build information as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_build_info_json(void) ;

/*
 Returns the cargo target triple as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_cargo_target_triple(void) ;

/*
 Returns the commit SHA as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_commit_sha(void) ;

/*
 Returns the commit SHA as a bincode buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_ struct rssn_BincodeBuffer rssn_get_commit_sha_bincode(void) ;

/*
 Returns the commit SHA as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_commit_sha_json(void) ;

/*
 Retrieves the last error message set by an FFI function on the current thread.

 The returned pointer is valid until the next call to an FFI function on the same thread.
 The caller should not free this pointer.
 */
rssn_ const char *rssn_get_last_error(void) ;

/*
 Gets real and imaginary parts of an expression.
 Returns a pointer to a tuple (Expr, Expr) - represented as Vec<Expr> of size 2 for simplicity?
 Or return two out pointers?
 I'll return a Vec<Expr> of size 2.
 */
rssn_ struct rssn_Vec_Expr *rssn_get_real_imag_parts(const struct rssn_Expr *aExpr) ;

/*
 Returns the rustc version as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_rustc_version(void) ;

/*
 Returns the system info as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_system_info(void) ;

/*
 Clears all expressions from the handle manager.

 **Warning**: This invalidates all existing handles.

 # Safety
 This function is always safe to call, but will invalidate all handles.
 */
rssn_ void rssn_handle_clear(void) ;

/*
 Clears all handles (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_handle_clear_bincode(void) ;

/*
 Clears all handles (JSON).

 Output: JSON object with "cleared" boolean field
 */
rssn_ char *rssn_handle_clear_json(void) ;

/*
 Clones an expression handle, creating a new handle pointing to the same expression.

 Returns 0 if the source handle doesn't exist.

 # Safety
 This function is safe to call with any handle value.
 */
rssn_ size_t rssn_handle_clone(size_t aHandle) ;

/*
 Clones a handle (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_handle_clone_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Clones a handle (JSON).

 Input: JSON object with "handle" field
 Output: JSON object with "new_handle" field
 */
rssn_ char *rssn_handle_clone_json(const char *aJsonStr) ;

/*
 Returns the number of expressions currently managed.

 # Safety
 This function is always safe to call.
 */
rssn_ size_t rssn_handle_count(void) ;

/*
 Checks if a handle exists in the manager.

 # Safety
 This function is safe to call with any handle value.
 */
rssn_ bool rssn_handle_exists(size_t aHandle) ;

/*
 Checks if a handle exists (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_handle_exists_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Checks if a handle exists (JSON).

 Input: JSON object with "handle" field
 Output: JSON object with "exists" boolean field
 */
rssn_ char *rssn_handle_exists_json(const char *aJsonStr) ;

/*
 Frees a handle from the manager.

 Returns true if the handle was found and freed, false otherwise.

 # Safety
 This function is safe to call with any handle value.
 */
rssn_ bool rssn_handle_free(size_t aHandle) ;

/*
 Frees a handle (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_handle_free_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Frees a handle (JSON).

 Input: JSON object with "handle" field
 Output: JSON object with "freed" boolean field
 */
rssn_ char *rssn_handle_free_json(const char *aJsonStr) ;

/*
 Retrieves an expression from the handle manager.

 Returns a new owned Expr pointer that must be freed by the caller.

 # Safety
 The caller must ensure the returned pointer is freed using `rssn_free_expr`.
 */
rssn_ struct rssn_Expr *rssn_handle_get(size_t aHandle) ;

/*
 Returns a list of all active handles as a JSON array string.

 The returned string must be freed using `rssn_free_string`.

 # Safety
 The caller must free the returned string.
 */
rssn_ char *rssn_handle_get_all(void) ;

/*
 Returns all active handles (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_handle_get_all_bincode(void) ;

/*
 Retrieves an expression by handle (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_handle_get_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Retrieves an expression by handle (JSON).

 Input: JSON object with "handle" field
 Output: JSON-serialized Expr
 */
rssn_ char *rssn_handle_get_json(const char *aJsonStr) ;

/*
 Inserts an expression into the handle manager and returns a unique handle.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ size_t rssn_handle_insert(const struct rssn_Expr *aExpr) ;

/*
 Inserts an expression (Bincode) into the handle manager.
 */
rssn_ struct rssn_BincodeBuffer rssn_handle_insert_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Inserts an expression (JSON) into the handle manager.

 Input: JSON-serialized Expr
 Output: JSON object with "handle" field
 */
rssn_ char *rssn_handle_insert_json(const char *aJsonStr) ;

/*
 Returns handle manager statistics (JSON).

 Output: JSON object with "count" and "handles" fields
 */
rssn_ char *rssn_handle_stats_json(void) ;

/*
 Converts an expression handle to a string representation.

 The returned string must be freed using `rssn_free_string`.

 # Safety
 The caller must free the returned string.
 */
rssn_ char *rssn_handle_to_string(size_t aHandle) ;

/*
 Simplifies an expression using the heuristic simplifier.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_heuristic_simplify(const struct rssn_Expr *aExpr) ;

/*
 Computes the Inverse Fast Fourier Transform (IFFT) of a sequence of complex numbers in-place.
 */
rssn_ int32_t rssn_ifft(rssn_Complex<double> *aData, size_t aLen) ;

/*
 Initializes the plugin manager with a specified plugin directory.

 This function must be called before any plugin operations are performed.

 # Arguments
 * `plugin_dir_ptr` - A null-terminated UTF-8 string for the plugin directory path.

 # Returns
 0 on success, -1 on failure. On failure, an error message can be retrieved
 with `rssn_get_last_error`.
 */
rssn_ int32_t rssn_init_plugin_manager(const char *aPluginDirPtr) ;

/*
 Integrates an expression: int(expr) d(var).

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `var` is a valid C string.
 */
rssn_ struct rssn_Expr *rssn_integrate(const struct rssn_Expr *aExpr, const char *aVar) ;

/*
 Integrates a rational function (Handle)
 */
rssn_
struct rssn_Expr *rssn_integrate_rational_function_handle(const struct rssn_Expr *aExpr,
                                                          const char *aX)
;

/*
 Evaluates a point on a Bezier curve defined by control points.
 */
rssn_
int32_t rssn_interp_bezier_curve(const struct rssn_FfiPoint *aPointsPtr,
                                 size_t aNumPoints,
                                 double aT,
                                 struct rssn_FfiPoint *aResultPtr)
;

/*
 Computes a Lagrange interpolating polynomial from a set of points.
 Returns a handle to the resulting polynomial expression.
 */
rssn_
int32_t rssn_interp_lagrange(const struct rssn_FfiPoint *aPointsPtr,
                             size_t aNumPoints,
                             size_t *aResultHandle)
;

/*
 Checks if an expression is prime.

 # Safety
 `n` must be a valid pointer to an `Expr`.
 */
rssn_ struct rssn_Expr *rssn_is_prime_handle(const struct rssn_Expr *aN) ;

/*
 Checks if a logical expression is satisfiable using handle-based FFI.

 Returns:
 - 1 if satisfiable
 - 0 if unsatisfiable
 - -1 if the expression contains quantifiers (undecidable)

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_ int32_t rssn_is_satisfiable_handle(const struct rssn_Expr *aExpr) ;

/*
 Computes absolute value (magnitude) of complex number (JSON)
 */
rssn_ char *rssn_json_abs(const char *aZJson) ;

rssn_
char *rssn_json_analytic_continuation(const char *aExprJson,
                                      const char *aVarJson,
                                      const char *aOrigCenterJson,
                                      const char *aNewCenterJson,
                                      const char *aOrderJson)
;

rssn_ char *rssn_json_analyze_convergence(const char *aTermJson, const char *aVarJson) ;

/*
 Computes argument (angle) of complex number (JSON)
 */
rssn_ char *rssn_json_arg(const char *aZJson) ;

rssn_
char *rssn_json_asymptotic_expansion(const char *aExprJson,
                                     const char *aVarJson,
                                     const char *aPointJson,
                                     const char *aOrderJson)
;

rssn_ char *rssn_json_buchberger(const char *aBasisJson, const char *aOrderJson) ;

/*
 Calculates residue using JSON.
 */
rssn_
char *rssn_json_calculate_residue(const char *aExprJson,
                                  const char *aVar,
                                  const char *aPoleJson)
;

/*
 Checks analytic using JSON.
 */
rssn_ bool rssn_json_check_analytic(const char *aExprJson, const char *aVar) ;

rssn_ char *rssn_json_chinese_remainder(const char *aCongruencesJson) ;

/*
 Classifies a PDE and suggests solution methods (JSON).
 */
rssn_
char *rssn_json_classify_pde(const char *aEquationJson,
                             const char *aFunc,
                             const char *aVarsJson)
;

rssn_ char *rssn_json_coordinates_get_metric_tensor(enum rssn_CoordinateSystem aSystem) ;

/*
 Computes definite integral using JSON.
 */
rssn_
char *rssn_json_definite_integrate(const char *aExprJson,
                                   const char *aVar,
                                   const char *aLowerJson,
                                   const char *aUpperJson)
;

/*
 Denests a nested square root (JSON)
 */
rssn_ char *rssn_json_denest_sqrt(const char *aExprJson) ;

/*
 Differentiates an expression using JSON.
 */
rssn_ char *rssn_json_differentiate(const char *aExprJson, const char *aVar) ;

/*
 Evaluates at point using JSON.
 */
rssn_
char *rssn_json_evaluate_at_point(const char *aExprJson,
                                  const char *aVar,
                                  const char *aValueJson)
;

rssn_ char *rssn_json_evaluate_numerical(const char *aExprJson) ;

rssn_ char *rssn_json_extended_gcd(const char *aAJson, const char *aBJson) ;

/*
 Factors a polynomial over a finite field (JSON)
 */
rssn_ char *rssn_json_factor_gf(const char *aPolyJson) ;

/*
 Finds pole order using JSON.
 */
rssn_
size_t rssn_json_find_pole_order(const char *aExprJson,
                                 const char *aVar,
                                 const char *aPoleJson)
;

/*
 Finds poles using JSON.
 */
rssn_ char *rssn_json_find_poles(const char *aExprJson, const char *aVar) ;

/*
 Gets the degree of a finite field polynomial (JSON)
 */
rssn_ int64_t rssn_json_finite_field_polynomial_degree(const char *aPolyJson) ;

/*
 Performs polynomial long division (JSON)
 */
rssn_
char *rssn_json_finite_field_polynomial_long_division(const char *aDividendJson,
                                                      const char *aDivisorJson)
;

/*
 Creates a new finite field polynomial (JSON)
 */
rssn_
char *rssn_json_finite_field_polynomial_new(const char *aCoeffsJson,
                                            const char *aModulusJson)
;

rssn_
char *rssn_json_fourier_series(const char *aExprJson,
                               const char *aVarJson,
                               const char *aPeriodJson,
                               const char *aOrderJson)
;

/*
 Computes general multi-valued arccos (JSON)
 */
rssn_ char *rssn_json_general_arccos(const char *aZJson, const char *aKJson, const char *aSJson) ;

/*
 Computes general multi-valued arcsin (JSON)
 */
rssn_ char *rssn_json_general_arcsin(const char *aZJson, const char *aKJson) ;

/*
 Computes general multi-valued arctan (JSON)
 */
rssn_ char *rssn_json_general_arctan(const char *aZJson, const char *aKJson) ;

/*
 Computes general multi-valued logarithm (JSON)
 */
rssn_ char *rssn_json_general_log(const char *aZJson, const char *aKJson) ;

/*
 Computes general multi-valued n-th root (JSON)
 */
rssn_ char *rssn_json_general_nth_root(const char *aZJson, const char *aNJson, const char *aKJson) ;

/*
 Computes general multi-valued power (JSON)
 */
rssn_ char *rssn_json_general_power(const char *aZJson, const char *aWJson, const char *aKJson) ;

/*
 Computes general multi-valued square root (JSON)
 */
rssn_ char *rssn_json_general_sqrt(const char *aZJson, const char *aKJson) ;

/*
 Gets real and imaginary parts using JSON.
 */
rssn_ char *rssn_json_get_real_imag_parts(const char *aExprJson) ;

/*
 Simplifies an expression using the heuristic simplifier (JSON input/output).
 */
rssn_ char *rssn_json_heuristic_simplify(const char *aExprJson) ;

/*
 Integrates an expression using JSON.
 */
rssn_ char *rssn_json_integrate(const char *aExprJson, const char *aVar) ;

/*
 Integrates a rational function (JSON)
 */
rssn_ char *rssn_json_integrate_rational_function(const char *aExprJson, const char *aXJson) ;

rssn_ char *rssn_json_is_prime(const char *aNJson) ;

/*
 Checks if a logical expression is satisfiable using JSON-based FFI.

 Returns a JSON string containing:
 - `{"result": "satisfiable"}` if satisfiable
 - `{"result": "unsatisfiable"}` if unsatisfiable
 - `{"result": "undecidable"}` if the expression contains quantifiers
 */
rssn_ char *rssn_json_is_satisfiable(const char *aExprJson) ;

rssn_
char *rssn_json_laurent_series(const char *aExprJson,
                               const char *aVarJson,
                               const char *aCenterJson,
                               const char *aOrderJson)
;

/*
 Computes limit using JSON.
 */
rssn_ char *rssn_json_limit(const char *aExprJson, const char *aVar, const char *aPointJson) ;

rssn_ char *rssn_json_matrix_add(const char *aM1Json, const char *aM2Json) ;

rssn_ char *rssn_json_matrix_determinant(const char *aMatrixJson) ;

rssn_ char *rssn_json_matrix_inverse(const char *aMatrixJson) ;

rssn_ char *rssn_json_matrix_mul(const char *aM1Json, const char *aM2Json) ;

rssn_ char *rssn_json_matrix_solve_linear_system(const char *aAJson, const char *aBJson) ;

rssn_ char *rssn_json_matrix_transpose(const char *aMatrixJson) ;

/*
 Computes geometric product (JSON)
 */
rssn_ char *rssn_json_multivector_geometric_product(const char *aAJson, const char *aBJson) ;

/*
 Computes grade projection (JSON)
 */
rssn_ char *rssn_json_multivector_grade_projection(const char *aMvJson, uint32_t aGrade) ;

/*
 Computes inner product (JSON)
 */
rssn_ char *rssn_json_multivector_inner_product(const char *aAJson, const char *aBJson) ;

/*
 Computes magnitude (JSON)
 */
rssn_ char *rssn_json_multivector_magnitude(const char *aMvJson) ;

/*
 Computes outer product (JSON)
 */
rssn_ char *rssn_json_multivector_outer_product(const char *aAJson, const char *aBJson) ;

/*
 Computes reverse (JSON)
 */
rssn_ char *rssn_json_multivector_reverse(const char *aMvJson) ;

/*
 Creates a new scalar multivector (JSON)
 */
rssn_
char *rssn_json_multivector_scalar(uint32_t aP,
                                   uint32_t aQ,
                                   uint32_t aR,
                                   const char *aValueJson)
;

/*
 Computes path integral using JSON.
 */
rssn_
char *rssn_json_path_integrate(const char *aExprJson,
                               const char *aVar,
                               const char *aContourJson)
;

/*
 Computes polynomial derivative over finite field (JSON)
 */
rssn_ char *rssn_json_poly_derivative_gf(const char *aPolyJson) ;

rssn_
char *rssn_json_poly_division_multivariate(const char *aDividendJson,
                                           const char *aDivisorsJson,
                                           const char *aOrderJson)
;

/*
 Computes polynomial GCD over finite field (JSON)
 */
rssn_ char *rssn_json_poly_gcd_gf(const char *aAJson, const char *aBJson) ;

/*
 Checks if an expression contains a variable (JSON)
 */
rssn_ bool rssn_json_polynomial_contains_var(const char *aExprJson, const char *aVar) ;

/*
 Computes the degree of a polynomial (JSON)
 */
rssn_ int64_t rssn_json_polynomial_degree(const char *aExprJson, const char *aVar) ;

/*
 Checks if an expression is a polynomial in the given variable (JSON)
 */
rssn_ bool rssn_json_polynomial_is_polynomial(const char *aExprJson, const char *aVar) ;

/*
 Finds the leading coefficient of a polynomial (JSON)
 */
rssn_ char *rssn_json_polynomial_leading_coefficient(const char *aExprJson, const char *aVar) ;

/*
 Performs polynomial long division (JSON)
 */
rssn_
char *rssn_json_polynomial_long_division(const char *aDividendJson,
                                         const char *aDivisorJson,
                                         const char *aVar)
;

/*
 Converts polynomial to coefficient vector (JSON)
 */
rssn_ char *rssn_json_polynomial_to_coeffs_vec(const char *aExprJson, const char *aVar) ;

/*
 Adds two prime field elements (JSON)
 */
rssn_ char *rssn_json_prime_field_element_add(const char *aAJson, const char *aBJson) ;

/*
 Divides two prime field elements (JSON)
 */
rssn_ char *rssn_json_prime_field_element_div(const char *aAJson, const char *aBJson) ;

/*
 Computes the inverse of a prime field element (JSON)
 */
rssn_ char *rssn_json_prime_field_element_inverse(const char *aElemJson) ;

/*
 Multiplies two prime field elements (JSON)
 */
rssn_ char *rssn_json_prime_field_element_mul(const char *aAJson, const char *aBJson) ;

/*
 Creates a new prime field element (JSON)
 */
rssn_ char *rssn_json_prime_field_element_new(const char *aValueJson, const char *aModulusJson) ;

/*
 Subtracts two prime field elements (JSON)
 */
rssn_ char *rssn_json_prime_field_element_sub(const char *aAJson, const char *aBJson) ;

rssn_
char *rssn_json_product(const char *aExprJson,
                        const char *aVarJson,
                        const char *aLowerJson,
                        const char *aUpperJson)
;

/*
 Integrates an expression using the Risch-Norman algorithm (JSON)
 */
rssn_ char *rssn_json_risch_norman_integrate(const char *aExprJson, const char *aXJson) ;

/*
 Simplifies an expression using the legacy simplifier (JSON input/output).
 */
rssn_ char *rssn_json_simplify(const char *aExprJson) ;

/*
 Simplifies an expression using the DAG-based simplifier (JSON input/output).
 */
rssn_ char *rssn_json_simplify_dag(const char *aExprJson) ;

/*
 Simplifies a logical expression using JSON-based FFI.
 */
rssn_ char *rssn_json_simplify_logic(const char *aExprJson) ;

/*
 Simplifies radical expressions (JSON)
 */
rssn_ char *rssn_json_simplify_radicals(const char *aExprJson) ;

rssn_ char *rssn_json_solve(const char *aExprJson, const char *aVarJson) ;

/*
 Solves a Bernoulli ODE using JSON.
 */
rssn_
char *rssn_json_solve_bernoulli_ode(const char *aEquationJson,
                                    const char *aFunc,
                                    const char *aVar)
;

/*
 Solves by reduction of order using JSON.
 */
rssn_
char *rssn_json_solve_by_reduction_of_order(const char *aEquationJson,
                                            const char *aFunc,
                                            const char *aVar,
                                            const char *aY1Json)
;

/*
 Solves a Cauchy-Euler ODE using JSON.
 */
rssn_
char *rssn_json_solve_cauchy_euler_ode(const char *aEquationJson,
                                       const char *aFunc,
                                       const char *aVar)
;

rssn_ char *rssn_json_solve_diophantine(const char *aEquationJson, const char *aVarsJson) ;

/*
 Solves an exact ODE using JSON.
 */
rssn_
char *rssn_json_solve_exact_ode(const char *aEquationJson,
                                const char *aFunc,
                                const char *aVar)
;

/*
 Solves a first-order linear ODE using JSON.
 */
rssn_
char *rssn_json_solve_first_order_linear_ode(const char *aEquationJson,
                                             const char *aFunc,
                                             const char *aVar)
;

/*
 Solves the 1D heat equation (JSON).
 */
rssn_
char *rssn_json_solve_heat_equation_1d(const char *aEquationJson,
                                       const char *aFunc,
                                       const char *aVarsJson)
;

/*
 Solves the 2D Laplace equation (JSON).
 */
rssn_
char *rssn_json_solve_laplace_equation_2d(const char *aEquationJson,
                                          const char *aFunc,
                                          const char *aVarsJson)
;

rssn_ char *rssn_json_solve_linear_system(const char *aSystemJson, const char *aVarsJson) ;

/*
 Solves an ODE using JSON.
 */
rssn_ char *rssn_json_solve_ode(const char *aOdeJson, const char *aFunc, const char *aVar) ;

/*
 Solves a PDE using JSON with automatic method selection.
 */
rssn_ char *rssn_json_solve_pde(const char *aPdeJson, const char *aFunc, const char *aVarsJson) ;

/*
 Solves a PDE using the method of characteristics (JSON).
 */
rssn_
char *rssn_json_solve_pde_by_characteristics(const char *aEquationJson,
                                             const char *aFunc,
                                             const char *aVarsJson)
;

/*
 Solves the 2D Poisson equation (JSON).
 */
rssn_
char *rssn_json_solve_poisson_equation_2d(const char *aEquationJson,
                                          const char *aFunc,
                                          const char *aVarsJson)
;

/*
 Solves a Riccati ODE using JSON.
 */
rssn_
char *rssn_json_solve_riccati_ode(const char *aEquationJson,
                                  const char *aFunc,
                                  const char *aVar,
                                  const char *aY1Json)
;

/*
 Solves a separable ODE using JSON.
 */
rssn_
char *rssn_json_solve_separable_ode(const char *aEquationJson,
                                    const char *aFunc,
                                    const char *aVar)
;

rssn_ char *rssn_json_solve_system(const char *aEquationsJson, const char *aVarsJson) ;

/*
 Solves the 1D wave equation using D'Alembert's formula (JSON).
 */
rssn_
char *rssn_json_solve_wave_equation_1d(const char *aEquationJson,
                                       const char *aFunc,
                                       const char *aVarsJson)
;

/*
 Computes square-free factorization (JSON)
 */
rssn_ char *rssn_json_square_free_factorization_gf(const char *aPolyJson) ;

/*
 Substitutes using JSON.
 */
rssn_
char *rssn_json_substitute(const char *aExprJson,
                           const char *aVar,
                           const char *aReplacementJson)
;

rssn_
char *rssn_json_summation(const char *aExprJson,
                          const char *aVarJson,
                          const char *aLowerJson,
                          const char *aUpperJson)
;

rssn_
char *rssn_json_taylor_series(const char *aExprJson,
                              const char *aVarJson,
                              const char *aCenterJson,
                              const char *aOrderJson)
;

rssn_ char *rssn_json_tensor_add(const char *aT1Json, const char *aT2Json) ;

rssn_ char *rssn_json_tensor_contract(const char *aTJson, size_t aAxis1, size_t aAxis2) ;

rssn_ char *rssn_json_tensor_outer_product(const char *aT1Json, const char *aT2Json) ;

rssn_ char *rssn_json_tensor_scalar_mul(const char *aTJson, const char *aScalarJson) ;

/*
 Converts a logical expression to Conjunctive Normal Form (CNF) using JSON-based FFI.
 */
rssn_ char *rssn_json_to_cnf(const char *aExprJson) ;

/*
 Converts a logical expression to Disjunctive Normal Form (DNF) using JSON-based FFI.
 */
rssn_ char *rssn_json_to_dnf(const char *aExprJson) ;

rssn_
char *rssn_json_transform_contravariant_vector(const char *aCompsJson,
                                               enum rssn_CoordinateSystem aFrom,
                                               enum rssn_CoordinateSystem aTo)
;

rssn_
char *rssn_json_transform_covariant_vector(const char *aCompsJson,
                                           enum rssn_CoordinateSystem aFrom,
                                           enum rssn_CoordinateSystem aTo)
;

rssn_ char *rssn_json_transform_curl(const char *aCompsJson, enum rssn_CoordinateSystem aFrom) ;

rssn_
char *rssn_json_transform_divergence(const char *aCompsJson,
                                     enum rssn_CoordinateSystem aFrom)
;

rssn_
char *rssn_json_transform_expression(const char *aExprJson,
                                     enum rssn_CoordinateSystem aFrom,
                                     enum rssn_CoordinateSystem aTo)
;

rssn_
char *rssn_json_transform_gradient(const char *aScalarJson,
                                   const char *aVarsJson,
                                   enum rssn_CoordinateSystem aFrom,
                                   enum rssn_CoordinateSystem aTo)
;

rssn_
char *rssn_json_transform_point(const char *aPointJson,
                                enum rssn_CoordinateSystem aFrom,
                                enum rssn_CoordinateSystem aTo)
;

rssn_ char *rssn_json_unify_expression(const char *aExprJson) ;

rssn_ char *rssn_json_vector_cross(const char *aV1Json, const char *aV2Json) ;

rssn_
char *rssn_json_vector_curl(const char *aVJson,
                            const char *aXVar,
                            const char *aYVar,
                            const char *aZVar)
;

rssn_
char *rssn_json_vector_divergence(const char *aVJson,
                                  const char *aXVar,
                                  const char *aYVar,
                                  const char *aZVar)
;

rssn_ char *rssn_json_vector_dot(const char *aV1Json, const char *aV2Json) ;

rssn_
char *rssn_json_vector_gradient(const char *aScalarFieldJson,
                                const char *aXVar,
                                const char *aYVar,
                                const char *aZVar)
;

rssn_ char *rssn_json_vector_magnitude(const char *aVJson) ;

rssn_ char *rssn_json_vector_normalize(const char *aVJson) ;

/*
 Applies the Knuth-Bendix completion algorithm to a set of equations.

 Returns a pointer to a Vec<RewriteRule> on success, or null on failure.

 # Safety
 The caller must ensure `equations` is a valid array of Expr pointers.
 */
rssn_
struct rssn_Vec_RewriteRule *rssn_knuth_bendix(const struct rssn_Expr *const *aEquations,
                                               size_t aEquationsLen)
;

/*
 Applies the Knuth-Bendix completion algorithm (Bincode).
 */
rssn_ struct rssn_BincodeBuffer rssn_knuth_bendix_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Applies the Knuth-Bendix completion algorithm (JSON).

 Input: JSON array of equations (Expr::Eq)
 Output: JSON array of RewriteRule objects
 */
rssn_ char *rssn_knuth_bendix_json(const char *aJsonStr) ;

rssn_
struct rssn_Expr *rssn_laurent_series_handle(const struct rssn_Expr *aExpr,
                                             const char *aVar,
                                             const struct rssn_Expr *aCenter,
                                             size_t aOrder)
;

/*
 Computes the limit of an expression: limit(expr, var -> point).

 # Safety
 The caller must ensure `expr` and `point` are valid Expr pointers and `var` is a valid C string.
 */
rssn_
struct rssn_Expr *rssn_limit(const struct rssn_Expr *aExpr,
                             const char *aVar,
                             const struct rssn_Expr *aPoint)
;

/*
 Computes the line integral of a scalar field along a curve.
 */
rssn_
char *rssn_line_integral_scalar(const char *aScalarField,
                                const struct rssn_ParametricCurve *aCurve)
;

/*
 Computes the line integral of a scalar field (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_line_integral_scalar_bincode(const uint8_t *aInputPtr,
                                                            size_t aInputLen)
;

/*
 Computes the line integral of a scalar field (JSON).
 */
rssn_ char *rssn_line_integral_scalar_json(const char *aInputJson) ;

/*
 Computes the line integral of a vector field along a curve.
 */
rssn_
char *rssn_line_integral_vector(const char *aFieldX,
                                const char *aFieldY,
                                const char *aFieldZ,
                                const struct rssn_ParametricCurve *aCurve)
;

/*
 Computes the line integral of a vector field (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_line_integral_vector_bincode(const uint8_t *aInputPtr,
                                                            size_t aInputLen)
;

/*
 Computes the line integral of a vector field (JSON).
 */
rssn_ char *rssn_line_integral_vector_json(const char *aInputJson) ;

/*
 Creates a natural logarithm expression: ln(expr).
 */
rssn_ struct rssn_Expr *rssn_ln(const struct rssn_Expr *aExpr) ;

/*
 Creates a natural logarithm expression from bincode: ln(expr).
 */
rssn_ struct rssn_BincodeBuffer rssn_ln_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a natural logarithm expression from JSON: ln(expr).
 */
rssn_ char *rssn_ln_json(const char *aJsonExpr) ;

rssn_ int32_t rssn_matrix_add(size_t aH1, size_t aH2, size_t *aResultH) ;

rssn_
struct rssn_Expr *rssn_matrix_add_handle(const struct rssn_Expr *aM1,
                                         const struct rssn_Expr *aM2)
;

rssn_ int32_t rssn_matrix_determinant(size_t aH, size_t *aResultH) ;

rssn_ struct rssn_Expr *rssn_matrix_determinant_handle(const struct rssn_Expr *aMatrix) ;

rssn_ int32_t rssn_matrix_identity(size_t aSize, size_t *aResultH) ;

rssn_ int32_t rssn_matrix_inverse(size_t aH, size_t *aResultH) ;

rssn_ struct rssn_Expr *rssn_matrix_inverse_handle(const struct rssn_Expr *aMatrix) ;

rssn_ int32_t rssn_matrix_mul(size_t aH1, size_t aH2, size_t *aResultH) ;

rssn_
struct rssn_Expr *rssn_matrix_mul_handle(const struct rssn_Expr *aM1,
                                         const struct rssn_Expr *aM2)
;

rssn_ int32_t rssn_matrix_scalar_mul(size_t aScalarH, size_t aMatrixH, size_t *aResultH) ;

rssn_
struct rssn_Expr *rssn_matrix_solve_linear_system_handle(const struct rssn_Expr *aA,
                                                         const struct rssn_Expr *aB)
;

rssn_ int32_t rssn_matrix_sub(size_t aH1, size_t aH2, size_t *aResultH) ;

rssn_ int32_t rssn_matrix_transpose(size_t aH, size_t *aResultH) ;

rssn_ struct rssn_Expr *rssn_matrix_transpose_handle(const struct rssn_Expr *aMatrix) ;

/*
 Computes geometric product (Handle)
 */
rssn_
struct rssn_Multivector *rssn_multivector_geometric_product_handle(const struct rssn_Multivector *aA,
                                                                   const struct rssn_Multivector *aB)
;

/*
 Computes grade projection (Handle)
 */
rssn_
struct rssn_Multivector *rssn_multivector_grade_projection_handle(const struct rssn_Multivector *aMv,
                                                                  uint32_t aGrade)
;

/*
 Computes inner product (Handle)
 */
rssn_
struct rssn_Multivector *rssn_multivector_inner_product_handle(const struct rssn_Multivector *aA,
                                                               const struct rssn_Multivector *aB)
;

/*
 Computes magnitude (Handle)
 */
rssn_ struct rssn_Expr *rssn_multivector_magnitude_handle(const struct rssn_Multivector *aMv) ;

/*
 Computes outer product (Handle)
 */
rssn_
struct rssn_Multivector *rssn_multivector_outer_product_handle(const struct rssn_Multivector *aA,
                                                               const struct rssn_Multivector *aB)
;

/*
 Computes reverse (Handle)
 */
rssn_ struct rssn_Multivector *rssn_multivector_reverse_handle(const struct rssn_Multivector *aMv) ;

/*
 Creates a new scalar multivector (Handle)
 */
rssn_
struct rssn_Multivector *rssn_multivector_scalar_handle(uint32_t aP,
                                                        uint32_t aQ,
                                                        uint32_t aR,
                                                        const struct rssn_Expr *aValue)
;

/*
 Computes the greatest common divisor (GCD) of two numbers.

 Returns 0 on success, -1 on error.
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_ int32_t rssn_nt_gcd(uint64_t aA, uint64_t aB, uint64_t *aResult) ;

/*
 Checks if a number is prime using the Miller-Rabin test.

 Returns 0 on success, -1 on error.
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_ int32_t rssn_nt_is_prime(uint64_t aN, bool *aResult) ;

/*
 Computes the modular multiplicative inverse.

 Returns 0 on success, -1 on error (e.g., if no inverse exists).
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_ int32_t rssn_nt_mod_inverse(int64_t aA, int64_t aB, int64_t *aResult) ;

/*
 Computes modular exponentiation (base^exp % modulus).

 Returns 0 on success, -1 on error.
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_ int32_t rssn_nt_mod_pow(uint64_t aBase, uint64_t aExp, uint64_t aModulus, uint64_t *aResult) ;

rssn_
int32_t rssn_numerical_gradient(size_t aExprH,
                                const char *const *aVars,
                                size_t aNumVars,
                                const double *aPoint,
                                size_t aPointLen,
                                double *aResultVec)
;

rssn_
int32_t rssn_numerical_integrate(size_t aExprH,
                                 const char *aVar,
                                 double aStart,
                                 double aEnd,
                                 size_t aNSteps,
                                 uint32_t aMethod,
                                 double *aResult)
;

/*
 Frees a ParametricCurve handle.
 */
rssn_ void rssn_parametric_curve_free(struct rssn_ParametricCurve *aCurve) ;

/*
 Creates a new ParametricCurve.
 */
rssn_
struct rssn_ParametricCurve *rssn_parametric_curve_new(const char *aRX,
                                                       const char *aRY,
                                                       const char *aRZ,
                                                       const char *aTVar,
                                                       const char *aTLower,
                                                       const char *aTUpper)
;

/*
 Frees a ParametricSurface handle.
 */
rssn_ void rssn_parametric_surface_free(struct rssn_ParametricSurface *aSurface) ;

/*
 Creates a new ParametricSurface.
 */
rssn_
struct rssn_ParametricSurface *rssn_parametric_surface_new(const char *aRX,
                                                           const char *aRY,
                                                           const char *aRZ,
                                                           const char *aUVar,
                                                           const char *aULower,
                                                           const char *aUUpper,
                                                           const char *aVVar,
                                                           const char *aVLower,
                                                           const char *aVUpper)
;

/*
 Clears a ParsingCache.
 */
rssn_ void rssn_parsing_cache_clear(struct rssn_ParsingCache *aCache) ;

/*
 Frees a ParsingCache.
 */
rssn_ void rssn_parsing_cache_free(struct rssn_ParsingCache *aCache) ;

/*
 Retrieves an expression from the ParsingCache.
 Returns a pointer to the Expr (Arc<Expr> with incremented refcount), or null if not found.
 The caller is responsible for freeing the returned Expr (using the appropriate Expr free function).
 */
rssn_
struct rssn_Expr *rssn_parsing_cache_get(struct rssn_ParsingCache *aCache,
                                         const char *aInput)
;

/*
 Retrieves an expression from the ParsingCache as a bincode buffer.
 */
rssn_
struct rssn_BincodeBuffer rssn_parsing_cache_get_bincode(struct rssn_ParsingCache *aCache,
                                                         const char *aInput)
;

/*
 Retrieves an expression from the ParsingCache as a JSON string.
 Returns null if not found or error.
 */
rssn_ char *rssn_parsing_cache_get_json(struct rssn_ParsingCache *aCache, const char *aInput) ;

/*
 Creates a new ParsingCache.
 The caller is responsible for freeing the memory using rssn_parsing_cache_free.
 */
rssn_ struct rssn_ParsingCache *rssn_parsing_cache_new(void) ;

/*
 Stores an expression in the ParsingCache.
 The expr pointer is cloned (deep copy of the structure, but DAG nodes are shared).
 */
rssn_
void rssn_parsing_cache_set(struct rssn_ParsingCache *aCache,
                            const char *aInput,
                            const struct rssn_Expr *aExpr)
;

/*
 Stores an expression in the ParsingCache from a bincode buffer.
 */
rssn_
void rssn_parsing_cache_set_bincode(struct rssn_ParsingCache *aCache,
                                    const char *aInput,
                                    struct rssn_BincodeBuffer aBuffer)
;

/*
 Stores an expression in the ParsingCache from a JSON string.
 */
rssn_
void rssn_parsing_cache_set_json(struct rssn_ParsingCache *aCache,
                                 const char *aInput,
                                 const char *aJsonExpr)
;

/*
 Computes a path integral.
 */
rssn_
struct rssn_Expr *rssn_path_integrate(const struct rssn_Expr *aExpr,
                                      const char *aVar,
                                      const struct rssn_Expr *aContour)
;

rssn_
int32_t rssn_physics_advection_diffusion_1d(const double *aInitialCond,
                                            size_t aLen,
                                            double aDx,
                                            double aC,
                                            double aD,
                                            double aDt,
                                            size_t aSteps,
                                            double *aResultPtr)
;

/*
 Returns the symbolic representation of Pi.
 */
rssn_ struct rssn_Expr *rssn_pi(void) ;

/*
 Returns Pi as bincode.
 */
rssn_ struct rssn_BincodeBuffer rssn_pi_bincode(void) ;

/*
 Returns Pi as JSON.
 */
rssn_ char *rssn_pi_json(void) ;

/*
 Executes a command on a loaded plugin.

 # Arguments
 * `plugin_name_ptr` - A null-terminated UTF-8 string representing the plugin's name.
 * `command_ptr` - A null-terminated UTF-8 string for the command to execute.
 * `args_handle` - A handle to the `Expr` object to be passed as an argument.

 # Returns
 A handle to the resulting `Expr` object on success, or 0 on failure.
 On failure, an error message can be retrieved with `rssn_get_last_error`.
 */
rssn_
size_t rssn_plugin_execute(const char *aPluginNamePtr,
                           const char *aCommandPtr,
                           size_t aArgsHandle)
;

rssn_ struct rssn_Expr *rssn_poles_get(const struct rssn_Vec_Expr *aPoles, size_t aIndex) ;

rssn_ size_t rssn_poles_len(const struct rssn_Vec_Expr *aPoles) ;

rssn_ int32_t rssn_poly_degree(size_t aExprHandle, const char *aVarPtr, int64_t *aResult) ;

/*
 Computes polynomial derivative over finite field (Handle)
 */
rssn_
struct rssn_FiniteFieldPolynomial *rssn_poly_derivative_gf_handle(const struct rssn_FiniteFieldPolynomial *aPoly)
;

/*
 Computes polynomial GCD over finite field (Handle)
 */
rssn_
struct rssn_FiniteFieldPolynomial *rssn_poly_gcd_gf_handle(const struct rssn_FiniteFieldPolynomial *aA,
                                                           const struct rssn_FiniteFieldPolynomial *aB)
;

rssn_ int32_t rssn_poly_is_polynomial(size_t aExprHandle, const char *aVarPtr, bool *aResult) ;

rssn_
int32_t rssn_poly_long_division(size_t aNHandle,
                                size_t aDHandle,
                                const char *aVarPtr,
                                size_t *aQHandle,
                                size_t *aRHandle)
;

/*
 Creates a power expression: base^exp.
 */
rssn_ struct rssn_Expr *rssn_pow(const struct rssn_Expr *aBase, const struct rssn_Expr *aExp) ;

/*
 Creates a power expression from bincode: base^exp.

 # Arguments
 * `base_buffer` - Bincode-serialized base Expr
 * `exp_buffer` - Bincode-serialized exponent Expr
 */
rssn_
struct rssn_BincodeBuffer rssn_pow_bincode(struct rssn_BincodeBuffer aBaseBuffer,
                                           struct rssn_BincodeBuffer aExpBuffer)
;

/*
 Creates a power expression from JSON: base^exp.

 # Arguments
 * `json_base` - JSON-serialized base Expr
 * `json_exp` - JSON-serialized exponent Expr
 */
rssn_ char *rssn_pow_json(const char *aJsonBase, const char *aJsonExp) ;

/*
 Adds two prime field elements (Handle)
 */
rssn_
struct rssn_PrimeFieldElement *rssn_prime_field_element_add_handle(const struct rssn_PrimeFieldElement *aA,
                                                                   const struct rssn_PrimeFieldElement *aB)
;

/*
 Frees a prime field element (Handle)
 */
rssn_ void rssn_prime_field_element_free_handle(struct rssn_PrimeFieldElement *aElem) ;

/*
 Computes the inverse of a prime field element (Handle)
 */
rssn_
struct rssn_PrimeFieldElement *rssn_prime_field_element_inverse_handle(const struct rssn_PrimeFieldElement *aElem)
;

/*
 Multiplies two prime field elements (Handle)
 */
rssn_
struct rssn_PrimeFieldElement *rssn_prime_field_element_mul_handle(const struct rssn_PrimeFieldElement *aA,
                                                                   const struct rssn_PrimeFieldElement *aB)
;

/*
 Creates a new prime field element (Handle)
 Returns a boxed pointer to the element
 */
rssn_
struct rssn_PrimeFieldElement *rssn_prime_field_element_new_handle(const rssn_BigInt *aValue,
                                                                   const rssn_BigInt *aModulus)
;

rssn_
struct rssn_Expr *rssn_product_handle(const struct rssn_Expr *aExpr,
                                      const char *aVar,
                                      const struct rssn_Expr *aLower,
                                      const struct rssn_Expr *aUpper)
;

/*
 Frees a rewrite rule.

 # Safety
 The caller must ensure `rule` was created by this module and hasn't been freed yet.
 */
rssn_ void rssn_rewrite_rule_free(struct rssn_RewriteRule *aRule) ;

/*
 Gets the LHS of a rewrite rule.

 Returns a new owned Expr pointer that must be freed by the caller.

 # Safety
 The caller must ensure `rule` is a valid RewriteRule pointer.
 */
rssn_ struct rssn_Expr *rssn_rewrite_rule_get_lhs(const struct rssn_RewriteRule *aRule) ;

/*
 Gets the RHS of a rewrite rule.

 Returns a new owned Expr pointer that must be freed by the caller.

 # Safety
 The caller must ensure `rule` is a valid RewriteRule pointer.
 */
rssn_ struct rssn_Expr *rssn_rewrite_rule_get_rhs(const struct rssn_RewriteRule *aRule) ;

/*
 Creates a new rewrite rule from lhs and rhs expressions.

 # Safety
 The caller must ensure `lhs` and `rhs` are valid Expr pointers.
 */
rssn_
struct rssn_RewriteRule *rssn_rewrite_rule_new(const struct rssn_Expr *aLhs,
                                               const struct rssn_Expr *aRhs)
;

/*
 Creates a rewrite rule from Bincode.
 */
rssn_ struct rssn_BincodeBuffer rssn_rewrite_rule_new_bincode(struct rssn_BincodeBuffer aInput) ;

/*
 Creates a rewrite rule from JSON.

 Input: JSON object with "lhs" and "rhs" fields (both Expr)
 Output: JSON-serialized RewriteRule
 */
rssn_ char *rssn_rewrite_rule_new_json(const char *aJsonStr) ;

/*
 Converts a rewrite rule to a string representation.

 The returned string must be freed using `rssn_free_string`.

 # Safety
 The caller must free the returned string.
 */
rssn_ char *rssn_rewrite_rule_to_string(const struct rssn_RewriteRule *aRule) ;

/*
 Converts a rewrite rule to a human-readable string (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_rewrite_rule_to_string_bincode(struct rssn_BincodeBuffer aInput)
;

/*
 Converts a rewrite rule to a human-readable string (JSON).

 Input: JSON-serialized RewriteRule
 Output: JSON object with "string" field
 */
rssn_ char *rssn_rewrite_rule_to_string_json(const char *aJsonStr) ;

/*
 Integrates an expression using the Risch-Norman algorithm (Handle)
 */
rssn_
struct rssn_Expr *rssn_risch_norman_integrate_handle(const struct rssn_Expr *aExpr,
                                                     const char *aX)
;

/*
 Frees a rules vector.

 # Safety
 The caller must ensure `rules` was created by this module and hasn't been freed yet.
 */
rssn_ void rssn_rules_vec_free(struct rssn_Vec_RewriteRule *aRules) ;

/*
 Gets a rule from a rules vector by index.

 Returns a new owned RewriteRule pointer that must be freed by the caller.

 # Safety
 The caller must ensure `rules` is a valid Vec<RewriteRule> pointer.
 */
rssn_
struct rssn_RewriteRule *rssn_rules_vec_get(const struct rssn_Vec_RewriteRule *aRules,
                                            size_t aIndex)
;

/*
 Gets the length of a rules vector.

 # Safety
 The caller must ensure `rules` is a valid Vec<RewriteRule> pointer.
 */
rssn_ size_t rssn_rules_vec_len(const struct rssn_Vec_RewriteRule *aRules) ;

rssn_
enum rssn_ConvergenceResult *rssn_series_analyze_convergence_handle(const struct rssn_Expr *aSeries,
                                                                    const char *aVar)
;

rssn_
struct rssn_BincodeBuffer rssn_series_bincode_analyze_convergence(struct rssn_BincodeBuffer aSeriesBuf,
                                                                  struct rssn_BincodeBuffer aVarBuf)
;

rssn_ char *rssn_series_json_analyze_convergence(const char *aSeriesJson, const char *aVarJson) ;

/*
 Simplifies an expression using the legacy simplifier.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_simplify(const struct rssn_Expr *aExpr) ;

/*
 Simplifies an expression using the DAG-based simplifier.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_simplify_dag(const struct rssn_Expr *aExpr) ;

/*
 Simplifies a logical expression using handle-based FFI.

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_ struct rssn_Expr *rssn_simplify_logic_handle(const struct rssn_Expr *aExpr) ;

/*
 Simplifies radical expressions (Handle)
 */
rssn_ struct rssn_Expr *rssn_simplify_radicals_handle(const struct rssn_Expr *aExpr) ;

/*
 Creates a sine expression: sin(expr).

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_sin(const struct rssn_Expr *aExpr) ;

/*
 Creates a sine expression from bincode: sin(expr).

 # Arguments
 * `expr_buffer` - Bincode-serialized Expr

 # Returns
 Bincode-serialized Expr
 */
rssn_ struct rssn_BincodeBuffer rssn_sin_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a sine expression from JSON: sin(expr).

 # Arguments
 * `json_expr` - JSON-serialized Expr

 # Returns
 JSON-serialized Expr or null on error
 */
rssn_ char *rssn_sin_json(const char *aJsonExpr) ;

rssn_ int32_t rssn_solve(size_t aExprH, const char *aVar, size_t *aResultH) ;

/*
 Solves the airfoil singular integral equation.
 */
rssn_
struct rssn_Expr *rssn_solve_airfoil_equation(const struct rssn_Expr *aFX,
                                              const char *aVarX,
                                              const char *aVarT)
;

/*
 Solves the airfoil singular integral equation (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_solve_airfoil_equation_bincode(const uint8_t *aInputPtr,
                                                              size_t aInputLen)
;

/*
 Solves the airfoil singular integral equation (JSON).
 */
rssn_ char *rssn_solve_airfoil_equation_json(const char *aInputJson) ;

/*
 Solves a Bernoulli ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_bernoulli_ode(const struct rssn_Expr *aEquation,
                                           const char *aFunc,
                                           const char *aVar)
;

/*
 Solves a second-order ODE by reduction of order with a known solution.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_by_reduction_of_order(const struct rssn_Expr *aEquation,
                                                   const char *aFunc,
                                                   const char *aVar,
                                                   const struct rssn_Expr *aY1)
;

/*
 Solves a Cauchy-Euler ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_cauchy_euler_ode(const struct rssn_Expr *aEquation,
                                              const char *aFunc,
                                              const char *aVar)
;

/*
 Solves a Diophantine equation.

 # Safety
 `equation` must be a valid pointer to an `Expr`.
 `vars_ptr` must be a valid pointer to an array of C strings of length `vars_len`.
 */
rssn_
struct rssn_Expr *rssn_solve_diophantine_handle(const struct rssn_Expr *aEquation,
                                                const char *const *aVarsPtr,
                                                int aVarsLen)
;

/*
 Solves an exact ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_exact_ode(const struct rssn_Expr *aEquation,
                                       const char *aFunc,
                                       const char *aVar)
;

/*
 Solves a first-order linear ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_first_order_linear_ode(const struct rssn_Expr *aEquation,
                                                    const char *aFunc,
                                                    const char *aVar)
;

rssn_ struct rssn_Vec_Expr *rssn_solve_handle(const struct rssn_Expr *aExpr, const char *aVar) ;

/*
 Solves the 1D heat equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_heat_equation_1d(const struct rssn_Expr *aEquation,
                                              const char *aFunc,
                                              const char *const *aVars,
                                              size_t aVarsLen)
;

/*
 Solves the Helmholtz equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_helmholtz_equation(const struct rssn_Expr *aEquation,
                                                const char *aFunc,
                                                const char *const *aVars,
                                                size_t aVarsLen)
;

/*
 Solves the Klein-Gordon equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_klein_gordon_equation(const struct rssn_Expr *aEquation,
                                                   const char *aFunc,
                                                   const char *const *aVars,
                                                   size_t aVarsLen)
;

/*
 Solves the 2D Laplace equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_laplace_equation_2d(const struct rssn_Expr *aEquation,
                                                 const char *aFunc,
                                                 const char *const *aVars,
                                                 size_t aVarsLen)
;

rssn_
struct rssn_Vec_Expr *rssn_solve_linear_system_handle(const struct rssn_Expr *aSystem,
                                                      const struct rssn_Vec_String *aVars)
;

/*
 Solves an ordinary differential equation.

 # Safety
 The caller must ensure `ode_expr` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_ode(const struct rssn_Expr *aOdeExpr,
                                 const char *aFunc,
                                 const char *aVar)
;

/*
 Solves a partial differential equation using automatic method selection.

 # Safety
 The caller must ensure `pde_expr` is a valid Expr pointer, `func` and `vars` are valid C strings,
 and `vars_len` accurately represents the number of variables.
 */
rssn_
struct rssn_Expr *rssn_solve_pde(const struct rssn_Expr *aPdeExpr,
                                 const char *aFunc,
                                 const char *const *aVars,
                                 size_t aVarsLen)
;

/*
 Solves a PDE using the method of characteristics.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_pde_by_characteristics(const struct rssn_Expr *aEquation,
                                                    const char *aFunc,
                                                    const char *const *aVars,
                                                    size_t aVarsLen)
;

/*
 Solves the 2D Poisson equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_poisson_equation_2d(const struct rssn_Expr *aEquation,
                                                 const char *aFunc,
                                                 const char *const *aVars,
                                                 size_t aVarsLen)
;

/*
 Solves a Riccati ODE with a known particular solution.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_riccati_ode(const struct rssn_Expr *aEquation,
                                         const char *aFunc,
                                         const char *aVar,
                                         const struct rssn_Expr *aY1)
;

/*
 Solves the SchrÃ¶dinger equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_schrodinger_equation(const struct rssn_Expr *aEquation,
                                                  const char *aFunc,
                                                  const char *const *aVars,
                                                  size_t aVarsLen)
;

/*
 Solves a separable ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_separable_ode(const struct rssn_Expr *aEquation,
                                           const char *aFunc,
                                           const char *aVar)
;

/*
 Solves the 1D wave equation using D'Alembert's formula.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_wave_equation_1d_dalembert(const struct rssn_Expr *aEquation,
                                                        const char *aFunc,
                                                        const char *const *aVars,
                                                        size_t aVarsLen)
;

/*
 Creates a square root expression: sqrt(expr).
 */
rssn_ struct rssn_Expr *rssn_sqrt(const struct rssn_Expr *aExpr) ;

/*
 Creates a square root expression from bincode: sqrt(expr).
 */
rssn_ struct rssn_BincodeBuffer rssn_sqrt_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a square root expression from JSON: sqrt(expr).
 */
rssn_ char *rssn_sqrt_json(const char *aJsonExpr) ;

/*
 Frees a State.
 */
rssn_ void rssn_state_free(struct rssn_State *aState) ;

/*
 Gets the intermediate value from the state.
 The returned string must be freed by the caller using rssn_free_string.
 */
rssn_ char *rssn_state_get_intermediate_value(const struct rssn_State *aState) ;

/*
 Gets the intermediate value from a bincode state buffer.
 Returns the value as a bincode buffer containing a String.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
struct rssn_BincodeBuffer rssn_state_get_intermediate_value_bincode(struct rssn_BincodeBuffer aStateBuffer)
;

/*
 Gets the intermediate value from a JSON state string.
 Returns the value as a plain string (not JSON-encoded).
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_state_get_intermediate_value_json(const char *aJsonState) ;

/*
 Creates a new State.
 The caller is responsible for freeing the memory using rssn_state_free.
 */
rssn_ struct rssn_State *rssn_state_new(void) ;

/*
 Creates a new State and returns it as a bincode buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_ struct rssn_BincodeBuffer rssn_state_new_bincode(void) ;

/*
 Creates a new State and returns it as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_state_new_json(void) ;

/*
 Sets the intermediate value in the state.
 */
rssn_ void rssn_state_set_intermediate_value(struct rssn_State *aState, const char *aValue) ;

/*
 Sets the intermediate value in a bincode state buffer and returns the updated buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
struct rssn_BincodeBuffer rssn_state_set_intermediate_value_bincode(struct rssn_BincodeBuffer aStateBuffer,
                                                                    struct rssn_BincodeBuffer aValueBuffer)
;

/*
 Sets the intermediate value in a JSON state string and returns the updated JSON.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_state_set_intermediate_value_json(const char *aJsonState, const char *aValue) ;

rssn_
int32_t rssn_stats_covariance(const double *aD1,
                              const double *aD2,
                              size_t aLen,
                              double *aResult)
;

rssn_ int32_t rssn_stats_mean(const double *aData, size_t aLen, double *aResult) ;

rssn_ int32_t rssn_stats_std_dev(const double *aData, size_t aLen, double *aResult) ;

rssn_ int32_t rssn_stats_variance(const double *aData, size_t aLen, double *aResult) ;

/*
 Substitutes a variable with an expression.
 */
rssn_
struct rssn_Expr *rssn_substitute(const struct rssn_Expr *aExpr,
                                  const char *aVar,
                                  const struct rssn_Expr *aReplacement)
;

rssn_
struct rssn_Expr *rssn_summation_handle(const struct rssn_Expr *aExpr,
                                        const char *aVar,
                                        const struct rssn_Expr *aLower,
                                        const struct rssn_Expr *aUpper)
;

/*
 Computes the surface integral (flux) of a vector field.
 */
rssn_
char *rssn_surface_integral(const char *aFieldX,
                            const char *aFieldY,
                            const char *aFieldZ,
                            const struct rssn_ParametricSurface *aSurface)
;

/*
 Computes the surface integral (flux) of a vector field (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_surface_integral_bincode(const uint8_t *aInputPtr,
                                                        size_t aInputLen)
;

/*
 Computes the surface integral (flux) of a vector field (JSON).
 */
rssn_ char *rssn_surface_integral_json(const char *aInputJson) ;

/*
 Creates a tangent expression: tan(expr).
 */
rssn_ struct rssn_Expr *rssn_tan(const struct rssn_Expr *aExpr) ;

/*
 Creates a tangent expression from bincode: tan(expr).
 */
rssn_ struct rssn_BincodeBuffer rssn_tan_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a tangent expression from JSON: tan(expr).
 */
rssn_ char *rssn_tan_json(const char *aJsonExpr) ;

rssn_
struct rssn_Expr *rssn_taylor_series_handle(const struct rssn_Expr *aExpr,
                                            const char *aVar,
                                            const struct rssn_Expr *aCenter,
                                            size_t aOrder)
;

rssn_
struct rssn_Tensor *rssn_tensor_add_handle(const struct rssn_Tensor *aT1,
                                           const struct rssn_Tensor *aT2)
;

rssn_
struct rssn_Tensor *rssn_tensor_contract_handle(const struct rssn_Tensor *aT,
                                                size_t aAxis1,
                                                size_t aAxis2)
;

rssn_
struct rssn_Tensor *rssn_tensor_outer_product_handle(const struct rssn_Tensor *aT1,
                                                     const struct rssn_Tensor *aT2)
;

rssn_
struct rssn_Tensor *rssn_tensor_scalar_mul_handle(const struct rssn_Tensor *aT,
                                                  const struct rssn_Expr *aScalar)
;

/*
 Allocates and returns a test string ("pong") to the caller.

 This function serves as a more advanced health check for the FFI interface.
 It allows the client to verify two things:
 1. That the FFI function can be called successfully.
 2. That memory allocated in Rust can be safely passed to and then freed by the client
    by calling `free_string` on the returned pointer.

 Returns a pointer to a null-terminated C string. The caller is responsible for freeing this string.
 */
rssn_ char *rssn_test_string_passing(void) ;

/*
 Converts a logical expression to Conjunctive Normal Form (CNF) using handle-based FFI.

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_ struct rssn_Expr *rssn_to_cnf_handle(const struct rssn_Expr *aExpr) ;

/*
 Converts a logical expression to Disjunctive Normal Form (DNF) using handle-based FFI.

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_ struct rssn_Expr *rssn_to_dnf_handle(const struct rssn_Expr *aExpr) ;

rssn_
struct rssn_Vec_Expr *rssn_transform_contravariant_vector_handle(const struct rssn_Vec_Expr *aComps,
                                                                 enum rssn_CoordinateSystem aFrom,
                                                                 enum rssn_CoordinateSystem aTo)
;

rssn_
struct rssn_Vec_Expr *rssn_transform_covariant_vector_handle(const struct rssn_Vec_Expr *aComps,
                                                             enum rssn_CoordinateSystem aFrom,
                                                             enum rssn_CoordinateSystem aTo)
;

rssn_
struct rssn_Vec_Expr *rssn_transform_curl_handle(const struct rssn_Vec_Expr *aComps,
                                                 enum rssn_CoordinateSystem aFrom)
;

rssn_
struct rssn_Expr *rssn_transform_divergence_handle(const struct rssn_Vec_Expr *aComps,
                                                   enum rssn_CoordinateSystem aFrom)
;

rssn_
struct rssn_Expr *rssn_transform_expression_handle(const struct rssn_Expr *aExpr,
                                                   enum rssn_CoordinateSystem aFrom,
                                                   enum rssn_CoordinateSystem aTo)
;

rssn_
struct rssn_Vec_Expr *rssn_transform_gradient_handle(const struct rssn_Expr *aScalar,
                                                     const struct rssn_Vec_String *aVars,
                                                     enum rssn_CoordinateSystem aFrom,
                                                     enum rssn_CoordinateSystem aTo)
;

rssn_
struct rssn_Vec_Expr *rssn_transform_point_handle(const struct rssn_Vec_Expr *aPoint,
                                                  enum rssn_CoordinateSystem aFrom,
                                                  enum rssn_CoordinateSystem aTo)
;

rssn_ struct rssn_Expr *rssn_unify_expression_handle(const struct rssn_Expr *aExpr) ;

/*
 Computes the dot product of two vectors.
 */
rssn_
int32_t rssn_vec_dot_product(const double *aD1,
                             size_t aL1,
                             const double *aD2,
                             size_t aL2,
                             double *aResult)
;

/*
 Computes the L2 norm of a vector.
 */
rssn_ int32_t rssn_vec_norm(const double *aData, size_t aLen, double *aResult) ;

rssn_ rssn_Vector *rssn_vector_cross_handle(const rssn_Vector *aV1, const rssn_Vector *aV2) ;

rssn_ struct rssn_Expr *rssn_vector_dot_handle(const rssn_Vector *aV1, const rssn_Vector *aV2) ;

rssn_ struct rssn_Expr *rssn_vector_magnitude_handle(const rssn_Vector *aV) ;

rssn_ rssn_Vector *rssn_vector_normalize_handle(const rssn_Vector *aV) ;

/*
 Frees a Volterra integral equation.
 */
rssn_ void rssn_volterra_free(struct rssn_VolterraEquation *aPtr) ;

/*
 Creates a new Volterra integral equation.
 */
rssn_
struct rssn_VolterraEquation *rssn_volterra_new(const struct rssn_Expr *aYX,
                                                const struct rssn_Expr *aFX,
                                                const struct rssn_Expr *aLambda,
                                                const struct rssn_Expr *aKernel,
                                                const struct rssn_Expr *aLowerBound,
                                                const char *aVarX,
                                                const char *aVarT)
;

/*
 Solves a Volterra equation by differentiation.
 */
rssn_
struct rssn_Expr *rssn_volterra_solve_by_differentiation(const struct rssn_VolterraEquation *aEq)
;

/*
 Solves a Volterra equation by differentiation (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_volterra_solve_by_differentiation_bincode(const uint8_t *aInputPtr,
                                                                         size_t aInputLen)
;

/*
 Solves a Volterra equation by differentiation (JSON).
 */
rssn_ char *rssn_volterra_solve_by_differentiation_json(const char *aInputJson) ;

/*
 Solves a Volterra equation using successive approximations.
 */
rssn_
struct rssn_Expr *rssn_volterra_solve_successive(const struct rssn_VolterraEquation *aEq,
                                                 size_t aIterations)
;

/*
 Solves a Volterra equation using successive approximations (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_volterra_solve_successive_bincode(const uint8_t *aInputPtr,
                                                                 size_t aInputLen)
;

/*
 Solves a Volterra equation using successive approximations (JSON).
 */
rssn_ char *rssn_volterra_solve_successive_json(const char *aInputJson) ;

/*
 Frees a Volume handle.
 */
rssn_ void rssn_volume_free(struct rssn_Volume *aVolume) ;

/*
 Computes the volume integral of a scalar field.
 */
rssn_ char *rssn_volume_integral(const char *aScalarField, const struct rssn_Volume *aVolume) ;

/*
 Computes the volume integral of a scalar field (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_volume_integral_bincode(const uint8_t *aInputPtr,
                                                       size_t aInputLen)
;

/*
 Computes the volume integral of a scalar field (JSON).
 */
rssn_ char *rssn_volume_integral_json(const char *aInputJson) ;

/*
 Creates a new Volume.
 */
rssn_
struct rssn_Volume *rssn_volume_new(const char *aZLower,
                                    const char *aZUpper,
                                    const char *aYLower,
                                    const char *aYUpper,
                                    const char *aXLower,
                                    const char *aXUpper,
                                    const char *aXVar,
                                    const char *aYVar,
                                    const char *aZVar)
;

rssn_ DEPRECATED_WITH_NOTE char *stats_percentile(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *stats_simple_linear_regression(const char *aJsonPtr) ;

/*
 Computes the Fast Fourier Transform (FFT) of a sequence of complex numbers.
 */
rssn_ DEPRECATED_WITH_NOTE char *transforms_fft(const char *aJsonPtr) ;

/*
 Computes the Inverse Fast Fourier Transform (IFFT) of a sequence of complex numbers.
 */
rssn_ DEPRECATED_WITH_NOTE char *transforms_ifft(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *vector_scalar_mul(const char *aJsonPtr) ;

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#ifdef __cplusplus
}  // namespace rssn
#endif  // __cplusplus

#endif  /* RSSN_H */
