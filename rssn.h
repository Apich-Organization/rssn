#ifndef RSSN_H
#define RSSN_H

/* Generated with cbindgen:0.29.2 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#ifdef __cplusplus
namespace rssn {
#endif  // __cplusplus

/*
 Represents the result of a convergence test.
 */
typedef enum rssn_ConvergenceResult {
    /*
     The series is determined to converge.
     */
    Converges,
    /*
     The series is determined to diverge.
     */
    Diverges,
    /*
     The convergence could not be determined with the available tests.
     */
    Inconclusive,
} rssn_ConvergenceResult;

/*
 Defines the monomial ordering to be used in polynomial division.
 */
typedef enum rssn_MonomialOrder {
    Lexicographical,
    GradedLexicographical,
    GradedReverseLexicographical,
} rssn_MonomialOrder;

typedef enum rssn_CoordinateSystem {
    Cartesian,
    Cylindrical,
    Spherical,
} rssn_CoordinateSystem;

/*
 A thread-safe cache for computation results.

 This cache stores the mapping from expressions to their computed values.
 It avoids re-computing the value of the same expression multiple times.
 */
typedef struct rssn_ComputationResultCache rssn_ComputationResultCache;

/*
 The central enum representing a mathematical expression in the symbolic system.

 `Expr` is an Abstract Syntax Tree (AST) that can represent a wide variety of
 mathematical objects and operations. Manual implementations for `Debug`, `Clone`,
 `PartialEq`, `Eq`, and `Hash` are provided to handle variants containing types
 that do not derive these traits automatically (e.g., `f64`, `Arc<dyn Distribution>`).
 */
typedef struct rssn_Expr rssn_Expr;

/*
 A thread-safe cache for parsed expressions.

 This cache stores the mapping from input strings to parsed `Expr` objects.
 It avoids re-parsing the same string multiple times.
 */
typedef struct rssn_ParsingCache rssn_ParsingCache;

/*
 Represents the state of a computation.

 This struct holds intermediate values and other context information
 required during a computation.
 */
typedef struct rssn_State rssn_State;

typedef struct rssn_Tensor rssn_Tensor;

typedef struct rssn_Vec_Expr rssn_Vec_Expr;

typedef struct rssn_Vec_SparsePolynomial rssn_Vec_SparsePolynomial;

typedef struct rssn_Vec_String rssn_Vec_String;

/*
 Represents a symbolic vector in 3D space.
 */
typedef struct rssn_Vector rssn_Vector;

/*
 A buffer containing binary data from bincode serialization.

 The caller is responsible for freeing this buffer using `rssn_free_bincode_buffer`.
 */
typedef struct rssn_BincodeBuffer {
    /*
     Pointer to the binary data.
     */
    uint8_t *mData;
    /*
     Length of the binary data in bytes.
     */
    size_t mLen;
} rssn_BincodeBuffer;

typedef struct rssn_FfiPoint {
    double mX;
    double mY;
} rssn_FfiPoint;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/*
 Computes the definite integral of an `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_definite_integrate(struct rssn_Expr *aHandle,
                                          const char *aVarPtr,
                                          struct rssn_Expr *aLowerHandle,
                                          struct rssn_Expr *aUpperHandle)
;

/*
 Differentiates an `Expr` and returns a handle to the new, derivative expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_differentiate(struct rssn_Expr *aHandle,
                                     const char *aVarPtr)
;

/*
 Computes the indefinite integral of an `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_integrate(struct rssn_Expr *aHandle,
                                 const char *aVarPtr)
;

/*
 Computes the limit of an `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_limit(struct rssn_Expr *aHandle,
                             const char *aVarPtr,
                             struct rssn_Expr *aToHandle)
;

/*
 Simplifies an `Expr` and returns a handle to the new, simplified expression.

 The caller is responsible for freeing the returned handle using `expr_free`.
 */
rssn_ DEPRECATED_WITH_NOTE struct rssn_Expr *expr_simplify(struct rssn_Expr *aHandle) ;

/*
 Solves an equation for a given variable and returns the solutions as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *expr_solve(struct rssn_Expr *aHandle, const char *aVarPtr) ;

/*
 Substitutes a variable in an `Expr` with another `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *expr_substitute(struct rssn_Expr *aHandle,
                                  const char *aVarPtr,
                                  struct rssn_Expr *aReplacementHandle)
;

/*
 Converts an expression to a LaTeX string.

 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_ char *expr_to_latex(struct rssn_Expr *aHandle) ;

/*
 Converts an expression to a formatted, pretty-printed string.

 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_ char *expr_to_pretty_string(struct rssn_Expr *aHandle) ;

/*
 Returns the string representation of an `Expr` handle.

 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_ char *expr_to_string(struct rssn_Expr *aHandle) ;

/*
 Attempts to unify the units within an expression.

 Returns a JSON string representing a `FfiResult` which contains either the
 new `Expr` object in the `ok` field or an error message in the `err` field.
 The caller can then use `expr_from_json` to get a handle to the new expression.
 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_ char *expr_unify_expression(struct rssn_Expr *aHandle) ;

/*
 Frees a C string that was allocated by this library.
 */
rssn_ void free_string(char *aS) ;

/*
 Evaluates a point on a BÃ©zier curve and returns the coordinates as a JSON string.
 */
rssn_ char *interpolate_bezier_curve(const char *aJsonPtr) ;

/*
 Computes a Lagrange interpolating polynomial and returns its coefficients as a JSON string.
 */
rssn_ char *interpolate_lagrange(const char *aJsonPtr) ;

/*
 Adds two matrices and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_add(struct rssn_Expr *aH1,
                             struct rssn_Expr *aH2)
;

/*
 Computes the characteristic polynomial of a matrix and returns the result as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_characteristic_polynomial(struct rssn_Expr *aHandle,
                                       const char *aVarPtr)
;

/*
 Computes the determinant of a matrix and returns a handle to the resulting expression.
 */
rssn_ DEPRECATED_WITH_NOTE struct rssn_Expr *matrix_determinant(struct rssn_Expr *aHandle) ;

/*
 Computes the eigenvalue decomposition of a matrix and returns the eigenvalues and eigenvectors as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_eigen_decomposition(struct rssn_Expr *aHandle)
;

/*
 Creates an identity matrix of a given size and returns a handle to it.
 */
rssn_ DEPRECATED_WITH_NOTE struct rssn_Expr *matrix_identity(size_t aSize) ;

/*
 Inverts a matrix and returns a handle to the new matrix expression.
 */
rssn_ DEPRECATED_WITH_NOTE struct rssn_Expr *matrix_inverse(struct rssn_Expr *aHandle) ;

/*
 Computes the LU decomposition of a matrix and returns the L and U matrices as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *matrix_lu_decomposition(struct rssn_Expr *aHandle) ;

/*
 Multiplies two matrices and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_mul(struct rssn_Expr *aH1,
                             struct rssn_Expr *aH2)
;

/*
 Computes the null space of a matrix and returns the result as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *matrix_null_space(struct rssn_Expr *aHandle) ;

/*
 Computes the Reduced Row Echelon Form (RREF) of a matrix and returns the result as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *matrix_rref(struct rssn_Expr *aHandle) ;

/*
 Multiplies a matrix by a scalar and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_scalar_mul(struct rssn_Expr *aScalarHandle,
                                    struct rssn_Expr *aMatrixHandle)
;

/*
 Subtracts the second matrix from the first and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *matrix_sub(struct rssn_Expr *aH1,
                             struct rssn_Expr *aH2)
;

/*
 Computes the trace of a matrix and returns the result as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *matrix_trace(struct rssn_Expr *aHandle) ;

/*
 Transposes a matrix and returns a handle to the new matrix expression.
 */
rssn_ DEPRECATED_WITH_NOTE struct rssn_Expr *matrix_transpose(struct rssn_Expr *aHandle) ;

rssn_ DEPRECATED_WITH_NOTE char *nt_mod_inverse(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *nt_mod_pow(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *numerical_gradient(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *numerical_integrate(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *physics_solve_advection_diffusion_1d(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE int64_t poly_degree(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE struct rssn_Expr *poly_from_coeffs_vec(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE bool poly_is_polynomial(const char *aJsonPtr) ;

rssn_
DEPRECATED_WITH_NOTE
struct rssn_Expr *poly_leading_coefficient(struct rssn_Expr *aHandle,
                                           const char *aVarPtr)
;

rssn_ DEPRECATED_WITH_NOTE char *poly_long_division(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *poly_to_coeffs_vec(const char *aJsonPtr) ;

/*
 Checks if an expression contains a variable (handle-based)
 */
rssn_ bool polynomial_contains_var_handle(const struct rssn_Expr *aExprHandle, const char *aVar) ;

/*
 Computes the degree of a polynomial (handle-based)
 */
rssn_ int64_t polynomial_degree_handle(const struct rssn_Expr *aExprHandle, const char *aVar) ;

/*
 Frees an Expr handle
 */
rssn_ void polynomial_free_expr_handle(struct rssn_Expr *aExprHandle) ;

/*
 Checks if an expression is a polynomial in the given variable (handle-based)
 */
rssn_ bool polynomial_is_polynomial_handle(const struct rssn_Expr *aExprHandle, const char *aVar) ;

/*
 Finds the leading coefficient of a polynomial (handle-based)
 */
rssn_
struct rssn_Expr *polynomial_leading_coefficient_handle(const struct rssn_Expr *aExprHandle,
                                                        const char *aVar)
;

/*
 Performs polynomial long division (handle-based)
 */
rssn_
void polynomial_long_division_handle(const struct rssn_Expr *aDividendHandle,
                                     const struct rssn_Expr *aDivisorHandle,
                                     const char *aVar,
                                     struct rssn_Expr **aQuotientOut,
                                     struct rssn_Expr **aRemainderOut)
;

rssn_
struct rssn_Expr *rssn_analytic_continuation_handle(const struct rssn_Expr *aExpr,
                                                    const char *aVar,
                                                    const struct rssn_Expr *aOrigCenter,
                                                    const struct rssn_Expr *aNewCenter,
                                                    size_t aOrder)
;

rssn_
enum rssn_ConvergenceResult rssn_analyze_convergence_handle(const struct rssn_Expr *aTerm,
                                                            const char *aVar)
;

rssn_
struct rssn_Expr *rssn_asymptotic_expansion_handle(const struct rssn_Expr *aExpr,
                                                   const char *aVar,
                                                   const struct rssn_Expr *aPoint,
                                                   size_t aOrder)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_analytic_continuation(struct rssn_BincodeBuffer aExprBuf,
                                                             struct rssn_BincodeBuffer aVarBuf,
                                                             struct rssn_BincodeBuffer aOrigCenterBuf,
                                                             struct rssn_BincodeBuffer aNewCenterBuf,
                                                             struct rssn_BincodeBuffer aOrderBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_analyze_convergence(struct rssn_BincodeBuffer aTermBuf,
                                                           struct rssn_BincodeBuffer aVarBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_asymptotic_expansion(struct rssn_BincodeBuffer aExprBuf,
                                                            struct rssn_BincodeBuffer aVarBuf,
                                                            struct rssn_BincodeBuffer aPointBuf,
                                                            struct rssn_BincodeBuffer aOrderBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_buchberger(struct rssn_BincodeBuffer aBasisBuf,
                                                  struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Calculates residue using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_calculate_residue(struct rssn_BincodeBuffer aExprBuf,
                                                         const char *aVar,
                                                         struct rssn_BincodeBuffer aPoleBuf)
;

/*
 Checks analytic using Bincode.
 */
rssn_ bool rssn_bincode_check_analytic(struct rssn_BincodeBuffer aExprBuf, const char *aVar) ;

/*
 Classifies a PDE (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_classify_pde(struct rssn_BincodeBuffer aEquationBuf,
                                                    const char *aFunc,
                                                    struct rssn_BincodeBuffer aVarsBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_coordinates_get_metric_tensor(struct rssn_BincodeBuffer aSystemBuf)
;

/*
 Computes definite integral using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_definite_integrate(struct rssn_BincodeBuffer aExprBuf,
                                                          const char *aVar,
                                                          struct rssn_BincodeBuffer aLowerBuf,
                                                          struct rssn_BincodeBuffer aUpperBuf)
;

/*
 Differentiates an expression using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_differentiate(struct rssn_BincodeBuffer aExprBuf,
                                                     const char *aVar)
;

/*
 Evaluates at point using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_evaluate_at_point(struct rssn_BincodeBuffer aExprBuf,
                                                         const char *aVar,
                                                         struct rssn_BincodeBuffer aValueBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_evaluate_numerical(struct rssn_BincodeBuffer aExprBuf)
;

/*
 Finds pole order using Bincode.
 */
rssn_
size_t rssn_bincode_find_pole_order(struct rssn_BincodeBuffer aExprBuf,
                                    const char *aVar,
                                    struct rssn_BincodeBuffer aPoleBuf)
;

/*
 Finds poles using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_find_poles(struct rssn_BincodeBuffer aExprBuf,
                                                  const char *aVar)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_fourier_series(struct rssn_BincodeBuffer aExprBuf,
                                                      struct rssn_BincodeBuffer aVarBuf,
                                                      struct rssn_BincodeBuffer aPeriodBuf,
                                                      struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Gets real and imaginary parts using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_get_real_imag_parts(struct rssn_BincodeBuffer aExprBuf)
;

/*
 Simplifies an expression using the heuristic simplifier (Bincode input/output).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_heuristic_simplify(struct rssn_BincodeBuffer aExprBuf)
;

/*
 Integrates an expression using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_integrate(struct rssn_BincodeBuffer aExprBuf,
                                                 const char *aVar)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_laurent_series(struct rssn_BincodeBuffer aExprBuf,
                                                      struct rssn_BincodeBuffer aVarBuf,
                                                      struct rssn_BincodeBuffer aCenterBuf,
                                                      struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Computes limit using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_limit(struct rssn_BincodeBuffer aExprBuf,
                                             const char *aVar,
                                             struct rssn_BincodeBuffer aPointBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_add(struct rssn_BincodeBuffer aM1Buf,
                                                  struct rssn_BincodeBuffer aM2Buf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_determinant(struct rssn_BincodeBuffer aMatrixBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_matrix_inverse(struct rssn_BincodeBuffer aMatrixBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_mul(struct rssn_BincodeBuffer aM1Buf,
                                                  struct rssn_BincodeBuffer aM2Buf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_solve_linear_system(struct rssn_BincodeBuffer aABuf,
                                                                  struct rssn_BincodeBuffer aBBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_matrix_transpose(struct rssn_BincodeBuffer aMatrixBuf)
;

/*
 Computes path integral using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_path_integrate(struct rssn_BincodeBuffer aExprBuf,
                                                      const char *aVar,
                                                      struct rssn_BincodeBuffer aContourBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_poly_division_multivariate(struct rssn_BincodeBuffer aDividendBuf,
                                                                  struct rssn_BincodeBuffer aDivisorsBuf,
                                                                  struct rssn_BincodeBuffer aOrderBuf)
;

/*
 Checks if an expression contains a variable (bincode)
 */
rssn_
bool rssn_bincode_polynomial_contains_var(struct rssn_BincodeBuffer aExprBuf,
                                          const char *aVar)
;

/*
 Computes the degree of a polynomial (bincode)
 */
rssn_ int64_t rssn_bincode_polynomial_degree(struct rssn_BincodeBuffer aExprBuf, const char *aVar) ;

/*
 Checks if an expression is a polynomial in the given variable (bincode)
 */
rssn_
bool rssn_bincode_polynomial_is_polynomial(struct rssn_BincodeBuffer aExprBuf,
                                           const char *aVar)
;

/*
 Finds the leading coefficient of a polynomial (bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_polynomial_leading_coefficient(struct rssn_BincodeBuffer aExprBuf,
                                                                      const char *aVar)
;

/*
 Performs polynomial long division (bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_polynomial_long_division(struct rssn_BincodeBuffer aDividendBuf,
                                                                struct rssn_BincodeBuffer aDivisorBuf,
                                                                const char *aVar)
;

/*
 Converts polynomial to coefficient vector (bincode)
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_polynomial_to_coeffs_vec(struct rssn_BincodeBuffer aExprBuf,
                                                                const char *aVar)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_product(struct rssn_BincodeBuffer aExprBuf,
                                               struct rssn_BincodeBuffer aVarBuf,
                                               struct rssn_BincodeBuffer aLowerBuf,
                                               struct rssn_BincodeBuffer aUpperBuf)
;

/*
 Simplifies an expression using the legacy simplifier (Bincode input/output).
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_simplify(struct rssn_BincodeBuffer aExprBuf) ;

/*
 Simplifies an expression using the DAG-based simplifier (Bincode input/output).
 */
rssn_ struct rssn_BincodeBuffer rssn_bincode_simplify_dag(struct rssn_BincodeBuffer aExprBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_solve(struct rssn_BincodeBuffer aExprBuf,
                                             struct rssn_BincodeBuffer aVarBuf)
;

/*
 Solves a Bernoulli ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_bernoulli_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                           const char *aFunc,
                                                           const char *aVar)
;

/*
 Solves by reduction of order using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_by_reduction_of_order(struct rssn_BincodeBuffer aEquationBuf,
                                                                   const char *aFunc,
                                                                   const char *aVar,
                                                                   struct rssn_BincodeBuffer aY1Buf)
;

/*
 Solves a Cauchy-Euler ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_cauchy_euler_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                              const char *aFunc,
                                                              const char *aVar)
;

/*
 Solves an exact ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_exact_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                       const char *aFunc,
                                                       const char *aVar)
;

/*
 Solves a first-order linear ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_first_order_linear_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                                    const char *aFunc,
                                                                    const char *aVar)
;

/*
 Solves the 1D heat equation (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_heat_equation_1d(struct rssn_BincodeBuffer aEquationBuf,
                                                              const char *aFunc,
                                                              struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves the 2D Laplace equation (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_laplace_equation_2d(struct rssn_BincodeBuffer aEquationBuf,
                                                                 const char *aFunc,
                                                                 struct rssn_BincodeBuffer aVarsBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_linear_system(struct rssn_BincodeBuffer aSystemBuf,
                                                           struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves an ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_ode(struct rssn_BincodeBuffer aOdeBuf,
                                                 const char *aFunc,
                                                 const char *aVar)
;

/*
 Solves a PDE using Bincode with automatic method selection.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_pde(struct rssn_BincodeBuffer aPdeBuf,
                                                 const char *aFunc,
                                                 struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves a PDE using the method of characteristics (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_pde_by_characteristics(struct rssn_BincodeBuffer aEquationBuf,
                                                                    const char *aFunc,
                                                                    struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves a Riccati ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_riccati_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                         const char *aFunc,
                                                         const char *aVar,
                                                         struct rssn_BincodeBuffer aY1Buf)
;

/*
 Solves a separable ODE using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_separable_ode(struct rssn_BincodeBuffer aEquationBuf,
                                                           const char *aFunc,
                                                           const char *aVar)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_system(struct rssn_BincodeBuffer aEquationsBuf,
                                                    struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves the 1D wave equation (Bincode).
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_solve_wave_equation_1d(struct rssn_BincodeBuffer aEquationBuf,
                                                              const char *aFunc,
                                                              struct rssn_BincodeBuffer aVarsBuf)
;

/*
 Substitutes using Bincode.
 */
rssn_
struct rssn_BincodeBuffer rssn_bincode_substitute(struct rssn_BincodeBuffer aExprBuf,
                                                  const char *aVar,
                                                  struct rssn_BincodeBuffer aReplacementBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_summation(struct rssn_BincodeBuffer aExprBuf,
                                                 struct rssn_BincodeBuffer aVarBuf,
                                                 struct rssn_BincodeBuffer aLowerBuf,
                                                 struct rssn_BincodeBuffer aUpperBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_taylor_series(struct rssn_BincodeBuffer aExprBuf,
                                                     struct rssn_BincodeBuffer aVarBuf,
                                                     struct rssn_BincodeBuffer aCenterBuf,
                                                     struct rssn_BincodeBuffer aOrderBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_tensor_add(struct rssn_BincodeBuffer aT1Buf,
                                                  struct rssn_BincodeBuffer aT2Buf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_tensor_outer_product(struct rssn_BincodeBuffer aT1Buf,
                                                            struct rssn_BincodeBuffer aT2Buf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_tensor_scalar_mul(struct rssn_BincodeBuffer aTBuf,
                                                         struct rssn_BincodeBuffer aScalarBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_contravariant_vector(struct rssn_BincodeBuffer aCompsBuf,
                                                                      struct rssn_BincodeBuffer aFromBuf,
                                                                      struct rssn_BincodeBuffer aToBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_covariant_vector(struct rssn_BincodeBuffer aCompsBuf,
                                                                  struct rssn_BincodeBuffer aFromBuf,
                                                                  struct rssn_BincodeBuffer aToBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_curl(struct rssn_BincodeBuffer aCompsBuf,
                                                      struct rssn_BincodeBuffer aFromBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_divergence(struct rssn_BincodeBuffer aCompsBuf,
                                                            struct rssn_BincodeBuffer aFromBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_expression(struct rssn_BincodeBuffer aExprBuf,
                                                            struct rssn_BincodeBuffer aFromBuf,
                                                            struct rssn_BincodeBuffer aToBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_gradient(struct rssn_BincodeBuffer aScalarBuf,
                                                          struct rssn_BincodeBuffer aVarsBuf,
                                                          struct rssn_BincodeBuffer aFromBuf,
                                                          struct rssn_BincodeBuffer aToBuf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_transform_point(struct rssn_BincodeBuffer aPointBuf,
                                                       struct rssn_BincodeBuffer aFromBuf,
                                                       struct rssn_BincodeBuffer aToBuf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_unify_expression(struct rssn_BincodeBuffer aExprBuf) ;

rssn_
struct rssn_BincodeBuffer rssn_bincode_vector_cross(struct rssn_BincodeBuffer aV1Buf,
                                                    struct rssn_BincodeBuffer aV2Buf)
;

rssn_
struct rssn_BincodeBuffer rssn_bincode_vector_dot(struct rssn_BincodeBuffer aV1Buf,
                                                  struct rssn_BincodeBuffer aV2Buf)
;

rssn_ struct rssn_BincodeBuffer rssn_bincode_vector_magnitude(struct rssn_BincodeBuffer aVBuf) ;

rssn_ struct rssn_BincodeBuffer rssn_bincode_vector_normalize(struct rssn_BincodeBuffer aVBuf) ;

/*
 Computes binomial coefficient C(n, k).
 */
rssn_ char *rssn_binomial_coefficient(size_t aN, size_t aK) ;

/*
 Computes binomial coefficient C(n, k) and returns as JSON string.
 */
rssn_ char *rssn_binomial_coefficient_json(size_t aN, size_t aK) ;

rssn_
struct rssn_Vec_SparsePolynomial *rssn_buchberger_handle(const struct rssn_Vec_SparsePolynomial *aBasis,
                                                         enum rssn_MonomialOrder aOrder)
;

/*
 Calculates the residue of a complex function at a given pole.
 */
rssn_
struct rssn_Expr *rssn_calculate_residue(const struct rssn_Expr *aExpr,
                                         const char *aVar,
                                         const struct rssn_Expr *aPole)
;

rssn_
int32_t rssn_calculus_definite_integrate(size_t aExprH,
                                         const char *aVar,
                                         size_t aLowerH,
                                         size_t aUpperH,
                                         size_t *aResultH)
;

rssn_ int32_t rssn_calculus_differentiate(size_t aExprH, const char *aVar, size_t *aResultH) ;

rssn_ int32_t rssn_calculus_integrate(size_t aExprH, const char *aVar, size_t *aResultH) ;

rssn_ int32_t rssn_calculus_limit(size_t aExprH, const char *aVar, size_t aToH, size_t *aResultH) ;

rssn_
int32_t rssn_calculus_substitute(size_t aExprH,
                                 const char *aVar,
                                 size_t aReplacementH,
                                 size_t *aResultH)
;

/*
 Checks if an expression is analytic with respect to a variable.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `var` is a valid C string.
 */
rssn_ bool rssn_check_analytic(const struct rssn_Expr *aExpr, const char *aVar) ;

/*
 Computes the number of combinations (nCk).
 */
rssn_ int32_t rssn_comb_combinations(uint64_t aN, uint64_t aK, double *aResult) ;

/*
 Computes the factorial of a number.
 */
rssn_ int32_t rssn_comb_factorial(uint64_t aN, double *aResult) ;

/*
 Computes the number of permutations (nPk).
 */
rssn_ int32_t rssn_comb_permutations(uint64_t aN, uint64_t aK, double *aResult) ;

/*
 Clears a ComputationResultCache.
 */
rssn_ void rssn_computation_result_cache_clear(struct rssn_ComputationResultCache *aCache) ;

/*
 Frees a ComputationResultCache.
 */
rssn_ void rssn_computation_result_cache_free(struct rssn_ComputationResultCache *aCache) ;

/*
 Retrieves a value from the ComputationResultCache.
 Returns a C string (char*) which must be freed by the caller using rssn_free_string.
 Returns null if not found.
 */
rssn_
char *rssn_computation_result_cache_get(struct rssn_ComputationResultCache *aCache,
                                        const struct rssn_Expr *aExpr)
;

/*
 Retrieves a value from the ComputationResultCache using a bincode expression key.
 */
rssn_
struct rssn_BincodeBuffer rssn_computation_result_cache_get_bincode(struct rssn_ComputationResultCache *aCache,
                                                                    struct rssn_BincodeBuffer aExprBuffer)
;

/*
 Retrieves a value from the ComputationResultCache using a JSON expression key.
 Returns the value as a JSON string (e.g. "\"result\"").
 */
rssn_
char *rssn_computation_result_cache_get_json(struct rssn_ComputationResultCache *aCache,
                                             const char *aJsonExpr)
;

/*
 Creates a new ComputationResultCache.
 The caller is responsible for freeing the memory using rssn_computation_result_cache_free.
 */
rssn_ struct rssn_ComputationResultCache *rssn_computation_result_cache_new(void) ;

/*
 Stores a value in the ComputationResultCache.
 */
rssn_
void rssn_computation_result_cache_set(struct rssn_ComputationResultCache *aCache,
                                       const struct rssn_Expr *aExpr,
                                       const char *aValue)
;

/*
 Stores a value in the ComputationResultCache using bincode buffers.
 */
rssn_
void rssn_computation_result_cache_set_bincode(struct rssn_ComputationResultCache *aCache,
                                               struct rssn_BincodeBuffer aExprBuffer,
                                               struct rssn_BincodeBuffer aValueBuffer)
;

/*
 Stores a value in the ComputationResultCache using JSON strings.
 */
rssn_
void rssn_computation_result_cache_set_json(struct rssn_ComputationResultCache *aCache,
                                            const char *aJsonExpr,
                                            const char *aJsonValue)
;

rssn_
struct rssn_Expr *rssn_coordinates_get_metric_tensor_handle(enum rssn_CoordinateSystem aSystem)
;

/*
 Creates a cosine expression: cos(expr).
 */
rssn_ struct rssn_Expr *rssn_cos(const struct rssn_Expr *aExpr) ;

/*
 Creates a cosine expression from bincode: cos(expr).
 */
rssn_ struct rssn_BincodeBuffer rssn_cos_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a cosine expression from JSON: cos(expr).
 */
rssn_ char *rssn_cos_json(const char *aJsonExpr) ;

/*
 Computes the definite integral of an expression.
 */
rssn_
struct rssn_Expr *rssn_definite_integrate(const struct rssn_Expr *aExpr,
                                          const char *aVar,
                                          const struct rssn_Expr *aLower,
                                          const struct rssn_Expr *aUpper)
;

/*
 Differentiates an expression: d/d(var) expr.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `var` is a valid C string.
 */
rssn_ struct rssn_Expr *rssn_differentiate(const struct rssn_Expr *aExpr, const char *aVar) ;

/*
 Returns the symbolic representation of Euler's number (e).
 */
rssn_ struct rssn_Expr *rssn_e(void) ;

/*
 Returns Euler's number (e) as bincode.
 */
rssn_ struct rssn_BincodeBuffer rssn_e_bincode(void) ;

/*
 Returns Euler's number (e) as JSON.
 */
rssn_ char *rssn_e_json(void) ;

/*
 Evaluates an expression at a given point.
 */
rssn_
struct rssn_Expr *rssn_evaluate_at_point(const struct rssn_Expr *aExpr,
                                         const char *aVar,
                                         const struct rssn_Expr *aValue)
;

rssn_ double rssn_evaluate_numerical_handle(const struct rssn_Expr *aExpr) ;

/*
 Creates an exponential expression: e^(expr).
 */
rssn_ struct rssn_Expr *rssn_exp(const struct rssn_Expr *aExpr) ;

/*
 Creates an exponential expression from bincode: e^(expr).
 */
rssn_ struct rssn_BincodeBuffer rssn_exp_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates an exponential expression from JSON: e^(expr).
 */
rssn_ char *rssn_exp_json(const char *aJsonExpr) ;

/*
 Expands a symbolic expression.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_expand(const struct rssn_Expr *aExpr) ;

/*
 Expands a symbolic expression from bincode.
 */
rssn_ struct rssn_BincodeBuffer rssn_expand_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Expands a symbolic expression from JSON.
 */
rssn_ char *rssn_expand_json(const char *aJsonExpr) ;

/*
 Creates an expression from a JSON string and returns a thread-safe handle.

 Returns 0 if the JSON is invalid.
 */
rssn_ size_t rssn_expr_create(const char *aJsonPtr) ;

/*
 Frees the memory associated with an expression handle.
 */
rssn_ void rssn_expr_free(size_t aHandle) ;

/*
 Simplifies an expression handle and returns a handle to the new, simplified expression.

 Returns 0 on error (e.g., invalid handle).
 */
rssn_ size_t rssn_expr_simplify(const size_t *aHandle) ;

/*
 Computes the Fast Fourier Transform (FFT) of a sequence of complex numbers in-place.
 */
rssn_ int32_t rssn_fft(rssn_Complex<double> *aData, size_t aLen) ;

/*
 Finds the order of a pole.
 */
rssn_
size_t rssn_find_pole_order(const struct rssn_Expr *aExpr,
                            const char *aVar,
                            const struct rssn_Expr *aPole)
;

/*
 Finds poles of an expression.
 */
rssn_ struct rssn_Vec_Expr *rssn_find_poles(const struct rssn_Expr *aExpr, const char *aVar) ;

rssn_
struct rssn_Expr *rssn_fourier_series_handle(const struct rssn_Expr *aExpr,
                                             const char *aVar,
                                             const struct rssn_Expr *aPeriod,
                                             size_t aOrder)
;

/*
 Frees a bincode buffer allocated by an FFI function.

 # Safety
 The buffer must have been allocated by an FFI function that returns `BincodeBuffer`.
 This function should only be called once per buffer.
 */
rssn_ void rssn_free_bincode_buffer(struct rssn_BincodeBuffer aBuffer) ;

/*
 Frees an Expr pointer created by this module.

 # Safety
 The caller must ensure `expr` was created by this module and hasn't been freed yet.
 */
rssn_ void rssn_free_expr(struct rssn_Expr *aExpr) ;

rssn_ void rssn_free_poles(struct rssn_Vec_Expr *aPoles) ;

/*
 Frees a string allocated by an FFI function.

 # Safety
 The string must have been allocated by an FFI function that returns `*mut c_char`.
 This function should only be called once per string.
 */
rssn_ void rssn_free_string(char *aS) ;

/*
 Returns the build date as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_build_date(void) ;

/*
 Returns the build date as a bincode buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_ struct rssn_BincodeBuffer rssn_get_build_date_bincode(void) ;

/*
 Returns the build date as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_build_date_json(void) ;

/*
 Returns all build information as a bincode buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_ struct rssn_BincodeBuffer rssn_get_build_info_bincode(void) ;

/*
 Returns all build information as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_build_info_json(void) ;

/*
 Returns the cargo target triple as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_cargo_target_triple(void) ;

/*
 Returns the commit SHA as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_commit_sha(void) ;

/*
 Returns the commit SHA as a bincode buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_ struct rssn_BincodeBuffer rssn_get_commit_sha_bincode(void) ;

/*
 Returns the commit SHA as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_commit_sha_json(void) ;

/*
 Retrieves the last error message set by an FFI function on the current thread.

 The returned pointer is valid until the next call to an FFI function on the same thread.
 The caller should not free this pointer.
 */
rssn_ const char *rssn_get_last_error(void) ;

/*
 Gets real and imaginary parts of an expression.
 Returns a pointer to a tuple (Expr, Expr) - represented as Vec<Expr> of size 2 for simplicity?
 Or return two out pointers?
 I'll return a Vec<Expr> of size 2.
 */
rssn_ struct rssn_Vec_Expr *rssn_get_real_imag_parts(const struct rssn_Expr *aExpr) ;

/*
 Returns the rustc version as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_rustc_version(void) ;

/*
 Returns the system info as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_system_info(void) ;

/*
 Simplifies an expression using the heuristic simplifier.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_heuristic_simplify(const struct rssn_Expr *aExpr) ;

/*
 Computes the Inverse Fast Fourier Transform (IFFT) of a sequence of complex numbers in-place.
 */
rssn_ int32_t rssn_ifft(rssn_Complex<double> *aData, size_t aLen) ;

/*
 Initializes the plugin manager with a specified plugin directory.

 This function must be called before any plugin operations are performed.

 # Arguments
 * `plugin_dir_ptr` - A null-terminated UTF-8 string for the plugin directory path.

 # Returns
 0 on success, -1 on failure. On failure, an error message can be retrieved
 with `rssn_get_last_error`.
 */
rssn_ int32_t rssn_init_plugin_manager(const char *aPluginDirPtr) ;

/*
 Integrates an expression: int(expr) d(var).

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `var` is a valid C string.
 */
rssn_ struct rssn_Expr *rssn_integrate(const struct rssn_Expr *aExpr, const char *aVar) ;

/*
 Evaluates a point on a Bezier curve defined by control points.
 */
rssn_
int32_t rssn_interp_bezier_curve(const struct rssn_FfiPoint *aPointsPtr,
                                 size_t aNumPoints,
                                 double aT,
                                 struct rssn_FfiPoint *aResultPtr)
;

/*
 Computes a Lagrange interpolating polynomial from a set of points.
 Returns a handle to the resulting polynomial expression.
 */
rssn_
int32_t rssn_interp_lagrange(const struct rssn_FfiPoint *aPointsPtr,
                             size_t aNumPoints,
                             size_t *aResultHandle)
;

rssn_
char *rssn_json_analytic_continuation(const char *aExprJson,
                                      const char *aVarJson,
                                      const char *aOrigCenterJson,
                                      const char *aNewCenterJson,
                                      const char *aOrderJson)
;

rssn_ char *rssn_json_analyze_convergence(const char *aTermJson, const char *aVarJson) ;

rssn_
char *rssn_json_asymptotic_expansion(const char *aExprJson,
                                     const char *aVarJson,
                                     const char *aPointJson,
                                     const char *aOrderJson)
;

rssn_ char *rssn_json_buchberger(const char *aBasisJson, const char *aOrderJson) ;

/*
 Calculates residue using JSON.
 */
rssn_
char *rssn_json_calculate_residue(const char *aExprJson,
                                  const char *aVar,
                                  const char *aPoleJson)
;

/*
 Checks analytic using JSON.
 */
rssn_ bool rssn_json_check_analytic(const char *aExprJson, const char *aVar) ;

/*
 Classifies a PDE and suggests solution methods (JSON).
 */
rssn_
char *rssn_json_classify_pde(const char *aEquationJson,
                             const char *aFunc,
                             const char *aVarsJson)
;

rssn_ char *rssn_json_coordinates_get_metric_tensor(enum rssn_CoordinateSystem aSystem) ;

/*
 Computes definite integral using JSON.
 */
rssn_
char *rssn_json_definite_integrate(const char *aExprJson,
                                   const char *aVar,
                                   const char *aLowerJson,
                                   const char *aUpperJson)
;

/*
 Differentiates an expression using JSON.
 */
rssn_ char *rssn_json_differentiate(const char *aExprJson, const char *aVar) ;

/*
 Evaluates at point using JSON.
 */
rssn_
char *rssn_json_evaluate_at_point(const char *aExprJson,
                                  const char *aVar,
                                  const char *aValueJson)
;

rssn_ char *rssn_json_evaluate_numerical(const char *aExprJson) ;

/*
 Finds pole order using JSON.
 */
rssn_
size_t rssn_json_find_pole_order(const char *aExprJson,
                                 const char *aVar,
                                 const char *aPoleJson)
;

/*
 Finds poles using JSON.
 */
rssn_ char *rssn_json_find_poles(const char *aExprJson, const char *aVar) ;

rssn_
char *rssn_json_fourier_series(const char *aExprJson,
                               const char *aVarJson,
                               const char *aPeriodJson,
                               const char *aOrderJson)
;

/*
 Gets real and imaginary parts using JSON.
 */
rssn_ char *rssn_json_get_real_imag_parts(const char *aExprJson) ;

/*
 Simplifies an expression using the heuristic simplifier (JSON input/output).
 */
rssn_ char *rssn_json_heuristic_simplify(const char *aExprJson) ;

/*
 Integrates an expression using JSON.
 */
rssn_ char *rssn_json_integrate(const char *aExprJson, const char *aVar) ;

rssn_
char *rssn_json_laurent_series(const char *aExprJson,
                               const char *aVarJson,
                               const char *aCenterJson,
                               const char *aOrderJson)
;

/*
 Computes limit using JSON.
 */
rssn_ char *rssn_json_limit(const char *aExprJson, const char *aVar, const char *aPointJson) ;

rssn_ char *rssn_json_matrix_add(const char *aM1Json, const char *aM2Json) ;

rssn_ char *rssn_json_matrix_determinant(const char *aMatrixJson) ;

rssn_ char *rssn_json_matrix_inverse(const char *aMatrixJson) ;

rssn_ char *rssn_json_matrix_mul(const char *aM1Json, const char *aM2Json) ;

rssn_ char *rssn_json_matrix_solve_linear_system(const char *aAJson, const char *aBJson) ;

rssn_ char *rssn_json_matrix_transpose(const char *aMatrixJson) ;

/*
 Computes path integral using JSON.
 */
rssn_
char *rssn_json_path_integrate(const char *aExprJson,
                               const char *aVar,
                               const char *aContourJson)
;

rssn_
char *rssn_json_poly_division_multivariate(const char *aDividendJson,
                                           const char *aDivisorsJson,
                                           const char *aOrderJson)
;

/*
 Checks if an expression contains a variable (JSON)
 */
rssn_ bool rssn_json_polynomial_contains_var(const char *aExprJson, const char *aVar) ;

/*
 Computes the degree of a polynomial (JSON)
 */
rssn_ int64_t rssn_json_polynomial_degree(const char *aExprJson, const char *aVar) ;

/*
 Checks if an expression is a polynomial in the given variable (JSON)
 */
rssn_ bool rssn_json_polynomial_is_polynomial(const char *aExprJson, const char *aVar) ;

/*
 Finds the leading coefficient of a polynomial (JSON)
 */
rssn_ char *rssn_json_polynomial_leading_coefficient(const char *aExprJson, const char *aVar) ;

/*
 Performs polynomial long division (JSON)
 */
rssn_
char *rssn_json_polynomial_long_division(const char *aDividendJson,
                                         const char *aDivisorJson,
                                         const char *aVar)
;

/*
 Converts polynomial to coefficient vector (JSON)
 */
rssn_ char *rssn_json_polynomial_to_coeffs_vec(const char *aExprJson, const char *aVar) ;

rssn_
char *rssn_json_product(const char *aExprJson,
                        const char *aVarJson,
                        const char *aLowerJson,
                        const char *aUpperJson)
;

/*
 Simplifies an expression using the legacy simplifier (JSON input/output).
 */
rssn_ char *rssn_json_simplify(const char *aExprJson) ;

/*
 Simplifies an expression using the DAG-based simplifier (JSON input/output).
 */
rssn_ char *rssn_json_simplify_dag(const char *aExprJson) ;

rssn_ char *rssn_json_solve(const char *aExprJson, const char *aVarJson) ;

/*
 Solves a Bernoulli ODE using JSON.
 */
rssn_
char *rssn_json_solve_bernoulli_ode(const char *aEquationJson,
                                    const char *aFunc,
                                    const char *aVar)
;

/*
 Solves by reduction of order using JSON.
 */
rssn_
char *rssn_json_solve_by_reduction_of_order(const char *aEquationJson,
                                            const char *aFunc,
                                            const char *aVar,
                                            const char *aY1Json)
;

/*
 Solves a Cauchy-Euler ODE using JSON.
 */
rssn_
char *rssn_json_solve_cauchy_euler_ode(const char *aEquationJson,
                                       const char *aFunc,
                                       const char *aVar)
;

/*
 Solves an exact ODE using JSON.
 */
rssn_
char *rssn_json_solve_exact_ode(const char *aEquationJson,
                                const char *aFunc,
                                const char *aVar)
;

/*
 Solves a first-order linear ODE using JSON.
 */
rssn_
char *rssn_json_solve_first_order_linear_ode(const char *aEquationJson,
                                             const char *aFunc,
                                             const char *aVar)
;

/*
 Solves the 1D heat equation (JSON).
 */
rssn_
char *rssn_json_solve_heat_equation_1d(const char *aEquationJson,
                                       const char *aFunc,
                                       const char *aVarsJson)
;

/*
 Solves the 2D Laplace equation (JSON).
 */
rssn_
char *rssn_json_solve_laplace_equation_2d(const char *aEquationJson,
                                          const char *aFunc,
                                          const char *aVarsJson)
;

rssn_ char *rssn_json_solve_linear_system(const char *aSystemJson, const char *aVarsJson) ;

/*
 Solves an ODE using JSON.
 */
rssn_ char *rssn_json_solve_ode(const char *aOdeJson, const char *aFunc, const char *aVar) ;

/*
 Solves a PDE using JSON with automatic method selection.
 */
rssn_ char *rssn_json_solve_pde(const char *aPdeJson, const char *aFunc, const char *aVarsJson) ;

/*
 Solves a PDE using the method of characteristics (JSON).
 */
rssn_
char *rssn_json_solve_pde_by_characteristics(const char *aEquationJson,
                                             const char *aFunc,
                                             const char *aVarsJson)
;

/*
 Solves the 2D Poisson equation (JSON).
 */
rssn_
char *rssn_json_solve_poisson_equation_2d(const char *aEquationJson,
                                          const char *aFunc,
                                          const char *aVarsJson)
;

/*
 Solves a Riccati ODE using JSON.
 */
rssn_
char *rssn_json_solve_riccati_ode(const char *aEquationJson,
                                  const char *aFunc,
                                  const char *aVar,
                                  const char *aY1Json)
;

/*
 Solves a separable ODE using JSON.
 */
rssn_
char *rssn_json_solve_separable_ode(const char *aEquationJson,
                                    const char *aFunc,
                                    const char *aVar)
;

rssn_ char *rssn_json_solve_system(const char *aEquationsJson, const char *aVarsJson) ;

/*
 Solves the 1D wave equation using D'Alembert's formula (JSON).
 */
rssn_
char *rssn_json_solve_wave_equation_1d(const char *aEquationJson,
                                       const char *aFunc,
                                       const char *aVarsJson)
;

/*
 Substitutes using JSON.
 */
rssn_
char *rssn_json_substitute(const char *aExprJson,
                           const char *aVar,
                           const char *aReplacementJson)
;

rssn_
char *rssn_json_summation(const char *aExprJson,
                          const char *aVarJson,
                          const char *aLowerJson,
                          const char *aUpperJson)
;

rssn_
char *rssn_json_taylor_series(const char *aExprJson,
                              const char *aVarJson,
                              const char *aCenterJson,
                              const char *aOrderJson)
;

rssn_ char *rssn_json_tensor_add(const char *aT1Json, const char *aT2Json) ;

rssn_ char *rssn_json_tensor_contract(const char *aTJson, size_t aAxis1, size_t aAxis2) ;

rssn_ char *rssn_json_tensor_outer_product(const char *aT1Json, const char *aT2Json) ;

rssn_ char *rssn_json_tensor_scalar_mul(const char *aTJson, const char *aScalarJson) ;

rssn_
char *rssn_json_transform_contravariant_vector(const char *aCompsJson,
                                               enum rssn_CoordinateSystem aFrom,
                                               enum rssn_CoordinateSystem aTo)
;

rssn_
char *rssn_json_transform_covariant_vector(const char *aCompsJson,
                                           enum rssn_CoordinateSystem aFrom,
                                           enum rssn_CoordinateSystem aTo)
;

rssn_ char *rssn_json_transform_curl(const char *aCompsJson, enum rssn_CoordinateSystem aFrom) ;

rssn_
char *rssn_json_transform_divergence(const char *aCompsJson,
                                     enum rssn_CoordinateSystem aFrom)
;

rssn_
char *rssn_json_transform_expression(const char *aExprJson,
                                     enum rssn_CoordinateSystem aFrom,
                                     enum rssn_CoordinateSystem aTo)
;

rssn_
char *rssn_json_transform_gradient(const char *aScalarJson,
                                   const char *aVarsJson,
                                   enum rssn_CoordinateSystem aFrom,
                                   enum rssn_CoordinateSystem aTo)
;

rssn_
char *rssn_json_transform_point(const char *aPointJson,
                                enum rssn_CoordinateSystem aFrom,
                                enum rssn_CoordinateSystem aTo)
;

rssn_ char *rssn_json_unify_expression(const char *aExprJson) ;

rssn_ char *rssn_json_vector_cross(const char *aV1Json, const char *aV2Json) ;

rssn_
char *rssn_json_vector_curl(const char *aVJson,
                            const char *aXVar,
                            const char *aYVar,
                            const char *aZVar)
;

rssn_
char *rssn_json_vector_divergence(const char *aVJson,
                                  const char *aXVar,
                                  const char *aYVar,
                                  const char *aZVar)
;

rssn_ char *rssn_json_vector_dot(const char *aV1Json, const char *aV2Json) ;

rssn_
char *rssn_json_vector_gradient(const char *aScalarFieldJson,
                                const char *aXVar,
                                const char *aYVar,
                                const char *aZVar)
;

rssn_ char *rssn_json_vector_magnitude(const char *aVJson) ;

rssn_ char *rssn_json_vector_normalize(const char *aVJson) ;

rssn_
struct rssn_Expr *rssn_laurent_series_handle(const struct rssn_Expr *aExpr,
                                             const char *aVar,
                                             const struct rssn_Expr *aCenter,
                                             size_t aOrder)
;

/*
 Computes the limit of an expression: limit(expr, var -> point).

 # Safety
 The caller must ensure `expr` and `point` are valid Expr pointers and `var` is a valid C string.
 */
rssn_
struct rssn_Expr *rssn_limit(const struct rssn_Expr *aExpr,
                             const char *aVar,
                             const struct rssn_Expr *aPoint)
;

/*
 Creates a natural logarithm expression: ln(expr).
 */
rssn_ struct rssn_Expr *rssn_ln(const struct rssn_Expr *aExpr) ;

/*
 Creates a natural logarithm expression from bincode: ln(expr).
 */
rssn_ struct rssn_BincodeBuffer rssn_ln_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a natural logarithm expression from JSON: ln(expr).
 */
rssn_ char *rssn_ln_json(const char *aJsonExpr) ;

rssn_ int32_t rssn_matrix_add(size_t aH1, size_t aH2, size_t *aResultH) ;

rssn_
struct rssn_Expr *rssn_matrix_add_handle(const struct rssn_Expr *aM1,
                                         const struct rssn_Expr *aM2)
;

rssn_ int32_t rssn_matrix_determinant(size_t aH, size_t *aResultH) ;

rssn_ struct rssn_Expr *rssn_matrix_determinant_handle(const struct rssn_Expr *aMatrix) ;

rssn_ int32_t rssn_matrix_identity(size_t aSize, size_t *aResultH) ;

rssn_ int32_t rssn_matrix_inverse(size_t aH, size_t *aResultH) ;

rssn_ struct rssn_Expr *rssn_matrix_inverse_handle(const struct rssn_Expr *aMatrix) ;

rssn_ int32_t rssn_matrix_mul(size_t aH1, size_t aH2, size_t *aResultH) ;

rssn_
struct rssn_Expr *rssn_matrix_mul_handle(const struct rssn_Expr *aM1,
                                         const struct rssn_Expr *aM2)
;

rssn_ int32_t rssn_matrix_scalar_mul(size_t aScalarH, size_t aMatrixH, size_t *aResultH) ;

rssn_
struct rssn_Expr *rssn_matrix_solve_linear_system_handle(const struct rssn_Expr *aA,
                                                         const struct rssn_Expr *aB)
;

rssn_ int32_t rssn_matrix_sub(size_t aH1, size_t aH2, size_t *aResultH) ;

rssn_ int32_t rssn_matrix_transpose(size_t aH, size_t *aResultH) ;

rssn_ struct rssn_Expr *rssn_matrix_transpose_handle(const struct rssn_Expr *aMatrix) ;

/*
 Computes the greatest common divisor (GCD) of two numbers.

 Returns 0 on success, -1 on error.
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_ int32_t rssn_nt_gcd(uint64_t aA, uint64_t aB, uint64_t *aResult) ;

/*
 Checks if a number is prime using the Miller-Rabin test.

 Returns 0 on success, -1 on error.
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_ int32_t rssn_nt_is_prime(uint64_t aN, bool *aResult) ;

/*
 Computes the modular multiplicative inverse.

 Returns 0 on success, -1 on error (e.g., if no inverse exists).
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_ int32_t rssn_nt_mod_inverse(int64_t aA, int64_t aB, int64_t *aResult) ;

/*
 Computes modular exponentiation (base^exp % modulus).

 Returns 0 on success, -1 on error.
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_ int32_t rssn_nt_mod_pow(uint64_t aBase, uint64_t aExp, uint64_t aModulus, uint64_t *aResult) ;

rssn_
int32_t rssn_numerical_gradient(size_t aExprH,
                                const char *const *aVars,
                                size_t aNumVars,
                                const double *aPoint,
                                size_t aPointLen,
                                double *aResultVec)
;

rssn_
int32_t rssn_numerical_integrate(size_t aExprH,
                                 const char *aVar,
                                 double aStart,
                                 double aEnd,
                                 size_t aNSteps,
                                 uint32_t aMethod,
                                 double *aResult)
;

/*
 Clears a ParsingCache.
 */
rssn_ void rssn_parsing_cache_clear(struct rssn_ParsingCache *aCache) ;

/*
 Frees a ParsingCache.
 */
rssn_ void rssn_parsing_cache_free(struct rssn_ParsingCache *aCache) ;

/*
 Retrieves an expression from the ParsingCache.
 Returns a pointer to the Expr (Arc<Expr> with incremented refcount), or null if not found.
 The caller is responsible for freeing the returned Expr (using the appropriate Expr free function).
 */
rssn_
struct rssn_Expr *rssn_parsing_cache_get(struct rssn_ParsingCache *aCache,
                                         const char *aInput)
;

/*
 Retrieves an expression from the ParsingCache as a bincode buffer.
 */
rssn_
struct rssn_BincodeBuffer rssn_parsing_cache_get_bincode(struct rssn_ParsingCache *aCache,
                                                         const char *aInput)
;

/*
 Retrieves an expression from the ParsingCache as a JSON string.
 Returns null if not found or error.
 */
rssn_ char *rssn_parsing_cache_get_json(struct rssn_ParsingCache *aCache, const char *aInput) ;

/*
 Creates a new ParsingCache.
 The caller is responsible for freeing the memory using rssn_parsing_cache_free.
 */
rssn_ struct rssn_ParsingCache *rssn_parsing_cache_new(void) ;

/*
 Stores an expression in the ParsingCache.
 The expr pointer is cloned (deep copy of the structure, but DAG nodes are shared).
 */
rssn_
void rssn_parsing_cache_set(struct rssn_ParsingCache *aCache,
                            const char *aInput,
                            const struct rssn_Expr *aExpr)
;

/*
 Stores an expression in the ParsingCache from a bincode buffer.
 */
rssn_
void rssn_parsing_cache_set_bincode(struct rssn_ParsingCache *aCache,
                                    const char *aInput,
                                    struct rssn_BincodeBuffer aBuffer)
;

/*
 Stores an expression in the ParsingCache from a JSON string.
 */
rssn_
void rssn_parsing_cache_set_json(struct rssn_ParsingCache *aCache,
                                 const char *aInput,
                                 const char *aJsonExpr)
;

/*
 Computes a path integral.
 */
rssn_
struct rssn_Expr *rssn_path_integrate(const struct rssn_Expr *aExpr,
                                      const char *aVar,
                                      const struct rssn_Expr *aContour)
;

rssn_
int32_t rssn_physics_advection_diffusion_1d(const double *aInitialCond,
                                            size_t aLen,
                                            double aDx,
                                            double aC,
                                            double aD,
                                            double aDt,
                                            size_t aSteps,
                                            double *aResultPtr)
;

/*
 Returns the symbolic representation of Pi.
 */
rssn_ struct rssn_Expr *rssn_pi(void) ;

/*
 Returns Pi as bincode.
 */
rssn_ struct rssn_BincodeBuffer rssn_pi_bincode(void) ;

/*
 Returns Pi as JSON.
 */
rssn_ char *rssn_pi_json(void) ;

/*
 Executes a command on a loaded plugin.

 # Arguments
 * `plugin_name_ptr` - A null-terminated UTF-8 string representing the plugin's name.
 * `command_ptr` - A null-terminated UTF-8 string for the command to execute.
 * `args_handle` - A handle to the `Expr` object to be passed as an argument.

 # Returns
 A handle to the resulting `Expr` object on success, or 0 on failure.
 On failure, an error message can be retrieved with `rssn_get_last_error`.
 */
rssn_
size_t rssn_plugin_execute(const char *aPluginNamePtr,
                           const char *aCommandPtr,
                           size_t aArgsHandle)
;

rssn_ struct rssn_Expr *rssn_poles_get(const struct rssn_Vec_Expr *aPoles, size_t aIndex) ;

rssn_ size_t rssn_poles_len(const struct rssn_Vec_Expr *aPoles) ;

rssn_ int32_t rssn_poly_degree(size_t aExprHandle, const char *aVarPtr, int64_t *aResult) ;

rssn_ int32_t rssn_poly_is_polynomial(size_t aExprHandle, const char *aVarPtr, bool *aResult) ;

rssn_
int32_t rssn_poly_long_division(size_t aNHandle,
                                size_t aDHandle,
                                const char *aVarPtr,
                                size_t *aQHandle,
                                size_t *aRHandle)
;

/*
 Creates a power expression: base^exp.
 */
rssn_ struct rssn_Expr *rssn_pow(const struct rssn_Expr *aBase, const struct rssn_Expr *aExp) ;

/*
 Creates a power expression from bincode: base^exp.

 # Arguments
 * `base_buffer` - Bincode-serialized base Expr
 * `exp_buffer` - Bincode-serialized exponent Expr
 */
rssn_
struct rssn_BincodeBuffer rssn_pow_bincode(struct rssn_BincodeBuffer aBaseBuffer,
                                           struct rssn_BincodeBuffer aExpBuffer)
;

/*
 Creates a power expression from JSON: base^exp.

 # Arguments
 * `json_base` - JSON-serialized base Expr
 * `json_exp` - JSON-serialized exponent Expr
 */
rssn_ char *rssn_pow_json(const char *aJsonBase, const char *aJsonExp) ;

rssn_
struct rssn_Expr *rssn_product_handle(const struct rssn_Expr *aExpr,
                                      const char *aVar,
                                      const struct rssn_Expr *aLower,
                                      const struct rssn_Expr *aUpper)
;

rssn_
enum rssn_ConvergenceResult *rssn_series_analyze_convergence_handle(const struct rssn_Expr *aSeries,
                                                                    const char *aVar)
;

rssn_
struct rssn_BincodeBuffer rssn_series_bincode_analyze_convergence(struct rssn_BincodeBuffer aSeriesBuf,
                                                                  struct rssn_BincodeBuffer aVarBuf)
;

rssn_ char *rssn_series_json_analyze_convergence(const char *aSeriesJson, const char *aVarJson) ;

/*
 Simplifies an expression using the legacy simplifier.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_simplify(const struct rssn_Expr *aExpr) ;

/*
 Simplifies an expression using the DAG-based simplifier.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_simplify_dag(const struct rssn_Expr *aExpr) ;

/*
 Creates a sine expression: sin(expr).

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ struct rssn_Expr *rssn_sin(const struct rssn_Expr *aExpr) ;

/*
 Creates a sine expression from bincode: sin(expr).

 # Arguments
 * `expr_buffer` - Bincode-serialized Expr

 # Returns
 Bincode-serialized Expr
 */
rssn_ struct rssn_BincodeBuffer rssn_sin_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a sine expression from JSON: sin(expr).

 # Arguments
 * `json_expr` - JSON-serialized Expr

 # Returns
 JSON-serialized Expr or null on error
 */
rssn_ char *rssn_sin_json(const char *aJsonExpr) ;

rssn_ int32_t rssn_solve(size_t aExprH, const char *aVar, size_t *aResultH) ;

/*
 Solves a Bernoulli ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_bernoulli_ode(const struct rssn_Expr *aEquation,
                                           const char *aFunc,
                                           const char *aVar)
;

/*
 Solves a second-order ODE by reduction of order with a known solution.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_by_reduction_of_order(const struct rssn_Expr *aEquation,
                                                   const char *aFunc,
                                                   const char *aVar,
                                                   const struct rssn_Expr *aY1)
;

/*
 Solves a Cauchy-Euler ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_cauchy_euler_ode(const struct rssn_Expr *aEquation,
                                              const char *aFunc,
                                              const char *aVar)
;

/*
 Solves an exact ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_exact_ode(const struct rssn_Expr *aEquation,
                                       const char *aFunc,
                                       const char *aVar)
;

/*
 Solves a first-order linear ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_first_order_linear_ode(const struct rssn_Expr *aEquation,
                                                    const char *aFunc,
                                                    const char *aVar)
;

rssn_ struct rssn_Vec_Expr *rssn_solve_handle(const struct rssn_Expr *aExpr, const char *aVar) ;

/*
 Solves the 1D heat equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_heat_equation_1d(const struct rssn_Expr *aEquation,
                                              const char *aFunc,
                                              const char *const *aVars,
                                              size_t aVarsLen)
;

/*
 Solves the Helmholtz equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_helmholtz_equation(const struct rssn_Expr *aEquation,
                                                const char *aFunc,
                                                const char *const *aVars,
                                                size_t aVarsLen)
;

/*
 Solves the Klein-Gordon equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_klein_gordon_equation(const struct rssn_Expr *aEquation,
                                                   const char *aFunc,
                                                   const char *const *aVars,
                                                   size_t aVarsLen)
;

/*
 Solves the 2D Laplace equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_laplace_equation_2d(const struct rssn_Expr *aEquation,
                                                 const char *aFunc,
                                                 const char *const *aVars,
                                                 size_t aVarsLen)
;

rssn_
struct rssn_Vec_Expr *rssn_solve_linear_system_handle(const struct rssn_Expr *aSystem,
                                                      const struct rssn_Vec_String *aVars)
;

/*
 Solves an ordinary differential equation.

 # Safety
 The caller must ensure `ode_expr` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_ode(const struct rssn_Expr *aOdeExpr,
                                 const char *aFunc,
                                 const char *aVar)
;

/*
 Solves a partial differential equation using automatic method selection.

 # Safety
 The caller must ensure `pde_expr` is a valid Expr pointer, `func` and `vars` are valid C strings,
 and `vars_len` accurately represents the number of variables.
 */
rssn_
struct rssn_Expr *rssn_solve_pde(const struct rssn_Expr *aPdeExpr,
                                 const char *aFunc,
                                 const char *const *aVars,
                                 size_t aVarsLen)
;

/*
 Solves a PDE using the method of characteristics.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_pde_by_characteristics(const struct rssn_Expr *aEquation,
                                                    const char *aFunc,
                                                    const char *const *aVars,
                                                    size_t aVarsLen)
;

/*
 Solves the 2D Poisson equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_poisson_equation_2d(const struct rssn_Expr *aEquation,
                                                 const char *aFunc,
                                                 const char *const *aVars,
                                                 size_t aVarsLen)
;

/*
 Solves a Riccati ODE with a known particular solution.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_riccati_ode(const struct rssn_Expr *aEquation,
                                         const char *aFunc,
                                         const char *aVar,
                                         const struct rssn_Expr *aY1)
;

/*
 Solves the SchrÃ¶dinger equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_schrodinger_equation(const struct rssn_Expr *aEquation,
                                                  const char *aFunc,
                                                  const char *const *aVars,
                                                  size_t aVarsLen)
;

/*
 Solves a separable ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
struct rssn_Expr *rssn_solve_separable_ode(const struct rssn_Expr *aEquation,
                                           const char *aFunc,
                                           const char *aVar)
;

/*
 Solves the 1D wave equation using D'Alembert's formula.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
struct rssn_Expr *rssn_solve_wave_equation_1d_dalembert(const struct rssn_Expr *aEquation,
                                                        const char *aFunc,
                                                        const char *const *aVars,
                                                        size_t aVarsLen)
;

/*
 Creates a square root expression: sqrt(expr).
 */
rssn_ struct rssn_Expr *rssn_sqrt(const struct rssn_Expr *aExpr) ;

/*
 Creates a square root expression from bincode: sqrt(expr).
 */
rssn_ struct rssn_BincodeBuffer rssn_sqrt_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a square root expression from JSON: sqrt(expr).
 */
rssn_ char *rssn_sqrt_json(const char *aJsonExpr) ;

/*
 Frees a State.
 */
rssn_ void rssn_state_free(struct rssn_State *aState) ;

/*
 Gets the intermediate value from the state.
 The returned string must be freed by the caller using rssn_free_string.
 */
rssn_ char *rssn_state_get_intermediate_value(const struct rssn_State *aState) ;

/*
 Gets the intermediate value from a bincode state buffer.
 Returns the value as a bincode buffer containing a String.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
struct rssn_BincodeBuffer rssn_state_get_intermediate_value_bincode(struct rssn_BincodeBuffer aStateBuffer)
;

/*
 Gets the intermediate value from a JSON state string.
 Returns the value as a plain string (not JSON-encoded).
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_state_get_intermediate_value_json(const char *aJsonState) ;

/*
 Creates a new State.
 The caller is responsible for freeing the memory using rssn_state_free.
 */
rssn_ struct rssn_State *rssn_state_new(void) ;

/*
 Creates a new State and returns it as a bincode buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_ struct rssn_BincodeBuffer rssn_state_new_bincode(void) ;

/*
 Creates a new State and returns it as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_state_new_json(void) ;

/*
 Sets the intermediate value in the state.
 */
rssn_ void rssn_state_set_intermediate_value(struct rssn_State *aState, const char *aValue) ;

/*
 Sets the intermediate value in a bincode state buffer and returns the updated buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
struct rssn_BincodeBuffer rssn_state_set_intermediate_value_bincode(struct rssn_BincodeBuffer aStateBuffer,
                                                                    struct rssn_BincodeBuffer aValueBuffer)
;

/*
 Sets the intermediate value in a JSON state string and returns the updated JSON.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_state_set_intermediate_value_json(const char *aJsonState, const char *aValue) ;

rssn_
int32_t rssn_stats_covariance(const double *aD1,
                              const double *aD2,
                              size_t aLen,
                              double *aResult)
;

rssn_ int32_t rssn_stats_mean(const double *aData, size_t aLen, double *aResult) ;

rssn_ int32_t rssn_stats_std_dev(const double *aData, size_t aLen, double *aResult) ;

rssn_ int32_t rssn_stats_variance(const double *aData, size_t aLen, double *aResult) ;

/*
 Substitutes a variable with an expression.
 */
rssn_
struct rssn_Expr *rssn_substitute(const struct rssn_Expr *aExpr,
                                  const char *aVar,
                                  const struct rssn_Expr *aReplacement)
;

rssn_
struct rssn_Expr *rssn_summation_handle(const struct rssn_Expr *aExpr,
                                        const char *aVar,
                                        const struct rssn_Expr *aLower,
                                        const struct rssn_Expr *aUpper)
;

/*
 Creates a tangent expression: tan(expr).
 */
rssn_ struct rssn_Expr *rssn_tan(const struct rssn_Expr *aExpr) ;

/*
 Creates a tangent expression from bincode: tan(expr).
 */
rssn_ struct rssn_BincodeBuffer rssn_tan_bincode(struct rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a tangent expression from JSON: tan(expr).
 */
rssn_ char *rssn_tan_json(const char *aJsonExpr) ;

rssn_
struct rssn_Expr *rssn_taylor_series_handle(const struct rssn_Expr *aExpr,
                                            const char *aVar,
                                            const struct rssn_Expr *aCenter,
                                            size_t aOrder)
;

rssn_
struct rssn_Tensor *rssn_tensor_add_handle(const struct rssn_Tensor *aT1,
                                           const struct rssn_Tensor *aT2)
;

rssn_
struct rssn_Tensor *rssn_tensor_contract_handle(const struct rssn_Tensor *aT,
                                                size_t aAxis1,
                                                size_t aAxis2)
;

rssn_
struct rssn_Tensor *rssn_tensor_outer_product_handle(const struct rssn_Tensor *aT1,
                                                     const struct rssn_Tensor *aT2)
;

rssn_
struct rssn_Tensor *rssn_tensor_scalar_mul_handle(const struct rssn_Tensor *aT,
                                                  const struct rssn_Expr *aScalar)
;

/*
 Allocates and returns a test string ("pong") to the caller.

 This function serves as a more advanced health check for the FFI interface.
 It allows the client to verify two things:
 1. That the FFI function can be called successfully.
 2. That memory allocated in Rust can be safely passed to and then freed by the client
    by calling `free_string` on the returned pointer.

 Returns a pointer to a null-terminated C string. The caller is responsible for freeing this string.
 */
rssn_ char *rssn_test_string_passing(void) ;

rssn_
struct rssn_Vec_Expr *rssn_transform_contravariant_vector_handle(const struct rssn_Vec_Expr *aComps,
                                                                 enum rssn_CoordinateSystem aFrom,
                                                                 enum rssn_CoordinateSystem aTo)
;

rssn_
struct rssn_Vec_Expr *rssn_transform_covariant_vector_handle(const struct rssn_Vec_Expr *aComps,
                                                             enum rssn_CoordinateSystem aFrom,
                                                             enum rssn_CoordinateSystem aTo)
;

rssn_
struct rssn_Vec_Expr *rssn_transform_curl_handle(const struct rssn_Vec_Expr *aComps,
                                                 enum rssn_CoordinateSystem aFrom)
;

rssn_
struct rssn_Expr *rssn_transform_divergence_handle(const struct rssn_Vec_Expr *aComps,
                                                   enum rssn_CoordinateSystem aFrom)
;

rssn_
struct rssn_Expr *rssn_transform_expression_handle(const struct rssn_Expr *aExpr,
                                                   enum rssn_CoordinateSystem aFrom,
                                                   enum rssn_CoordinateSystem aTo)
;

rssn_
struct rssn_Vec_Expr *rssn_transform_gradient_handle(const struct rssn_Expr *aScalar,
                                                     const struct rssn_Vec_String *aVars,
                                                     enum rssn_CoordinateSystem aFrom,
                                                     enum rssn_CoordinateSystem aTo)
;

rssn_
struct rssn_Vec_Expr *rssn_transform_point_handle(const struct rssn_Vec_Expr *aPoint,
                                                  enum rssn_CoordinateSystem aFrom,
                                                  enum rssn_CoordinateSystem aTo)
;

rssn_ struct rssn_Expr *rssn_unify_expression_handle(const struct rssn_Expr *aExpr) ;

/*
 Computes the dot product of two vectors.
 */
rssn_
int32_t rssn_vec_dot_product(const double *aD1,
                             size_t aL1,
                             const double *aD2,
                             size_t aL2,
                             double *aResult)
;

/*
 Computes the L2 norm of a vector.
 */
rssn_ int32_t rssn_vec_norm(const double *aData, size_t aLen, double *aResult) ;

rssn_ rssn_Vector *rssn_vector_cross_handle(const rssn_Vector *aV1, const rssn_Vector *aV2) ;

rssn_ struct rssn_Expr *rssn_vector_dot_handle(const rssn_Vector *aV1, const rssn_Vector *aV2) ;

rssn_ struct rssn_Expr *rssn_vector_magnitude_handle(const rssn_Vector *aV) ;

rssn_ rssn_Vector *rssn_vector_normalize_handle(const rssn_Vector *aV) ;

rssn_ DEPRECATED_WITH_NOTE char *stats_percentile(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *stats_simple_linear_regression(const char *aJsonPtr) ;

/*
 Computes the Fast Fourier Transform (FFT) of a sequence of complex numbers.
 */
rssn_ DEPRECATED_WITH_NOTE char *transforms_fft(const char *aJsonPtr) ;

/*
 Computes the Inverse Fast Fourier Transform (IFFT) of a sequence of complex numbers.
 */
rssn_ DEPRECATED_WITH_NOTE char *transforms_ifft(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *vector_scalar_mul(const char *aJsonPtr) ;

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#ifdef __cplusplus
}  // namespace rssn
#endif  // __cplusplus

#endif  /* RSSN_H */
