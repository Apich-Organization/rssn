#ifndef RSSN_H
#define RSSN_H

/* Generated with cbindgen:0.29.2 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <cstdarg>
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <ostream>
#include <new>

namespace rssn {

/*
 Atomic mass unit (kg)
 */
constexpr static const double rssn_ATOMIC_MASS_UNIT = 1.660539067e-27;

/*
 Avogadro's number (mol⁻¹)
 */
constexpr static const double rssn_AVOGADRO_NUMBER = 6.02214076e23;

/*
 Bohr radius (m)
 */
constexpr static const double rssn_BOHR_RADIUS = 5.291772109e-11;

/*
 Boltzmann constant (J/K)
 */
constexpr static const double rssn_BOLTZMANN_CONSTANT = 1.380649e-23;

/*
 Boltzmann constant in SI units (J/K)
 */
constexpr static const double rssn_BOLTZMANN_CONSTANT_SI = 1.380649e-23;

/*
 Coulomb constant k = 1/(4πε₀) (N·m²/C²)
 */
constexpr static const double rssn_COULOMB_CONSTANT = 8.987551787e9;

/*
 Electron mass (kg)
 */
constexpr static const double rssn_ELECTRON_MASS = 9.10938356e-31;

/*
 Elementary charge (C)
 */
constexpr static const double rssn_ELEMENTARY_CHARGE = 1.602176634e-19;

/*
 Reduced unit for energy (using argon as reference)
 1 reduced energy = ε ≈ 1.65e-21 J for argon
 */
constexpr static const double rssn_ENERGY_UNIT_ARGON = 1.65e-21;

/*
 Fine structure constant
 */
constexpr static const double rssn_FINE_STRUCTURE_CONSTANT = 7.297352566e-3;

/*
 Gas constant R = NA × kB (J/(mol·K))
 */
constexpr static const double rssn_GAS_CONSTANT = 8.314462618;

/*
 Gravitational constant (m³/(kg·s²))
 */
constexpr static const double rssn_GRAVITATIONAL_CONSTANT = 6.67430e-11;

/*
 Reduced Planck's constant ħ = h/(2π) (J·s)
 */
constexpr static const double rssn_HBAR = 1.054571817e-34;

/*
 Reduced unit for length (using argon as reference)
 1 reduced length = σ ≈ 3.4 Å for argon
 */
constexpr static const double rssn_LENGTH_UNIT_ARGON = 3.4e-10;

/*
 Neutron mass (kg)
 */
constexpr static const double rssn_NEUTRON_MASS = 1.674927351e-27;

/*
 Planck's constant (J·s)
 */
constexpr static const double rssn_PLANCK_CONSTANT = 6.62607015e-34;

/*
 Proton mass (kg)
 */
constexpr static const double rssn_PROTON_MASS = 1.672621898e-27;

/*
 Speed of light in vacuum (m/s)
 */
constexpr static const double rssn_SPEED_OF_LIGHT = 299792458.0;

/*
 Standard Earth gravity (m/s²)
 */
constexpr static const double rssn_STANDARD_GRAVITY = 9.80665;

/*
 Stefan-Boltzmann constant (W/(m²·K⁴))
 */
constexpr static const double rssn_STEFAN_BOLTZMANN = 5.670374419e-8;

/*
 Reduced unit for temperature (using argon as reference)
 1 reduced temperature = `ε/k_B` ≈ 120 K for argon
 */
constexpr static const double rssn_TEMPERATURE_UNIT_ARGON = 119.8;

/*
 Vacuum permeability μ₀ (H/m)
 */
constexpr static const double rssn_VACUUM_PERMEABILITY = 1.256637061e-6;

/*
 Vacuum permittivity ε₀ (F/m)
 */
constexpr static const double rssn_VACUUM_PERMITTIVITY = 8.854187817e-12;

/*
 Represents the result of a convergence test.
 */
enum class rssn_ConvergenceResult {
    /*
     The series is determined to converge.
     */
    RssnConvergenceResultConverges,
    /*
     The series is determined to diverge.
     */
    RssnConvergenceResultDiverges,
    /*
     The convergence could not be determined with the available tests.
     */
    RssnConvergenceResultInconclusive,
};

/*
 Defines the monomial ordering to be used in polynomial division.
 */
enum class rssn_MonomialOrder {
    RssnMonomialOrderLexicographical,
    RssnMonomialOrderGradedLexicographical,
    RssnMonomialOrderGradedReverseLexicographical,
};

enum class rssn_CoordinateSystem {
    RssnCoordinateSystemCartesian,
    RssnCoordinateSystemCylindrical,
    RssnCoordinateSystemSpherical,
};

template<typename T = void>
struct rssn_Arc;

/*
 Represents a Banach space, a complete normed vector space.

 This implementation specifically models L^p([a, b]), the space of functions for which
 the p-th power of their absolute value is Lebesgue integrable.
 */
struct rssn_BanachSpace;

/*
 Represents a Bézier curve defined by a set of control points.

 A Bézier curve of degree `n` is defined by `n + 1` control points. The curve
 starts at the first control point and ends at the last control point,
 passing smoothly between them based on the Bernstein polynomial basis.
 */
struct rssn_BezierCurve;

/*
 Represents a quantum state using Dirac notation (Bra).

 Symbolically, a bra is represented as `<state|`.
 */
struct rssn_Bra;

/*
 Represents the full Cylindrical Algebraic Decomposition of R^n.
 */
struct rssn_Cad;

/*
 RGBA color with values in [0, 1].
 */
struct rssn_Color;

/*
 Represents a complex dynamical system defined by z_{n+1} = `f(z_n)` + c.
 */
struct rssn_ComplexDynamicalSystem;

/*
 A thread-safe cache for computation results.

 This cache stores the mapping from expressions to their computed values.
 It avoids re-computing the value of the same expression multiple times.
 */
struct rssn_ComputationResultCache;

struct rssn_CriticalPoint;

/*
 Represents a crystal lattice with basis vectors.
 */
struct rssn_CrystalLattice;

/*
 Opaque type for cubic spline closure.
 */
struct rssn_CubicSplineHandle;

/*
 Represents a point on an elliptic curve, including the point at infinity.
 */
struct rssn_CurvePoint;

/*
 Represents a differential k-form.

 A k-form is a mathematical object that can be integrated over a k-dimensional manifold.
 It is a sum of terms, where each term is a scalar function (coefficient) multiplied by
 a wedge product of k basis 1-forms (like dx, dy, etc.).

 For example, a 2-form in R^3 could be `f(x,y,z) dx^dy + g(x,y,z) dx^dz`.

 Here, the basis wedge products (e.g., `dx^dy`) are represented by a bitmask (`blade`).
 If `vars = ["x", "y", "z"]`, then `dx` is `1<<0`, `dy` is `1<<1`, `dz` is `1<<2`.
 The wedge product `dx^dy` corresponds to the bitmask `(1<<0) | (1<<1) = 3`.
 */
struct rssn_DifferentialForm;

/*
 ECDH key pair containing private and public keys.
 */
struct rssn_EcdhKeyPair;

/*
 ECDSA signature containing r and s components.
 */
struct rssn_EcdsaSignature;

/*
 Represents an elliptic curve over a prime field: y^2 = x^3 + ax + b.
 */
struct rssn_EllipticCurve;

/*
 The central enum representing a mathematical expression in the symbolic system.

 `Expr` is an Abstract Syntax Tree (AST) that can represent a wide variety of
 mathematical objects and operations. Manual implementations for `Debug`, `Clone`,
 `PartialEq`, `Eq`, and `Hash` are provided to handle variants containing types
 that do not derive these traits automatically (e.g., `f64`, `Arc<dyn Distribution>`).
 */
struct rssn_Expr;

struct rssn_ExprList;

struct rssn_FfiOptimizationResult;

/*
 Represents a finite field GF(p) where p is the modulus.
 */
struct rssn_FiniteField;

struct rssn_FiniteFieldPolynomial;

/*
 Represents a Fredholm integral equation of the second kind.

 The equation has the form: `y(x) = f(x) + lambda * integral_a_b(K(x, t) * y(t) dt)`,
 where `y(x)` is the unknown function to be solved for.
 */
struct rssn_FredholmEquation;

/*
 Represents a graph with weighted edges for numerical algorithms.
 The graph is represented by an adjacency list.
 */
struct rssn_Graph;

/*
 Represents a group with its multiplication table.
 */
struct rssn_Group;

template<typename K = void, typename V = void, typename Hasher = void>
struct rssn_HashMap;

/*
 Represents a Hilbert space, a complete inner product space.
 This implementation specifically models L^2([a, b]), the space of square-integrable
 complex-valued functions on an interval [a, b].
 */
struct rssn_HilbertSpace;

/*
 Represents an Iterated Function System (IFS).

 An IFS is a finite set of contraction mappings on a complete metric space.
 It is often used to construct fractals (e.g., Sierpinski triangle, Barnsley fern).
 */
struct rssn_IteratedFunctionSystem;

/*
 Represents a quantum state using Dirac notation (Ket).

 Symbolically, a ket is represented as `|state>`.
 */
struct rssn_Ket;

/*
 Represents a Lie algebra, defined by its name and basis elements.
 */
struct rssn_LieAlgebra;

/*
 Represents common linear operators that act on functions in a vector space.
 */
struct rssn_LinearOperator;

/*
 Represents the solution to a system of linear equations.
 */
struct rssn_LinearSolution;

/*
 A generic dense matrix over any type that implements the Field trait.
 */
template<typename T = void>
struct rssn_Matrix;

/*
 Represents a 1D simulation domain, composed of a series of cells.
 */
struct rssn_Mesh;

/*
 Represents a numerical Möbius transformation: f(z) = (az + b) / (cz + d)
 */
struct rssn_MobiusTransformation;

/*
 Represents a multivector in a Clifford algebra.

 The basis blades are represented by a bitmask. E.g., in 3D:
 001 (1) -> e1, 010 (2) -> e2, 100 (4) -> e3
 011 (3) -> e12, 101 (5) -> e13, 110 (6) -> e23
 111 (7) -> e123 (pseudoscalar)
 */
struct rssn_Multivector;

/*
 Represents a multivector in 3D Geometric Algebra (`G_3`).
 Components are: 1 (scalar), e1, e2, e3 (vectors), e12, e23, e31 (bivectors), e123 (pseudoscalar)
 */
struct rssn_Multivector3D;

/*
 Represents a quantum operator.

 Symbolically, an operator `A` acts on a state `|ψ>` as `A|ψ>`.
 */
struct rssn_Operator;

/*
 Represents a parameterized curve C given by r(t).
 */
struct rssn_ParametricCurve;

/*
 Represents a parameterized surface S given by r(u, v).
 */
struct rssn_ParametricSurface;

/*
 A thread-safe cache for parsed expressions.

 This cache stores the mapping from input strings to parsed `Expr` objects.
 It avoids re-parsing the same string multiple times.
 */
struct rssn_ParsingCache;

/*
 Represents the analytic continuation of a function along a path.
 It is stored as a chain of series expansions, each centered at a point on the path.
 */
struct rssn_PathContinuation;

/*
 Represents a 3D object as a polygon mesh.
 A mesh is composed of a list of vertices (3D points) and a list of polygons (faces)
 that connect those vertices.
 */
struct rssn_PolygonMesh;

/*
 Represents a polynomial with f64 coefficients for numerical operations.
 */
struct rssn_Polynomial;

/*
 Represents an element in a prime field GF(p), where p is the modulus.

 The value is stored as a `u64`, and all arithmetic operations are performed
 modulo the specified `modulus`.
 */
struct rssn_PrimeFieldElement;

/*
 Represents a group representation.
 */
struct rssn_Representation;

/*
 Represents a rewrite rule, e.g., `lhs -> rhs`.
 */
struct rssn_RewriteRule;

/*
 Opaque handle for a Matrix<f64>.
 */
struct rssn_RssnMatrixHandle;

struct rssn_SPHSystem;

/*
 Represents a k-simplex as a set of its vertex indices.
 */
struct rssn_Simplex;

/*
 Represents a simplicial complex.
 */
struct rssn_SimplicialComplex;

/*
 Represents a singularity type in complex analysis.
 */
struct rssn_SingularityType;

/*
 Represents a sparse multivariate polynomial.

 A sparse polynomial is stored as a map from `Monomial`s to their `Expr` coefficients.
 This representation is highly efficient for polynomials with a small number of non-zero
 terms relative to the degree, such as `x^1000 + 1`.
 */
struct rssn_SparsePolynomial;

/*
 Represents the state of a computation.

 This struct holds intermediate values and other context information
 required during a computation.
 */
struct rssn_State;

struct rssn_String;

/*
 Represents a k-chain as a formal linear combination of k-simplices (symbolic version).
 */
struct rssn_SymbolicChain;

struct rssn_Tensor;

template<typename T = void>
struct rssn_Vec;

/*
 Represents a symbolic vector in 3D space.
 */
struct rssn_Vector;

/*
 Represents a Volterra integral equation of the second kind.

 The equation has the form: `y(x) = f(x) + lambda * integral_a_x(K(x, t) * y(t) dt)`.
 It is similar to the Fredholm equation, but the upper limit of integration is the variable `x`.
 */
struct rssn_VolterraEquation;

/*
 Represents a volume V for triple integration.
 Defines the integration order as dz dy dx.
 */
struct rssn_Volume;

/*
 A buffer containing binary data from bincode serialization.

 The caller is responsible for freeing this buffer using `rssn_free_bincode_buffer`.
 */
struct rssn_BincodeBuffer {
    /*
     Pointer to the binary data.
     */
    uint8_t *mData;
    /*
     Length of the binary data in bytes.
     */
    size_t mLen;

    rssn_BincodeBuffer(uint8_t *const& aMData,
                       size_t const& aMLen)
      : mData(aMData),
        mLen(aMLen)
    {}

    bool operator==(const rssn_BincodeBuffer& aOther) const {
        return mData == aOther.mData &&
               mLen == aOther.mLen;
    }
    bool operator!=(const rssn_BincodeBuffer& aOther) const {
        return mData != aOther.mData ||
               mLen != aOther.mLen;
    }
};

/*
 Opaque type for Graph<String> to work with cbindgen
 */
struct rssn_RssnGraph {
    uint8_t mPrivate[0];

    rssn_RssnGraph(uint8_t const& aMPrivate[0])
      : mPrivate(aMPrivate)
    {}

};

struct rssn_FfiPoint {
    double mX;
    double mY;

    rssn_FfiPoint(double const& aMX,
                  double const& aMY)
      : mX(aMX),
        mY(aMY)
    {}

    bool operator==(const rssn_FfiPoint& aOther) const {
        return mX == aOther.mX &&
               mY == aOther.mY;
    }
    bool operator!=(const rssn_FfiPoint& aOther) const {
        return mX != aOther.mX ||
               mY != aOther.mY;
    }
};

/*
 Structure to hold two expressions (e.g., transformed x and t).
 */
struct rssn_ExprPair {
    rssn_Expr *mFirst;
    rssn_Expr *mSecond;

    rssn_ExprPair(rssn_Expr *const& aMFirst,
                  rssn_Expr *const& aMSecond)
      : mFirst(aMFirst),
        mSecond(aMSecond)
    {}

    bool operator==(const rssn_ExprPair& aOther) const {
        return mFirst == aOther.mFirst &&
               mSecond == aOther.mSecond;
    }
    bool operator!=(const rssn_ExprPair& aOther) const {
        return mFirst != aOther.mFirst ||
               mSecond != aOther.mSecond;
    }
};

struct rssn_IsingResultHandle {
    rssn_Matrix<double> *mGrid;
    double mMagnetization;

    rssn_IsingResultHandle(rssn_Matrix<double> *const& aMGrid,
                           double const& aMMagnetization)
      : mGrid(aMGrid),
        mMagnetization(aMMagnetization)
    {}

    bool operator==(const rssn_IsingResultHandle& aOther) const {
        return mGrid == aOther.mGrid &&
               mMagnetization == aOther.mMagnetization;
    }
    bool operator!=(const rssn_IsingResultHandle& aOther) const {
        return mGrid != aOther.mGrid ||
               mMagnetization != aOther.mMagnetization;
    }
};

struct rssn_NavierStokesResultHandles {
    rssn_Matrix<double> *mU;
    rssn_Matrix<double> *mV;
    rssn_Matrix<double> *mP;

    rssn_NavierStokesResultHandles(rssn_Matrix<double> *const& aMU,
                                   rssn_Matrix<double> *const& aMV,
                                   rssn_Matrix<double> *const& aMP)
      : mU(aMU),
        mV(aMV),
        mP(aMP)
    {}

    bool operator==(const rssn_NavierStokesResultHandles& aOther) const {
        return mU == aOther.mU &&
               mV == aOther.mV &&
               mP == aOther.mP;
    }
    bool operator!=(const rssn_NavierStokesResultHandles& aOther) const {
        return mU != aOther.mU ||
               mV != aOther.mV ||
               mP != aOther.mP;
    }
};











extern "C" {

rssn_
rssn_Expr *calculate_residue(const rssn_Expr *aFunc,
                             const char *aVar,
                             const rssn_Expr *aSingularity)
;

rssn_
rssn_BincodeBuffer calculate_residue_bincode(rssn_BincodeBuffer aFuncBincode,
                                             const char *aVar,
                                             rssn_BincodeBuffer aSingularityBincode)
;

rssn_
char *calculate_residue_json(const char *aFuncJson,
                             const char *aVar,
                             const char *aSingularityJson)
;

rssn_
rssn_Expr *cauchy_derivative_formula(const rssn_Expr *aFunc,
                                     const char *aVar,
                                     const rssn_Expr *aZ0,
                                     size_t aN)
;

rssn_
rssn_BincodeBuffer cauchy_derivative_formula_bincode(rssn_BincodeBuffer aFuncBincode,
                                                     const char *aVar,
                                                     rssn_BincodeBuffer aZ0Bincode,
                                                     size_t aN)
;

rssn_
char *cauchy_derivative_formula_json(const char *aFuncJson,
                                     const char *aVar,
                                     const char *aZ0Json,
                                     size_t aN)
;

rssn_
rssn_Expr *cauchy_integral_formula(const rssn_Expr *aFunc,
                                   const char *aVar,
                                   const rssn_Expr *aZ0)
;

rssn_
rssn_BincodeBuffer cauchy_integral_formula_bincode(rssn_BincodeBuffer aFuncBincode,
                                                   const char *aVar,
                                                   rssn_BincodeBuffer aZ0Bincode)
;

rssn_
char *cauchy_integral_formula_json(const char *aFuncJson,
                                   const char *aVar,
                                   const char *aZ0Json)
;

rssn_
rssn_SingularityType *classify_singularity(const rssn_Expr *aFunc,
                                           const char *aVar,
                                           const rssn_Expr *aSingularity,
                                           size_t aOrder)
;

rssn_
rssn_BincodeBuffer classify_singularity_bincode(rssn_BincodeBuffer aFuncBincode,
                                                const char *aVar,
                                                rssn_BincodeBuffer aSingularityBincode,
                                                size_t aOrder)
;

rssn_
char *classify_singularity_json(const char *aFuncJson,
                                const char *aVar,
                                const char *aSingularityJson,
                                size_t aOrder)
;

rssn_
rssn_Expr *complex_arg(const rssn_Expr *aZ)
;

rssn_
rssn_BincodeBuffer complex_arg_bincode(rssn_BincodeBuffer aZBincode)
;

rssn_
char *complex_arg_json(const char *aZJson)
;

rssn_
double complex_distance(const rssn_Expr *aP1,
                        const rssn_Expr *aP2)
;

rssn_
double complex_distance_bincode(rssn_BincodeBuffer aP1Bincode,
                                rssn_BincodeBuffer aP2Bincode)
;

rssn_
double complex_distance_json(const char *aP1Json,
                             const char *aP2Json)
;

rssn_
rssn_Expr *complex_exp(const rssn_Expr *aZ)
;

rssn_
rssn_BincodeBuffer complex_exp_bincode(rssn_BincodeBuffer aZBincode)
;

rssn_
char *complex_exp_json(const char *aZJson)
;

rssn_
rssn_Expr *complex_log(const rssn_Expr *aZ)
;

rssn_
rssn_BincodeBuffer complex_log_bincode(rssn_BincodeBuffer aZBincode)
;

rssn_
char *complex_log_json(const char *aZJson)
;

rssn_
rssn_Expr *complex_modulus(const rssn_Expr *aZ)
;

rssn_
rssn_BincodeBuffer complex_modulus_bincode(rssn_BincodeBuffer aZBincode)
;

rssn_
char *complex_modulus_json(const char *aZJson)
;

rssn_
rssn_Expr *contour_integral_residue_theorem(const rssn_Expr *aFunc,
                                            const char *aVar,
                                            const rssn_Expr *const *aSingularities,
                                            size_t aSingularitiesLen)
;

rssn_
rssn_BincodeBuffer contour_integral_residue_theorem_bincode(rssn_BincodeBuffer aFuncBincode,
                                                            const char *aVar,
                                                            rssn_BincodeBuffer aSingularitiesBincode)
;

rssn_
char *contour_integral_residue_theorem_json(const char *aFuncJson,
                                            const char *aVar,
                                            const char *aSingularitiesJson)
;

rssn_
double estimate_radius_of_convergence(const rssn_Expr *aSeriesExpr,
                                      const char *aVar,
                                      const rssn_Expr *aCenter,
                                      size_t aOrder)
;

rssn_
double estimate_radius_of_convergence_bincode(rssn_BincodeBuffer aSeriesExprBincode,
                                              const char *aVar,
                                              rssn_BincodeBuffer aCenterBincode,
                                              size_t aOrder)
;

rssn_
double estimate_radius_of_convergence_json(const char *aSeriesExprJson,
                                           const char *aVar,
                                           const char *aCenterJson,
                                           size_t aOrder)
;

/*
 Computes the definite integral of an `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *expr_definite_integrate(rssn_Expr *aHandle,
                                   const char *aVarPtr,
                                   rssn_Expr *aLowerHandle,
                                   rssn_Expr *aUpperHandle)
;

/*
 Differentiates an `Expr` and returns a handle to the new, derivative expression.
 */
rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *expr_differentiate(rssn_Expr *aHandle,
                              const char *aVarPtr)
;

/*
 Computes the indefinite integral of an `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *expr_integrate(rssn_Expr *aHandle,
                          const char *aVarPtr)
;

/*
 Computes the limit of an `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *expr_limit(rssn_Expr *aHandle,
                      const char *aVarPtr,
                      rssn_Expr *aToHandle)
;

/*
 Simplifies an `Expr` and returns a handle to the new, simplified expression.

 The caller is responsible for freeing the returned handle using `expr_free`.
 */
rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *expr_simplify(rssn_Expr *aHandle)
;

/*
 Solves an equation for a given variable and returns the solutions as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *expr_solve(rssn_Expr *aHandle,
                 const char *aVarPtr)
;

/*
 Substitutes a variable in an `Expr` with another `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *expr_substitute(rssn_Expr *aHandle,
                           const char *aVarPtr,
                           rssn_Expr *aReplacementHandle)
;

/*
 Converts an expression to a LaTeX string.

 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_
char *expr_to_latex(rssn_Expr *aHandle)
;

/*
 Converts an expression to a formatted, pretty-printed string.

 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_
char *expr_to_pretty_string(rssn_Expr *aHandle)
;

/*
 Returns the string representation of an `Expr` handle.

 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_
char *expr_to_string(rssn_Expr *aHandle)
;

/*
 Attempts to unify the units within an expression.

 Returns a JSON string representing a `FfiResult` which contains either the
 new `Expr` object in the `ok` field or an error message in the `err` field.
 The caller can then use `expr_from_json` to get a handle to the new expression.
 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_
char *expr_unify_expression(rssn_Expr *aHandle)
;

/*
 Frees a C string that was allocated by this library.
 */
rssn_
void free_string(char *aS)
;

/*
 Evaluates a point on a Bézier curve and returns the coordinates as a JSON string.
 */
rssn_
char *interpolate_bezier_curve(const char *aJsonPtr)
;

/*
 Computes a Lagrange interpolating polynomial and returns its coefficients as a JSON string.
 */
rssn_
char *interpolate_lagrange(const char *aJsonPtr)
;

rssn_
rssn_Expr *laurent_series(const rssn_Expr *aFunc,
                          const char *aVar,
                          const rssn_Expr *aCenter,
                          size_t aOrder)
;

rssn_
rssn_BincodeBuffer laurent_series_bincode(rssn_BincodeBuffer aFuncBincode,
                                          const char *aVar,
                                          rssn_BincodeBuffer aCenterBincode,
                                          size_t aOrder)
;

rssn_
char *laurent_series_json(const char *aFuncJson,
                          const char *aVar,
                          const char *aCenterJson,
                          size_t aOrder)
;

/*
 Adds two matrices and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *matrix_add(rssn_Expr *aH1,
                      rssn_Expr *aH2)
;

/*
 Computes the characteristic polynomial of a matrix and returns the result as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_characteristic_polynomial(rssn_Expr *aHandle,
                                       const char *aVarPtr)
;

/*
 Computes the determinant of a matrix and returns a handle to the resulting expression.
 */
rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *matrix_determinant(rssn_Expr *aHandle)
;

/*
 Computes the eigenvalue decomposition of a matrix and returns the eigenvalues and eigenvectors as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_eigen_decomposition(rssn_Expr *aHandle)
;

/*
 Creates an identity matrix of a given size and returns a handle to it.
 */
rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *matrix_identity(size_t aSize)
;

/*
 Inverts a matrix and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *matrix_inverse(rssn_Expr *aHandle)
;

/*
 Computes the LU decomposition of a matrix and returns the L and U matrices as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_lu_decomposition(rssn_Expr *aHandle)
;

/*
 Multiplies two matrices and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *matrix_mul(rssn_Expr *aH1,
                      rssn_Expr *aH2)
;

/*
 Computes the null space of a matrix and returns the result as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_null_space(rssn_Expr *aHandle)
;

/*
 Computes the Reduced Row Echelon Form (RREF) of a matrix and returns the result as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_rref(rssn_Expr *aHandle)
;

/*
 Multiplies a matrix by a scalar and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *matrix_scalar_mul(rssn_Expr *aScalarHandle,
                             rssn_Expr *aMatrixHandle)
;

/*
 Subtracts the second matrix from the first and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *matrix_sub(rssn_Expr *aH1,
                      rssn_Expr *aH2)
;

/*
 Computes the trace of a matrix and returns the result as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_trace(rssn_Expr *aHandle)
;

/*
 Transposes a matrix and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *matrix_transpose(rssn_Expr *aHandle)
;

rssn_
rssn_Expr *mobius_transformation_apply(const rssn_MobiusTransformation *aMobius,
                                       const rssn_Expr *aZ)
;

rssn_
rssn_BincodeBuffer mobius_transformation_apply_bincode(rssn_BincodeBuffer aMobiusBincode,
                                                       rssn_BincodeBuffer aZBincode)
;

rssn_
char *mobius_transformation_apply_json(const char *aMobiusJson,
                                       const char *aZJson)
;

rssn_
rssn_MobiusTransformation *mobius_transformation_compose(const rssn_MobiusTransformation *aMobius1,
                                                         const rssn_MobiusTransformation *aMobius2)
;

rssn_
rssn_BincodeBuffer mobius_transformation_compose_bincode(rssn_BincodeBuffer aMobius1Bincode,
                                                         rssn_BincodeBuffer aMobius2Bincode)
;

rssn_
char *mobius_transformation_compose_json(const char *aMobius1Json,
                                         const char *aMobius2Json)
;

rssn_
rssn_MobiusTransformation *mobius_transformation_identity()
;

rssn_
rssn_BincodeBuffer mobius_transformation_identity_bincode()
;

rssn_
char *mobius_transformation_identity_json()
;

rssn_
rssn_MobiusTransformation *mobius_transformation_inverse(const rssn_MobiusTransformation *aMobius)
;

rssn_
rssn_BincodeBuffer mobius_transformation_inverse_bincode(rssn_BincodeBuffer aMobiusBincode)
;

rssn_
char *mobius_transformation_inverse_json(const char *aMobiusJson)
;

rssn_
rssn_MobiusTransformation *mobius_transformation_new(const rssn_Expr *aA,
                                                     const rssn_Expr *aB,
                                                     const rssn_Expr *aC,
                                                     const rssn_Expr *aD)
;

rssn_
rssn_BincodeBuffer mobius_transformation_new_bincode(rssn_BincodeBuffer aABincode,
                                                     rssn_BincodeBuffer aBBincode,
                                                     rssn_BincodeBuffer aCBincode,
                                                     rssn_BincodeBuffer aDBincode)
;

rssn_
char *mobius_transformation_new_json(const char *aAJson,
                                     const char *aBJson,
                                     const char *aCJson,
                                     const char *aDJson)
;

rssn_
DEPRECATED_WITH_NOTE
char *nt_mod_inverse(const char *aJsonPtr)
;

rssn_
DEPRECATED_WITH_NOTE
char *nt_mod_pow(const char *aJsonPtr)
;

rssn_
DEPRECATED_WITH_NOTE
char *numerical_gradient(const char *aJsonPtr)
;

rssn_
DEPRECATED_WITH_NOTE
char *numerical_integrate(const char *aJsonPtr)
;

rssn_
void numerical_optimize_drop_result_handle(rssn_FfiOptimizationResult *aHandle)
;

rssn_
void numerical_optimize_free_json(char *aPtr)
;

rssn_
double numerical_optimize_get_result_cost_handle(const rssn_FfiOptimizationResult *aHandle)
;

rssn_
uint64_t numerical_optimize_get_result_iterations_handle(const rssn_FfiOptimizationResult *aHandle)
;

rssn_
bool numerical_optimize_get_result_param_handle(const rssn_FfiOptimizationResult *aHandle,
                                                double *aBuffer)
;

rssn_
size_t numerical_optimize_get_result_param_len_handle(const rssn_FfiOptimizationResult *aHandle)
;

rssn_
rssn_FfiOptimizationResult *numerical_optimize_rosenbrock_bfgs_handle(double aA,
                                                                      double aB,
                                                                      const double *aInitParamPtr,
                                                                      size_t aInitParamLen,
                                                                      uint64_t aMaxIters,
                                                                      double aTolerance)
;

rssn_
rssn_FfiOptimizationResult *numerical_optimize_rosenbrock_gd_handle(double aA,
                                                                    double aB,
                                                                    const double *aInitParamPtr,
                                                                    size_t aInitParamLen,
                                                                    uint64_t aMaxIters,
                                                                    double aTolerance)
;

rssn_
rssn_BincodeBuffer numerical_optimize_solve_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *numerical_optimize_solve_json(const char *aJsonPtr)
;

rssn_
rssn_FfiOptimizationResult *numerical_optimize_sphere_gd_handle(const double *aInitParamPtr,
                                                                size_t aInitParamLen,
                                                                uint64_t aMaxIters,
                                                                double aTolerance)
;

rssn_
char *path_continuation_continue_along_path(rssn_PathContinuation *aPc,
                                            const rssn_Expr *const *aPathPoints,
                                            size_t aPathPointsLen)
;

rssn_
rssn_BincodeBuffer path_continuation_continue_along_path_bincode(rssn_BincodeBuffer aPcBincode,
                                                                 rssn_BincodeBuffer aPathPointsBincode)
;

rssn_
char *path_continuation_continue_along_path_json(const char *aPcJson,
                                                 const char *aPathPointsJson)
;

rssn_
rssn_Expr *path_continuation_get_final_expression(const rssn_PathContinuation *aPc)
;

rssn_
rssn_BincodeBuffer path_continuation_get_final_expression_bincode(rssn_BincodeBuffer aPcBincode)
;

rssn_
char *path_continuation_get_final_expression_json(const char *aPcJson)
;

rssn_
rssn_PathContinuation *path_continuation_new(const rssn_Expr *aFunc,
                                             const char *aVar,
                                             const rssn_Expr *aStartPoint,
                                             size_t aOrder)
;

rssn_
rssn_BincodeBuffer path_continuation_new_bincode(rssn_BincodeBuffer aFuncBincode,
                                                 const char *aVar,
                                                 rssn_BincodeBuffer aStartPointBincode,
                                                 size_t aOrder)
;

rssn_
char *path_continuation_new_json(const char *aFuncJson,
                                 const char *aVar,
                                 const char *aStartPointJson,
                                 size_t aOrder)
;

rssn_
DEPRECATED_WITH_NOTE
char *physics_solve_advection_diffusion_1d(const char *aJsonPtr)
;

rssn_
DEPRECATED_WITH_NOTE
int64_t poly_degree(const char *aJsonPtr)
;

rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *poly_from_coeffs_vec(const char *aJsonPtr)
;

rssn_
DEPRECATED_WITH_NOTE
bool poly_is_polynomial(const char *aJsonPtr)
;

rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *poly_leading_coefficient(rssn_Expr *aHandle,
                                    const char *aVarPtr)
;

rssn_
DEPRECATED_WITH_NOTE
char *poly_long_division(const char *aJsonPtr)
;

rssn_
DEPRECATED_WITH_NOTE
char *poly_to_coeffs_vec(const char *aJsonPtr)
;

/*
 Checks if an expression contains a variable (handle-based)
 */
rssn_
bool polynomial_contains_var_handle(const rssn_Expr *aExprHandle,
                                    const char *aVar)
;

/*
 Computes the degree of a polynomial (handle-based)
 */
rssn_
int64_t polynomial_degree_handle(const rssn_Expr *aExprHandle,
                                 const char *aVar)
;

/*
 Frees an Expr handle
 */
rssn_
void polynomial_free_expr_handle(rssn_Expr *aExprHandle)
;

/*
 Checks if an expression is a polynomial in the given variable (handle-based)
 */
rssn_
bool polynomial_is_polynomial_handle(const rssn_Expr *aExprHandle,
                                     const char *aVar)
;

/*
 Finds the leading coefficient of a polynomial (handle-based)
 */
rssn_
rssn_Expr *polynomial_leading_coefficient_handle(const rssn_Expr *aExprHandle,
                                                 const char *aVar)
;

/*
 Performs polynomial long division (handle-based)
 */
rssn_
void polynomial_long_division_handle(const rssn_Expr *aDividendHandle,
                                     const rssn_Expr *aDivisorHandle,
                                     const char *aVar,
                                     rssn_Expr **aQuotientOut,
                                     rssn_Expr **aRemainderOut)
;

/*
 Computes absolute value (magnitude) of complex number (Handle)
 */
rssn_
rssn_Expr *rssn_abs_handle(const rssn_Expr *aZ)
;

rssn_
rssn_Expr *rssn_adjoint_representation_algebra(const rssn_Expr *aX,
                                               const rssn_Expr *aY)
;

rssn_
rssn_Expr *rssn_adjoint_representation_group(const rssn_Expr *aG,
                                             const rssn_Expr *aX)
;

rssn_
rssn_Expr *rssn_analytic_continuation_handle(const rssn_Expr *aExpr,
                                             const char *aVar,
                                             const rssn_Expr *aOrigCenter,
                                             const rssn_Expr *aNewCenter,
                                             size_t aOrder)
;

rssn_
rssn_ConvergenceResult rssn_analyze_convergence_handle(const rssn_Expr *aTerm,
                                                       const char *aVar)
;

/*
 Analyzes stability of a fixed point (Handle)
 */
rssn_
rssn_Expr *rssn_analyze_stability(const rssn_Expr *aMapPtr,
                                  const char *aVar,
                                  const rssn_Expr *aFixedPointPtr)
;

/*
 Applies a set of rewrite rules to an expression until a normal form is reached.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `rules` is a valid array.
 */
rssn_
rssn_Expr *rssn_apply_rules_to_normal_form(const rssn_Expr *aExpr,
                                           const rssn_RewriteRule *const *aRules,
                                           size_t aRulesLen)
;

/*
 Applies rewrite rules to an expression (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_apply_rules_to_normal_form_bincode(rssn_BincodeBuffer aInput)
;

/*
 Applies rewrite rules to an expression (JSON).

 Input: JSON object with "expr" and "rules" fields
 Output: JSON-serialized Expr (the normal form)
 */
rssn_
char *rssn_apply_rules_to_normal_form_json(const char *aJsonStr)
;

/*
 Checks if two graphs are potentially isomorphic using WL test.
 */
rssn_
int rssn_are_isomorphic_heuristic(const rssn_RssnGraph *aG1,
                                  const rssn_RssnGraph *aG2)
;

rssn_
bool rssn_are_orthogonal(const rssn_HilbertSpace *aSpace,
                         const rssn_Expr *aF,
                         const rssn_Expr *aG)
;

/*
 Computes argument (angle) of complex number (Handle)
 */
rssn_
rssn_Expr *rssn_arg_handle(const rssn_Expr *aZ)
;

rssn_
rssn_Expr *rssn_asymptotic_expansion_handle(const rssn_Expr *aExpr,
                                            const char *aVar,
                                            const rssn_Expr *aPoint,
                                            size_t aOrder)
;

rssn_
rssn_Expr *rssn_banach_norm(const rssn_BanachSpace *aSpace,
                            const rssn_Expr *aF)
;

rssn_
rssn_BanachSpace *rssn_banach_space_create(const char *aVar,
                                           const rssn_Expr *aLowerBound,
                                           const rssn_Expr *aUpperBound,
                                           const rssn_Expr *aP)
;

rssn_
void rssn_banach_space_free(rssn_BanachSpace *aPtr)
;

rssn_
rssn_Expr *rssn_bell_number(size_t aN)
;

/*
 Constructs Bessel's differential equation: x²y'' + xy' + (x² - n²)y = 0.
 */
rssn_
rssn_Expr *rssn_bessel_differential_equation(const rssn_Expr *aY,
                                             const rssn_Expr *aX,
                                             const rssn_Expr *aN)
;

/*
 Computes the symbolic modified Bessel function of the first kind I_n(x).
 */
rssn_
rssn_Expr *rssn_bessel_i(const rssn_Expr *aOrder,
                         const rssn_Expr *aArg)
;

/*
 Computes the modified Bessel function of the first kind I₀(x).
 */
rssn_
double rssn_bessel_i0(double aX)
;

/*
 Computes the modified Bessel function of the first kind I₁(x).
 */
rssn_
double rssn_bessel_i1(double aX)
;

/*
 Computes the symbolic Bessel function of the first kind J_n(x).
 */
rssn_
rssn_Expr *rssn_bessel_j(const rssn_Expr *aOrder,
                         const rssn_Expr *aArg)
;

/*
 Computes the Bessel function of the first kind J₀(x).
 */
rssn_
double rssn_bessel_j0(double aX)
;

/*
 Computes the Bessel function of the first kind J₁(x).
 */
rssn_
double rssn_bessel_j1(double aX)
;

/*
 Computes the symbolic modified Bessel function of the second kind K_n(x).
 */
rssn_
rssn_Expr *rssn_bessel_k(const rssn_Expr *aOrder,
                         const rssn_Expr *aArg)
;

/*
 Computes the modified Bessel function of the second kind K₀(x).
 */
rssn_
double rssn_bessel_k0(double aX)
;

/*
 Computes the modified Bessel function of the second kind K₁(x).
 */
rssn_
double rssn_bessel_k1(double aX)
;

/*
 Computes the symbolic Bessel function of the second kind Y_n(x).
 */
rssn_
rssn_Expr *rssn_bessel_y(const rssn_Expr *aOrder,
                         const rssn_Expr *aArg)
;

/*
 Computes the Bessel function of the second kind Y₀(x).
 */
rssn_
double rssn_bessel_y0(double aX)
;

/*
 Computes the Bessel function of the second kind Y₁(x).
 */
rssn_
double rssn_bessel_y1(double aX)
;

/*
 Computes the symbolic Beta function B(a, b).
 */
rssn_
rssn_Expr *rssn_beta(const rssn_Expr *aA,
                     const rssn_Expr *aB)
;

/*
 Computes the beta function B(a, b).
 */
rssn_
double rssn_beta_numerical(double aA,
                           double aB)
;

/*
 Computes the derivative (tangent) of a Bezier curve at parameter t.
 */
rssn_
rssn_Vector *rssn_bezier_curve_derivative(const rssn_BezierCurve *aCurve,
                                          const rssn_Expr *aT)
;

/*
 Evaluates a Bezier curve at parameter t.
 */
rssn_
rssn_Vector *rssn_bezier_curve_evaluate(const rssn_BezierCurve *aCurve,
                                        const rssn_Expr *aT)
;

/*
 Frees a Bezier curve.
 */
rssn_
void rssn_bezier_curve_free(rssn_BezierCurve *aCurve)
;

/*
 Creates a new Bezier curve from control points.
 */
rssn_
rssn_BezierCurve *rssn_bezier_curve_new(const rssn_Vector *aPoints,
                                        size_t aCount)
;

/*
 Splits a Bezier curve at parameter t into two curves.
 Returns left curve. Use rssn_bezier_curve_split_right for the right curve.
 */
rssn_
rssn_BezierCurve *rssn_bezier_curve_split_left(const rssn_BezierCurve *aCurve,
                                               const rssn_Expr *aT)
;

/*
 Splits a Bezier curve at parameter t into two curves.
 Returns right curve.
 */
rssn_
rssn_BezierCurve *rssn_bezier_curve_split_right(const rssn_BezierCurve *aCurve,
                                                const rssn_Expr *aT)
;

/*
 Computes absolute value (magnitude) of complex number (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_abs(rssn_BincodeBuffer aZBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_adjoint_representation_algebra(rssn_BincodeBuffer aXBuf,
                                                               rssn_BincodeBuffer aYBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_adjoint_representation_group(rssn_BincodeBuffer aGBuf,
                                                             rssn_BincodeBuffer aXBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_analytic_continuation(rssn_BincodeBuffer aExprBuf,
                                                      rssn_BincodeBuffer aVarBuf,
                                                      rssn_BincodeBuffer aOrigCenterBuf,
                                                      rssn_BincodeBuffer aNewCenterBuf,
                                                      rssn_BincodeBuffer aOrderBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_analyze_convergence(rssn_BincodeBuffer aTermBuf,
                                                    rssn_BincodeBuffer aVarBuf)
;

/*
 Analyzes stability of a fixed point (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_analyze_stability(rssn_BincodeBuffer aMapBuf,
                                                  const char *aVar,
                                                  rssn_BincodeBuffer aFixedPointBuf)
;

/*
 Checks if two graphs are isomorphic.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_are_isomorphic_heuristic(rssn_BincodeBuffer aInputBuf)
;

/*
 Computes argument (angle) of complex number (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_arg(rssn_BincodeBuffer aZBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_asymptotic_expansion(rssn_BincodeBuffer aExprBuf,
                                                     rssn_BincodeBuffer aVarBuf,
                                                     rssn_BincodeBuffer aPointBuf,
                                                     rssn_BincodeBuffer aOrderBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_bell_number(size_t aN)
;

rssn_
rssn_BincodeBuffer rssn_bincode_bessel_differential_equation(rssn_BincodeBuffer aYBuf,
                                                             rssn_BincodeBuffer aXBuf,
                                                             rssn_BincodeBuffer aNBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_bessel_i(rssn_BincodeBuffer aOrderBuf,
                                         rssn_BincodeBuffer aArgBuf)
;

/*
 Computes I₀(x) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_bessel_i0(rssn_BincodeBuffer aValBuf)
;

/*
 Computes I₁(x) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_bessel_i1(rssn_BincodeBuffer aValBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_bessel_j(rssn_BincodeBuffer aOrderBuf,
                                         rssn_BincodeBuffer aArgBuf)
;

/*
 Computes J₀(x) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_bessel_j0(rssn_BincodeBuffer aValBuf)
;

/*
 Computes J₁(x) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_bessel_j1(rssn_BincodeBuffer aValBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_bessel_k(rssn_BincodeBuffer aOrderBuf,
                                         rssn_BincodeBuffer aArgBuf)
;

/*
 Computes K₀(x) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_bessel_k0(rssn_BincodeBuffer aValBuf)
;

/*
 Computes K₁(x) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_bessel_k1(rssn_BincodeBuffer aValBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_bessel_y(rssn_BincodeBuffer aOrderBuf,
                                         rssn_BincodeBuffer aArgBuf)
;

/*
 Computes Y₀(x) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_bessel_y0(rssn_BincodeBuffer aValBuf)
;

/*
 Computes Y₁(x) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_bessel_y1(rssn_BincodeBuffer aValBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_beta(rssn_BincodeBuffer aABuf,
                                     rssn_BincodeBuffer aBBuf)
;

/*
 Computes B(a, b) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_beta_numerical(rssn_BincodeBuffer aABuf,
                                               rssn_BincodeBuffer aBBuf)
;

/*
 Computes C(n, k) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_binomial(rssn_BincodeBuffer aNBuf,
                                         rssn_BincodeBuffer aKBuf)
;

/*
 Computes the boundary of a domain (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_boundary(rssn_BincodeBuffer aDomainBuf)
;

/*
 Computes the inner product <Bra|Ket> using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_bra_ket(rssn_BincodeBuffer aBraBuf,
                                        rssn_BincodeBuffer aKetBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_buchberger(rssn_BincodeBuffer aBasisBuf,
                                           rssn_BincodeBuffer aOrderBuf)
;

/*
 Computes CAD for a set of polynomials via Bincode interface.

 Input buffer should contain a serialized `CadInput`: `{"polys": [Expr, ...], "vars": ["x", "y", ...]}`.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_cad(rssn_BincodeBuffer aInputBuf)
;

/*
 Calculates residue using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_calculate_residue(rssn_BincodeBuffer aExprBuf,
                                                  const char *aVar,
                                                  rssn_BincodeBuffer aPoleBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_catalan_number(size_t aN)
;

rssn_
rssn_BincodeBuffer rssn_bincode_character(rssn_BincodeBuffer aRepBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_chebyshev_differential_equation(rssn_BincodeBuffer aYBuf,
                                                                rssn_BincodeBuffer aXBuf,
                                                                rssn_BincodeBuffer aNBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_chebyshev_t(rssn_BincodeBuffer aNBuf,
                                            rssn_BincodeBuffer aXBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_chebyshev_u(rssn_BincodeBuffer aNBuf,
                                            rssn_BincodeBuffer aXBuf)
;

/*
 Checks analytic using Bincode.
 */
rssn_
bool rssn_bincode_check_analytic(rssn_BincodeBuffer aExprBuf,
                                 const char *aVar)
;

rssn_
bool rssn_bincode_check_jacobi_identity(rssn_BincodeBuffer aAlgebraBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_chinese_remainder(rssn_BincodeBuffer aCongruencesBuf)
;

/*
 Exact chromatic number.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_chromatic_number_exact(rssn_BincodeBuffer aGraphBuf)
;

/*
 Classifies a PDE (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_bincode_classify_pde(rssn_BincodeBuffer aEquationBuf,
                                             const char *aFunc,
                                             rssn_BincodeBuffer aVarsBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_combinations(rssn_BincodeBuffer aNBuf,
                                             rssn_BincodeBuffer aKBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_commutator_table(rssn_BincodeBuffer aAlgebraBuf)
;

/*
 Finds fixed points (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_complex_system_fixed_points(rssn_BincodeBuffer aSystemBuf)
;

/*
 Iterates the system once (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_complex_system_iterate(rssn_BincodeBuffer aSystemBuf,
                                                       rssn_BincodeBuffer aZBuf)
;

/*
 Creates a new Mandelbrot family system (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_complex_system_new_mandelbrot(rssn_BincodeBuffer aCBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_conditional_entropy(rssn_BincodeBuffer aJointProbsBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_convolution_fourier(rssn_BincodeBuffer aFBuf,
                                                    rssn_BincodeBuffer aGBuf,
                                                    rssn_BincodeBuffer aInVarBuf,
                                                    rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_convolution_laplace(rssn_BincodeBuffer aFBuf,
                                                    rssn_BincodeBuffer aGBuf,
                                                    rssn_BincodeBuffer aInVarBuf,
                                                    rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_coordinates_get_metric_tensor(rssn_BincodeBuffer aSystemBuf)
;

/*
 Computes the symbolic Pearson correlation coefficient using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_correlation(rssn_BincodeBuffer aData1Buf,
                                            rssn_BincodeBuffer aData2Buf)
;

/*
 Counts the number of distinct real roots in an interval (Bincode)
 */
rssn_
int64_t rssn_bincode_count_real_roots_in_interval(rssn_BincodeBuffer aExprBuf,
                                                  const char *aVarPtr,
                                                  double aA,
                                                  double aB)
;

/*
 Computes the symbolic covariance of two sets of expressions using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_covariance(rssn_BincodeBuffer aData1Buf,
                                           rssn_BincodeBuffer aData2Buf)
;

/*
 Computes CRC-32 checksum via Bincode interface.
 Input: Vec<u8>
 Returns: u32
 */
rssn_
rssn_BincodeBuffer rssn_bincode_crc32_compute(rssn_BincodeBuffer aDataBuf)
;

/*
 Finalizes CRC-32 computation via Bincode interface.
 Input: u32 (running crc)
 Returns: u32 (final crc)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_crc32_finalize(rssn_BincodeBuffer aCrcBuf)
;

/*
 Updates CRC-32 incrementally via Bincode interface.
 Input: (crc: u32, data: Vec<u8>)
 Returns: u32
 */
rssn_
rssn_BincodeBuffer rssn_bincode_crc32_update(rssn_BincodeBuffer aCrcBuf,
                                             rssn_BincodeBuffer aDataBuf)
;

/*
 Verifies CRC-32 checksum via Bincode interface.
 Input: (data: Vec<u8>, expected_crc: u32)
 Returns: bool
 */
rssn_
rssn_BincodeBuffer rssn_bincode_crc32_verify(rssn_BincodeBuffer aDataBuf,
                                             rssn_BincodeBuffer aExpectedCrcBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_cross_entropy(rssn_BincodeBuffer aPProbsBuf,
                                              rssn_BincodeBuffer aQProbsBuf)
;

/*
 Adds two points.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_curve_add(rssn_BincodeBuffer aCurveBuf,
                                          rssn_BincodeBuffer aP1Buf,
                                          rssn_BincodeBuffer aP2Buf)
;

/*
 Doubles a point.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_curve_double(rssn_BincodeBuffer aCurveBuf,
                                             rssn_BincodeBuffer aPointBuf)
;

/*
 Checks if a point is on the curve.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_curve_is_on_curve(rssn_BincodeBuffer aCurveBuf,
                                                  rssn_BincodeBuffer aPointBuf)
;

/*
 Negates a point.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_curve_negate(rssn_BincodeBuffer aCurveBuf,
                                             rssn_BincodeBuffer aPointBuf)
;

/*
 Creates an affine curve point via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_curve_point_affine(rssn_BincodeBuffer aXBuf,
                                                   rssn_BincodeBuffer aYBuf,
                                                   rssn_BincodeBuffer aModulusBuf)
;

/*
 Creates a point at infinity via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_curve_point_infinity()
;

/*
 Scalar multiplication.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_curve_scalar_mult(rssn_BincodeBuffer aCurveBuf,
                                                  rssn_BincodeBuffer aKBuf,
                                                  rssn_BincodeBuffer aPBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_cyclic_group_create(size_t aN)
;

/*
 Computes definite integral using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_definite_integrate(rssn_BincodeBuffer aExprBuf,
                                                   const char *aVar,
                                                   rssn_BincodeBuffer aLowerBuf,
                                                   rssn_BincodeBuffer aUpperBuf)
;

/*
 Denests a nested square root (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_denest_sqrt(rssn_BincodeBuffer aExprBuf)
;

/*
 Computes the density of states for a 3D electron gas using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_density_of_states_3d(rssn_BincodeBuffer aEnergyBuf,
                                                     rssn_BincodeBuffer aMassBuf,
                                                     rssn_BincodeBuffer aVolumeBuf)
;

/*
 Differentiates an expression using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_differentiate(rssn_BincodeBuffer aExprBuf,
                                              const char *aVar)
;

rssn_
rssn_BincodeBuffer rssn_bincode_digamma(rssn_BincodeBuffer aArgBuf)
;

/*
 Computes ψ(x) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_digamma_numerical(rssn_BincodeBuffer aValBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dihedral_group_create(size_t aN)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_bernoulli(rssn_BincodeBuffer aPBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_beta(rssn_BincodeBuffer aAlphaBuf,
                                          rssn_BincodeBuffer aBetaBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_binomial(rssn_BincodeBuffer aNBuf,
                                              rssn_BincodeBuffer aPBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_cdf(rssn_BincodeBuffer aDistBuf,
                                         rssn_BincodeBuffer aXBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_expectation(rssn_BincodeBuffer aDistBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_exponential(rssn_BincodeBuffer aRateBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_gamma(rssn_BincodeBuffer aShapeBuf,
                                           rssn_BincodeBuffer aRateBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_mgf(rssn_BincodeBuffer aDistBuf,
                                         rssn_BincodeBuffer aTBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_normal(rssn_BincodeBuffer aMeanBuf,
                                            rssn_BincodeBuffer aStdDevBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_pdf(rssn_BincodeBuffer aDistBuf,
                                         rssn_BincodeBuffer aXBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_poisson(rssn_BincodeBuffer aRateBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_student_t(rssn_BincodeBuffer aNuBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_uniform(rssn_BincodeBuffer aMinBuf,
                                             rssn_BincodeBuffer aMaxBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_variance(rssn_BincodeBuffer aDistBuf)
;

/*
 Computes n!! via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_double_factorial(rssn_BincodeBuffer aNBuf)
;

/*
 Computes Drude conductivity using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_drude_conductivity(rssn_BincodeBuffer aNBuf,
                                                   rssn_BincodeBuffer aEBuf,
                                                   rssn_BincodeBuffer aTauBuf,
                                                   rssn_BincodeBuffer aMassBuf)
;

/*
 Signs a message.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_ecdsa_sign(rssn_BincodeBuffer aMessageHashBuf,
                                           rssn_BincodeBuffer aPrivateKeyBuf,
                                           rssn_BincodeBuffer aCurveBuf,
                                           rssn_BincodeBuffer aGeneratorBuf,
                                           rssn_BincodeBuffer aOrderBuf)
;

/*
 Verifies a signature.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_ecdsa_verify(rssn_BincodeBuffer aMessageHashBuf,
                                             rssn_BincodeBuffer aSignatureBuf,
                                             rssn_BincodeBuffer aPublicKeyBuf,
                                             rssn_BincodeBuffer aCurveBuf,
                                             rssn_BincodeBuffer aGeneratorBuf,
                                             rssn_BincodeBuffer aOrderBuf)
;

/*
 Calculates energy density using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_electromagnetic_energy_density(rssn_BincodeBuffer aEFieldBuf,
                                                               rssn_BincodeBuffer aBFieldBuf)
;

/*
 Creates a new elliptic curve via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_elliptic_curve_new(rssn_BincodeBuffer aABuf,
                                                   rssn_BincodeBuffer aBBuf,
                                                   rssn_BincodeBuffer aModulusBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_erf(rssn_BincodeBuffer aArgBuf)
;

/*
 Computes erf(x) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_erf_numerical(rssn_BincodeBuffer aValBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_erfc(rssn_BincodeBuffer aArgBuf)
;

/*
 Computes erfc(x) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_erfc_numerical(rssn_BincodeBuffer aValBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_erfi(rssn_BincodeBuffer aArgBuf)
;

/*
 Computes the Euler-Lagrange equation using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_euler_lagrange(rssn_BincodeBuffer aLagrangianBuf,
                                               const char *aFunc,
                                               const char *aVar)
;

/*
 Computes Euler-Lagrange equation using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_euler_lagrange_equation(rssn_BincodeBuffer aLagrangianBuf,
                                                        const char *aQ,
                                                        const char *aQDot,
                                                        const char *aTVar)
;

/*
 Evaluates at point using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_evaluate_at_point(rssn_BincodeBuffer aExprBuf,
                                                  const char *aVar,
                                                  rssn_BincodeBuffer aValueBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_evaluate_numerical(rssn_BincodeBuffer aExprBuf)
;

/*
 Computes the expectation value using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_expectation_value(rssn_BincodeBuffer aOpBuf,
                                                  rssn_BincodeBuffer aPsiBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_exponential_map(rssn_BincodeBuffer aXBuf,
                                                size_t aOrder)
;

rssn_
rssn_BincodeBuffer rssn_bincode_extended_gcd(rssn_BincodeBuffer aABuf,
                                             rssn_BincodeBuffer aBBuf)
;

/*
 Computes the exterior derivative of a differential form (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_exterior_derivative(rssn_BincodeBuffer aFormBuf,
                                                    rssn_BincodeBuffer aVarsBuf)
;

/*
 Factors a polynomial over a finite field (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_factor_gf(rssn_BincodeBuffer aPolyBuf)
;

/*
 Computes n! via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_factorial(rssn_BincodeBuffer aNBuf)
;

/*
 Computes (x)₍ₙ₎ via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_falling_factorial(rssn_BincodeBuffer aXBuf,
                                                  rssn_BincodeBuffer aNBuf)
;

/*
 Computes Fermi energy for a 3D electron gas using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_fermi_energy_3d(rssn_BincodeBuffer aConcentrationBuf,
                                                rssn_BincodeBuffer aMassBuf)
;

/*
 Finds constrained extrema (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_find_constrained_extrema(rssn_BincodeBuffer aExprBuf,
                                                         rssn_BincodeBuffer aConstraintsBuf,
                                                         rssn_BincodeBuffer aVarsBuf)
;

/*
 Finds extrema of a function (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_find_extrema(rssn_BincodeBuffer aExprBuf,
                                             rssn_BincodeBuffer aVarsBuf)
;

/*
 Finds fixed points of a 1D map (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_find_fixed_points(rssn_BincodeBuffer aMapBuf,
                                                  const char *aVar)
;

/*
 Finds pole order using Bincode.
 */
rssn_
size_t rssn_bincode_find_pole_order(rssn_BincodeBuffer aExprBuf,
                                    const char *aVar,
                                    rssn_BincodeBuffer aPoleBuf)
;

/*
 Finds poles using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_find_poles(rssn_BincodeBuffer aExprBuf,
                                           const char *aVar)
;

/*
 Gets the degree of a finite field polynomial (Bincode)
 */
rssn_
int64_t rssn_bincode_finite_field_polynomial_degree(rssn_BincodeBuffer aPolyBuf)
;

/*
 Performs polynomial long division (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_finite_field_polynomial_long_division(rssn_BincodeBuffer aDividendBuf,
                                                                      rssn_BincodeBuffer aDivisorBuf)
;

/*
 Creates a new finite field polynomial (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_finite_field_polynomial_new(rssn_BincodeBuffer aCoeffsBuf,
                                                            rssn_BincodeBuffer aModulusBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_fourier_differentiation(rssn_BincodeBuffer aFOmegaBuf,
                                                        rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_fourier_frequency_shift(rssn_BincodeBuffer aFOmegaBuf,
                                                        rssn_BincodeBuffer aABuf,
                                                        rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_fourier_scaling(rssn_BincodeBuffer aFOmegaBuf,
                                                rssn_BincodeBuffer aABuf,
                                                rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_fourier_series(rssn_BincodeBuffer aExprBuf,
                                               rssn_BincodeBuffer aVarBuf,
                                               rssn_BincodeBuffer aPeriodBuf,
                                               rssn_BincodeBuffer aOrderBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_fourier_time_shift(rssn_BincodeBuffer aFOmegaBuf,
                                                   rssn_BincodeBuffer aABuf,
                                                   rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_fourier_transform(rssn_BincodeBuffer aExprBuf,
                                                  rssn_BincodeBuffer aInVarBuf,
                                                  rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_gamma(rssn_BincodeBuffer aArgBuf)
;

/*
 Computes Γ(x) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_gamma_numerical(rssn_BincodeBuffer aValBuf)
;

/*
 Represents Gauss's theorem (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_gauss_theorem(rssn_BincodeBuffer aVectorFieldBuf,
                                              rssn_BincodeBuffer aVolumeBuf)
;

/*
 Computes general multi-valued arccos (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_general_arccos(rssn_BincodeBuffer aZBuf,
                                               rssn_BincodeBuffer aKBuf,
                                               rssn_BincodeBuffer aSBuf)
;

/*
 Computes general multi-valued arcsin (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_general_arcsin(rssn_BincodeBuffer aZBuf,
                                               rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued arctan (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_general_arctan(rssn_BincodeBuffer aZBuf,
                                               rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued logarithm (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_general_log(rssn_BincodeBuffer aZBuf,
                                            rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued n-th root (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_general_nth_root(rssn_BincodeBuffer aZBuf,
                                                 rssn_BincodeBuffer aNBuf,
                                                 rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued power (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_general_power(rssn_BincodeBuffer aZBuf,
                                              rssn_BincodeBuffer aWBuf,
                                              rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued square root (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_general_sqrt(rssn_BincodeBuffer aZBuf,
                                             rssn_BincodeBuffer aKBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_generalized_laguerre(rssn_BincodeBuffer aNBuf,
                                                     rssn_BincodeBuffer aAlphaBuf,
                                                     rssn_BincodeBuffer aXBuf)
;

/*
 Represents the generalized Stokes' theorem (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_generalized_stokes_theorem(rssn_BincodeBuffer aOmegaBuf,
                                                           rssn_BincodeBuffer aManifoldBuf,
                                                           rssn_BincodeBuffer aVarsBuf)
;

/*
 Generates a key pair.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_generate_keypair(rssn_BincodeBuffer aCurveBuf,
                                                 rssn_BincodeBuffer aGeneratorBuf)
;

/*
 Generates a shared secret.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_generate_shared_secret(rssn_BincodeBuffer aCurveBuf,
                                                       rssn_BincodeBuffer aPrivateKeyBuf,
                                                       rssn_BincodeBuffer aOtherPublicKeyBuf)
;

/*
 Gets real and imaginary parts using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_get_real_imag_parts(rssn_BincodeBuffer aExprBuf)
;

/*
 Performs addition in GF(2^8) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_gf256_add(rssn_BincodeBuffer aABuf,
                                          rssn_BincodeBuffer aBBuf)
;

/*
 Computes inverse in GF(2^8) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_gf256_inv(rssn_BincodeBuffer aABuf)
;

/*
 Performs multiplication in GF(2^8) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_gf256_mul(rssn_BincodeBuffer aABuf,
                                          rssn_BincodeBuffer aBBuf)
;

/*
 Calculates Gibbs Free Energy using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_gibbs_free_energy(rssn_BincodeBuffer aHBuf,
                                                  rssn_BincodeBuffer aTBuf,
                                                  rssn_BincodeBuffer aSBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_gini_impurity(rssn_BincodeBuffer aProbsBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_gram_schmidt(rssn_BincodeBuffer aSpaceBuf,
                                             rssn_BincodeBuffer aBasisBuf)
;

/*
 Adds an edge to the graph.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_add_edge(rssn_BincodeBuffer aInputBuf)
;

/*
 Adds a node to the graph.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_add_node(rssn_BincodeBuffer aInputBuf)
;

/*
 Gets the adjacency matrix.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_adjacency_matrix(rssn_BincodeBuffer aGraphBuf)
;

/*
 Performs BFS traversal.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_bfs(rssn_BincodeBuffer aInputBuf)
;

/*
 Performs BFS traversal.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_bfs_api(rssn_BincodeBuffer aInputBuf)
;

/*
 Finds maximum matching in bipartite graph.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_bipartite_maximum_matching(rssn_BincodeBuffer aInputBuf)
;

/*
 Finds bridges and articulation points.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_bridges_and_articulation_points(rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes the Cartesian product of two graphs.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_cartesian_product(rssn_BincodeBuffer aInputBuf)
;

/*
 Computes the complement of a graph.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_complement(rssn_BincodeBuffer aGraphBuf)
;

/*
 Finds connected components.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_connected_components(rssn_BincodeBuffer aGraphBuf)
;

/*
 Finds connected components.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_connected_components_api(rssn_BincodeBuffer aGraphBuf)
;

/*
 Performs DFS traversal.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_dfs(rssn_BincodeBuffer aInputBuf)
;

/*
 Performs DFS traversal.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_dfs_api(rssn_BincodeBuffer aInputBuf)
;

/*
 Computes maximum flow using Dinic's algorithm.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_dinic_max_flow(rssn_BincodeBuffer aInputBuf)
;

/*
 Computes the disjoint union of two graphs.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_disjoint_union(rssn_BincodeBuffer aInputBuf)
;

/*
 Computes maximum flow using Edmonds-Karp.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_edmonds_karp_max_flow(rssn_BincodeBuffer aInputBuf)
;

/*
 Checks if graph has a cycle.
 */
rssn_
bool rssn_bincode_graph_has_cycle(rssn_BincodeBuffer aGraphBuf)
;

/*
 Checks if graph has a cycle.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_has_cycle_api(rssn_BincodeBuffer aGraphBuf)
;

/*
 Creates an induced subgraph.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_induced_subgraph(rssn_BincodeBuffer aInputBuf)
;

/*
 Computes the intersection of two graphs.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_intersection(rssn_BincodeBuffer aInputBuf)
;

/*
 Checks if graph is bipartite.
 */
rssn_
bool rssn_bincode_graph_is_bipartite(rssn_BincodeBuffer aGraphBuf)
;

/*
 Checks if graph is bipartite.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_is_bipartite_api(rssn_BincodeBuffer aGraphBuf)
;

/*
 Checks if graph is connected.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_is_connected(rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes the join of two graphs.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_join(rssn_BincodeBuffer aInputBuf)
;

/*
 Computes MST using Kruskal's algorithm.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_kruskal_mst(rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes MST using Kruskal's algorithm.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_kruskal_mst_api(rssn_BincodeBuffer aGraphBuf)
;

/*
 Gets the Laplacian matrix.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_laplacian_matrix(rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes maximum flow.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_max_flow(rssn_BincodeBuffer aInputBuf)
;

/*
 Creates a new graph from bincode specification.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_new(rssn_BincodeBuffer aSpecBuf)
;

/*
 Finds strongly connected components.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_strongly_connected_components(rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes the Tensor product of two graphs.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_tensor_product(rssn_BincodeBuffer aInputBuf)
;

/*
 Performs topological sort.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_topological_sort(rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes the union of two graphs.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_union(rssn_BincodeBuffer aInputBuf)
;

/*
 Greedy coloring.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_greedy_coloring(rssn_BincodeBuffer aGraphBuf)
;

/*
 Represents Green's theorem (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_greens_theorem(rssn_BincodeBuffer aPBuf,
                                               rssn_BincodeBuffer aQBuf,
                                               rssn_BincodeBuffer aDomainBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_group_center(rssn_BincodeBuffer aGroupBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_group_conjugacy_classes(rssn_BincodeBuffer aGroupBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_group_create(rssn_BincodeBuffer aBuf)
;

rssn_
size_t rssn_bincode_group_element_order(rssn_BincodeBuffer aGroupBuf,
                                        rssn_BincodeBuffer aABuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_group_inverse(rssn_BincodeBuffer aGroupBuf,
                                              rssn_BincodeBuffer aABuf)
;

rssn_
bool rssn_bincode_group_is_abelian(rssn_BincodeBuffer aGroupBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_group_multiply(rssn_BincodeBuffer aGroupBuf,
                                               rssn_BincodeBuffer aABuf,
                                               rssn_BincodeBuffer aBBuf)
;

/*
 Applies Hamilton's Principle using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_hamiltons_principle(rssn_BincodeBuffer aLagrangianBuf,
                                                    const char *aFunc,
                                                    const char *aVar)
;

/*
 Checks if a Hamming(7,4) codeword is valid via Bincode interface.
 Input: Vec<u8> (7 bytes)
 Returns: bool
 */
rssn_
rssn_BincodeBuffer rssn_bincode_hamming_check(rssn_BincodeBuffer aCodewordBuf)
;

/*
 Decodes a 7-bit Hamming(7,4) codeword via Bincode interface.
 Returns tuple of (data, error_pos).
 */
rssn_
rssn_BincodeBuffer rssn_bincode_hamming_decode(rssn_BincodeBuffer aCodewordBuf)
;

/*
 Computes Hamming distance between two byte slices via Bincode interface.
 Input: (a: Vec<u8>, b: Vec<u8>)
 Returns: Option<usize>
 */
rssn_
rssn_BincodeBuffer rssn_bincode_hamming_distance(rssn_BincodeBuffer aABuf,
                                                 rssn_BincodeBuffer aBBuf)
;

/*
 Encodes 4 data bits into a 7-bit Hamming(7,4) codeword via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_hamming_encode(rssn_BincodeBuffer aDataBuf)
;

/*
 Computes Hamming weight of a byte slice via Bincode interface.
 Input: Vec<u8>
 Returns: usize
 */
rssn_
rssn_BincodeBuffer rssn_bincode_hamming_weight(rssn_BincodeBuffer aDataBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_hermite_differential_equation(rssn_BincodeBuffer aYBuf,
                                                              rssn_BincodeBuffer aXBuf,
                                                              rssn_BincodeBuffer aNBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_hermite_h(rssn_BincodeBuffer aDegreeBuf,
                                          rssn_BincodeBuffer aArgBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_hermite_rodrigues_formula(rssn_BincodeBuffer aNBuf,
                                                          rssn_BincodeBuffer aXBuf)
;

/*
 Computes Hessian matrix (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_hessian_matrix(rssn_BincodeBuffer aExprBuf,
                                               rssn_BincodeBuffer aVarsBuf)
;

/*
 Simplifies an expression using the heuristic simplifier (Bincode input/output).
 */
rssn_
rssn_BincodeBuffer rssn_bincode_heuristic_simplify(rssn_BincodeBuffer aExprBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_hilbert_space_create(rssn_BincodeBuffer aBuf)
;

/*
 Calculates ideal gas Law using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_ideal_gas_law(rssn_BincodeBuffer aPBuf,
                                              rssn_BincodeBuffer aVBuf,
                                              rssn_BincodeBuffer aNBuf,
                                              rssn_BincodeBuffer aRBuf,
                                              rssn_BincodeBuffer aTBuf)
;

/*
 Creates a new IteratedFunctionSystem (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_ifs_create(rssn_BincodeBuffer aFunctionsBuf,
                                           rssn_BincodeBuffer aProbabilitiesBuf,
                                           rssn_BincodeBuffer aVariablesBuf)
;

/*
 Calculates similarity dimension (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_ifs_similarity_dimension(rssn_BincodeBuffer aScalingFactorsBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_inner_product(rssn_BincodeBuffer aSpaceBuf,
                                              rssn_BincodeBuffer aFBuf,
                                              rssn_BincodeBuffer aGBuf)
;

/*
 Integrates an expression using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_integrate(rssn_BincodeBuffer aExprBuf,
                                          const char *aVar)
;

/*
 Integrates a rational function (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_integrate_rational_function(rssn_BincodeBuffer aExprBuf,
                                                            rssn_BincodeBuffer aXBuf)
;

/*
 Computes erf⁻¹(x) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_inverse_erf(rssn_BincodeBuffer aValBuf)
;

/*
 Computes erfc⁻¹(x) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_inverse_erfc(rssn_BincodeBuffer aValBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_inverse_fourier_transform(rssn_BincodeBuffer aExprBuf,
                                                          rssn_BincodeBuffer aInVarBuf,
                                                          rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_inverse_laplace_transform(rssn_BincodeBuffer aExprBuf,
                                                          rssn_BincodeBuffer aInVarBuf,
                                                          rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_inverse_z_transform(rssn_BincodeBuffer aExprBuf,
                                                    rssn_BincodeBuffer aInVarBuf,
                                                    rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_is_prime(rssn_BincodeBuffer aNBuf)
;

/*
 Checks if a logical expression is satisfiable using bincode-based FFI.

 Returns a bincode buffer containing:
 - `Some(true)` if satisfiable
 - `Some(false)` if unsatisfiable
 - `None` if the expression contains quantifiers (undecidable)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_is_satisfiable(rssn_BincodeBuffer aExprBuf)
;

/*
 Isolates real roots in an interval (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_isolate_real_roots(rssn_BincodeBuffer aExprBuf,
                                                   const char *aVarPtr,
                                                   double aPrecision)
;

rssn_
rssn_BincodeBuffer rssn_bincode_joint_entropy(rssn_BincodeBuffer aJointProbsBuf)
;

/*
 Calculates kinetic energy using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_kinetic_energy(rssn_BincodeBuffer aMassBuf,
                                               rssn_BincodeBuffer aVelocityBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_kl_divergence(rssn_BincodeBuffer aPProbsBuf,
                                              rssn_BincodeBuffer aQProbsBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_klein_four_group_create()
;

rssn_
rssn_BincodeBuffer rssn_bincode_laguerre_differential_equation(rssn_BincodeBuffer aYBuf,
                                                               rssn_BincodeBuffer aXBuf,
                                                               rssn_BincodeBuffer aNBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_laguerre_l(rssn_BincodeBuffer aDegreeBuf,
                                           rssn_BincodeBuffer aArgBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_laplace_differentiation(rssn_BincodeBuffer aFSBuf,
                                                        rssn_BincodeBuffer aOutVarBuf,
                                                        rssn_BincodeBuffer aFZeroBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_laplace_frequency_shift(rssn_BincodeBuffer aFSBuf,
                                                        rssn_BincodeBuffer aABuf,
                                                        rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_laplace_integration(rssn_BincodeBuffer aFSBuf,
                                                    rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_laplace_scaling(rssn_BincodeBuffer aFSBuf,
                                                rssn_BincodeBuffer aABuf,
                                                rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_laplace_time_shift(rssn_BincodeBuffer aFSBuf,
                                                   rssn_BincodeBuffer aABuf,
                                                   rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_laplace_transform(rssn_BincodeBuffer aExprBuf,
                                                  rssn_BincodeBuffer aInVarBuf,
                                                  rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_laurent_series(rssn_BincodeBuffer aExprBuf,
                                               rssn_BincodeBuffer aVarBuf,
                                               rssn_BincodeBuffer aCenterBuf,
                                               rssn_BincodeBuffer aOrderBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_legendre_differential_equation(rssn_BincodeBuffer aYBuf,
                                                               rssn_BincodeBuffer aXBuf,
                                                               rssn_BincodeBuffer aNBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_legendre_p(rssn_BincodeBuffer aDegreeBuf,
                                           rssn_BincodeBuffer aArgBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_legendre_rodrigues_formula(rssn_BincodeBuffer aNBuf,
                                                           rssn_BincodeBuffer aXBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_lie_algebra_so3()
;

rssn_
rssn_BincodeBuffer rssn_bincode_lie_algebra_su2()
;

rssn_
rssn_BincodeBuffer rssn_bincode_lie_bracket(rssn_BincodeBuffer aXBuf,
                                            rssn_BincodeBuffer aYBuf)
;

/*
 Computes limit using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_limit(rssn_BincodeBuffer aExprBuf,
                                      const char *aVar,
                                      rssn_BincodeBuffer aPointBuf)
;

/*
 Computes ln(B(a, b)) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_ln_beta_numerical(rssn_BincodeBuffer aABuf,
                                                  rssn_BincodeBuffer aBBuf)
;

/*
 Computes ln(n!) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_ln_factorial(rssn_BincodeBuffer aNBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_ln_gamma(rssn_BincodeBuffer aArgBuf)
;

/*
 Computes ln(Γ(x)) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_ln_gamma_numerical(rssn_BincodeBuffer aValBuf)
;

/*
 Calculates Lorentz factor using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_lorentz_factor(rssn_BincodeBuffer aVelocityBuf)
;

/*
 Calculates Lorentz force using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_lorentz_force(rssn_BincodeBuffer aChargeBuf,
                                              rssn_BincodeBuffer aEFieldBuf,
                                              rssn_BincodeBuffer aVelocityBuf,
                                              rssn_BincodeBuffer aBFieldBuf)
;

/*
 Returns Lorenz system equations (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_lorenz_system()
;

/*
 Calculates Lyapunov exponent (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_lyapunov_exponent(rssn_BincodeBuffer aMapBuf,
                                                  const char *aVar,
                                                  rssn_BincodeBuffer aInitialXBuf,
                                                  size_t aNIterations)
;

/*
 Calculates mass-energy equivalence using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_mass_energy_equivalence(rssn_BincodeBuffer aMassBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_matrix_add(rssn_BincodeBuffer aM1Buf,
                                           rssn_BincodeBuffer aM2Buf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_matrix_determinant(rssn_BincodeBuffer aMatrixBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_matrix_inverse(rssn_BincodeBuffer aMatrixBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_matrix_mul(rssn_BincodeBuffer aM1Buf,
                                           rssn_BincodeBuffer aM2Buf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_matrix_solve_linear_system(rssn_BincodeBuffer aABuf,
                                                           rssn_BincodeBuffer aBBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_matrix_transpose(rssn_BincodeBuffer aMatrixBuf)
;

/*
 Computes the symbolic mean of a set of expressions using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_mean(rssn_BincodeBuffer aDataBuf)
;

/*
 Computes geometric product (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_multivector_geometric_product(rssn_BincodeBuffer aABuf,
                                                              rssn_BincodeBuffer aBBuf)
;

/*
 Computes grade projection (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_multivector_grade_projection(rssn_BincodeBuffer aMvBuf,
                                                             uint32_t aGrade)
;

/*
 Computes inner product (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_multivector_inner_product(rssn_BincodeBuffer aABuf,
                                                          rssn_BincodeBuffer aBBuf)
;

/*
 Computes magnitude (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_multivector_magnitude(rssn_BincodeBuffer aMvBuf)
;

/*
 Computes outer product (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_multivector_outer_product(rssn_BincodeBuffer aABuf,
                                                          rssn_BincodeBuffer aBBuf)
;

/*
 Computes reverse (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_multivector_reverse(rssn_BincodeBuffer aMvBuf)
;

/*
 Creates a new scalar multivector (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_multivector_scalar(uint32_t aP,
                                                   uint32_t aQ,
                                                   uint32_t aR,
                                                   rssn_BincodeBuffer aValueBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_mutual_information(rssn_BincodeBuffer aJointProbsBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_nonlinear_regression(rssn_BincodeBuffer aDataBuf,
                                                     rssn_BincodeBuffer aModelBuf,
                                                     rssn_BincodeBuffer aVarsBuf,
                                                     rssn_BincodeBuffer aParamsBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_norm(rssn_BincodeBuffer aSpaceBuf,
                                     rssn_BincodeBuffer aFBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_one_sample_t_test(rssn_BincodeBuffer aDataBuf,
                                                  rssn_BincodeBuffer aTargetMeanBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_partial_fraction_decomposition(rssn_BincodeBuffer aExprBuf,
                                                               rssn_BincodeBuffer aVarBuf)
;

/*
 Computes path integral using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_path_integrate(rssn_BincodeBuffer aExprBuf,
                                               const char *aVar,
                                               rssn_BincodeBuffer aContourBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_permutations(rssn_BincodeBuffer aNBuf,
                                             rssn_BincodeBuffer aKBuf)
;

/*
 Compresses a point.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_point_compress(rssn_BincodeBuffer aPointBuf)
;

/*
 Decompresses a point.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_point_decompress(rssn_BincodeBuffer aXBuf,
                                                 rssn_BincodeBuffer aIsOddBuf,
                                                 rssn_BincodeBuffer aCurveBuf)
;

/*
 Adds two polynomials over a general finite field via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_poly_add_gf(rssn_BincodeBuffer aP1Buf,
                                            rssn_BincodeBuffer aP2Buf,
                                            rssn_BincodeBuffer aModulusBuf)
;

/*
 Adds two polynomials over GF(2^8) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_poly_add_gf256(rssn_BincodeBuffer aP1Buf,
                                               rssn_BincodeBuffer aP2Buf)
;

/*
 Computes polynomial derivative over finite field (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_poly_derivative_gf(rssn_BincodeBuffer aPolyBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_poly_division_multivariate(rssn_BincodeBuffer aDividendBuf,
                                                           rssn_BincodeBuffer aDivisorsBuf,
                                                           rssn_BincodeBuffer aOrderBuf)
;

/*
 Evaluates a polynomial over GF(2^8) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_poly_eval_gf256(rssn_BincodeBuffer aPolyBuf,
                                                rssn_BincodeBuffer aXBuf)
;

/*
 Computes polynomial GCD over finite field (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_poly_gcd_gf(rssn_BincodeBuffer aABuf,
                                            rssn_BincodeBuffer aBBuf)
;

/*
 Multiplies two polynomials over a general finite field via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_poly_mul_gf(rssn_BincodeBuffer aP1Buf,
                                            rssn_BincodeBuffer aP2Buf,
                                            rssn_BincodeBuffer aModulusBuf)
;

/*
 Multiplies two polynomials over GF(2^8) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_poly_mul_gf256(rssn_BincodeBuffer aP1Buf,
                                               rssn_BincodeBuffer aP2Buf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_polygamma(rssn_BincodeBuffer aNBuf,
                                          rssn_BincodeBuffer aZBuf)
;

/*
 Checks if an expression contains a variable (bincode)
 */
rssn_
bool rssn_bincode_polynomial_contains_var(rssn_BincodeBuffer aExprBuf,
                                          const char *aVar)
;

/*
 Computes the degree of a polynomial (bincode)
 */
rssn_
int64_t rssn_bincode_polynomial_degree(rssn_BincodeBuffer aExprBuf,
                                       const char *aVar)
;

/*
 Checks if an expression is a polynomial in the given variable (bincode)
 */
rssn_
bool rssn_bincode_polynomial_is_polynomial(rssn_BincodeBuffer aExprBuf,
                                           const char *aVar)
;

/*
 Finds the leading coefficient of a polynomial (bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_polynomial_leading_coefficient(rssn_BincodeBuffer aExprBuf,
                                                               const char *aVar)
;

/*
 Performs polynomial long division (bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_polynomial_long_division(rssn_BincodeBuffer aDividendBuf,
                                                         rssn_BincodeBuffer aDivisorBuf,
                                                         const char *aVar)
;

rssn_
rssn_BincodeBuffer rssn_bincode_polynomial_regression(rssn_BincodeBuffer aDataBuf,
                                                      size_t aDegree)
;

/*
 Converts polynomial to coefficient vector (bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_polynomial_to_coeffs_vec(rssn_BincodeBuffer aExprBuf,
                                                         const char *aVar)
;

/*
 Adds two prime field elements (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_prime_field_element_add(rssn_BincodeBuffer aABuf,
                                                        rssn_BincodeBuffer aBBuf)
;

/*
 Divides two prime field elements (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_prime_field_element_div(rssn_BincodeBuffer aABuf,
                                                        rssn_BincodeBuffer aBBuf)
;

/*
 Computes the inverse of a prime field element (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_prime_field_element_inverse(rssn_BincodeBuffer aElemBuf)
;

/*
 Multiplies two prime field elements (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_prime_field_element_mul(rssn_BincodeBuffer aABuf,
                                                        rssn_BincodeBuffer aBBuf)
;

/*
 Creates a new prime field element (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_prime_field_element_new(rssn_BincodeBuffer aValueBuf,
                                                        rssn_BincodeBuffer aModulusBuf)
;

/*
 Subtracts two prime field elements (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_prime_field_element_sub(rssn_BincodeBuffer aABuf,
                                                        rssn_BincodeBuffer aBBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_product(rssn_BincodeBuffer aExprBuf,
                                        rssn_BincodeBuffer aVarBuf,
                                        rssn_BincodeBuffer aLowerBuf,
                                        rssn_BincodeBuffer aUpperBuf)
;

/*
 Computes a propagator using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_qft_propagator(rssn_BincodeBuffer aPBuf,
                                               rssn_BincodeBuffer aMBuf,
                                               bool aIsFermion)
;

/*
 Generates a 3x3 2D reflection matrix via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_reflection_2d(rssn_BincodeBuffer aAngleBuf)
;

/*
 Generates a 4x4 3D reflection matrix via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_reflection_3d(rssn_BincodeBuffer aNxBuf,
                                              rssn_BincodeBuffer aNyBuf,
                                              rssn_BincodeBuffer aNzBuf)
;

/*
 Computes P(a, x) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_regularized_gamma_p(rssn_BincodeBuffer aABuf,
                                                    rssn_BincodeBuffer aXBuf)
;

/*
 Computes Q(a, x) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_regularized_gamma_q(rssn_BincodeBuffer aABuf,
                                                    rssn_BincodeBuffer aXBuf)
;

/*
 Computes Iₓ(a, b) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_regularized_incomplete_beta(rssn_BincodeBuffer aABuf,
                                                            rssn_BincodeBuffer aBBuf,
                                                            rssn_BincodeBuffer aXBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_representation_create(rssn_BincodeBuffer aBuf)
;

rssn_
bool rssn_bincode_representation_is_valid(rssn_BincodeBuffer aRepBuf,
                                          rssn_BincodeBuffer aGroupBuf)
;

/*
 Integrates an expression using the Risch-Norman algorithm (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_risch_norman_integrate(rssn_BincodeBuffer aExprBuf,
                                                       rssn_BincodeBuffer aXBuf)
;

/*
 Computes (x)ₙ via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_rising_factorial(rssn_BincodeBuffer aXBuf,
                                                 rssn_BincodeBuffer aNBuf)
;

/*
 Generates a 3x3 2D rotation matrix via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_rotation_2d(rssn_BincodeBuffer aAngleBuf)
;

/*
 Generates a 4x4 3D rotation matrix around X-axis via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_rotation_3d_x(rssn_BincodeBuffer aAngleBuf)
;

/*
 Generates a 4x4 3D rotation matrix around Y-axis via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_rotation_3d_y(rssn_BincodeBuffer aAngleBuf)
;

/*
 Generates a 4x4 3D rotation matrix around Z-axis via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_rotation_3d_z(rssn_BincodeBuffer aAngleBuf)
;

/*
 Generates a 4x4 3D rotation around arbitrary axis via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_rotation_axis_angle(rssn_BincodeBuffer aAxisXBuf,
                                                    rssn_BincodeBuffer aAxisYBuf,
                                                    rssn_BincodeBuffer aAxisZBuf,
                                                    rssn_BincodeBuffer aAngleBuf)
;

/*
 Checks if a Reed-Solomon codeword is valid via Bincode interface.
 Input: (codeword: Vec<u8>, n_sym: usize)
 Returns: bool
 */
rssn_
rssn_BincodeBuffer rssn_bincode_rs_check(rssn_BincodeBuffer aCodewordBuf,
                                         rssn_BincodeBuffer aNSymBuf)
;

/*
 Decodes a Reed-Solomon codeword via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_rs_decode(rssn_BincodeBuffer aCodewordBuf,
                                          rssn_BincodeBuffer aNSymBuf)
;

/*
 Encodes data using Reed-Solomon code via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_rs_encode(rssn_BincodeBuffer aDataBuf,
                                          rssn_BincodeBuffer aNSymBuf)
;

/*
 Estimates error count in a Reed-Solomon codeword via Bincode interface.
 Input: (codeword: Vec<u8>, n_sym: usize)
 Returns: usize
 */
rssn_
rssn_BincodeBuffer rssn_bincode_rs_error_count(rssn_BincodeBuffer aCodewordBuf,
                                               rssn_BincodeBuffer aNSymBuf)
;

/*
 Lagrangian density for a scalar field using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_scalar_field_lagrangian(rssn_BincodeBuffer aPhiBuf,
                                                        rssn_BincodeBuffer aMBuf)
;

/*
 Generates a 3x3 2D scaling matrix via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_scaling_2d(rssn_BincodeBuffer aSxBuf,
                                           rssn_BincodeBuffer aSyBuf)
;

/*
 Generates a 4x4 3D scaling matrix via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_scaling_3d(rssn_BincodeBuffer aSxBuf,
                                           rssn_BincodeBuffer aSyBuf,
                                           rssn_BincodeBuffer aSzBuf)
;

/*
 Calculates Schwarzschild radius using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_schwarzschild_radius(rssn_BincodeBuffer aMassBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_shannon_entropy(rssn_BincodeBuffer aProbsBuf)
;

/*
 Generates a 3x3 2D shear matrix via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_shear_2d(rssn_BincodeBuffer aShxBuf,
                                         rssn_BincodeBuffer aShyBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_simple_linear_regression(rssn_BincodeBuffer aDataBuf)
;

/*
 Creates a new Simplex (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_simplex_create(rssn_BincodeBuffer aVerticesBuf)
;

/*
 Gets the dimension of a Simplex (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_simplex_dimension(rssn_BincodeBuffer aSimplexBuf)
;

/*
 Adds a simplex to a SimplicialComplex (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_simplicial_complex_add_simplex(rssn_BincodeBuffer aComplexBuf,
                                                               rssn_BincodeBuffer aVerticesBuf)
;

/*
 Applies the symbolic boundary operator to a SymbolicChain (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_simplicial_complex_apply_symbolic_boundary_operator(rssn_BincodeBuffer aComplexBuf,
                                                                                    rssn_BincodeBuffer aChainBuf)
;

/*
 Creates a new SimplicialComplex (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_simplicial_complex_create()
;

/*
 Gets the symbolic boundary matrix for dimension k (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_simplicial_complex_get_symbolic_boundary_matrix(rssn_BincodeBuffer aComplexBuf,
                                                                                size_t aK)
;

/*
 Simplifies an expression using the legacy simplifier (Bincode input/output).
 */
rssn_
rssn_BincodeBuffer rssn_bincode_simplify(rssn_BincodeBuffer aExprBuf)
;

/*
 Simplifies an expression using the DAG-based simplifier (Bincode input/output).
 */
rssn_
rssn_BincodeBuffer rssn_bincode_simplify_dag(rssn_BincodeBuffer aExprBuf)
;

/*
 Simplifies a logical expression using bincode-based FFI.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_simplify_logic(rssn_BincodeBuffer aExprBuf)
;

/*
 Simplifies radical expressions (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_simplify_radicals(rssn_BincodeBuffer aExprBuf)
;

/*
 Computes sinc(x) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_sinc(rssn_BincodeBuffer aValBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_so3_generators()
;

rssn_
rssn_BincodeBuffer rssn_bincode_solve(rssn_BincodeBuffer aExprBuf,
                                      rssn_BincodeBuffer aVarBuf)
;

/*
 Solves a Bernoulli ODE using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_bernoulli_ode(rssn_BincodeBuffer aEquationBuf,
                                                    const char *aFunc,
                                                    const char *aVar)
;

/*
 Solves by reduction of order using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_by_reduction_of_order(rssn_BincodeBuffer aEquationBuf,
                                                            const char *aFunc,
                                                            const char *aVar,
                                                            rssn_BincodeBuffer aY1Buf)
;

/*
 Solves a Cauchy-Euler ODE using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_cauchy_euler_ode(rssn_BincodeBuffer aEquationBuf,
                                                       const char *aFunc,
                                                       const char *aVar)
;

rssn_
rssn_BincodeBuffer rssn_bincode_solve_diophantine(rssn_BincodeBuffer aEquationBuf,
                                                  rssn_BincodeBuffer aVarsBuf)
;

/*
 Generates and attempts to solve the Euler-Lagrange equation using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_euler_lagrange(rssn_BincodeBuffer aLagrangianBuf,
                                                     const char *aFunc,
                                                     const char *aVar)
;

/*
 Solves an exact ODE using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_exact_ode(rssn_BincodeBuffer aEquationBuf,
                                                const char *aFunc,
                                                const char *aVar)
;

/*
 Solves a first-order linear ODE using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_first_order_linear_ode(rssn_BincodeBuffer aEquationBuf,
                                                             const char *aFunc,
                                                             const char *aVar)
;

/*
 Solves the 1D heat equation (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_heat_equation_1d(rssn_BincodeBuffer aEquationBuf,
                                                       const char *aFunc,
                                                       rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves the 2D Laplace equation (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_laplace_equation_2d(rssn_BincodeBuffer aEquationBuf,
                                                          const char *aFunc,
                                                          rssn_BincodeBuffer aVarsBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_solve_linear_system(rssn_BincodeBuffer aSystemBuf,
                                                    rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves an ODE using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_ode(rssn_BincodeBuffer aOdeBuf,
                                          const char *aFunc,
                                          const char *aVar)
;

/*
 Solves a PDE using Bincode with automatic method selection.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_pde(rssn_BincodeBuffer aPdeBuf,
                                          const char *aFunc,
                                          rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves a PDE using the method of characteristics (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_pde_by_characteristics(rssn_BincodeBuffer aEquationBuf,
                                                             const char *aFunc,
                                                             rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves a Riccati ODE using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_riccati_ode(rssn_BincodeBuffer aEquationBuf,
                                                  const char *aFunc,
                                                  const char *aVar,
                                                  rssn_BincodeBuffer aY1Buf)
;

/*
 Solves a separable ODE using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_separable_ode(rssn_BincodeBuffer aEquationBuf,
                                                    const char *aFunc,
                                                    const char *aVar)
;

rssn_
rssn_BincodeBuffer rssn_bincode_solve_system(rssn_BincodeBuffer aEquationsBuf,
                                             rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves the 1D wave equation (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_wave_equation_1d(rssn_BincodeBuffer aEquationBuf,
                                                       const char *aFunc,
                                                       rssn_BincodeBuffer aVarsBuf)
;

/*
 Computes square-free factorization (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_square_free_factorization_gf(rssn_BincodeBuffer aPolyBuf)
;

/*
 Computes the symbolic standard deviation of a set of expressions using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_std_dev(rssn_BincodeBuffer aDataBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_stirling_number_second_kind(size_t aN,
                                                            size_t aK)
;

/*
 Represents Stokes' theorem (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_stokes_theorem(rssn_BincodeBuffer aVectorFieldBuf,
                                               rssn_BincodeBuffer aSurfaceBuf)
;

/*
 Generates the Sturm sequence for a given polynomial (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_sturm_sequence(rssn_BincodeBuffer aExprBuf,
                                               const char *aVarPtr)
;

rssn_
rssn_BincodeBuffer rssn_bincode_su2_generators()
;

/*
 Substitutes using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_substitute(rssn_BincodeBuffer aExprBuf,
                                           const char *aVar,
                                           rssn_BincodeBuffer aReplacementBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_summation(rssn_BincodeBuffer aExprBuf,
                                          rssn_BincodeBuffer aVarBuf,
                                          rssn_BincodeBuffer aLowerBuf,
                                          rssn_BincodeBuffer aUpperBuf)
;

/*
 Adds a term to a SymbolicChain (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_symbolic_chain_add_term(rssn_BincodeBuffer aChainBuf,
                                                        rssn_BincodeBuffer aSimplexBuf,
                                                        rssn_BincodeBuffer aCoeffBuf)
;

/*
 Creates a new SymbolicChain (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_symbolic_chain_create(size_t aDimension)
;

rssn_
rssn_BincodeBuffer rssn_bincode_symmetric_group_create(size_t aN)
;

rssn_
rssn_BincodeBuffer rssn_bincode_taylor_series(rssn_BincodeBuffer aExprBuf,
                                              rssn_BincodeBuffer aVarBuf,
                                              rssn_BincodeBuffer aCenterBuf,
                                              rssn_BincodeBuffer aOrderBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_tensor_add(rssn_BincodeBuffer aT1Buf,
                                           rssn_BincodeBuffer aT2Buf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_tensor_outer_product(rssn_BincodeBuffer aT1Buf,
                                                     rssn_BincodeBuffer aT2Buf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_tensor_scalar_mul(rssn_BincodeBuffer aTBuf,
                                                  rssn_BincodeBuffer aScalarBuf)
;

/*
 Converts a logical expression to Conjunctive Normal Form (CNF) using bincode-based FFI.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_to_cnf(rssn_BincodeBuffer aExprBuf)
;

/*
 Converts a logical expression to Disjunctive Normal Form (DNF) using bincode-based FFI.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_to_dnf(rssn_BincodeBuffer aExprBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_transform_contravariant_vector(rssn_BincodeBuffer aCompsBuf,
                                                               rssn_BincodeBuffer aFromBuf,
                                                               rssn_BincodeBuffer aToBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_transform_covariant_vector(rssn_BincodeBuffer aCompsBuf,
                                                           rssn_BincodeBuffer aFromBuf,
                                                           rssn_BincodeBuffer aToBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_transform_curl(rssn_BincodeBuffer aCompsBuf,
                                               rssn_BincodeBuffer aFromBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_transform_divergence(rssn_BincodeBuffer aCompsBuf,
                                                     rssn_BincodeBuffer aFromBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_transform_expression(rssn_BincodeBuffer aExprBuf,
                                                     rssn_BincodeBuffer aFromBuf,
                                                     rssn_BincodeBuffer aToBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_transform_gradient(rssn_BincodeBuffer aScalarBuf,
                                                   rssn_BincodeBuffer aVarsBuf,
                                                   rssn_BincodeBuffer aFromBuf,
                                                   rssn_BincodeBuffer aToBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_transform_point(rssn_BincodeBuffer aPointBuf,
                                                rssn_BincodeBuffer aFromBuf,
                                                rssn_BincodeBuffer aToBuf)
;

/*
 Generates a 3x3 2D translation matrix via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_translation_2d(rssn_BincodeBuffer aTxBuf,
                                               rssn_BincodeBuffer aTyBuf)
;

/*
 Generates a 4x4 3D translation matrix via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_translation_3d(rssn_BincodeBuffer aTxBuf,
                                               rssn_BincodeBuffer aTyBuf,
                                               rssn_BincodeBuffer aTzBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_two_sample_t_test(rssn_BincodeBuffer aData1Buf,
                                                  rssn_BincodeBuffer aData2Buf,
                                                  rssn_BincodeBuffer aMuDiffBuf)
;

/*
 Computes the uncertainty using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_uncertainty(rssn_BincodeBuffer aOpBuf,
                                            rssn_BincodeBuffer aPsiBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_unify_expression(rssn_BincodeBuffer aExprBuf)
;

/*
 Computes the symbolic variance of a set of expressions using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_variance(rssn_BincodeBuffer aDataBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_vector_cross(rssn_BincodeBuffer aV1Buf,
                                             rssn_BincodeBuffer aV2Buf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_vector_dot(rssn_BincodeBuffer aV1Buf,
                                           rssn_BincodeBuffer aV2Buf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_vector_magnitude(rssn_BincodeBuffer aVBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_vector_normalize(rssn_BincodeBuffer aVBuf)
;

/*
 Verifies an equation solution using Bincode.
 */
rssn_
bool rssn_bincode_verify_equation_solution(rssn_BincodeBuffer aEquationsBuf,
                                           rssn_BincodeBuffer aSolutionBuf,
                                           rssn_BincodeBuffer aFreeVarsBuf)
;

/*
 Verifies an indefinite integral using Bincode.
 */
rssn_
bool rssn_bincode_verify_indefinite_integral(rssn_BincodeBuffer aIntegrandBuf,
                                             rssn_BincodeBuffer aIntegralResultBuf,
                                             rssn_BincodeBuffer aVarBuf)
;

/*
 Computes the wedge product of two differential forms (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_wedge_product(rssn_BincodeBuffer aForm1Buf,
                                              rssn_BincodeBuffer aForm2Buf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_z_differentiation(rssn_BincodeBuffer aFZBuf,
                                                  rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_z_scaling(rssn_BincodeBuffer aFZBuf,
                                          rssn_BincodeBuffer aABuf,
                                          rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_z_test(rssn_BincodeBuffer aDataBuf,
                                       rssn_BincodeBuffer aTargetMeanBuf,
                                       rssn_BincodeBuffer aPopStdDevBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_z_time_shift(rssn_BincodeBuffer aFZBuf,
                                             rssn_BincodeBuffer aKBuf,
                                             rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_z_transform(rssn_BincodeBuffer aExprBuf,
                                            rssn_BincodeBuffer aInVarBuf,
                                            rssn_BincodeBuffer aOutVarBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_zeta(rssn_BincodeBuffer aArgBuf)
;

/*
 Computes ζ(s) via Bincode interface.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_zeta_numerical(rssn_BincodeBuffer aValBuf)
;

/*
 Computes the binomial coefficient C(n, k).
 */
rssn_
uint64_t rssn_binomial(uint64_t aN,
                       uint64_t aK)
;

/*
 Computes binomial coefficient C(n, k).
 */
rssn_
char *rssn_binomial_coefficient(size_t aN,
                                size_t aK)
;

/*
 Computes binomial coefficient C(n, k) and returns as JSON string.
 */
rssn_
char *rssn_binomial_coefficient_json(size_t aN,
                                     size_t aK)
;

/*
 Calculates Boltzmann Distribution.
 */
rssn_
rssn_Expr *rssn_boltzmann_distribution(const rssn_Expr *aEnergy,
                                       const rssn_Expr *aTemperature,
                                       const rssn_Expr *aPartitionFunction)
;

/*
 Computes the boundary of a domain (Handle)
 */
rssn_
rssn_Expr *rssn_boundary_handle(const rssn_Expr *aDomainPtr)
;

/*
 Frees a Bra.
 */
rssn_
void rssn_bra_free(rssn_Bra *aBra)
;

/*
 Computes the inner product <Bra|Ket>.
 */
rssn_
rssn_Expr *rssn_bra_ket(const rssn_Bra *aBra,
                        const rssn_Ket *aKet)
;

/*
 Creates a new Bra from a state expression.
 */
rssn_
rssn_Bra *rssn_bra_new(const rssn_Expr *aState)
;

rssn_
rssn_Vec<rssn_SparsePolynomial> *rssn_buchberger_handle(const rssn_Vec<rssn_SparsePolynomial> *aBasis,
                                                        rssn_MonomialOrder aOrder)
;

/*
 Gets the number of cells in a CAD.
 */
rssn_
size_t rssn_cad_get_cell_count(const rssn_Cad *aPtr)
;

/*
 Computes CAD for a set of polynomials (Handle).

 Expects an array of Expr handles (which must be SparsePolynomial variants)
 and an array of variable name strings.
 */
rssn_
rssn_Cad *rssn_cad_handle(const rssn_Expr *const *aPolys,
                          size_t aPolysCount,
                          const char *const *aVars,
                          size_t aVarsCount)
;

/*
 Calculates the residue of a complex function at a given pole.
 */
rssn_
rssn_Expr *rssn_calculate_residue(const rssn_Expr *aExpr,
                                  const char *aVar,
                                  const rssn_Expr *aPole)
;

rssn_
int32_t rssn_calculus_definite_integrate(size_t aExprH,
                                         const char *aVar,
                                         size_t aLowerH,
                                         size_t aUpperH,
                                         size_t *aResultH)
;

rssn_
int32_t rssn_calculus_differentiate(size_t aExprH,
                                    const char *aVar,
                                    size_t *aResultH)
;

rssn_
int32_t rssn_calculus_integrate(size_t aExprH,
                                const char *aVar,
                                size_t *aResultH)
;

rssn_
int32_t rssn_calculus_limit(size_t aExprH,
                            const char *aVar,
                            size_t aToH,
                            size_t *aResultH)
;

rssn_
int32_t rssn_calculus_substitute(size_t aExprH,
                                 const char *aVar,
                                 size_t aReplacementH,
                                 size_t *aResultH)
;

/*
 Calculates Carnot Efficiency: 1 - Tc/Th.
 */
rssn_
rssn_Expr *rssn_carnot_efficiency(const rssn_Expr *aTc,
                                  const rssn_Expr *aTh)
;

/*
 Expands an expression using algebraic rules.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_
rssn_Expr *rssn_cas_expand(const rssn_Expr *aExpr)
;

/*
 Expands an expression using algebraic rules (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_cas_expand_bincode(rssn_BincodeBuffer aInput)
;

/*
 Expands an expression using algebraic rules (JSON).
 */
rssn_
char *rssn_cas_expand_json(const char *aJsonStr)
;

/*
 Factorizes an expression.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_
rssn_Expr *rssn_cas_factorize(const rssn_Expr *aExpr)
;

/*
 Factorizes an expression (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_cas_factorize_bincode(rssn_BincodeBuffer aInput)
;

/*
 Factorizes an expression (JSON).
 */
rssn_
char *rssn_cas_factorize_json(const char *aJsonStr)
;

/*
 Normalizes an expression to a canonical form.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_
rssn_Expr *rssn_cas_normalize(const rssn_Expr *aExpr)
;

/*
 Normalizes an expression to a canonical form (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_cas_normalize_bincode(rssn_BincodeBuffer aInput)
;

/*
 Normalizes an expression to a canonical form (JSON).
 */
rssn_
char *rssn_cas_normalize_json(const char *aJsonStr)
;

/*
 Simplifies an expression using a set of polynomial side-relations.

 # Arguments
 * `expr` - The expression to simplify.
 * `relations` - Array of pointers to relation expressions (e.g., `x^2 + y^2 - 1`).
 * `relations_len` - Number of relations.
 * `vars` - Array of C strings representing variable ordering.
 * `vars_len` - Number of variables.
 * `order_int` - Monomial ordering: 0=Lex, 1=GradedLex, 2=GradedReverseLex.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_cas_simplify_with_relations(const rssn_Expr *aExpr,
                                            const rssn_Expr *const *aRelations,
                                            size_t aRelationsLen,
                                            const char *const *aVars,
                                            size_t aVarsLen,
                                            int32_t aOrderInt)
;

/*
 Simplifies an expression using a set of polynomial side-relations (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_cas_simplify_with_relations_bincode(rssn_BincodeBuffer aInput)
;

/*
 Simplifies an expression using a set of polynomial side-relations (JSON).
 */
rssn_
char *rssn_cas_simplify_with_relations_json(const char *aJsonStr)
;

rssn_
rssn_Expr *rssn_catalan_number(size_t aN)
;

rssn_
void rssn_character(const rssn_Representation *aRep,
                    size_t *aOutLen,
                    rssn_Expr ***aOutKeys,
                    rssn_Expr ***aOutValues)
;

/*
 Constructs Chebyshev's differential equation: (1-x²)y'' - xy' + n²y = 0.
 */
rssn_
rssn_Expr *rssn_chebyshev_differential_equation(const rssn_Expr *aY,
                                                const rssn_Expr *aX,
                                                const rssn_Expr *aN)
;

/*
 Computes the symbolic Chebyshev polynomial of the first kind T_n(x).
 */
rssn_
rssn_Expr *rssn_chebyshev_t(const rssn_Expr *aN,
                            const rssn_Expr *aX)
;

/*
 Computes the symbolic Chebyshev polynomial of the second kind U_n(x).
 */
rssn_
rssn_Expr *rssn_chebyshev_u(const rssn_Expr *aN,
                            const rssn_Expr *aX)
;

/*
 Checks if an expression is analytic with respect to a variable.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `var` is a valid C string.
 */
rssn_
bool rssn_check_analytic(const rssn_Expr *aExpr,
                         const char *aVar)
;

rssn_
bool rssn_check_jacobi_identity(const rssn_LieAlgebra *aAlgebra)
;

/*
 Solves a system of congruences using the Chinese Remainder Theorem.

 # Safety
 `remainders` and `moduli` must be valid pointers to arrays of `Expr` pointers of length `len`.
 */
rssn_
rssn_Expr *rssn_chinese_remainder_handle(const rssn_Expr *const *aRemainders,
                                         const rssn_Expr *const *aModuli,
                                         int aLen)
;

/*
 Finds the chromatic number exactly (NP-hard).
 */
rssn_
size_t rssn_chromatic_number_exact(const rssn_RssnGraph *aGraph)
;

/*
 Computes the number of combinations (nCk).
 */
rssn_
int32_t rssn_comb_combinations(uint64_t aN,
                               uint64_t aK,
                               double *aResult)
;

/*
 Computes the factorial of a number.
 */
rssn_
int32_t rssn_comb_factorial(uint64_t aN,
                            double *aResult)
;

/*
 Computes the number of permutations (nPk).
 */
rssn_
int32_t rssn_comb_permutations(uint64_t aN,
                               uint64_t aK,
                               double *aResult)
;

rssn_
rssn_Expr *rssn_combinations(const rssn_Expr *aN,
                             const rssn_Expr *aK)
;

/*
 Computes the commutator [A, B] acting on a Ket.
 */
rssn_
rssn_Expr *rssn_commutator(const rssn_Operator *aA,
                           const rssn_Operator *aB,
                           const rssn_Ket *aKet)
;

rssn_
rssn_Expr **rssn_commutator_table(const rssn_LieAlgebra *aAlgebra,
                                  size_t *aOutRows,
                                  size_t *aOutCols)
;

/*
 Finds fixed points (Handle)
 */
rssn_
rssn_Expr **rssn_complex_system_fixed_points(const rssn_ComplexDynamicalSystem *aSystemPtr,
                                             size_t *aOutLen)
;

/*
 Frees a ComplexDynamicalSystem handle
 */
rssn_
void rssn_complex_system_free(rssn_ComplexDynamicalSystem *aPtr)
;

/*
 Iterates the system once (Handle)
 */
rssn_
rssn_Expr *rssn_complex_system_iterate(const rssn_ComplexDynamicalSystem *aSystemPtr,
                                       const rssn_Expr *aZPtr)
;

/*
 Creates a new Mandelbrot family system (Handle)
 */
rssn_
rssn_ComplexDynamicalSystem *rssn_complex_system_new_mandelbrot(const rssn_Expr *aCPtr)
;

/*
 Clears a ComputationResultCache.
 */
rssn_
void rssn_computation_result_cache_clear(rssn_ComputationResultCache *aCache)
;

/*
 Frees a ComputationResultCache.
 */
rssn_
void rssn_computation_result_cache_free(rssn_ComputationResultCache *aCache)
;

/*
 Retrieves a value from the ComputationResultCache.
 Returns a C string (char*) which must be freed by the caller using rssn_free_string.
 Returns null if not found.
 */
rssn_
char *rssn_computation_result_cache_get(rssn_ComputationResultCache *aCache,
                                        const rssn_Expr *aExpr)
;

/*
 Retrieves a value from the ComputationResultCache using a bincode expression key.
 */
rssn_
rssn_BincodeBuffer rssn_computation_result_cache_get_bincode(rssn_ComputationResultCache *aCache,
                                                             rssn_BincodeBuffer aExprBuffer)
;

/*
 Retrieves a value from the ComputationResultCache using a JSON expression key.
 Returns the value as a JSON string (e.g. "\"result\"").
 */
rssn_
char *rssn_computation_result_cache_get_json(rssn_ComputationResultCache *aCache,
                                             const char *aJsonExpr)
;

/*
 Creates a new ComputationResultCache.
 The caller is responsible for freeing the memory using rssn_computation_result_cache_free.
 */
rssn_
rssn_ComputationResultCache *rssn_computation_result_cache_new()
;

/*
 Stores a value in the ComputationResultCache.
 */
rssn_
void rssn_computation_result_cache_set(rssn_ComputationResultCache *aCache,
                                       const rssn_Expr *aExpr,
                                       const char *aValue)
;

/*
 Stores a value in the ComputationResultCache using bincode buffers.
 */
rssn_
void rssn_computation_result_cache_set_bincode(rssn_ComputationResultCache *aCache,
                                               rssn_BincodeBuffer aExprBuffer,
                                               rssn_BincodeBuffer aValueBuffer)
;

/*
 Stores a value in the ComputationResultCache using JSON strings.
 */
rssn_
void rssn_computation_result_cache_set_json(rssn_ComputationResultCache *aCache,
                                            const char *aJsonExpr,
                                            const char *aJsonValue)
;

rssn_
rssn_Expr *rssn_conditional_entropy(const rssn_Expr *aJointProbs)
;

/*
 Applies Aitken's acceleration to the input sequence.

 # Arguments
 * `data` - Pointer to the input sequence array.
 * `len` - Length of the input sequence.

 # Returns
 A pointer to a new `Vec<f64>` containing the accelerated sequence, or null on error.
 */
rssn_
rssn_Vec<double> *rssn_convergence_aitken(const double *aData,
                                          size_t aLen)
;

/*
 Bincode FFI for Aitken acceleration.
 */
rssn_
rssn_BincodeBuffer rssn_convergence_aitken_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for Aitken acceleration.
 */
rssn_
char *rssn_convergence_aitken_json(const char *aJsonPtr)
;

/*
 Frees a generic `Vec<f64>` pointer created by convergence functions.
 */
rssn_
void rssn_convergence_free_vec(rssn_Vec<double> *aVec)
;

/*
 Copies the vector data into a provided buffer.
 buffer must have size at least `len * sizeof(f64)`.
 */
rssn_
void rssn_convergence_get_vec_data(const rssn_Vec<double> *aVec,
                                   double *aBuffer)
;

/*
 Returns the length of the vector.
 */
rssn_
size_t rssn_convergence_get_vec_len(const rssn_Vec<double> *aVec)
;

/*
 Applies Richardson extrapolation to the input sequence.

 # Arguments
 * `data` - Pointer to the input sequence array (assumed approximations with halving steps).
 * `len` - Length of the input sequence.

 # Returns
 A pointer to a new `Vec<f64>` containing the extrapolated sequence, or null on error.
 */
rssn_
rssn_Vec<double> *rssn_convergence_richardson(const double *aData,
                                              size_t aLen)
;

/*
 Bincode FFI for Richardson extrapolation.
 */
rssn_
rssn_BincodeBuffer rssn_convergence_richardson_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for Richardson extrapolation.
 */
rssn_
char *rssn_convergence_richardson_json(const char *aJsonPtr)
;

/*
 Applies Wynn's epsilon algorithm to the input sequence.

 # Arguments
 * `data` - Pointer to the input sequence array.
 * `len` - Length of the input sequence.

 # Returns
 A pointer to a new `Vec<f64>` containing the accelerated sequence, or null on error.
 */
rssn_
rssn_Vec<double> *rssn_convergence_wynn(const double *aData,
                                        size_t aLen)
;

/*
 Bincode FFI for Wynn's epsilon algorithm.
 */
rssn_
rssn_BincodeBuffer rssn_convergence_wynn_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for Wynn's epsilon algorithm.
 */
rssn_
char *rssn_convergence_wynn_json(const char *aJsonPtr)
;

rssn_
rssn_Expr *rssn_convolution_fourier(const rssn_Expr *aF,
                                    const rssn_Expr *aG,
                                    const char *aInVar,
                                    const char *aOutVar)
;

rssn_
rssn_Expr *rssn_convolution_laplace(const rssn_Expr *aF,
                                    const rssn_Expr *aG,
                                    const char *aInVar,
                                    const char *aOutVar)
;

rssn_
rssn_Expr *rssn_coordinates_get_metric_tensor_handle(rssn_CoordinateSystem aSystem)
;

/*
 Computes the symbolic Pearson correlation coefficient.

 # Safety
 The caller must ensure `data1` and `data2` are valid pointers to arrays of `Expr` pointers.
 */
rssn_
rssn_Expr *rssn_correlation(const rssn_Expr *const *aData1,
                            size_t aLen1,
                            const rssn_Expr *const *aData2,
                            size_t aLen2)
;

/*
 Creates a cosine expression: cos(expr).
 */
rssn_
rssn_Expr *rssn_cos(const rssn_Expr *aExpr)
;

/*
 Creates a cosine expression from bincode: cos(expr).
 */
rssn_
rssn_BincodeBuffer rssn_cos_bincode(rssn_BincodeBuffer aExprBuffer)
;

/*
 Creates a cosine expression from JSON: cos(expr).
 */
rssn_
char *rssn_cos_json(const char *aJsonExpr)
;

/*
 Calculates Coulomb's Law field.
 */
rssn_
rssn_Vector *rssn_coulombs_law(const rssn_Expr *aCharge,
                               const rssn_Vector *aR)
;

/*
 Counts the number of distinct real roots in an interval (Handle)
 */
rssn_
int64_t rssn_count_real_roots_in_interval_handle(const rssn_Expr *aExprPtr,
                                                 const char *aVarPtr,
                                                 double aA,
                                                 double aB)
;

/*
 Computes the symbolic covariance of two sets of expressions.

 # Safety
 The caller must ensure `data1` and `data2` are valid pointers to arrays of `Expr` pointers.
 */
rssn_
rssn_Expr *rssn_covariance(const rssn_Expr *const *aData1,
                           size_t aLen1,
                           const rssn_Expr *const *aData2,
                           size_t aLen2)
;

/*
 Computes CRC-32 checksum of data.

 # Safety
 Caller must ensure `data` points to `len` bytes.
 */
rssn_
uint32_t rssn_crc32_compute(const uint8_t *aData,
                            size_t aLen)
;

/*
 Finalizes a CRC-32 computation started with crc32_update.
 */
rssn_
uint32_t rssn_crc32_finalize(uint32_t aCrc)
;

/*
 Updates an existing CRC-32 with additional data (for incremental computation).

 # Safety
 Caller must ensure `data` points to `len` bytes.
 Use 0xFFFFFFFF as initial crc for first call.
 */
rssn_
uint32_t rssn_crc32_update(uint32_t aCrc,
                           const uint8_t *aData,
                           size_t aLen)
;

/*
 Verifies CRC-32 checksum of data.

 # Safety
 Caller must ensure `data` points to `len` bytes.
 Returns 1 if valid, 0 if invalid.
 */
rssn_
int32_t rssn_crc32_verify(const uint8_t *aData,
                          size_t aLen,
                          uint32_t aExpectedCrc)
;

/*
 Creates a grid complex
 */
rssn_
rssn_SimplicialComplex *rssn_create_grid_complex(size_t aWidth,
                                                 size_t aHeight)
;

/*
 Creates a torus complex
 */
rssn_
rssn_SimplicialComplex *rssn_create_torus_complex(size_t aM,
                                                  size_t aN)
;

rssn_
rssn_Expr *rssn_cross_entropy(const rssn_Expr *const *aPProbs,
                              size_t aPLen,
                              const rssn_Expr *const *aQProbs,
                              size_t aQLen)
;

/*
 Frees a CrystalLattice.
 */
rssn_
void rssn_crystal_lattice_free(rssn_CrystalLattice *aPtr)
;

/*
 Creates a new CrystalLattice.
 */
rssn_
rssn_CrystalLattice *rssn_crystal_lattice_new(const rssn_Vector *aA1,
                                              const rssn_Vector *aA2,
                                              const rssn_Vector *aA3)
;

/*
 Computes reciprocal lattice vectors.
 */
rssn_
void rssn_crystal_lattice_reciprocal_vectors(const rssn_CrystalLattice *aPtr,
                                             rssn_Vector **aB1,
                                             rssn_Vector **aB2,
                                             rssn_Vector **aB3)
;

/*
 Computes the volume of the unit cell.
 */
rssn_
rssn_Expr *rssn_crystal_lattice_volume(const rssn_CrystalLattice *aPtr)
;

rssn_
rssn_CurvePoint *rssn_curve_add(const rssn_EllipticCurve *aCurve,
                                const rssn_CurvePoint *aP1,
                                const rssn_CurvePoint *aP2)
;

rssn_
rssn_CurvePoint *rssn_curve_double(const rssn_EllipticCurve *aCurve,
                                   const rssn_CurvePoint *aPoint)
;

rssn_
bool rssn_curve_is_on_curve(const rssn_EllipticCurve *aCurve,
                            const rssn_CurvePoint *aPoint)
;

rssn_
rssn_CurvePoint *rssn_curve_negate(const rssn_EllipticCurve *aCurve,
                                   const rssn_CurvePoint *aPoint)
;

/*
 Creates an affine curve point from decimal strings.
 */
rssn_
rssn_CurvePoint *rssn_curve_point_affine(const char *aXStr,
                                         const char *aYStr,
                                         const char *aModulusStr)
;

/*
 Frees a curve point handle.
 */
rssn_
void rssn_curve_point_free(rssn_CurvePoint *aPoint)
;

/*
 Gets the x-coordinate of an affine point as a string. Returns NULL if infinity.
 */
rssn_
char *rssn_curve_point_get_x(const rssn_CurvePoint *aPoint)
;

/*
 Gets the y-coordinate of an affine point as a string. Returns NULL if infinity.
 */
rssn_
char *rssn_curve_point_get_y(const rssn_CurvePoint *aPoint)
;

/*
 Creates the point at infinity.
 */
rssn_
rssn_CurvePoint *rssn_curve_point_infinity()
;

/*
 Checks if a point is the point at infinity.
 */
rssn_
bool rssn_curve_point_is_infinity(const rssn_CurvePoint *aPoint)
;

/*
 Scalar multiplication. k is a string.
 */
rssn_
rssn_CurvePoint *rssn_curve_scalar_mult(const rssn_EllipticCurve *aCurve,
                                        const char *aKStr,
                                        const rssn_CurvePoint *aP)
;

rssn_
rssn_Group *rssn_cyclic_group_create(size_t aN)
;

/*
 Computes the definite integral of an expression.
 */
rssn_
rssn_Expr *rssn_definite_integrate(const rssn_Expr *aExpr,
                                   const char *aVar,
                                   const rssn_Expr *aLower,
                                   const rssn_Expr *aUpper)
;

/*
 Denests a nested square root (Handle)
 */
rssn_
rssn_Expr *rssn_denest_sqrt_handle(const rssn_Expr *aExpr)
;

/*
 Computes the density of states for a 3D electron gas.
 */
rssn_
rssn_Expr *rssn_density_of_states_3d(const rssn_Expr *aEnergy,
                                     const rssn_Expr *aEffectiveMass,
                                     const rssn_Expr *aVolume)
;

/*
 Differentiates an expression: d/d(var) expr.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `var` is a valid C string.
 */
rssn_
rssn_Expr *rssn_differentiate(const rssn_Expr *aExpr,
                              const char *aVar)
;

/*
 Computes the symbolic Digamma function ψ(z).
 */
rssn_
rssn_Expr *rssn_digamma(const rssn_Expr *aArg)
;

/*
 Computes the digamma function ψ(x) = d/dx ln(Γ(x)).
 */
rssn_
double rssn_digamma_numerical(double aX)
;

rssn_
rssn_Group *rssn_dihedral_group_create(size_t aN)
;

/*
 Computes the Dirac adjoint of a fermion field.
 */
rssn_
rssn_Expr *rssn_dirac_adjoint(const rssn_Expr *aPsi)
;

/*
 Dirac equation for a free particle.
 */
rssn_
rssn_Expr *rssn_dirac_equation(const rssn_Expr *aPsi,
                               const rssn_Expr *aM)
;

rssn_
rssn_Expr *rssn_dist_bernoulli(const rssn_Expr *aP)
;

rssn_
rssn_Expr *rssn_dist_beta(const rssn_Expr *aAlpha,
                          const rssn_Expr *aBeta)
;

rssn_
rssn_Expr *rssn_dist_binomial(const rssn_Expr *aN,
                              const rssn_Expr *aP)
;

rssn_
rssn_Expr *rssn_dist_cdf(const rssn_Expr *aDist,
                         const rssn_Expr *aX)
;

rssn_
rssn_Expr *rssn_dist_expectation(const rssn_Expr *aDist)
;

rssn_
rssn_Expr *rssn_dist_exponential(const rssn_Expr *aRate)
;

rssn_
rssn_Expr *rssn_dist_gamma(const rssn_Expr *aShape,
                           const rssn_Expr *aRate)
;

rssn_
rssn_Expr *rssn_dist_mgf(const rssn_Expr *aDist,
                         const rssn_Expr *aT)
;

rssn_
rssn_Expr *rssn_dist_normal(const rssn_Expr *aMean,
                            const rssn_Expr *aStdDev)
;

rssn_
rssn_Expr *rssn_dist_pdf(const rssn_Expr *aDist,
                         const rssn_Expr *aX)
;

rssn_
rssn_Expr *rssn_dist_poisson(const rssn_Expr *aRate)
;

rssn_
rssn_Expr *rssn_dist_student_t(const rssn_Expr *aNu)
;

rssn_
rssn_Expr *rssn_dist_uniform(const rssn_Expr *aMin,
                             const rssn_Expr *aMax)
;

rssn_
rssn_Expr *rssn_dist_variance(const rssn_Expr *aDist)
;

/*
 Computes the double factorial n!!.
 */
rssn_
uint64_t rssn_double_factorial(uint64_t aN)
;

/*
 Computes Drude conductivity.
 */
rssn_
rssn_Expr *rssn_drude_conductivity(const rssn_Expr *aN,
                                   const rssn_Expr *aECharge,
                                   const rssn_Expr *aTau,
                                   const rssn_Expr *aMStar)
;

/*
 Returns the symbolic representation of Euler's number (e).
 */
rssn_
rssn_Expr *rssn_e()
;

/*
 Returns Euler's number (e) as bincode.
 */
rssn_
rssn_BincodeBuffer rssn_e_bincode()
;

/*
 Returns Euler's number (e) as JSON.
 */
rssn_ char *rssn_e_json() ;

rssn_
rssn_EcdsaSignature *rssn_ecdsa_sign(const char *aMessageHashStr,
                                     const char *aPrivateKeyStr,
                                     const rssn_EllipticCurve *aCurve,
                                     const rssn_CurvePoint *aGenerator,
                                     const char *aOrderStr)
;

rssn_
void rssn_ecdsa_signature_free(rssn_EcdsaSignature *aSig)
;

rssn_
char *rssn_ecdsa_signature_get_r(const rssn_EcdsaSignature *aSig)
;

rssn_
char *rssn_ecdsa_signature_get_s(const rssn_EcdsaSignature *aSig)
;

rssn_
bool rssn_ecdsa_verify(const char *aMessageHashStr,
                       const rssn_EcdsaSignature *aSignature,
                       const rssn_CurvePoint *aPublicKey,
                       const rssn_EllipticCurve *aCurve,
                       const rssn_CurvePoint *aGenerator,
                       const char *aOrderStr)
;

/*
 Computes electric field from scalar and vector potentials.
 */
rssn_
rssn_Vector *rssn_electric_field_from_potentials(const rssn_Expr *aV,
                                                 const rssn_Vector *aA,
                                                 const char *aX,
                                                 const char *aY,
                                                 const char *aZ,
                                                 const char *aT)
;

/*
 Calculates energy density.
 */
rssn_
rssn_Expr *rssn_electromagnetic_energy_density(const rssn_Vector *aEField,
                                               const rssn_Vector *aBField)
;

/*
 Frees an elliptic curve handle.
 */
rssn_
void rssn_elliptic_curve_free(rssn_EllipticCurve *aCurve)
;

/*
 Creates a new elliptic curve from decimal strings.
 */
rssn_
rssn_EllipticCurve *rssn_elliptic_curve_new(const char *aAStr,
                                            const char *aBStr,
                                            const char *aModulusStr)
;

/*
 Calculates enthalpy: U + PV.
 */
rssn_
rssn_Expr *rssn_enthalpy(const rssn_Expr *aU,
                         const rssn_Expr *aP,
                         const rssn_Expr *aV)
;

/*
 Computes the symbolic error function erf(z).
 */
rssn_
rssn_Expr *rssn_erf(const rssn_Expr *aArg)
;

/*
 Computes the error function erf(x).
 */
rssn_
double rssn_erf_numerical(double aX)
;

/*
 Computes the symbolic complementary error function erfc(z).
 */
rssn_
rssn_Expr *rssn_erfc(const rssn_Expr *aArg)
;

/*
 Computes the complementary error function erfc(x).
 */
rssn_
double rssn_erfc_numerical(double aX)
;

/*
 Computes the symbolic imaginary error function erfi(z).
 */
rssn_
rssn_Expr *rssn_erfi(const rssn_Expr *aArg)
;

/*
 Computes the Euler-Lagrange equation for a given Lagrangian.

 # Safety
 The caller must ensure `lagrangian` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
rssn_Expr *rssn_euler_lagrange(const rssn_Expr *aLagrangian,
                               const char *aFunc,
                               const char *aVar)
;

/*
 Computes Euler-Lagrange equation.
 */
rssn_
rssn_Expr *rssn_euler_lagrange_equation(const rssn_Expr *aLagrangian,
                                        const char *aQ,
                                        const char *aQDot,
                                        const char *aTVar)
;

/*
 Evaluates an expression at a given point.
 */
rssn_
rssn_Expr *rssn_evaluate_at_point(const rssn_Expr *aExpr,
                                  const char *aVar,
                                  const rssn_Expr *aValue)
;

rssn_
double rssn_evaluate_numerical_handle(const rssn_Expr *aExpr)
;

/*
 Creates an exponential expression: e^(expr).
 */
rssn_
rssn_Expr *rssn_exp(const rssn_Expr *aExpr)
;

/*
 Creates an exponential expression from bincode: e^(expr).
 */
rssn_
rssn_BincodeBuffer rssn_exp_bincode(rssn_BincodeBuffer aExprBuffer)
;

/*
 Creates an exponential expression from JSON: e^(expr).
 */
rssn_
char *rssn_exp_json(const char *aJsonExpr)
;

/*
 Expands a symbolic expression.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_
rssn_Expr *rssn_expand(const rssn_Expr *aExpr)
;

/*
 Expands a symbolic expression from bincode.
 */
rssn_
rssn_BincodeBuffer rssn_expand_bincode(rssn_BincodeBuffer aExprBuffer)
;

/*
 Expands a symbolic expression from JSON.
 */
rssn_
char *rssn_expand_json(const char *aJsonExpr)
;

/*
 Computes the expectation value <A>.
 */
rssn_
rssn_Expr *rssn_expectation_value(const rssn_Operator *aOp,
                                  const rssn_Ket *aPsi)
;

rssn_
rssn_Expr *rssn_exponential_map(const rssn_Expr *aX,
                                size_t aOrder)
;

/*
 Creates an expression from a JSON string and returns a thread-safe handle.

 Returns 0 if the JSON is invalid.
 */
rssn_
size_t rssn_expr_create(const char *aJsonPtr)
;

/*
 Frees the memory associated with an expression handle.
 */
rssn_
void rssn_expr_free(size_t aHandle)
;

rssn_
void rssn_expr_list_free(rssn_ExprList *aList)
;

rssn_
rssn_Expr *rssn_expr_list_get(const rssn_ExprList *aList,
                              size_t aIndex)
;

rssn_
size_t rssn_expr_list_len(const rssn_ExprList *aList)
;

/*
 Simplifies an expression handle and returns a handle to the new, simplified expression.

 Returns 0 on error (e.g., invalid handle).
 */
rssn_
size_t rssn_expr_simplify(const size_t *aHandle)
;

/*
 Computes the Extended GCD of two expressions.

 # Safety
 `a` and `b` must be valid pointers to `Expr`.
 */
rssn_
rssn_Expr *rssn_extended_gcd_handle(const rssn_Expr *aA,
                                    const rssn_Expr *aB)
;

/*
 Computes the exterior derivative of a differential form (Handle)
 */
rssn_
rssn_DifferentialForm *rssn_exterior_derivative_handle(const rssn_DifferentialForm *aFormPtr,
                                                       const char *const *aVarsPtr,
                                                       int aVarsLen)
;

/*
 Factors a polynomial over a finite field (Handle)
 */
rssn_
rssn_Vec<rssn_FiniteFieldPolynomial> *rssn_factor_gf_handle(const rssn_FiniteFieldPolynomial *aPoly)
;

/*
 Computes the factorial n!.
 */
rssn_
uint64_t rssn_factorial(uint64_t aN)
;

/*
 Computes the falling factorial (x)₍ₙ₎.
 */
rssn_
double rssn_falling_factorial(double aX,
                              uint32_t aN)
;

/*
 Computes Fermi energy for a 3D electron gas.
 */
rssn_
rssn_Expr *rssn_fermi_energy_3d(const rssn_Expr *aConcentration,
                                const rssn_Expr *aEffectiveMass)
;

/*
 Feynman propagator in position space.
 */
rssn_
rssn_Expr *rssn_feynman_propagator_position_space(const rssn_Expr *aX,
                                                  const rssn_Expr *aY,
                                                  const rssn_Expr *aM)
;

/*
 Computes the Feynman slash notation.
 */
rssn_
rssn_Expr *rssn_feynman_slash(const rssn_Expr *aVMu)
;

/*
 Computes the Fast Fourier Transform (FFT) of a sequence of complex numbers in-place.
 */
rssn_
int32_t rssn_fft(rssn_Complex<double> *aData,
                 size_t aLen)
;

/*
 Finds constrained extrema (Handle)
 */
rssn_
rssn_Vec<rssn_HashMap<rssn_Expr, rssn_Expr>> *rssn_find_constrained_extrema_handle(const rssn_Expr *aExprPtr,
                                                                                   const rssn_Vec<rssn_Expr> *aConstraintsPtr,
                                                                                   const char *const *aVarsPtr,
                                                                                   int aVarsLen)
;

/*
 Finds extrema of a function (Handle)
 */
rssn_
rssn_Vec<rssn_CriticalPoint> *rssn_find_extrema_handle(const rssn_Expr *aExprPtr,
                                                       const char *const *aVarsPtr,
                                                       int aVarsLen)
;

/*
 Finds fixed points of a 1D map (Handle)
 */
rssn_
rssn_Expr **rssn_find_fixed_points(const rssn_Expr *aMapPtr,
                                   const char *aVar,
                                   size_t *aOutLen)
;

/*
 Finds the order of a pole.
 */
rssn_
size_t rssn_find_pole_order(const rssn_Expr *aExpr,
                            const char *aVar,
                            const rssn_Expr *aPole)
;

/*
 Finds poles of an expression.
 */
rssn_
rssn_Vec<rssn_Expr> *rssn_find_poles(const rssn_Expr *aExpr,
                                     const char *aVar)
;

/*
 Frees a finite field handle.

 # Safety
 Caller must ensure `field` is a valid pointer returned by `rssn_finite_field_new`.
 */
rssn_
void rssn_finite_field_free(rssn_Arc<rssn_FiniteField> *aField)
;

/*
 Creates a new finite field GF(modulus).

 Returns an opaque handle to the field.
 */
rssn_
rssn_Arc<rssn_FiniteField> *rssn_finite_field_new(int64_t aModulus)
;

/*
 First-order energy correction.
 */
rssn_
rssn_Expr *rssn_first_order_energy_correction(const rssn_Operator *aPerturbation,
                                              const rssn_Ket *aUnperturbedState)
;

rssn_
rssn_Expr *rssn_fourier_differentiation(const rssn_Expr *aFOmega,
                                        const char *aOutVar)
;

rssn_
rssn_Expr *rssn_fourier_frequency_shift(const rssn_Expr *aFOmega,
                                        const rssn_Expr *aA,
                                        const char *aOutVar)
;

rssn_
rssn_Expr *rssn_fourier_scaling(const rssn_Expr *aFOmega,
                                const rssn_Expr *aA,
                                const char *aOutVar)
;

rssn_
rssn_Expr *rssn_fourier_series_handle(const rssn_Expr *aExpr,
                                      const char *aVar,
                                      const rssn_Expr *aPeriod,
                                      size_t aOrder)
;

rssn_
rssn_Expr *rssn_fourier_time_shift(const rssn_Expr *aFOmega,
                                   const rssn_Expr *aA,
                                   const char *aOutVar)
;

/*
 Computes the symbolic Fourier transform of an expression.

 # Safety
 Caller must ensure `expr` is a valid pointer to an `Expr`.
 `in_var` and `out_var` must be valid C strings or null (defaults apply).
 */
rssn_
rssn_Expr *rssn_fourier_transform(const rssn_Expr *aExpr,
                                  const char *aInVar,
                                  const char *aOutVar)
;

/*
 Frees a Fredholm integral equation.
 */
rssn_
void rssn_fredholm_free(rssn_FredholmEquation *aPtr)
;

/*
 Creates a new Fredholm integral equation.
 */
rssn_
rssn_FredholmEquation *rssn_fredholm_new(const rssn_Expr *aYX,
                                         const rssn_Expr *aFX,
                                         const rssn_Expr *aLambda,
                                         const rssn_Expr *aKernel,
                                         const rssn_Expr *aLowerBound,
                                         const rssn_Expr *aUpperBound,
                                         const char *aVarX,
                                         const char *aVarT)
;

/*
 Solves a Fredholm equation using the Neumann series method.
 */
rssn_
rssn_Expr *rssn_fredholm_solve_neumann(const rssn_FredholmEquation *aEq,
                                       size_t aIterations)
;

/*
 Solves a Fredholm equation using the Neumann series method (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_fredholm_solve_neumann_bincode(const uint8_t *aInputPtr,
                                                       size_t aInputLen)
;

/*
 Solves a Fredholm equation using the Neumann series method (JSON).
 */
rssn_
char *rssn_fredholm_solve_neumann_json(const char *aInputJson)
;

/*
 Solves a Fredholm equation with a separable kernel.
 */
rssn_
rssn_Expr *rssn_fredholm_solve_separable(const rssn_FredholmEquation *aEq,
                                         const rssn_Expr *const *aAFuncs,
                                         size_t aALen,
                                         const rssn_Expr *const *aBFuncs,
                                         size_t aBLen)
;

/*
 Solves a Fredholm equation with a separable kernel (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_fredholm_solve_separable_bincode(const uint8_t *aInputPtr,
                                                         size_t aInputLen)
;

/*
 Solves a Fredholm equation with a separable kernel (JSON).
 */
rssn_
char *rssn_fredholm_solve_separable_json(const char *aInputJson)
;

/*
 Frees a bincode buffer allocated by an FFI function.

 # Safety
 The buffer must have been allocated by an FFI function that returns `BincodeBuffer`.
 This function should only be called once per buffer.
 */
rssn_
void rssn_free_bincode_buffer(rssn_BincodeBuffer aBuffer)
;

/*
 Frees a CAD handle.
 */
rssn_
void rssn_free_cad_handle(rssn_Cad *aPtr)
;

/*
 Frees a Vec<CriticalPoint> handle
 */
rssn_
void rssn_free_critical_point_vec_handle(rssn_Vec<rssn_CriticalPoint> *aPtr)
;

/*
 Frees a DifferentialForm handle
 */
rssn_
void rssn_free_differential_form_handle(rssn_DifferentialForm *aPtr)
;

/*
 Frees an Expr pointer created by this module.

 # Safety
 The caller must ensure `expr` was created by this module and hasn't been freed yet.
 */
rssn_
void rssn_free_expr(rssn_Expr *aExpr)
;

/*
 Frees a Vec<Expr> handle
 */
rssn_
void rssn_free_expr_vec_handle(rssn_Vec<rssn_Expr> *aPtr)
;

/*
 Frees a float64 array allocated by the FEM FFI.
 */
rssn_
void rssn_free_f64_array(double *aPtr,
                         size_t aSize)
;

/*
 Frees a float64 array allocated by the CNM FFI.
 */
rssn_
void rssn_free_f64_cnm_array(double *aPtr,
                             size_t aSize)
;

/*
 Frees a float64 array allocated by the MTM FFI.
 */
rssn_
void rssn_free_f64_mtm_array(double *aPtr,
                             size_t aSize)
;

/*
 Frees a multivector (Handle)
 */
rssn_
void rssn_free_multivector_handle(rssn_Multivector *aPtr)
;

rssn_
void rssn_free_poles(rssn_Vec<rssn_Expr> *aPoles)
;

/*
 Frees a vector of polynomials (Handle)
 */
rssn_
void rssn_free_poly_vec_handle(rssn_Vec<rssn_FiniteFieldPolynomial> *aPtr)
;

/*
 Frees a Vec<HashMap<Expr, Expr>> handle
 */
rssn_
void rssn_free_solution_vec_handle(rssn_Vec<rssn_HashMap<rssn_Expr, rssn_Expr>> *aPtr)
;

/*
 Frees a string allocated by an FFI function.

 # Safety
 The string must have been allocated by an FFI function that returns `*mut c_char`.
 This function should only be called once per string.
 */
rssn_
void rssn_free_string(char *aS)
;

/*
 Frees a C string returned by other functions.
 */
rssn_
void rssn_free_string_api(char *aPtr)
;

rssn_
void rssn_free_string_constant(char *aPtr)
;

/*
 Computes the symbolic Gamma function Γ(z).
 */
rssn_
rssn_Expr *rssn_gamma(const rssn_Expr *aArg)
;

/*
 Computes the gamma function Γ(x).
 */
rssn_
double rssn_gamma_numerical(double aX)
;

/*
 Represents Gauss's theorem (Handle)
 */
rssn_
rssn_Expr *rssn_gauss_theorem_handle(const rssn_Vector *aVectorFieldPtr,
                                     const rssn_Expr *aVolumePtr)
;

/*
 Computes general multi-valued arccos (Handle)
 */
rssn_
rssn_Expr *rssn_general_arccos_handle(const rssn_Expr *aZ,
                                      const rssn_Expr *aK,
                                      const rssn_Expr *aS)
;

/*
 Computes general multi-valued arcsin (Handle)
 */
rssn_
rssn_Expr *rssn_general_arcsin_handle(const rssn_Expr *aZ,
                                      const rssn_Expr *aK)
;

/*
 Computes general multi-valued arctan (Handle)
 */
rssn_
rssn_Expr *rssn_general_arctan_handle(const rssn_Expr *aZ,
                                      const rssn_Expr *aK)
;

/*
 Computes general multi-valued logarithm (Handle)
 */
rssn_
rssn_Expr *rssn_general_log_handle(const rssn_Expr *aZ,
                                   const rssn_Expr *aK)
;

/*
 Computes general multi-valued n-th root (Handle)
 */
rssn_
rssn_Expr *rssn_general_nth_root_handle(const rssn_Expr *aZ,
                                        const rssn_Expr *aN,
                                        const rssn_Expr *aK)
;

/*
 Computes general multi-valued power (Handle)
 */
rssn_
rssn_Expr *rssn_general_power_handle(const rssn_Expr *aZ,
                                     const rssn_Expr *aW,
                                     const rssn_Expr *aK)
;

/*
 Computes general multi-valued square root (Handle)
 */
rssn_
rssn_Expr *rssn_general_sqrt_handle(const rssn_Expr *aZ,
                                    const rssn_Expr *aK)
;

/*
 Computes the symbolic Generalized Laguerre polynomial L_n^α(x).
 */
rssn_
rssn_Expr *rssn_generalized_laguerre(const rssn_Expr *aN,
                                     const rssn_Expr *aAlpha,
                                     const rssn_Expr *aX)
;

/*
 Represents the generalized Stokes' theorem (Handle)
 */
rssn_
rssn_Expr *rssn_generalized_stokes_theorem_handle(const rssn_DifferentialForm *aOmegaPtr,
                                                  const rssn_Expr *aManifoldPtr,
                                                  const char *const *aVarsPtr,
                                                  int aVarsLen)
;

rssn_
rssn_EcdhKeyPair *rssn_generate_keypair(const rssn_EllipticCurve *aCurve,
                                        const rssn_CurvePoint *aGenerator)
;

rssn_
rssn_CurvePoint *rssn_generate_shared_secret(const rssn_EllipticCurve *aCurve,
                                             const char *aPrivateKeyStr,
                                             const rssn_CurvePoint *aOtherPublicKey)
;

/*
 Returns the build date as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_get_build_date()
;

/*
 Returns the build date as a bincode_next buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
rssn_BincodeBuffer rssn_get_build_date_bincode()
;

/*
 Returns the build date as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_get_build_date_json()
;

/*
 Returns all build information as a bincode_next buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
rssn_BincodeBuffer rssn_get_build_info_bincode()
;

/*
 Returns all build information as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_get_build_info_json()
;

/*
 Returns the cargo target triple as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_get_cargo_target_triple()
;

/*
 Returns the commit SHA as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_get_commit_sha()
;

/*
 Returns the commit SHA as a bincode_next buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
rssn_BincodeBuffer rssn_get_commit_sha_bincode()
;

/*
 Returns the commit SHA as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_get_commit_sha_json()
;

/*
 Retrieves the last error message set by an FFI function on the current thread.

 The returned pointer is valid until the next call to an FFI function on the same thread.
 The caller should not free this pointer.
 */
rssn_
const char *rssn_get_last_error()
;

/*
 Gets real and imaginary parts of an expression.
 Returns a pointer to a tuple (Expr, Expr) - represented as Vec<Expr> of size 2 for simplicity?
 Or return two out pointers?
 I'll return a Vec<Expr> of size 2.
 */
rssn_
rssn_Vec<rssn_Expr> *rssn_get_real_imag_parts(const rssn_Expr *aExpr)
;

/*
 Returns the rustc version as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_get_rustc_version()
;

/*
 Returns the system info as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_get_system_info()
;

/*
 Performs addition in GF(2^8) (XOR operation).
 */
rssn_
uint8_t rssn_gf256_add(uint8_t aA,
                       uint8_t aB)
;

/*
 Performs division in GF(2^8).
 Returns 0 if divisor is 0 (error case).
 */
rssn_
uint8_t rssn_gf256_div(uint8_t aA,
                       uint8_t aB)
;

/*
 Computes the exponentiation (anti-logarithm) in GF(2^8).
 */
rssn_
uint8_t rssn_gf256_exp(uint8_t aLogVal)
;

/*
 Computes the multiplicative inverse in GF(2^8).
 Returns 0 if input is 0 (error case).
 */
rssn_
uint8_t rssn_gf256_inv(uint8_t aA)
;

/*
 Computes the discrete logarithm in GF(2^8).
 Returns 0 if input is 0 (error case, as log(0) is undefined).
 */
rssn_
uint8_t rssn_gf256_log(uint8_t aA)
;

/*
 Performs multiplication in GF(2^8).
 */
rssn_
uint8_t rssn_gf256_mul(uint8_t aA,
                       uint8_t aB)
;

/*
 Computes a^exp in GF(2^8).
 */
rssn_
uint8_t rssn_gf256_pow(uint8_t aA,
                       uint8_t aExp)
;

/*
 Calculates Gibbs Free Energy: H - TS.
 */
rssn_
rssn_Expr *rssn_gibbs_free_energy(const rssn_Expr *aH,
                                  const rssn_Expr *aT,
                                  const rssn_Expr *aS)
;

rssn_
rssn_Expr *rssn_gini_impurity(const rssn_Expr *const *aProbs,
                              size_t aLen)
;

rssn_
rssn_Expr **rssn_gram_schmidt(const rssn_HilbertSpace *aSpace,
                              const rssn_Expr *const *aBasisPtr,
                              size_t aBasisLen,
                              size_t *aOutLen)
;

/*
 Adds an edge to the graph.
 */
rssn_
void rssn_graph_add_edge(rssn_RssnGraph *aPtr,
                         const char *aFromLabel,
                         const char *aToLabel,
                         const rssn_Expr *aWeight)
;

/*
 Adds a node to the graph.
 */
rssn_
size_t rssn_graph_add_node(rssn_RssnGraph *aPtr,
                           const char *aLabel)
;

/*
 Gets the adjacency matrix of the graph.
 */
rssn_
rssn_Expr *rssn_graph_adjacency_matrix(const rssn_RssnGraph *aPtr)
;

/*
 Performs BFS traversal from a start node.
 Returns a JSON string containing the node IDs in visit order.
 */
rssn_
char *rssn_graph_bfs(const rssn_RssnGraph *aPtr,
                     size_t aStartNode)
;

/*
 Performs BFS traversal starting from a given node.
 Returns a JSON array of node indices in visit order.
 */
rssn_
char *rssn_graph_bfs_api(const rssn_RssnGraph *aGraph,
                         size_t aStartNode)
;

/*
 Finds maximum matching in a bipartite graph.
 partition_json should be a JSON array of 0s and 1s indicating the partition.
 Returns a JSON array of [u, v] pairs representing the matching.
 */
rssn_
char *rssn_graph_bipartite_maximum_matching(const rssn_RssnGraph *aGraph,
                                            const char *aPartitionJson)
;

/*
 Finds bridges and articulation points.
 Returns a JSON object with "bridges" and "articulation_points" fields.
 */
rssn_
char *rssn_graph_bridges_and_articulation_points_api(const rssn_RssnGraph *aGraph)
;

/*
 Computes the Cartesian product of two graphs.
 */
rssn_
rssn_RssnGraph *rssn_graph_cartesian_product(const rssn_RssnGraph *aPtr1,
                                             const rssn_RssnGraph *aPtr2)
;

/*
 Computes the complement of a graph.
 */
rssn_
rssn_RssnGraph *rssn_graph_complement(const rssn_RssnGraph *aPtr)
;

/*
 Finds connected components.
 Returns a JSON string containing the components.
 */
rssn_
char *rssn_graph_connected_components(const rssn_RssnGraph *aPtr)
;

/*
 Finds all connected components in an undirected graph.
 Returns a JSON array of arrays, where each inner array is a component.
 */
rssn_
char *rssn_graph_connected_components_api(const rssn_RssnGraph *aGraph)
;

/*
 Performs DFS traversal from a start node.
 Returns a JSON string containing the node IDs in visit order.
 */
rssn_
char *rssn_graph_dfs(const rssn_RssnGraph *aPtr,
                     size_t aStartNode)
;

/*
 Performs DFS traversal starting from a given node.
 Returns a JSON array of node indices in visit order.
 */
rssn_
char *rssn_graph_dfs_api(const rssn_RssnGraph *aGraph,
                         size_t aStartNode)
;

/*
 Computes maximum flow using Dinic's algorithm.
 */
rssn_
double rssn_graph_dinic_max_flow(const rssn_RssnGraph *aGraph,
                                 size_t aSource,
                                 size_t aSink)
;

/*
 Computes the disjoint union of two graphs.
 */
rssn_
rssn_RssnGraph *rssn_graph_disjoint_union(const rssn_RssnGraph *aPtr1,
                                          const rssn_RssnGraph *aPtr2)
;

/*
 Computes maximum flow using Edmonds-Karp algorithm.
 */
rssn_
double rssn_graph_edmonds_karp_max_flow(const rssn_RssnGraph *aGraph,
                                        size_t aSource,
                                        size_t aSink)
;

/*
 Frees a graph.
 */
rssn_
void rssn_graph_free(rssn_RssnGraph *aPtr)
;

/*
 Checks if the graph has a cycle.
 */
rssn_
int rssn_graph_has_cycle(const rssn_RssnGraph *aPtr)
;

/*
 Checks if the graph has a cycle.
 */
rssn_
int rssn_graph_has_cycle_api(const rssn_RssnGraph *aGraph)
;

/*
 Gets the incidence matrix of the graph.
 */
rssn_
rssn_Expr *rssn_graph_incidence_matrix(const rssn_RssnGraph *aPtr)
;

/*
 Creates an induced subgraph.
 */
rssn_
rssn_RssnGraph *rssn_graph_induced_subgraph(const rssn_RssnGraph *aPtr,
                                            const char *const *aNodeLabels,
                                            size_t aCount)
;

/*
 Computes the intersection of two graphs.
 */
rssn_
rssn_RssnGraph *rssn_graph_intersection(const rssn_RssnGraph *aPtr1,
                                        const rssn_RssnGraph *aPtr2)
;

/*
 Checks if the graph is bipartite.
 Returns 1 if bipartite, 0 otherwise.
 */
rssn_
int rssn_graph_is_bipartite(const rssn_RssnGraph *aPtr)
;

/*
 Checks if a graph is bipartite.
 Returns a JSON array of partition assignments (0 or 1 for each node), or null if not bipartite.
 */
rssn_
char *rssn_graph_is_bipartite_api(const rssn_RssnGraph *aGraph)
;

/*
 Checks if the graph is connected.
 */
rssn_
int rssn_graph_is_connected(const rssn_RssnGraph *aGraph)
;

/*
 Computes the join of two graphs.
 */
rssn_
rssn_RssnGraph *rssn_graph_join(const rssn_RssnGraph *aPtr1,
                                const rssn_RssnGraph *aPtr2)
;

/*
 Computes minimum spanning tree using Kruskal's algorithm.
 Returns a JSON string containing the MST edges.
 */
rssn_
char *rssn_graph_kruskal_mst(const rssn_RssnGraph *aPtr)
;

/*
 Computes the minimum spanning tree using Kruskal's algorithm.
 Returns a new graph containing only the MST edges.
 */
rssn_
rssn_RssnGraph *rssn_graph_kruskal_mst_api(const rssn_RssnGraph *aGraph)
;

/*
 Gets the Laplacian matrix of the graph.
 */
rssn_
rssn_Expr *rssn_graph_laplacian_matrix(const rssn_RssnGraph *aPtr)
;

/*
 Computes maximum flow using Edmonds-Karp algorithm.
 */
rssn_
double rssn_graph_max_flow(const rssn_RssnGraph *aPtr,
                           size_t aSource,
                           size_t aSink)
;

/*
 Creates a new graph.
 */
rssn_
rssn_RssnGraph *rssn_graph_new(int aIsDirected)
;

/*
 Gets the number of nodes in the graph.
 */
rssn_
size_t rssn_graph_node_count(const rssn_RssnGraph *aPtr)
;

/*
 Finds all strongly connected components in a directed graph.
 Returns a JSON array of arrays.
 */
rssn_
char *rssn_graph_strongly_connected_components(const rssn_RssnGraph *aGraph)
;

/*
 Computes the Tensor product of two graphs.
 */
rssn_
rssn_RssnGraph *rssn_graph_tensor_product(const rssn_RssnGraph *aPtr1,
                                          const rssn_RssnGraph *aPtr2)
;

/*
 Performs topological sort on a DAG.
 Returns a JSON array of node indices in topological order, or null if the graph has a cycle.
 */
rssn_
char *rssn_graph_topological_sort(const rssn_RssnGraph *aGraph)
;

/*
 Computes the union of two graphs.
 */
rssn_
rssn_RssnGraph *rssn_graph_union(const rssn_RssnGraph *aPtr1,
                                 const rssn_RssnGraph *aPtr2)
;

/*
 Finds a valid vertex coloring using greedy heuristic.
 Returns a JSON object mapping node IDs to colors.
 */
rssn_
char *rssn_greedy_coloring(const rssn_RssnGraph *aGraph)
;

/*
 Represents Green's theorem (Handle)
 */
rssn_
rssn_Expr *rssn_greens_theorem_handle(const rssn_Expr *aPPtr,
                                      const rssn_Expr *aQPtr,
                                      const rssn_Expr *aDomainPtr)
;

rssn_
rssn_Expr **rssn_group_center(const rssn_Group *aGroup,
                              size_t *aOutLen)
;

rssn_
rssn_Group *rssn_group_create(const rssn_Expr *const *aElementsPtr,
                              size_t aElementsLen,
                              const rssn_Expr *const *aKeysAPtr,
                              const rssn_Expr *const *aKeysBPtr,
                              const rssn_Expr *const *aValuesPtr,
                              size_t aTableLen,
                              const rssn_Expr *aIdentityPtr)
;

rssn_
size_t rssn_group_element_order(const rssn_Group *aGroup,
                                const rssn_Expr *aA)
;

rssn_
void rssn_group_free(rssn_Group *aPtr)
;

rssn_
rssn_Expr *rssn_group_inverse(const rssn_Group *aGroup,
                              const rssn_Expr *aA)
;

rssn_
bool rssn_group_is_abelian(const rssn_Group *aGroup)
;

rssn_
rssn_Expr *rssn_group_multiply(const rssn_Group *aGroup,
                               const rssn_Expr *aA,
                               const rssn_Expr *aB)
;

/*
 Computes Hall coefficient.
 */
rssn_
rssn_Expr *rssn_hall_coefficient(const rssn_Expr *aN,
                                 const rssn_Expr *aQ)
;

/*
 Calculates Hamiltonian: T + V.
 */
rssn_
rssn_Expr *rssn_hamiltonian(const rssn_Expr *aT,
                            const rssn_Expr *aV)
;

/*
 Hamiltonian for a free particle.
 */
rssn_
rssn_Operator *rssn_hamiltonian_free_particle(const rssn_Expr *aM)
;

/*
 Hamiltonian for a harmonic oscillator.
 */
rssn_
rssn_Operator *rssn_hamiltonian_harmonic_oscillator(const rssn_Expr *aM,
                                                    const rssn_Expr *aOmega)
;

/*
 Applies Hamilton's Principle to derive the equations of motion.

 # Safety
 The caller must ensure `lagrangian` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
rssn_Expr *rssn_hamiltons_principle(const rssn_Expr *aLagrangian,
                                    const char *aFunc,
                                    const char *aVar)
;

/*
 Checks if a Hamming(7,4) codeword is valid without correcting.

 # Safety
 Caller must ensure `codeword` points to 7 bytes.
 Returns 1 if valid, 0 if invalid, -1 on error.
 */
rssn_
int32_t rssn_hamming_check(const uint8_t *aCodeword)
;

/*
 Decodes a 7-bit Hamming(7,4) codeword, correcting single-bit errors.

 # Safety
 Caller must ensure `codeword` points to 7 bytes and `data_out` points to 4 bytes.
 `error_pos` will receive the 1-based error position or 0 if no error.
 */
rssn_
int32_t rssn_hamming_decode(const uint8_t *aCodeword,
                            uint8_t *aDataOut,
                            uint8_t *aErrorPos)
;

/*
 Computes Hamming distance between two byte slices.

 # Safety
 Caller must ensure `a` and `b` point to `len` bytes each.
 Returns -1 on error (null pointers or different lengths).
 */
rssn_
int32_t rssn_hamming_distance(const uint8_t *aA,
                              size_t aALen,
                              const uint8_t *aB,
                              size_t aBLen)
;

/*
 Encodes 4 data bits into a 7-bit Hamming(7,4) codeword.

 # Safety
 Caller must ensure `data` points to 4 bytes and `out` points to 7 bytes of allocated memory.
 */
rssn_
int32_t rssn_hamming_encode(const uint8_t *aData,
                            uint8_t *aOut)
;

/*
 Computes Hamming weight (number of 1s) of a byte slice.

 # Safety
 Caller must ensure `data` points to `len` bytes.
 */
rssn_
int32_t rssn_hamming_weight(const uint8_t *aData,
                            size_t aLen)
;

/*
 Clears all expressions from the handle manager.

 **Warning**: This invalidates all existing handles.

 # Safety
 This function is always safe to call, but will invalidate all handles.
 */
rssn_
void rssn_handle_clear()
;

/*
 Clears all handles (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_handle_clear_bincode()
;

/*
 Clears all handles (JSON).

 Output: JSON object with "cleared" boolean field
 */
rssn_
char *rssn_handle_clear_json()
;

/*
 Clones an expression handle, creating a new handle pointing to the same expression.

 Returns 0 if the source handle doesn't exist.

 # Safety
 This function is safe to call with any handle value.
 */
rssn_
size_t rssn_handle_clone(size_t aHandle)
;

/*
 Clones a handle (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_handle_clone_bincode(rssn_BincodeBuffer aInput)
;

/*
 Clones a handle (JSON).

 Input: JSON object with "handle" field
 Output: JSON object with "new_handle" field
 */
rssn_
char *rssn_handle_clone_json(const char *aJsonStr)
;

/*
 Returns the number of expressions currently managed.

 # Safety
 This function is always safe to call.
 */
rssn_
size_t rssn_handle_count()
;

/*
 Checks if a handle exists in the manager.

 # Safety
 This function is safe to call with any handle value.
 */
rssn_
bool rssn_handle_exists(size_t aHandle)
;

/*
 Checks if a handle exists (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_handle_exists_bincode(rssn_BincodeBuffer aInput)
;

/*
 Checks if a handle exists (JSON).

 Input: JSON object with "handle" field
 Output: JSON object with "exists" boolean field
 */
rssn_
char *rssn_handle_exists_json(const char *aJsonStr)
;

/*
 Frees a handle from the manager.

 Returns true if the handle was found and freed, false otherwise.

 # Safety
 This function is safe to call with any handle value.
 */
rssn_
bool rssn_handle_free(size_t aHandle)
;

/*
 Frees a handle (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_handle_free_bincode(rssn_BincodeBuffer aInput)
;

/*
 Frees a handle (JSON).

 Input: JSON object with "handle" field
 Output: JSON object with "freed" boolean field
 */
rssn_
char *rssn_handle_free_json(const char *aJsonStr)
;

/*
 Retrieves an expression from the handle manager.

 Returns a new owned Expr pointer that must be freed by the caller.

 # Safety
 The caller must ensure the returned pointer is freed using `rssn_free_expr`.
 */
rssn_
rssn_Expr *rssn_handle_get(size_t aHandle)
;

/*
 Returns a list of all active handles as a JSON array string.

 The returned string must be freed using `rssn_free_string`.

 # Safety
 The caller must free the returned string.
 */
rssn_
char *rssn_handle_get_all()
;

/*
 Returns all active handles (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_handle_get_all_bincode()
;

/*
 Retrieves an expression by handle (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_handle_get_bincode(rssn_BincodeBuffer aInput)
;

/*
 Retrieves an expression by handle (JSON).

 Input: JSON object with "handle" field
 Output: JSON-serialized Expr
 */
rssn_
char *rssn_handle_get_json(const char *aJsonStr)
;

/*
 Inserts an expression into the handle manager and returns a unique handle.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_
size_t rssn_handle_insert(const rssn_Expr *aExpr)
;

/*
 Inserts an expression (Bincode) into the handle manager.
 */
rssn_
rssn_BincodeBuffer rssn_handle_insert_bincode(rssn_BincodeBuffer aInput)
;

/*
 Inserts an expression (JSON) into the handle manager.

 Input: JSON-serialized Expr
 Output: JSON object with "handle" field
 */
rssn_
char *rssn_handle_insert_json(const char *aJsonStr)
;

/*
 Returns handle manager statistics (JSON).

 Output: JSON object with "count" and "handles" fields
 */
rssn_
char *rssn_handle_stats_json()
;

/*
 Converts an expression handle to a string representation.

 The returned string must be freed using `rssn_free_string`.

 # Safety
 The caller must free the returned string.
 */
rssn_
char *rssn_handle_to_string(size_t aHandle)
;

/*
 Constructs Hermite's differential equation: y'' - 2xy' + 2ny = 0.
 */
rssn_
rssn_Expr *rssn_hermite_differential_equation(const rssn_Expr *aY,
                                              const rssn_Expr *aX,
                                              const rssn_Expr *aN)
;

/*
 Computes the symbolic Hermite polynomial H_n(x).
 */
rssn_
rssn_Expr *rssn_hermite_h(const rssn_Expr *aDegree,
                          const rssn_Expr *aArg)
;

/*
 Constructs Rodrigues' formula for Hermite polynomials.
 */
rssn_
rssn_Expr *rssn_hermite_rodrigues_formula(const rssn_Expr *aN,
                                          const rssn_Expr *aX)
;

/*
 Computes Hessian matrix (Handle)
 */
rssn_
rssn_Expr *rssn_hessian_matrix_handle(const rssn_Expr *aExprPtr,
                                      const char *const *aVarsPtr,
                                      int aVarsLen)
;

/*
 Simplifies an expression using the heuristic simplifier.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_
rssn_Expr *rssn_heuristic_simplify(const rssn_Expr *aExpr)
;

rssn_
rssn_HilbertSpace *rssn_hilbert_space_create(const char *aVar,
                                             const rssn_Expr *aLowerBound,
                                             const rssn_Expr *aUpperBound)
;

rssn_
void rssn_hilbert_space_free(rssn_HilbertSpace *aPtr)
;

/*
 Calculates ideal gas Law expression: PV - nRT.
 */
rssn_
rssn_Expr *rssn_ideal_gas_law(const rssn_Expr *aP,
                              const rssn_Expr *aV,
                              const rssn_Expr *aN,
                              const rssn_Expr *aR,
                              const rssn_Expr *aT)
;

/*
 Computes the Inverse Fast Fourier Transform (IFFT) of a sequence of complex numbers in-place.
 */
rssn_
int32_t rssn_ifft(rssn_Complex<double> *aData,
                  size_t aLen)
;

/*
 Creates a new IteratedFunctionSystem (Handle)
 */
rssn_
rssn_IteratedFunctionSystem *rssn_ifs_create(rssn_Expr *const *aFunctionsPtr,
                                             size_t aFunctionsLen,
                                             rssn_Expr *const *aProbabilitiesPtr,
                                             size_t aProbabilitiesLen,
                                             const char *const *aVariablesPtr,
                                             size_t aVariablesLen)
;

/*
 Frees an IteratedFunctionSystem handle
 */
rssn_
void rssn_ifs_free(rssn_IteratedFunctionSystem *aPtr)
;

/*
 Calculates similarity dimension (Handle)
 */
rssn_
rssn_Expr *rssn_ifs_similarity_dimension(rssn_Expr *const *aScalingFactorsPtr,
                                         size_t aLen)
;

/*
 Initializes the plugin manager with a specified plugin directory.

 This function must be called before any plugin operations are performed.

 # Arguments
 * `plugin_dir_ptr` - A null-terminated UTF-8 string for the plugin directory path.

 # Returns
 0 on success, -1 on failure. On failure, an error message can be retrieved
 with `rssn_get_last_error`.
 */
rssn_
int32_t rssn_init_plugin_manager(const char *aPluginDirPtr)
;

rssn_
rssn_Expr *rssn_inner_product(const rssn_HilbertSpace *aSpace,
                              const rssn_Expr *aF,
                              const rssn_Expr *aG)
;

/*
 Integrates an expression: int(expr) d(var).

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `var` is a valid C string.
 */
rssn_
rssn_Expr *rssn_integrate(const rssn_Expr *aExpr,
                          const char *aVar)
;

/*
 Integrates a rational function (Handle)
 */
rssn_
rssn_Expr *rssn_integrate_rational_function_handle(const rssn_Expr *aExpr,
                                                   const char *aX)
;

/*
 Evaluates a point on a Bezier curve defined by control points.
 */
rssn_
int32_t rssn_interp_bezier_curve(const rssn_FfiPoint *aPointsPtr,
                                 size_t aNumPoints,
                                 double aT,
                                 rssn_FfiPoint *aResultPtr)
;

/*
 Computes a Lagrange interpolating polynomial from a set of points.
 Returns a handle to the resulting polynomial expression.
 */
rssn_
int32_t rssn_interp_lagrange(const rssn_FfiPoint *aPointsPtr,
                             size_t aNumPoints,
                             size_t *aResultHandle)
;

/*
 Computes the inverse error function erf⁻¹(x).
 */
rssn_
double rssn_inverse_erf(double aX)
;

/*
 Computes the inverse complementary error function erfc⁻¹(x).
 */
rssn_
double rssn_inverse_erfc(double aX)
;

rssn_
rssn_Expr *rssn_inverse_fourier_transform(const rssn_Expr *aExpr,
                                          const char *aInVar,
                                          const char *aOutVar)
;

rssn_
rssn_Expr *rssn_inverse_laplace_transform(const rssn_Expr *aExpr,
                                          const char *aInVar,
                                          const char *aOutVar)
;

rssn_
rssn_Expr *rssn_inverse_z_transform(const rssn_Expr *aExpr,
                                    const char *aInVar,
                                    const char *aOutVar)
;

/*
 Checks if an expression is prime.

 # Safety
 `n` must be a valid pointer to an `Expr`.
 */
rssn_
rssn_Expr *rssn_is_prime_handle(const rssn_Expr *aN)
;

/*
 Checks if a logical expression is satisfiable using handle-based FFI.

 Returns:
 - 1 if satisfiable
 - 0 if unsatisfiable
 - -1 if the expression contains quantifiers (undecidable)

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_
int32_t rssn_is_satisfiable_handle(const rssn_Expr *aExpr)
;

rssn_
rssn_Expr *rssn_joint_entropy(const rssn_Expr *aJointProbs)
;

/*
 Computes absolute value (magnitude) of complex number (JSON)
 */
rssn_
char *rssn_json_abs(const char *aZJson)
;

rssn_
char *rssn_json_adjoint_representation_algebra(const char *aXJson,
                                               const char *aYJson)
;

rssn_
char *rssn_json_adjoint_representation_group(const char *aGJson,
                                             const char *aXJson)
;

rssn_
char *rssn_json_analytic_continuation(const char *aExprJson,
                                      const char *aVarJson,
                                      const char *aOrigCenterJson,
                                      const char *aNewCenterJson,
                                      const char *aOrderJson)
;

rssn_
char *rssn_json_analyze_convergence(const char *aTermJson,
                                    const char *aVarJson)
;

/*
 Analyzes stability of a fixed point (JSON)
 */
rssn_
char *rssn_json_analyze_stability(const char *aMapJson,
                                  const char *aVar,
                                  const char *aFixedPointJson)
;

/*
 Checks if two graphs are isomorphic.
 Input: {"g1": Graph, "g2": Graph}
 Output: bool
 */
rssn_
char *rssn_json_are_isomorphic_heuristic(const char *aJson)
;

/*
 Computes argument (angle) of complex number (JSON)
 */
rssn_
char *rssn_json_arg(const char *aZJson)
;

rssn_
char *rssn_json_asymptotic_expansion(const char *aExprJson,
                                     const char *aVarJson,
                                     const char *aPointJson,
                                     const char *aOrderJson)
;

rssn_
char *rssn_json_bell_number(size_t aN)
;

/*
 Constructs Bessel's differential equation via JSON interface.
 */
rssn_
char *rssn_json_bessel_differential_equation(const char *aYJson,
                                             const char *aXJson,
                                             const char *aNJson)
;

/*
 Computes the symbolic modified Bessel function I_n(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_i(const char *aOrderJson,
                         const char *aArgJson)
;

/*
 Computes I₀(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_i0(const char *aXJson)
;

/*
 Computes I₁(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_i1(const char *aXJson)
;

/*
 Computes the symbolic Bessel function J_n(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_j(const char *aOrderJson,
                         const char *aArgJson)
;

/*
 Computes J₀(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_j0(const char *aXJson)
;

/*
 Computes J₁(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_j1(const char *aXJson)
;

/*
 Computes the symbolic modified Bessel function K_n(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_k(const char *aOrderJson,
                         const char *aArgJson)
;

/*
 Computes K₀(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_k0(const char *aXJson)
;

/*
 Computes K₁(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_k1(const char *aXJson)
;

/*
 Computes the symbolic Bessel function Y_n(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_y(const char *aOrderJson,
                         const char *aArgJson)
;

/*
 Computes Y₀(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_y0(const char *aXJson)
;

/*
 Computes Y₁(x) via JSON interface.
 */
rssn_
char *rssn_json_bessel_y1(const char *aXJson)
;

/*
 Computes the symbolic Beta function B(a, b) via JSON interface.
 */
rssn_
char *rssn_json_beta(const char *aAJson,
                     const char *aBJson)
;

/*
 Computes B(a, b) via JSON interface.
 */
rssn_
char *rssn_json_beta_numerical(const char *aAJson,
                               const char *aBJson)
;

/*
 Computes C(n, k) via JSON interface.
 */
rssn_
char *rssn_json_binomial(const char *aNJson,
                         const char *aKJson)
;

/*
 Computes the boundary of a domain (JSON)
 */
rssn_
char *rssn_json_boundary(const char *aDomainJson)
;

/*
 Computes the inner product <Bra|Ket> using JSON.
 */
rssn_
char *rssn_json_bra_ket(const char *aBraJson,
                        const char *aKetJson)
;

rssn_
char *rssn_json_buchberger(const char *aBasisJson,
                           const char *aOrderJson)
;

/*
 Computes CAD for a set of polynomials via JSON interface.

 Input JSON should be an object: `{"polys": [Expr, ...], "vars": ["x", "y", ...]}`.
 */
rssn_
char *rssn_json_cad(const char *aInputJson)
;

/*
 Calculates residue using JSON.
 */
rssn_
char *rssn_json_calculate_residue(const char *aExprJson,
                                  const char *aVar,
                                  const char *aPoleJson)
;

rssn_
char *rssn_json_catalan_number(size_t aN)
;

rssn_
char *rssn_json_character(const char *aRepJson)
;

/*
 Constructs Chebyshev's differential equation via JSON interface.
 */
rssn_
char *rssn_json_chebyshev_differential_equation(const char *aYJson,
                                                const char *aXJson,
                                                const char *aNJson)
;

/*
 Computes the symbolic Chebyshev polynomial T_n(x) via JSON interface.
 */
rssn_
char *rssn_json_chebyshev_t(const char *aNJson,
                            const char *aXJson)
;

/*
 Computes the symbolic Chebyshev polynomial U_n(x) via JSON interface.
 */
rssn_
char *rssn_json_chebyshev_u(const char *aNJson,
                            const char *aXJson)
;

/*
 Checks analytic using JSON.
 */
rssn_
bool rssn_json_check_analytic(const char *aExprJson,
                              const char *aVar)
;

rssn_
bool rssn_json_check_jacobi_identity(const char *aAlgebraJson)
;

rssn_
char *rssn_json_chinese_remainder(const char *aCongruencesJson)
;

/*
 Exact chromatic number.
 Input: Graph
 Output: usize
 */
rssn_
char *rssn_json_chromatic_number_exact(const char *aJson)
;

/*
 Classifies a PDE and suggests solution methods (JSON).
 */
rssn_
char *rssn_json_classify_pde(const char *aEquationJson,
                             const char *aFunc,
                             const char *aVarsJson)
;

rssn_
char *rssn_json_combinations(const char *aNJson,
                             const char *aKJson)
;

rssn_
char *rssn_json_commutator_table(const char *aAlgebraJson)
;

/*
 Finds fixed points (JSON)
 */
rssn_
char *rssn_json_complex_system_fixed_points(const char *aSystemJson)
;

/*
 Iterates the system once (JSON)
 */
rssn_
char *rssn_json_complex_system_iterate(const char *aSystemJson,
                                       const char *aZJson)
;

/*
 Creates a new Mandelbrot family system (JSON)
 */
rssn_
char *rssn_json_complex_system_new_mandelbrot(const char *aCJson)
;

rssn_
char *rssn_json_conditional_entropy(const char *aJointProbsJson)
;

rssn_
char *rssn_json_convolution_fourier(const char *aFJson,
                                    const char *aGJson,
                                    const char *aInVarJson,
                                    const char *aOutVarJson)
;

rssn_
char *rssn_json_convolution_laplace(const char *aFJson,
                                    const char *aGJson,
                                    const char *aInVarJson,
                                    const char *aOutVarJson)
;

rssn_
char *rssn_json_coordinates_get_metric_tensor(rssn_CoordinateSystem aSystem)
;

/*
 Computes the symbolic Pearson correlation coefficient using JSON.
 */
rssn_
char *rssn_json_correlation(const char *aData1Json,
                            const char *aData2Json)
;

/*
 Counts the number of distinct real roots in an interval (JSON)
 */
rssn_
int64_t rssn_json_count_real_roots_in_interval(const char *aExprJson,
                                               const char *aVarPtr,
                                               double aA,
                                               double aB)
;

/*
 Computes the symbolic covariance of two sets of expressions using JSON.
 */
rssn_
char *rssn_json_covariance(const char *aData1Json,
                           const char *aData2Json)
;

/*
 Computes CRC-32 checksum via JSON interface.
 Input: [bytes]
 Returns: u32 checksum
 */
rssn_
char *rssn_json_crc32_compute(const char *aDataJson)
;

/*
 Finalizes CRC-32 computation via JSON interface.
 Input: running crc as u32
 Returns: final crc as u32
 */
rssn_
char *rssn_json_crc32_finalize(const char *aCrcJson)
;

/*
 Updates CRC-32 incrementally via JSON interface.
 Input: current crc as u32, data as [bytes]
 Returns: updated crc as u32
 */
rssn_
char *rssn_json_crc32_update(const char *aCrcJson,
                             const char *aDataJson)
;

/*
 Verifies CRC-32 checksum via JSON interface.
 Input: data as [bytes], expected_crc as u32
 Returns: boolean
 */
rssn_
char *rssn_json_crc32_verify(const char *aDataJson,
                             const char *aExpectedCrcJson)
;

rssn_
char *rssn_json_cross_entropy(const char *aPProbsJson,
                              const char *aQProbsJson)
;

/*
 Adds two points.
 */
rssn_
char *rssn_json_curve_add(const char *aCurveJson,
                          const char *aP1Json,
                          const char *aP2Json)
;

/*
 Doubles a point.
 */
rssn_
char *rssn_json_curve_double(const char *aCurveJson,
                             const char *aPointJson)
;

/*
 Checks if a point is on the curve.
 */
rssn_
char *rssn_json_curve_is_on_curve(const char *aCurveJson,
                                  const char *aPointJson)
;

/*
 Negates a point.
 */
rssn_
char *rssn_json_curve_negate(const char *aCurveJson,
                             const char *aPointJson)
;

/*
 Creates an affine curve point.
 Arguments: x (str), y (str), modulus (str)
 */
rssn_
char *rssn_json_curve_point_affine(const char *aXJson,
                                   const char *aYJson,
                                   const char *aModulusJson)
;

/*
 Creates a point at infinity.
 */
rssn_
char *rssn_json_curve_point_infinity()
;

/*
 Scalar multiplication.
 */
rssn_
char *rssn_json_curve_scalar_mult(const char *aCurveJson,
                                  const char *aKJson,
                                  const char *aPJson)
;

rssn_
char *rssn_json_cyclic_group_create(size_t aN)
;

/*
 Computes definite integral using JSON.
 */
rssn_
char *rssn_json_definite_integrate(const char *aExprJson,
                                   const char *aVar,
                                   const char *aLowerJson,
                                   const char *aUpperJson)
;

/*
 Denests a nested square root (JSON)
 */
rssn_
char *rssn_json_denest_sqrt(const char *aExprJson)
;

/*
 Computes the density of states for a 3D electron gas using JSON.
 */
rssn_
char *rssn_json_density_of_states_3d(const char *aEnergyJson,
                                     const char *aMassJson,
                                     const char *aVolumeJson)
;

/*
 Differentiates an expression using JSON.
 */
rssn_
char *rssn_json_differentiate(const char *aExprJson,
                              const char *aVar)
;

/*
 Computes the symbolic Digamma function ψ(z) via JSON interface.
 */
rssn_
char *rssn_json_digamma(const char *aArgJson)
;

/*
 Computes the digamma function ψ(x) via JSON interface.
 */
rssn_
char *rssn_json_digamma_numerical(const char *aXJson)
;

rssn_
char *rssn_json_dihedral_group_create(size_t aN)
;

/*
 Computes the Dirac adjoint using JSON.
 */
rssn_
char *rssn_json_dirac_adjoint(const char *aPsiJson)
;

rssn_
char *rssn_json_dist_bernoulli(const char *aPJson)
;

rssn_
char *rssn_json_dist_beta(const char *aAlphaJson,
                          const char *aBetaJson)
;

rssn_
char *rssn_json_dist_binomial(const char *aNJson,
                              const char *aPJson)
;

rssn_
char *rssn_json_dist_cdf(const char *aDistJson,
                         const char *aXJson)
;

rssn_
char *rssn_json_dist_expectation(const char *aDistJson)
;

rssn_
char *rssn_json_dist_exponential(const char *aRateJson)
;

rssn_
char *rssn_json_dist_gamma(const char *aShapeJson,
                           const char *aRateJson)
;

rssn_
char *rssn_json_dist_mgf(const char *aDistJson,
                         const char *aTJson)
;

rssn_
char *rssn_json_dist_normal(const char *aMeanJson,
                            const char *aStdDevJson)
;

rssn_
char *rssn_json_dist_pdf(const char *aDistJson,
                         const char *aXJson)
;

rssn_
char *rssn_json_dist_poisson(const char *aRateJson)
;

rssn_
char *rssn_json_dist_student_t(const char *aNuJson)
;

rssn_
char *rssn_json_dist_uniform(const char *aMinJson,
                             const char *aMaxJson)
;

rssn_
char *rssn_json_dist_variance(const char *aDistJson)
;

/*
 Computes n!! via JSON interface.
 */
rssn_
char *rssn_json_double_factorial(const char *aNJson)
;

/*
 Computes Drude conductivity using JSON.
 */
rssn_
char *rssn_json_drude_conductivity(const char *aNJson,
                                   const char *aEJson,
                                   const char *aTauJson,
                                   const char *aMassJson)
;

/*
 Signs a message.
 */
rssn_
char *rssn_json_ecdsa_sign(const char *aMessageHashJson,
                           const char *aPrivateKeyJson,
                           const char *aCurveJson,
                           const char *aGeneratorJson,
                           const char *aOrderJson)
;

/*
 Verifies a signature.
 */
rssn_
char *rssn_json_ecdsa_verify(const char *aMessageHashJson,
                             const char *aSignatureJson,
                             const char *aPublicKeyJson,
                             const char *aCurveJson,
                             const char *aGeneratorJson,
                             const char *aOrderJson)
;

/*
 Calculates energy density using JSON.
 */
rssn_
char *rssn_json_electromagnetic_energy_density(const char *aEFieldJson,
                                               const char *aBFieldJson)
;

/*
 Creates a new elliptic curve.
 Arguments: a (str), b (str), modulus (str)
 */
rssn_
char *rssn_json_elliptic_curve_new(const char *aAJson,
                                   const char *aBJson,
                                   const char *aModulusJson)
;

/*
 Computes the symbolic error function erf(z) via JSON interface.
 */
rssn_
char *rssn_json_erf(const char *aArgJson)
;

/*
 Computes erf(x) via JSON interface.
 */
rssn_
char *rssn_json_erf_numerical(const char *aXJson)
;

/*
 Computes the symbolic complementary error function erfc(z) via JSON interface.
 */
rssn_
char *rssn_json_erfc(const char *aArgJson)
;

/*
 Computes erfc(x) via JSON interface.
 */
rssn_
char *rssn_json_erfc_numerical(const char *aXJson)
;

/*
 Computes the symbolic imaginary error function erfi(z) via JSON interface.
 */
rssn_
char *rssn_json_erfi(const char *aArgJson)
;

/*
 Computes the Euler-Lagrange equation using JSON.
 */
rssn_
char *rssn_json_euler_lagrange(const char *aLagrangianJson,
                               const char *aFunc,
                               const char *aVar)
;

/*
 Computes Euler-Lagrange equation using JSON.
 */
rssn_
char *rssn_json_euler_lagrange_equation(const char *aLagrangianJson,
                                        const char *aQ,
                                        const char *aQDot,
                                        const char *aTVar)
;

/*
 Evaluates at point using JSON.
 */
rssn_
char *rssn_json_evaluate_at_point(const char *aExprJson,
                                  const char *aVar,
                                  const char *aValueJson)
;

rssn_
char *rssn_json_evaluate_numerical(const char *aExprJson)
;

/*
 Computes the expectation value using JSON.
 */
rssn_
char *rssn_json_expectation_value(const char *aOpJson,
                                  const char *aPsiJson)
;

rssn_
char *rssn_json_exponential_map(const char *aXJson,
                                size_t aOrder)
;

rssn_
char *rssn_json_extended_gcd(const char *aAJson,
                             const char *aBJson)
;

/*
 Computes the exterior derivative of a differential form (JSON)
 */
rssn_
char *rssn_json_exterior_derivative(const char *aFormJson,
                                    const char *aVarsJson)
;

/*
 Factors a polynomial over a finite field (JSON)
 */
rssn_
char *rssn_json_factor_gf(const char *aPolyJson)
;

/*
 Computes n! via JSON interface.
 */
rssn_
char *rssn_json_factorial(const char *aNJson)
;

/*
 Computes the falling factorial (x)₍ₙ₎ via JSON interface.
 */
rssn_
char *rssn_json_falling_factorial(const char *aXJson,
                                  const char *aNJson)
;

/*
 Computes Fermi energy for a 3D electron gas using JSON.
 */
rssn_
char *rssn_json_fermi_energy_3d(const char *aConcentrationJson,
                                const char *aMassJson)
;

/*
 Computes the Feynman slash using JSON.
 */
rssn_
char *rssn_json_feynman_slash(const char *aVMuJson)
;

/*
 Finds constrained extrema (JSON)
 */
rssn_
char *rssn_json_find_constrained_extrema(const char *aExprJson,
                                         const char *aConstraintsJson,
                                         const char *aVarsJson)
;

/*
 Finds extrema of a function (JSON)
 */
rssn_
char *rssn_json_find_extrema(const char *aExprJson,
                             const char *aVarsJson)
;

/*
 Finds fixed points of a 1D map (JSON)
 */
rssn_
char *rssn_json_find_fixed_points(const char *aMapJson,
                                  const char *aVar)
;

/*
 Finds pole order using JSON.
 */
rssn_
size_t rssn_json_find_pole_order(const char *aExprJson,
                                 const char *aVar,
                                 const char *aPoleJson)
;

/*
 Finds poles using JSON.
 */
rssn_
char *rssn_json_find_poles(const char *aExprJson,
                           const char *aVar)
;

/*
 Gets the degree of a finite field polynomial (JSON)
 */
rssn_
int64_t rssn_json_finite_field_polynomial_degree(const char *aPolyJson)
;

/*
 Performs polynomial long division (JSON)
 */
rssn_
char *rssn_json_finite_field_polynomial_long_division(const char *aDividendJson,
                                                      const char *aDivisorJson)
;

/*
 Creates a new finite field polynomial (JSON)
 */
rssn_
char *rssn_json_finite_field_polynomial_new(const char *aCoeffsJson,
                                            const char *aModulusJson)
;

rssn_
char *rssn_json_fourier_differentiation(const char *aFOmegaJson,
                                        const char *aOutVarJson)
;

rssn_
char *rssn_json_fourier_frequency_shift(const char *aFOmegaJson,
                                        const char *aAJson,
                                        const char *aOutVarJson)
;

rssn_
char *rssn_json_fourier_scaling(const char *aFOmegaJson,
                                const char *aAJson,
                                const char *aOutVarJson)
;

rssn_
char *rssn_json_fourier_series(const char *aExprJson,
                               const char *aVarJson,
                               const char *aPeriodJson,
                               const char *aOrderJson)
;

rssn_
char *rssn_json_fourier_time_shift(const char *aFOmegaJson,
                                   const char *aAJson,
                                   const char *aOutVarJson)
;

rssn_
char *rssn_json_fourier_transform(const char *aExprJson,
                                  const char *aInVarJson,
                                  const char *aOutVarJson)
;

/*
 Computes the symbolic Gamma function Γ(z) via JSON interface.
 */
rssn_
char *rssn_json_gamma(const char *aArgJson)
;

/*
 Computes the gamma function Γ(x) via JSON interface.
 */
rssn_
char *rssn_json_gamma_numerical(const char *aXJson)
;

/*
 Represents Gauss's theorem (JSON)
 */
rssn_
char *rssn_json_gauss_theorem(const char *aVectorFieldJson,
                              const char *aVolumeJson)
;

/*
 Computes general multi-valued arccos (JSON)
 */
rssn_
char *rssn_json_general_arccos(const char *aZJson,
                               const char *aKJson,
                               const char *aSJson)
;

/*
 Computes general multi-valued arcsin (JSON)
 */
rssn_
char *rssn_json_general_arcsin(const char *aZJson,
                               const char *aKJson)
;

/*
 Computes general multi-valued arctan (JSON)
 */
rssn_
char *rssn_json_general_arctan(const char *aZJson,
                               const char *aKJson)
;

/*
 Computes general multi-valued logarithm (JSON)
 */
rssn_
char *rssn_json_general_log(const char *aZJson,
                            const char *aKJson)
;

/*
 Computes general multi-valued n-th root (JSON)
 */
rssn_
char *rssn_json_general_nth_root(const char *aZJson,
                                 const char *aNJson,
                                 const char *aKJson)
;

/*
 Computes general multi-valued power (JSON)
 */
rssn_
char *rssn_json_general_power(const char *aZJson,
                              const char *aWJson,
                              const char *aKJson)
;

/*
 Computes general multi-valued square root (JSON)
 */
rssn_
char *rssn_json_general_sqrt(const char *aZJson,
                             const char *aKJson)
;

/*
 Computes the symbolic Generalized Laguerre polynomial L_n^α(x) via JSON interface.
 */
rssn_
char *rssn_json_generalized_laguerre(const char *aNJson,
                                     const char *aAlphaJson,
                                     const char *aXJson)
;

/*
 Represents the generalized Stokes' theorem (JSON)
 */
rssn_
char *rssn_json_generalized_stokes_theorem(const char *aOmegaJson,
                                           const char *aManifoldJson,
                                           const char *aVarsJson)
;

/*
 Generates a key pair.
 */
rssn_
char *rssn_json_generate_keypair(const char *aCurveJson,
                                 const char *aGeneratorJson)
;

/*
 Generates a shared secret.
 */
rssn_
char *rssn_json_generate_shared_secret(const char *aCurveJson,
                                       const char *aPrivateKeyJson,
                                       const char *aOtherPublicKeyJson)
;

/*
 Gets real and imaginary parts using JSON.
 */
rssn_
char *rssn_json_get_real_imag_parts(const char *aExprJson)
;

/*
 Performs addition in GF(2^8) via JSON interface.
 */
rssn_
char *rssn_json_gf256_add(const char *aAJson,
                          const char *aBJson)
;

/*
 Computes inverse in GF(2^8) via JSON interface.
 */
rssn_
char *rssn_json_gf256_inv(const char *aAJson)
;

/*
 Performs multiplication in GF(2^8) via JSON interface.
 */
rssn_
char *rssn_json_gf256_mul(const char *aAJson,
                          const char *aBJson)
;

/*
 Calculates Gibbs Free Energy using JSON.
 */
rssn_
char *rssn_json_gibbs_free_energy(const char *aHJson,
                                  const char *aTJson,
                                  const char *aSJson)
;

rssn_
char *rssn_json_gini_impurity(const char *aProbsJson)
;

rssn_
char *rssn_json_gram_schmidt(const char *aSpaceJson,
                             const char *aBasisJson)
;

/*
 Adds an edge to the graph.
 Input JSON: {"graph": <graph>, "from": "label1", "to": "label2", "weight": <expr>}
 */
rssn_
char *rssn_json_graph_add_edge(const char *aJson)
;

/*
 Adds a node to the graph.
 Input JSON: {"graph": <graph>, "label": "node_label"}
 Returns updated graph as JSON.
 */
rssn_
char *rssn_json_graph_add_node(const char *aJson)
;

/*
 Gets the adjacency matrix of the graph.
 Input JSON: <graph>
 Returns Expr (matrix) as JSON.
 */
rssn_
char *rssn_json_graph_adjacency_matrix(const char *aJson)
;

/*
 Performs BFS traversal.
 Input JSON: {"graph": <graph>, "start_node": <index>}
 */
rssn_
char *rssn_json_graph_bfs(const char *aJson)
;

/*
 Performs BFS traversal.
 Input: {"graph": Graph, "start_node": usize}
 Output: [usize]
 */
rssn_
char *rssn_json_graph_bfs_api(const char *aJson)
;

/*
 Finds maximum matching in bipartite graph.
 Input: {"graph": Graph, "partition": [i8]}
 Output: [(usize, usize)]
 */
rssn_
char *rssn_json_graph_bipartite_maximum_matching(const char *aJson)
;

/*
 Finds bridges and articulation points.
 Input: Graph
 Output: {"bridges": [(usize, usize)], "articulation_points": [usize]}
 */
rssn_
char *rssn_json_graph_bridges_and_articulation_points(const char *aJson)
;

/*
 Computes the Cartesian product of two graphs.
 */
rssn_
char *rssn_json_graph_cartesian_product(const char *aJson)
;

/*
 Computes the complement of a graph.
 */
rssn_
char *rssn_json_graph_complement(const char *aJson)
;

/*
 Finds connected components.
 */
rssn_
char *rssn_json_graph_connected_components(const char *aJson)
;

/*
 Finds connected components.
 Input: Graph
 Output: [[usize]] (array of arrays)
 */
rssn_
char *rssn_json_graph_connected_components_api(const char *aJson)
;

/*
 Performs DFS traversal.
 */
rssn_
char *rssn_json_graph_dfs(const char *aJson)
;

/*
 Performs DFS traversal.
 Input: {"graph": Graph, "start_node": usize}
 Output: [usize] (array of node indices)
 */
rssn_
char *rssn_json_graph_dfs_api(const char *aJson)
;

/*
 Computes maximum flow using Dinic's algorithm.
 Input: {"graph": Graph, "source": usize, "sink": usize}
 Output: f64
 */
rssn_
char *rssn_json_graph_dinic_max_flow(const char *aJson)
;

/*
 Computes the disjoint union of two graphs.
 */
rssn_
char *rssn_json_graph_disjoint_union(const char *aJson)
;

/*
 Computes maximum flow using Edmonds-Karp.
 Input: {"graph": Graph, "source": usize, "sink": usize}
 Output: f64
 */
rssn_
char *rssn_json_graph_edmonds_karp_max_flow(const char *aJson)
;

/*
 Checks if graph has a cycle.
 */
rssn_
char *rssn_json_graph_has_cycle(const char *aJson)
;

/*
 Checks if graph has a cycle.
 Input: Graph
 Output: bool
 */
rssn_
char *rssn_json_graph_has_cycle_api(const char *aJson)
;

/*
 Creates an induced subgraph.
 Input JSON: {"graph": <graph>, "nodes": ["label1", "label2"]}
 */
rssn_
char *rssn_json_graph_induced_subgraph(const char *aJson)
;

/*
 Computes the intersection of two graphs.
 */
rssn_
char *rssn_json_graph_intersection(const char *aJson)
;

/*
 Checks if graph is bipartite.
 */
rssn_
char *rssn_json_graph_is_bipartite(const char *aJson)
;

/*
 Checks if graph is bipartite.
 Input: Graph
 Output: [i8] or null
 */
rssn_
char *rssn_json_graph_is_bipartite_api(const char *aJson)
;

/*
 Checks if graph is connected.
 Input: Graph
 Output: bool
 */
rssn_
char *rssn_json_graph_is_connected(const char *aJson)
;

/*
 Computes the join of two graphs.
 */
rssn_
char *rssn_json_graph_join(const char *aJson)
;

/*
 Computes MST using Kruskal's algorithm.
 */
rssn_
char *rssn_json_graph_kruskal_mst(const char *aJson)
;

/*
 Computes MST using Kruskal's algorithm.
 Input: Graph
 Output: Graph (MST)
 */
rssn_
char *rssn_json_graph_kruskal_mst_api(const char *aJson)
;

/*
 Gets the Laplacian matrix of the graph.
 */
rssn_
char *rssn_json_graph_laplacian_matrix(const char *aJson)
;

/*
 Computes maximum flow.
 Input JSON: {"graph": <graph>, "source": <index>, "sink": <index>}
 */
rssn_
char *rssn_json_graph_max_flow(const char *aJson)
;

/*
 Creates a new graph from JSON specification.
 JSON format: {"is_directed": true/false}
 */
rssn_
char *rssn_json_graph_new(const char *aJson)
;

/*
 Finds strongly connected components.
 Input: Graph
 Output: [[usize]]
 */
rssn_
char *rssn_json_graph_strongly_connected_components(const char *aJson)
;

/*
 Computes the Tensor product of two graphs.
 */
rssn_
char *rssn_json_graph_tensor_product(const char *aJson)
;

/*
 Performs topological sort.
 Input: Graph
 Output: [usize] or null
 */
rssn_
char *rssn_json_graph_topological_sort(const char *aJson)
;

/*
 Computes the union of two graphs.
 Input JSON: {"g1": <graph>, "g2": <graph>}
 */
rssn_
char *rssn_json_graph_union(const char *aJson)
;

/*
 Greedy coloring.
 Input: Graph
 Output: {node_id: color_id}
 */
rssn_
char *rssn_json_greedy_coloring(const char *aJson)
;

/*
 Represents Green's theorem (JSON)
 */
rssn_
char *rssn_json_greens_theorem(const char *aPJson,
                               const char *aQJson,
                               const char *aDomainJson)
;

rssn_
char *rssn_json_group_center(const char *aGroupJson)
;

rssn_
char *rssn_json_group_conjugacy_classes(const char *aGroupJson)
;

rssn_
char *rssn_json_group_create(const char *aJsonStr)
;

rssn_
size_t rssn_json_group_element_order(const char *aGroupJson,
                                     const char *aAJson)
;

rssn_
char *rssn_json_group_inverse(const char *aGroupJson,
                              const char *aAJson)
;

rssn_
bool rssn_json_group_is_abelian(const char *aGroupJson)
;

rssn_
char *rssn_json_group_multiply(const char *aGroupJson,
                               const char *aAJson,
                               const char *aBJson)
;

/*
 Applies Hamilton's Principle using JSON.
 */
rssn_
char *rssn_json_hamiltons_principle(const char *aLagrangianJson,
                                    const char *aFunc,
                                    const char *aVar)
;

/*
 Checks if a Hamming(7,4) codeword is valid via JSON interface.
 Input: [7 bytes]
 Returns: boolean
 */
rssn_
char *rssn_json_hamming_check(const char *aCodewordJson)
;

/*
 Decodes a 7-bit Hamming(7,4) codeword via JSON interface.
 Returns JSON object with "data" and "error_pos" fields.
 */
rssn_
char *rssn_json_hamming_decode(const char *aCodewordJson)
;

/*
 Computes Hamming distance between two byte slices via JSON interface.
 Input: {"a": [bytes], "b": [bytes]}
 Returns: distance as integer, or null on error
 */
rssn_
char *rssn_json_hamming_distance(const char *aAJson,
                                 const char *aBJson)
;

/*
 Encodes 4 data bits into a 7-bit Hamming(7,4) codeword via JSON interface.
 */
rssn_
char *rssn_json_hamming_encode(const char *aDataJson)
;

/*
 Computes Hamming weight of a byte slice via JSON interface.
 Input: [bytes]
 Returns: weight as integer
 */
rssn_
char *rssn_json_hamming_weight(const char *aDataJson)
;

/*
 Constructs Hermite's differential equation via JSON interface.
 */
rssn_
char *rssn_json_hermite_differential_equation(const char *aYJson,
                                              const char *aXJson,
                                              const char *aNJson)
;

/*
 Computes the symbolic Hermite polynomial H_n(x) via JSON interface.
 */
rssn_
char *rssn_json_hermite_h(const char *aDegreeJson,
                          const char *aArgJson)
;

/*
 Constructs Rodrigues' formula for Hermite polynomials via JSON interface.
 */
rssn_
char *rssn_json_hermite_rodrigues_formula(const char *aNJson,
                                          const char *aXJson)
;

/*
 Computes Hessian matrix (JSON)
 */
rssn_
char *rssn_json_hessian_matrix(const char *aExprJson,
                               const char *aVarsJson)
;

/*
 Simplifies an expression using the heuristic simplifier (JSON input/output).
 */
rssn_
char *rssn_json_heuristic_simplify(const char *aExprJson)
;

rssn_
char *rssn_json_hilbert_space_create(const char *aJsonStr)
;

/*
 Calculates ideal gas Law using JSON.
 */
rssn_
char *rssn_json_ideal_gas_law(const char *aPJson,
                              const char *aVJson,
                              const char *aNJson,
                              const char *aRJson,
                              const char *aTJson)
;

/*
 Creates a new IteratedFunctionSystem (JSON)
 */
rssn_
char *rssn_json_ifs_create(const char *aFunctionsJson,
                           const char *aProbabilitiesJson,
                           const char *aVariablesJson)
;

/*
 Calculates similarity dimension (JSON)
 */
rssn_
char *rssn_json_ifs_similarity_dimension(const char *aScalingFactorsJson)
;

rssn_
char *rssn_json_inner_product(const char *aSpaceJson,
                              const char *aFJson,
                              const char *aGJson)
;

/*
 Integrates an expression using JSON.
 */
rssn_
char *rssn_json_integrate(const char *aExprJson,
                          const char *aVar)
;

/*
 Integrates a rational function (JSON)
 */
rssn_
char *rssn_json_integrate_rational_function(const char *aExprJson,
                                            const char *aXJson)
;

/*
 Computes erf⁻¹(x) via JSON interface.
 */
rssn_
char *rssn_json_inverse_erf(const char *aXJson)
;

/*
 Computes erfc⁻¹(x) via JSON interface.
 */
rssn_
char *rssn_json_inverse_erfc(const char *aXJson)
;

rssn_
char *rssn_json_inverse_fourier_transform(const char *aExprJson,
                                          const char *aInVarJson,
                                          const char *aOutVarJson)
;

rssn_
char *rssn_json_inverse_laplace_transform(const char *aExprJson,
                                          const char *aInVarJson,
                                          const char *aOutVarJson)
;

rssn_
char *rssn_json_inverse_z_transform(const char *aExprJson,
                                    const char *aInVarJson,
                                    const char *aOutVarJson)
;

rssn_
char *rssn_json_is_prime(const char *aNJson)
;

/*
 Checks if a logical expression is satisfiable using JSON-based FFI.

 Returns a JSON string containing:
 - `{"result": "satisfiable"}` if satisfiable
 - `{"result": "unsatisfiable"}` if unsatisfiable
 - `{"result": "undecidable"}` if the expression contains quantifiers
 */
rssn_
char *rssn_json_is_satisfiable(const char *aExprJson)
;

/*
 Isolates real roots in an interval (JSON)
 */
rssn_
char *rssn_json_isolate_real_roots(const char *aExprJson,
                                   const char *aVarPtr,
                                   double aPrecision)
;

rssn_
char *rssn_json_joint_entropy(const char *aJointProbsJson)
;

/*
 Calculates kinetic energy using JSON.
 */
rssn_
char *rssn_json_kinetic_energy(const char *aMassJson,
                               const char *aVelocityJson)
;

rssn_
char *rssn_json_kl_divergence(const char *aPProbsJson,
                              const char *aQProbsJson)
;

rssn_
char *rssn_json_klein_four_group_create()
;

/*
 Constructs Laguerre's differential equation via JSON interface.
 */
rssn_
char *rssn_json_laguerre_differential_equation(const char *aYJson,
                                               const char *aXJson,
                                               const char *aNJson)
;

/*
 Computes the symbolic Laguerre polynomial L_n(x) via JSON interface.
 */
rssn_
char *rssn_json_laguerre_l(const char *aDegreeJson,
                           const char *aArgJson)
;

rssn_
char *rssn_json_laplace_differentiation(const char *aFSJson,
                                        const char *aOutVarJson,
                                        const char *aFZeroJson)
;

rssn_
char *rssn_json_laplace_frequency_shift(const char *aFSJson,
                                        const char *aAJson,
                                        const char *aOutVarJson)
;

rssn_
char *rssn_json_laplace_integration(const char *aFSJson,
                                    const char *aOutVarJson)
;

rssn_
char *rssn_json_laplace_scaling(const char *aFSJson,
                                const char *aAJson,
                                const char *aOutVarJson)
;

rssn_
char *rssn_json_laplace_time_shift(const char *aFSJson,
                                   const char *aAJson,
                                   const char *aOutVarJson)
;

rssn_
char *rssn_json_laplace_transform(const char *aExprJson,
                                  const char *aInVarJson,
                                  const char *aOutVarJson)
;

rssn_
char *rssn_json_laurent_series(const char *aExprJson,
                               const char *aVarJson,
                               const char *aCenterJson,
                               const char *aOrderJson)
;

/*
 Constructs Legendre's differential equation via JSON interface.
 */
rssn_
char *rssn_json_legendre_differential_equation(const char *aYJson,
                                               const char *aXJson,
                                               const char *aNJson)
;

/*
 Computes the symbolic Legendre polynomial P_n(x) via JSON interface.
 */
rssn_
char *rssn_json_legendre_p(const char *aDegreeJson,
                           const char *aArgJson)
;

/*
 Constructs Rodrigues' formula for Legendre polynomials via JSON interface.
 */
rssn_
char *rssn_json_legendre_rodrigues_formula(const char *aNJson,
                                           const char *aXJson)
;

rssn_
char *rssn_json_lie_algebra_so3()
;

rssn_
char *rssn_json_lie_algebra_su2()
;

rssn_
char *rssn_json_lie_bracket(const char *aXJson,
                            const char *aYJson)
;

/*
 Computes limit using JSON.
 */
rssn_
char *rssn_json_limit(const char *aExprJson,
                      const char *aVar,
                      const char *aPointJson)
;

/*
 Computes ln(B(a, b)) via JSON interface.
 */
rssn_
char *rssn_json_ln_beta_numerical(const char *aAJson,
                                  const char *aBJson)
;

/*
 Computes ln(n!) via JSON interface.
 */
rssn_
char *rssn_json_ln_factorial(const char *aNJson)
;

/*
 Computes the symbolic log-gamma function ln(Γ(z)) via JSON interface.
 */
rssn_
char *rssn_json_ln_gamma(const char *aArgJson)
;

/*
 Computes ln(Γ(x)) via JSON interface.
 */
rssn_
char *rssn_json_ln_gamma_numerical(const char *aXJson)
;

/*
 Calculates Lorentz factor using JSON.
 */
rssn_
char *rssn_json_lorentz_factor(const char *aVelocityJson)
;

/*
 Calculates Lorentz force using JSON.
 */
rssn_
char *rssn_json_lorentz_force(const char *aChargeJson,
                              const char *aEFieldJson,
                              const char *aVelocityJson,
                              const char *aBFieldJson)
;

/*
 Returns Lorenz system equations (JSON)
 */
rssn_ char *rssn_json_lorenz_system() ;

/*
 Calculates Lyapunov exponent (JSON)
 */
rssn_
char *rssn_json_lyapunov_exponent(const char *aMapJson,
                                  const char *aVar,
                                  const char *aInitialXJson,
                                  size_t aNIterations)
;

/*
 Calculates mass-energy equivalence using JSON.
 */
rssn_
char *rssn_json_mass_energy_equivalence(const char *aMassJson)
;

rssn_
char *rssn_json_matrix_add(const char *aM1Json,
                           const char *aM2Json)
;

rssn_
char *rssn_json_matrix_determinant(const char *aMatrixJson)
;

rssn_
char *rssn_json_matrix_inverse(const char *aMatrixJson)
;

rssn_
char *rssn_json_matrix_mul(const char *aM1Json,
                           const char *aM2Json)
;

rssn_
char *rssn_json_matrix_solve_linear_system(const char *aAJson,
                                           const char *aBJson)
;

rssn_
char *rssn_json_matrix_transpose(const char *aMatrixJson)
;

/*
 Computes the symbolic mean of a set of expressions using JSON.
 */
rssn_
char *rssn_json_mean(const char *aDataJson)
;

/*
 Computes geometric product (JSON)
 */
rssn_
char *rssn_json_multivector_geometric_product(const char *aAJson,
                                              const char *aBJson)
;

/*
 Computes grade projection (JSON)
 */
rssn_
char *rssn_json_multivector_grade_projection(const char *aMvJson,
                                             uint32_t aGrade)
;

/*
 Computes inner product (JSON)
 */
rssn_
char *rssn_json_multivector_inner_product(const char *aAJson,
                                          const char *aBJson)
;

/*
 Computes magnitude (JSON)
 */
rssn_
char *rssn_json_multivector_magnitude(const char *aMvJson)
;

/*
 Computes outer product (JSON)
 */
rssn_
char *rssn_json_multivector_outer_product(const char *aAJson,
                                          const char *aBJson)
;

/*
 Computes reverse (JSON)
 */
rssn_
char *rssn_json_multivector_reverse(const char *aMvJson)
;

/*
 Creates a new scalar multivector (JSON)
 */
rssn_
char *rssn_json_multivector_scalar(uint32_t aP,
                                   uint32_t aQ,
                                   uint32_t aR,
                                   const char *aValueJson)
;

rssn_
char *rssn_json_mutual_information(const char *aJointProbsJson)
;

rssn_
char *rssn_json_nonlinear_regression(const char *aDataJson,
                                     const char *aModelJson,
                                     const char *aVarsJson,
                                     const char *aParamsJson)
;

rssn_
char *rssn_json_norm(const char *aSpaceJson,
                     const char *aFJson)
;

rssn_
char *rssn_json_one_sample_t_test(const char *aDataJson,
                                  const char *aTargetMeanJson)
;

rssn_
char *rssn_json_partial_fraction_decomposition(const char *aExprJson,
                                               const char *aVarJson)
;

/*
 Computes path integral using JSON.
 */
rssn_
char *rssn_json_path_integrate(const char *aExprJson,
                               const char *aVar,
                               const char *aContourJson)
;

rssn_
char *rssn_json_permutations(const char *aNJson,
                             const char *aKJson)
;

/*
 Compresses a point.
 */
rssn_
char *rssn_json_point_compress(const char *aPointJson)
;

/*
 Decompresses a point.
 */
rssn_
char *rssn_json_point_decompress(const char *aXJson,
                                 const char *aIsOddJson,
                                 const char *aCurveJson)
;

/*
 Adds two polynomials over a general finite field via JSON interface.
 */
rssn_
char *rssn_json_poly_add_gf(const char *aP1Json,
                            const char *aP2Json,
                            const char *aModulusJson)
;

/*
 Adds two polynomials over GF(2^8) via JSON interface.
 */
rssn_
char *rssn_json_poly_add_gf256(const char *aP1Json,
                               const char *aP2Json)
;

/*
 Computes polynomial derivative over finite field (JSON)
 */
rssn_
char *rssn_json_poly_derivative_gf(const char *aPolyJson)
;

rssn_
char *rssn_json_poly_division_multivariate(const char *aDividendJson,
                                           const char *aDivisorsJson,
                                           const char *aOrderJson)
;

/*
 Evaluates a polynomial over GF(2^8) via JSON interface.
 */
rssn_
char *rssn_json_poly_eval_gf256(const char *aPolyJson,
                                const char *aXJson)
;

/*
 Computes polynomial GCD over finite field (JSON)
 */
rssn_
char *rssn_json_poly_gcd_gf(const char *aAJson,
                            const char *aBJson)
;

/*
 Multiplies two polynomials over a general finite field via JSON interface.
 */
rssn_
char *rssn_json_poly_mul_gf(const char *aP1Json,
                            const char *aP2Json,
                            const char *aModulusJson)
;

/*
 Multiplies two polynomials over GF(2^8) via JSON interface.
 */
rssn_
char *rssn_json_poly_mul_gf256(const char *aP1Json,
                               const char *aP2Json)
;

/*
 Computes the symbolic Polygamma function ψ⁽ⁿ⁾(z) via JSON interface.
 */
rssn_
char *rssn_json_polygamma(const char *aNJson,
                          const char *aZJson)
;

/*
 Checks if an expression contains a variable (JSON)
 */
rssn_
bool rssn_json_polynomial_contains_var(const char *aExprJson,
                                       const char *aVar)
;

/*
 Computes the degree of a polynomial (JSON)
 */
rssn_
int64_t rssn_json_polynomial_degree(const char *aExprJson,
                                    const char *aVar)
;

/*
 Checks if an expression is a polynomial in the given variable (JSON)
 */
rssn_
bool rssn_json_polynomial_is_polynomial(const char *aExprJson,
                                        const char *aVar)
;

/*
 Finds the leading coefficient of a polynomial (JSON)
 */
rssn_
char *rssn_json_polynomial_leading_coefficient(const char *aExprJson,
                                               const char *aVar)
;

/*
 Performs polynomial long division (JSON)
 */
rssn_
char *rssn_json_polynomial_long_division(const char *aDividendJson,
                                         const char *aDivisorJson,
                                         const char *aVar)
;

rssn_
char *rssn_json_polynomial_regression(const char *aDataJson,
                                      size_t aDegree)
;

/*
 Converts polynomial to coefficient vector (JSON)
 */
rssn_
char *rssn_json_polynomial_to_coeffs_vec(const char *aExprJson,
                                         const char *aVar)
;

/*
 Adds two prime field elements (JSON)
 */
rssn_
char *rssn_json_prime_field_element_add(const char *aAJson,
                                        const char *aBJson)
;

/*
 Divides two prime field elements (JSON)
 */
rssn_
char *rssn_json_prime_field_element_div(const char *aAJson,
                                        const char *aBJson)
;

/*
 Computes the inverse of a prime field element (JSON)
 */
rssn_
char *rssn_json_prime_field_element_inverse(const char *aElemJson)
;

/*
 Multiplies two prime field elements (JSON)
 */
rssn_
char *rssn_json_prime_field_element_mul(const char *aAJson,
                                        const char *aBJson)
;

/*
 Creates a new prime field element (JSON)
 */
rssn_
char *rssn_json_prime_field_element_new(const char *aValueJson,
                                        const char *aModulusJson)
;

/*
 Subtracts two prime field elements (JSON)
 */
rssn_
char *rssn_json_prime_field_element_sub(const char *aAJson,
                                        const char *aBJson)
;

rssn_
char *rssn_json_product(const char *aExprJson,
                        const char *aVarJson,
                        const char *aLowerJson,
                        const char *aUpperJson)
;

/*
 Lagrangian density for QCD using JSON.
 */
rssn_
char *rssn_json_qcd_lagrangian(const char *aPsiBarJson,
                               const char *aPsiJson,
                               const char *aGMuJson,
                               const char *aMJson,
                               const char *aGsJson)
;

/*
 Lagrangian density for QED using JSON.
 */
rssn_
char *rssn_json_qed_lagrangian(const char *aPsiBarJson,
                               const char *aPsiJson,
                               const char *aAMuJson,
                               const char *aMJson,
                               const char *aEJson)
;

/*
 Computes a propagator using JSON.
 */
rssn_
char *rssn_json_qft_propagator(const char *aPJson,
                               const char *aMJson,
                               bool aIsFermion)
;

/*
 Generates a 3x3 2D reflection matrix via JSON interface.
 */
rssn_
char *rssn_json_reflection_2d(const char *aAngleJson)
;

/*
 Generates a 4x4 3D reflection matrix via JSON interface.
 */
rssn_
char *rssn_json_reflection_3d(const char *aNxJson,
                              const char *aNyJson,
                              const char *aNzJson)
;

/*
 Computes P(a, x) via JSON interface.
 */
rssn_
char *rssn_json_regularized_gamma_p(const char *aAJson,
                                    const char *aXJson)
;

/*
 Computes Q(a, x) via JSON interface.
 */
rssn_
char *rssn_json_regularized_gamma_q(const char *aAJson,
                                    const char *aXJson)
;

/*
 Computes the regularized incomplete beta Iₓ(a, b) via JSON interface.
 */
rssn_
char *rssn_json_regularized_incomplete_beta(const char *aAJson,
                                            const char *aBJson,
                                            const char *aXJson)
;

rssn_
char *rssn_json_representation_create(const char *aJsonStr)
;

rssn_
bool rssn_json_representation_is_valid(const char *aRepJson,
                                       const char *aGroupJson)
;

/*
 Integrates an expression using the Risch-Norman algorithm (JSON)
 */
rssn_
char *rssn_json_risch_norman_integrate(const char *aExprJson,
                                       const char *aXJson)
;

/*
 Computes the rising factorial (x)ₙ via JSON interface.
 */
rssn_
char *rssn_json_rising_factorial(const char *aXJson,
                                 const char *aNJson)
;

/*
 Generates a 3x3 2D rotation matrix via JSON interface.
 */
rssn_
char *rssn_json_rotation_2d(const char *aAngleJson)
;

/*
 Generates a 4x4 3D rotation matrix around X-axis via JSON interface.
 */
rssn_
char *rssn_json_rotation_3d_x(const char *aAngleJson)
;

/*
 Generates a 4x4 3D rotation matrix around Y-axis via JSON interface.
 */
rssn_
char *rssn_json_rotation_3d_y(const char *aAngleJson)
;

/*
 Generates a 4x4 3D rotation matrix around Z-axis via JSON interface.
 */
rssn_
char *rssn_json_rotation_3d_z(const char *aAngleJson)
;

/*
 Generates a 4x4 3D rotation around arbitrary axis via JSON interface.
 */
rssn_
char *rssn_json_rotation_axis_angle(const char *aAxisXJson,
                                    const char *aAxisYJson,
                                    const char *aAxisZJson,
                                    const char *aAngleJson)
;

/*
 Checks if a Reed-Solomon codeword is valid via JSON interface.
 Returns: boolean
 */
rssn_
char *rssn_json_rs_check(const char *aCodewordJson,
                         const char *aNSymJson)
;

/*
 Decodes a Reed-Solomon codeword via JSON interface.
 */
rssn_
char *rssn_json_rs_decode(const char *aCodewordJson,
                          const char *aNSymJson)
;

/*
 Encodes data using Reed-Solomon code via JSON interface.
 Input: {"data": [bytes], "n_sym": number}
 */
rssn_
char *rssn_json_rs_encode(const char *aDataJson,
                          const char *aNSymJson)
;

/*
 Estimates error count in a Reed-Solomon codeword via JSON interface.
 Returns: error count as integer
 */
rssn_
char *rssn_json_rs_error_count(const char *aCodewordJson,
                               const char *aNSymJson)
;

/*
 Lagrangian density for a scalar field using JSON.
 */
rssn_
char *rssn_json_scalar_field_lagrangian(const char *aPhiJson,
                                        const char *aMJson)
;

/*
 Generates a 3x3 2D scaling matrix via JSON interface.
 */
rssn_
char *rssn_json_scaling_2d(const char *aSxJson,
                           const char *aSyJson)
;

/*
 Generates a 4x4 3D scaling matrix via JSON interface.
 */
rssn_
char *rssn_json_scaling_3d(const char *aSxJson,
                           const char *aSyJson,
                           const char *aSzJson)
;

/*
 Calculates Schwarzschild radius using JSON.
 */
rssn_
char *rssn_json_schwarzschild_radius(const char *aMassJson)
;

rssn_
char *rssn_json_shannon_entropy(const char *aProbsJson)
;

/*
 Generates a 3x3 2D shear matrix via JSON interface.
 */
rssn_
char *rssn_json_shear_2d(const char *aShxJson,
                         const char *aShyJson)
;

rssn_
char *rssn_json_simple_linear_regression(const char *aDataJson)
;

/*
 Creates a new Simplex (JSON)
 */
rssn_
char *rssn_json_simplex_create(const char *aVerticesJson)
;

/*
 Gets the dimension of a Simplex (JSON)
 */
rssn_
char *rssn_json_simplex_dimension(const char *aSimplexJson)
;

/*
 Adds a simplex to a SimplicialComplex (JSON)
 */
rssn_
char *rssn_json_simplicial_complex_add_simplex(const char *aComplexJson,
                                               const char *aVerticesJson)
;

/*
 Applies the symbolic boundary operator to a SymbolicChain (JSON)
 */
rssn_
char *rssn_json_simplicial_complex_apply_symbolic_boundary_operator(const char *aComplexJson,
                                                                    const char *aChainJson)
;

/*
 Creates a new SimplicialComplex (JSON)
 */
rssn_
char *rssn_json_simplicial_complex_create()
;

/*
 Gets the symbolic boundary matrix for dimension k (JSON)
 */
rssn_
char *rssn_json_simplicial_complex_get_symbolic_boundary_matrix(const char *aComplexJson,
                                                                size_t aK)
;

/*
 Simplifies an expression using the legacy simplifier (JSON input/output).
 */
rssn_
char *rssn_json_simplify(const char *aExprJson)
;

/*
 Simplifies an expression using the DAG-based simplifier (JSON input/output).
 */
rssn_
char *rssn_json_simplify_dag(const char *aExprJson)
;

/*
 Simplifies a logical expression using JSON-based FFI.
 */
rssn_
char *rssn_json_simplify_logic(const char *aExprJson)
;

/*
 Simplifies radical expressions (JSON)
 */
rssn_
char *rssn_json_simplify_radicals(const char *aExprJson)
;

/*
 Computes sinc(x) via JSON interface.
 */
rssn_
char *rssn_json_sinc(const char *aXJson)
;

rssn_ char *rssn_json_so3_generators() ;

rssn_
char *rssn_json_solve(const char *aExprJson,
                      const char *aVarJson)
;

/*
 Solves a Bernoulli ODE using JSON.
 */
rssn_
char *rssn_json_solve_bernoulli_ode(const char *aEquationJson,
                                    const char *aFunc,
                                    const char *aVar)
;

/*
 Solves by reduction of order using JSON.
 */
rssn_
char *rssn_json_solve_by_reduction_of_order(const char *aEquationJson,
                                            const char *aFunc,
                                            const char *aVar,
                                            const char *aY1Json)
;

/*
 Solves a Cauchy-Euler ODE using JSON.
 */
rssn_
char *rssn_json_solve_cauchy_euler_ode(const char *aEquationJson,
                                       const char *aFunc,
                                       const char *aVar)
;

rssn_
char *rssn_json_solve_diophantine(const char *aEquationJson,
                                  const char *aVarsJson)
;

/*
 Generates and attempts to solve the Euler-Lagrange equation using JSON.
 */
rssn_
char *rssn_json_solve_euler_lagrange(const char *aLagrangianJson,
                                     const char *aFunc,
                                     const char *aVar)
;

/*
 Solves an exact ODE using JSON.
 */
rssn_
char *rssn_json_solve_exact_ode(const char *aEquationJson,
                                const char *aFunc,
                                const char *aVar)
;

/*
 Solves a first-order linear ODE using JSON.
 */
rssn_
char *rssn_json_solve_first_order_linear_ode(const char *aEquationJson,
                                             const char *aFunc,
                                             const char *aVar)
;

/*
 Solves the 1D heat equation (JSON).
 */
rssn_
char *rssn_json_solve_heat_equation_1d(const char *aEquationJson,
                                       const char *aFunc,
                                       const char *aVarsJson)
;

/*
 Solves the 2D Laplace equation (JSON).
 */
rssn_
char *rssn_json_solve_laplace_equation_2d(const char *aEquationJson,
                                          const char *aFunc,
                                          const char *aVarsJson)
;

rssn_
char *rssn_json_solve_linear_system(const char *aSystemJson,
                                    const char *aVarsJson)
;

/*
 Solves an ODE using JSON.
 */
rssn_
char *rssn_json_solve_ode(const char *aOdeJson,
                          const char *aFunc,
                          const char *aVar)
;

/*
 Solves a PDE using JSON with automatic method selection.
 */
rssn_
char *rssn_json_solve_pde(const char *aPdeJson,
                          const char *aFunc,
                          const char *aVarsJson)
;

/*
 Solves a PDE using the method of characteristics (JSON).
 */
rssn_
char *rssn_json_solve_pde_by_characteristics(const char *aEquationJson,
                                             const char *aFunc,
                                             const char *aVarsJson)
;

/*
 Solves the 2D Poisson equation (JSON).
 */
rssn_
char *rssn_json_solve_poisson_equation_2d(const char *aEquationJson,
                                          const char *aFunc,
                                          const char *aVarsJson)
;

/*
 Solves a Riccati ODE using JSON.
 */
rssn_
char *rssn_json_solve_riccati_ode(const char *aEquationJson,
                                  const char *aFunc,
                                  const char *aVar,
                                  const char *aY1Json)
;

/*
 Solves a separable ODE using JSON.
 */
rssn_
char *rssn_json_solve_separable_ode(const char *aEquationJson,
                                    const char *aFunc,
                                    const char *aVar)
;

rssn_
char *rssn_json_solve_system(const char *aEquationsJson,
                             const char *aVarsJson)
;

/*
 Solves the 1D wave equation using D'Alembert's formula (JSON).
 */
rssn_
char *rssn_json_solve_wave_equation_1d(const char *aEquationJson,
                                       const char *aFunc,
                                       const char *aVarsJson)
;

/*
 Computes square-free factorization (JSON)
 */
rssn_
char *rssn_json_square_free_factorization_gf(const char *aPolyJson)
;

/*
 Computes the symbolic standard deviation of a set of expressions using JSON.
 */
rssn_
char *rssn_json_std_dev(const char *aDataJson)
;

rssn_
char *rssn_json_stirling_number_second_kind(size_t aN,
                                            size_t aK)
;

/*
 Represents Stokes' theorem (JSON)
 */
rssn_
char *rssn_json_stokes_theorem(const char *aVectorFieldJson,
                               const char *aSurfaceJson)
;

/*
 Generates the Sturm sequence for a given polynomial (JSON)
 */
rssn_
char *rssn_json_sturm_sequence(const char *aExprJson,
                               const char *aVarPtr)
;

rssn_ char *rssn_json_su2_generators() ;

/*
 Substitutes using JSON.
 */
rssn_
char *rssn_json_substitute(const char *aExprJson,
                           const char *aVar,
                           const char *aReplacementJson)
;

rssn_
char *rssn_json_summation(const char *aExprJson,
                          const char *aVarJson,
                          const char *aLowerJson,
                          const char *aUpperJson)
;

/*
 Adds a term to a SymbolicChain (JSON)
 */
rssn_
char *rssn_json_symbolic_chain_add_term(const char *aChainJson,
                                        const char *aSimplexJson,
                                        const char *aCoeffJson)
;

/*
 Creates a new SymbolicChain (JSON)
 */
rssn_
char *rssn_json_symbolic_chain_create(size_t aDimension)
;

rssn_
char *rssn_json_symmetric_group_create(size_t aN)
;

rssn_
char *rssn_json_taylor_series(const char *aExprJson,
                              const char *aVarJson,
                              const char *aCenterJson,
                              const char *aOrderJson)
;

rssn_
char *rssn_json_tensor_add(const char *aT1Json,
                           const char *aT2Json)
;

rssn_
char *rssn_json_tensor_contract(const char *aTJson,
                                size_t aAxis1,
                                size_t aAxis2)
;

rssn_
char *rssn_json_tensor_outer_product(const char *aT1Json,
                                     const char *aT2Json)
;

rssn_
char *rssn_json_tensor_scalar_mul(const char *aTJson,
                                  const char *aScalarJson)
;

/*
 Converts a logical expression to Conjunctive Normal Form (CNF) using JSON-based FFI.
 */
rssn_
char *rssn_json_to_cnf(const char *aExprJson)
;

/*
 Converts a logical expression to Disjunctive Normal Form (DNF) using JSON-based FFI.
 */
rssn_
char *rssn_json_to_dnf(const char *aExprJson)
;

rssn_
char *rssn_json_transform_contravariant_vector(const char *aCompsJson,
                                               rssn_CoordinateSystem aFrom,
                                               rssn_CoordinateSystem aTo)
;

rssn_
char *rssn_json_transform_covariant_vector(const char *aCompsJson,
                                           rssn_CoordinateSystem aFrom,
                                           rssn_CoordinateSystem aTo)
;

rssn_
char *rssn_json_transform_curl(const char *aCompsJson,
                               rssn_CoordinateSystem aFrom)
;

rssn_
char *rssn_json_transform_divergence(const char *aCompsJson,
                                     rssn_CoordinateSystem aFrom)
;

rssn_
char *rssn_json_transform_expression(const char *aExprJson,
                                     rssn_CoordinateSystem aFrom,
                                     rssn_CoordinateSystem aTo)
;

rssn_
char *rssn_json_transform_gradient(const char *aScalarJson,
                                   const char *aVarsJson,
                                   rssn_CoordinateSystem aFrom,
                                   rssn_CoordinateSystem aTo)
;

rssn_
char *rssn_json_transform_point(const char *aPointJson,
                                rssn_CoordinateSystem aFrom,
                                rssn_CoordinateSystem aTo)
;

/*
 Generates a 3x3 2D translation matrix via JSON interface.
 */
rssn_
char *rssn_json_translation_2d(const char *aTxJson,
                               const char *aTyJson)
;

/*
 Generates a 4x4 3D translation matrix via JSON interface.
 */
rssn_
char *rssn_json_translation_3d(const char *aTxJson,
                               const char *aTyJson,
                               const char *aTzJson)
;

rssn_
char *rssn_json_two_sample_t_test(const char *aData1Json,
                                  const char *aData2Json,
                                  const char *aMuDiffJson)
;

/*
 Computes the uncertainty using JSON.
 */
rssn_
char *rssn_json_uncertainty(const char *aOpJson,
                            const char *aPsiJson)
;

rssn_
char *rssn_json_unify_expression(const char *aExprJson)
;

/*
 Computes the symbolic variance of a set of expressions using JSON.
 */
rssn_
char *rssn_json_variance(const char *aDataJson)
;

rssn_
char *rssn_json_vector_cross(const char *aV1Json,
                             const char *aV2Json)
;

rssn_
char *rssn_json_vector_curl(const char *aVJson,
                            const char *aXVar,
                            const char *aYVar,
                            const char *aZVar)
;

rssn_
char *rssn_json_vector_divergence(const char *aVJson,
                                  const char *aXVar,
                                  const char *aYVar,
                                  const char *aZVar)
;

rssn_
char *rssn_json_vector_dot(const char *aV1Json,
                           const char *aV2Json)
;

rssn_
char *rssn_json_vector_gradient(const char *aScalarFieldJson,
                                const char *aXVar,
                                const char *aYVar,
                                const char *aZVar)
;

rssn_
char *rssn_json_vector_magnitude(const char *aVJson)
;

rssn_
char *rssn_json_vector_normalize(const char *aVJson)
;

/*
 Verifies an equation solution using JSON.
 */
rssn_
bool rssn_json_verify_equation_solution(const char *aEquationsJson,
                                        const char *aSolutionJson,
                                        const char *aFreeVarsJson)
;

/*
 Verifies an indefinite integral using JSON.
 */
rssn_
bool rssn_json_verify_indefinite_integral(const char *aIntegrandJson,
                                          const char *aIntegralResultJson,
                                          const char *aVarJson)
;

/*
 Verifies a matrix inverse using JSON.
 */
rssn_
bool rssn_json_verify_matrix_inverse(const char *aOriginalJson,
                                     const char *aInverseJson)
;

/*
 Computes the wedge product of two differential forms (JSON)
 */
rssn_
char *rssn_json_wedge_product(const char *aForm1Json,
                              const char *aForm2Json)
;

rssn_
char *rssn_json_z_differentiation(const char *aFZJson,
                                  const char *aOutVarJson)
;

rssn_
char *rssn_json_z_scaling(const char *aFZJson,
                          const char *aAJson,
                          const char *aOutVarJson)
;

rssn_
char *rssn_json_z_test(const char *aDataJson,
                       const char *aTargetMeanJson,
                       const char *aPopStdDevJson)
;

rssn_
char *rssn_json_z_time_shift(const char *aFZJson,
                             const char *aKJson,
                             const char *aOutVarJson)
;

rssn_
char *rssn_json_z_transform(const char *aExprJson,
                            const char *aInVarJson,
                            const char *aOutVarJson)
;

/*
 Computes the symbolic Riemann zeta function ζ(s) via JSON interface.
 */
rssn_
char *rssn_json_zeta(const char *aArgJson)
;

/*
 Computes ζ(s) via JSON interface.
 */
rssn_
char *rssn_json_zeta_numerical(const char *aSJson)
;

/*
 Frees a Ket.
 */
rssn_
void rssn_ket_free(rssn_Ket *aKet)
;

/*
 Creates a new Ket from a state expression.
 */
rssn_
rssn_Ket *rssn_ket_new(const rssn_Expr *aState)
;

rssn_
void rssn_keypair_free(rssn_EcdhKeyPair *aKeypair)
;

rssn_
char *rssn_keypair_get_private_key(const rssn_EcdhKeyPair *aKp)
;

/*
 Returns a NEW handle to the public key point (must be freed).
 */
rssn_
rssn_CurvePoint *rssn_keypair_get_public_key(const rssn_EcdhKeyPair *aKp)
;

/*
 Calculates kinetic energy: 1/2 * m * v^2.
 */
rssn_
rssn_Expr *rssn_kinetic_energy(const rssn_Expr *aMass,
                               const rssn_Expr *aVelocity)
;

rssn_
rssn_Expr *rssn_kl_divergence(const rssn_Expr *const *aPProbs,
                              size_t aPLen,
                              const rssn_Expr *const *aQProbs,
                              size_t aQLen)
;

rssn_
rssn_Group *rssn_klein_four_group_create()
;

/*
 Klein-Gordon equation.
 */
rssn_
rssn_Expr *rssn_klein_gordon_equation(const rssn_Expr *aPsi,
                                      const rssn_Expr *aM)
;

/*
 Applies the Knuth-Bendix completion algorithm to a set of equations.

 Returns a pointer to a Vec<RewriteRule> on success, or null on failure.

 # Safety
 The caller must ensure `equations` is a valid array of Expr pointers.
 */
rssn_
rssn_Vec<rssn_RewriteRule> *rssn_knuth_bendix(const rssn_Expr *const *aEquations,
                                              size_t aEquationsLen)
;

/*
 Applies the Knuth-Bendix completion algorithm (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_knuth_bendix_bincode(rssn_BincodeBuffer aInput)
;

/*
 Applies the Knuth-Bendix completion algorithm (JSON).

 Input: JSON array of equations (Expr::Eq)
 Output: JSON array of RewriteRule objects
 */
rssn_
char *rssn_knuth_bendix_json(const char *aJsonStr)
;

/*
 Calculates Lagrangian: T - V.
 */
rssn_
rssn_Expr *rssn_lagrangian(const rssn_Expr *aT,
                           const rssn_Expr *aV)
;

/*
 Constructs Laguerre's differential equation: xy'' + (1-x)y' + ny = 0.
 */
rssn_
rssn_Expr *rssn_laguerre_differential_equation(const rssn_Expr *aY,
                                               const rssn_Expr *aX,
                                               const rssn_Expr *aN)
;

/*
 Computes the symbolic Laguerre polynomial L_n(x).
 */
rssn_
rssn_Expr *rssn_laguerre_l(const rssn_Expr *aDegree,
                           const rssn_Expr *aArg)
;

rssn_
rssn_Expr *rssn_laplace_differentiation(const rssn_Expr *aFS,
                                        const char *aOutVar,
                                        const rssn_Expr *aFZero)
;

rssn_
rssn_Expr *rssn_laplace_frequency_shift(const rssn_Expr *aFS,
                                        const rssn_Expr *aA,
                                        const char *aOutVar)
;

rssn_
rssn_Expr *rssn_laplace_integration(const rssn_Expr *aFS,
                                    const char *aOutVar)
;

rssn_
rssn_Expr *rssn_laplace_scaling(const rssn_Expr *aFS,
                                const rssn_Expr *aA,
                                const char *aOutVar)
;

rssn_
rssn_Expr *rssn_laplace_time_shift(const rssn_Expr *aFS,
                                   const rssn_Expr *aA,
                                   const char *aOutVar)
;

rssn_
rssn_Expr *rssn_laplace_transform(const rssn_Expr *aExpr,
                                  const char *aInVar,
                                  const char *aOutVar)
;

rssn_
rssn_Expr *rssn_laurent_series_handle(const rssn_Expr *aExpr,
                                      const char *aVar,
                                      const rssn_Expr *aCenter,
                                      size_t aOrder)
;

/*
 Constructs Legendre's differential equation: (1-x²)y'' - 2xy' + n(n+1)y = 0.
 */
rssn_
rssn_Expr *rssn_legendre_differential_equation(const rssn_Expr *aY,
                                               const rssn_Expr *aX,
                                               const rssn_Expr *aN)
;

/*
 Computes the symbolic Legendre polynomial P_n(x).
 */
rssn_
rssn_Expr *rssn_legendre_p(const rssn_Expr *aDegree,
                           const rssn_Expr *aArg)
;

/*
 Constructs Rodrigues' formula for Legendre polynomials.
 */
rssn_
rssn_Expr *rssn_legendre_rodrigues_formula(const rssn_Expr *aN,
                                           const rssn_Expr *aX)
;

rssn_
void rssn_lie_algebra_free(rssn_LieAlgebra *aPtr)
;

rssn_
rssn_Expr *rssn_lie_algebra_get_basis_element(const rssn_LieAlgebra *aPtr,
                                              size_t aIndex)
;

rssn_
size_t rssn_lie_algebra_get_dimension(const rssn_LieAlgebra *aPtr)
;

rssn_
char *rssn_lie_algebra_get_name(const rssn_LieAlgebra *aPtr)
;

rssn_
rssn_LieAlgebra *rssn_lie_algebra_so3_create()
;

rssn_
rssn_LieAlgebra *rssn_lie_algebra_su2_create()
;

rssn_
rssn_Expr *rssn_lie_bracket(const rssn_Expr *aX,
                            const rssn_Expr *aY)
;

/*
 Computes the limit of an expression: limit(expr, var -> point).

 # Safety
 The caller must ensure `expr` and `point` are valid Expr pointers and `var` is a valid C string.
 */
rssn_
rssn_Expr *rssn_limit(const rssn_Expr *aExpr,
                      const char *aVar,
                      const rssn_Expr *aPoint)
;

/*
 Computes the line integral of a scalar field along a curve.
 */
rssn_
char *rssn_line_integral_scalar(const char *aScalarField,
                                const rssn_ParametricCurve *aCurve)
;

/*
 Computes the line integral of a scalar field (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_line_integral_scalar_bincode(const uint8_t *aInputPtr,
                                                     size_t aInputLen)
;

/*
 Computes the line integral of a scalar field (JSON).
 */
rssn_
char *rssn_line_integral_scalar_json(const char *aInputJson)
;

/*
 Computes the line integral of a vector field along a curve.
 */
rssn_
char *rssn_line_integral_vector(const char *aFieldX,
                                const char *aFieldY,
                                const char *aFieldZ,
                                const rssn_ParametricCurve *aCurve)
;

/*
 Computes the line integral of a vector field (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_line_integral_vector_bincode(const uint8_t *aInputPtr,
                                                     size_t aInputLen)
;

/*
 Computes the line integral of a vector field (JSON).
 */
rssn_
char *rssn_line_integral_vector_json(const char *aInputJson)
;

rssn_
rssn_Expr *rssn_linear_operator_apply(const rssn_LinearOperator *aOp,
                                      const rssn_Expr *aExpr)
;

rssn_
rssn_LinearOperator *rssn_linear_operator_derivative_create(const char *aVar)
;

rssn_
void rssn_linear_operator_free(rssn_LinearOperator *aPtr)
;

rssn_
rssn_LinearOperator *rssn_linear_operator_integral_create(const rssn_Expr *aLowerBound,
                                                          const char *aVar)
;

/*
 Creates a natural logarithm expression: ln(expr).
 */
rssn_
rssn_Expr *rssn_ln(const rssn_Expr *aExpr)
;

/*
 Computes the natural logarithm of the beta function ln(B(a, b)).
 */
rssn_
double rssn_ln_beta_numerical(double aA,
                              double aB)
;

/*
 Creates a natural logarithm expression from bincode: ln(expr).
 */
rssn_
rssn_BincodeBuffer rssn_ln_bincode(rssn_BincodeBuffer aExprBuffer)
;

/*
 Computes the natural logarithm of the factorial ln(n!).
 */
rssn_
double rssn_ln_factorial(uint64_t aN)
;

/*
 Computes the symbolic log-gamma function ln(Γ(z)).
 */
rssn_
rssn_Expr *rssn_ln_gamma(const rssn_Expr *aArg)
;

/*
 Computes the natural logarithm of the gamma function ln(Γ(x)).
 */
rssn_
double rssn_ln_gamma_numerical(double aX)
;

/*
 Creates a natural logarithm expression from JSON: ln(expr).
 */
rssn_
char *rssn_ln_json(const char *aJsonExpr)
;

/*
 Calculates the Lorentz factor.
 */
rssn_
rssn_Expr *rssn_lorentz_factor(const rssn_Expr *aVelocity)
;

/*
 Calculates the Lorentz force.
 */
rssn_
rssn_Vector *rssn_lorentz_force(const rssn_Expr *aCharge,
                                const rssn_Vector *aEField,
                                const rssn_Vector *aVelocity,
                                const rssn_Vector *aBField)
;

/*
 Performs a Lorentz transformation in the x-direction.
 */
rssn_
rssn_ExprPair rssn_lorentz_transformation_x(const rssn_Expr *aX,
                                            const rssn_Expr *aT,
                                            const rssn_Expr *aV)
;

/*
 Returns Lorenz system equations (Handle)
 */
rssn_
bool rssn_lorenz_system(rssn_Expr **aDxOut,
                        rssn_Expr **aDyOut,
                        rssn_Expr **aDzOut)
;

/*
 Calculates Lyapunov exponent (Handle)
 */
rssn_
rssn_Expr *rssn_lyapunov_exponent(const rssn_Expr *aMapPtr,
                                  const char *aVar,
                                  const rssn_Expr *aInitialXPtr,
                                  size_t aNIterations)
;

/*
 Computes magnetic field from vector potential.
 */
rssn_
rssn_Vector *rssn_magnetic_field_from_vector_potential(const rssn_Vector *aA,
                                                       const char *aX,
                                                       const char *aY,
                                                       const char *aZ)
;

/*
 Calculates mass-energy equivalence.
 */
rssn_
rssn_Expr *rssn_mass_energy_equivalence(const rssn_Expr *aMass)
;

rssn_
int32_t rssn_matrix_add(size_t aH1,
                        size_t aH2,
                        size_t *aResultH)
;

rssn_
rssn_Expr *rssn_matrix_add_handle(const rssn_Expr *aM1,
                                  const rssn_Expr *aM2)
;

rssn_
int32_t rssn_matrix_determinant(size_t aH,
                                size_t *aResultH)
;

rssn_
rssn_Expr *rssn_matrix_determinant_handle(const rssn_Expr *aMatrix)
;

rssn_
int32_t rssn_matrix_identity(size_t aSize,
                             size_t *aResultH)
;

rssn_
int32_t rssn_matrix_inverse(size_t aH,
                            size_t *aResultH)
;

rssn_
rssn_Expr *rssn_matrix_inverse_handle(const rssn_Expr *aMatrix)
;

rssn_
int32_t rssn_matrix_mul(size_t aH1,
                        size_t aH2,
                        size_t *aResultH)
;

rssn_
rssn_Expr *rssn_matrix_mul_handle(const rssn_Expr *aM1,
                                  const rssn_Expr *aM2)
;

rssn_
int32_t rssn_matrix_scalar_mul(size_t aScalarH,
                               size_t aMatrixH,
                               size_t *aResultH)
;

rssn_
rssn_Expr *rssn_matrix_solve_linear_system_handle(const rssn_Expr *aA,
                                                  const rssn_Expr *aB)
;

rssn_
int32_t rssn_matrix_sub(size_t aH1,
                        size_t aH2,
                        size_t *aResultH)
;

rssn_
int32_t rssn_matrix_transpose(size_t aH,
                              size_t *aResultH)
;

rssn_
rssn_Expr *rssn_matrix_transpose_handle(const rssn_Expr *aMatrix)
;

/*
 Computes the symbolic mean of a set of expressions.

 # Safety
 The caller must ensure `data` is a valid pointer to an array of `Expr` pointers of size `len`.
 */
rssn_
rssn_Expr *rssn_mean(const rssn_Expr *const *aData,
                     size_t aLen)
;

/*
 Computes geometric product (Handle)
 */
rssn_
rssn_Multivector *rssn_multivector_geometric_product_handle(const rssn_Multivector *aA,
                                                            const rssn_Multivector *aB)
;

/*
 Computes grade projection (Handle)
 */
rssn_
rssn_Multivector *rssn_multivector_grade_projection_handle(const rssn_Multivector *aMv,
                                                           uint32_t aGrade)
;

/*
 Computes inner product (Handle)
 */
rssn_
rssn_Multivector *rssn_multivector_inner_product_handle(const rssn_Multivector *aA,
                                                        const rssn_Multivector *aB)
;

/*
 Computes magnitude (Handle)
 */
rssn_
rssn_Expr *rssn_multivector_magnitude_handle(const rssn_Multivector *aMv)
;

/*
 Computes outer product (Handle)
 */
rssn_
rssn_Multivector *rssn_multivector_outer_product_handle(const rssn_Multivector *aA,
                                                        const rssn_Multivector *aB)
;

/*
 Computes reverse (Handle)
 */
rssn_
rssn_Multivector *rssn_multivector_reverse_handle(const rssn_Multivector *aMv)
;

/*
 Creates a new scalar multivector (Handle)
 */
rssn_
rssn_Multivector *rssn_multivector_scalar_handle(uint32_t aP,
                                                 uint32_t aQ,
                                                 uint32_t aR,
                                                 const rssn_Expr *aValue)
;

rssn_
rssn_Expr *rssn_mutual_information(const rssn_Expr *aJointProbs)
;

rssn_
rssn_Expr *rssn_nonlinear_regression(const rssn_Expr *const *aXData,
                                     const rssn_Expr *const *aYData,
                                     size_t aLen,
                                     const rssn_Expr *aModel,
                                     const char *const *aVars,
                                     size_t aVarsLen,
                                     const char *const *aParams,
                                     size_t aParamsLen)
;

rssn_
rssn_Expr *rssn_norm(const rssn_HilbertSpace *aSpace,
                     const rssn_Expr *aF)
;

/*
 Computes the greatest common divisor (GCD) of two numbers.

 Returns 0 on success, -1 on error.
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_
int32_t rssn_nt_gcd(uint64_t aA,
                    uint64_t aB,
                    uint64_t *aResult)
;

/*
 Checks if a number is prime using the Miller-Rabin test.

 Returns 0 on success, -1 on error.
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_
int32_t rssn_nt_is_prime(uint64_t aN,
                         bool *aResult)
;

/*
 Computes the modular multiplicative inverse.

 Returns 0 on success, -1 on error (e.g., if no inverse exists).
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_
int32_t rssn_nt_mod_inverse(int64_t aA,
                            int64_t aB,
                            int64_t *aResult)
;

/*
 Computes modular exponentiation (base^exp % modulus).

 Returns 0 on success, -1 on error.
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_
int32_t rssn_nt_mod_pow(uint64_t aBase,
                        uint64_t aExp,
                        uint64_t aModulus,
                        uint64_t *aResult)
;

/*
 Evaluates a B-spline curve at parameter t.
 */
rssn_
int32_t rssn_num_b_spline(const double *aControlPoints,
                          size_t aNPoints,
                          size_t aDim,
                          size_t aDegree,
                          const double *aKnots,
                          size_t aNKnots,
                          double aT,
                          double *aOutPoint)
;

rssn_
rssn_BincodeBuffer rssn_num_b_spline_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_b_spline_json(const char *aInputPtr)
;

/*
 Evaluates a Bézier curve at parameter t.
 control_points is a flattened array of size n_points * dim.
 */
rssn_
int32_t rssn_num_bezier_curve(const double *aControlPoints,
                              size_t aNPoints,
                              size_t aDim,
                              double aT,
                              double *aOutPoint)
;

rssn_
rssn_BincodeBuffer rssn_num_bezier_curve_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_bezier_curve_json(const char *aInputPtr)
;

/*
 Computes the numerical gradient of a function at a point.
 Returns a pointer to a Vec<f64> containing the gradient.
 */
rssn_
rssn_Vec<double> *rssn_num_calculus_gradient(const rssn_Expr *aF,
                                             const char *const *aVars,
                                             const double *aPoint,
                                             size_t aNVars)
;

/*
 Computes the numerical Hessian matrix of a scalar function at a point.
 Returns a pointer to a Matrix<f64>.
 */
rssn_
rssn_Matrix<double> *rssn_num_calculus_hessian(const rssn_Expr *aF,
                                               const char *const *aVars,
                                               const double *aPoint,
                                               size_t aNVars)
;

/*
 Computes the numerical Jacobian matrix of a vector-valued function at a point.
 Returns a pointer to a Matrix<f64>.
 */
rssn_
rssn_Matrix<double> *rssn_num_calculus_jacobian(const rssn_Expr *const *aFuncs,
                                                size_t aNFuncs,
                                                const char *const *aVars,
                                                const double *aPoint,
                                                size_t aNVars)
;

/*
 Computes the numerical partial derivative of a function with respect to a variable at a point.
 */
rssn_
int32_t rssn_num_calculus_partial_derivative(const rssn_Expr *aF,
                                             const char *aVar,
                                             double aX,
                                             double *aResult)
;

/*
 Returns kinematic viscosity of air at 20°C.
 */
rssn_
double rssn_num_cfd_air_kinematic_viscosity()
;

/*
 Returns Prandtl number of air.
 */
rssn_
double rssn_num_cfd_air_prandtl_number()
;

rssn_
char *rssn_num_cfd_air_properties_json(const char *aInput)
;

/*
 Calculates CFL number.
 */
rssn_
double rssn_num_cfd_cfl_number(double aVelocity,
                               double aDt,
                               double aDx)
;

rssn_
rssn_BincodeBuffer rssn_num_cfd_cfl_number_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_cfd_cfl_number_json(const char *aInput)
;

/*
 Checks CFL stability.
 */
rssn_
bool rssn_num_cfd_check_cfl_stability(double aVelocity,
                                      double aDt,
                                      double aDx,
                                      double aMaxCfl)
;

/*
 Calculates diffusion number.
 */
rssn_
double rssn_num_cfd_diffusion_number(double aAlpha,
                                     double aDt,
                                     double aDx)
;

rssn_
char *rssn_num_cfd_fluid_properties_json(const char *aInput)
;

/*
 Calculates Froude number.
 */
rssn_
double rssn_num_cfd_froude_number(double aVelocity,
                                  double aLength,
                                  double aGravity)
;

/*
 Calculates Mach number.
 */
rssn_
double rssn_num_cfd_mach_number(double aVelocity,
                                double aSpeedOfSound)
;

/*
 Calculates Reynolds number.
 */
rssn_
double rssn_num_cfd_reynolds_number(double aVelocity,
                                    double aLength,
                                    double aKinematicViscosity)
;

rssn_
rssn_BincodeBuffer rssn_num_cfd_reynolds_number_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_cfd_reynolds_number_json(const char *aInput)
;

rssn_
rssn_BincodeBuffer rssn_num_cfd_solve_advection_1d_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_cfd_solve_advection_1d_json(const char *aInput)
;

rssn_
char *rssn_num_cfd_solve_advection_diffusion_1d_json(const char *aInput)
;

rssn_
char *rssn_num_cfd_solve_burgers_1d_json(const char *aInput)
;

rssn_
char *rssn_num_cfd_solve_diffusion_1d_json(const char *aInput)
;

/*
 Returns kinematic viscosity of water at 20°C.
 */
rssn_
double rssn_num_cfd_water_kinematic_viscosity()
;

/*
 Returns Prandtl number of water.
 */
rssn_
double rssn_num_cfd_water_prandtl_number()
;

rssn_
char *rssn_num_cfd_water_properties_json(const char *aInput)
;

/*
 Computes the Bell number B(n).
 */
rssn_
int32_t rssn_num_comb_bell(uint64_t aN,
                           double *aResult)
;

rssn_
rssn_BincodeBuffer rssn_num_comb_bell_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_comb_bell_json(const char *aInputJson)
;

/*
 Computes the Catalan number C_n.
 */
rssn_
int32_t rssn_num_comb_catalan(uint64_t aN,
                              double *aResult)
;

rssn_
rssn_BincodeBuffer rssn_num_comb_catalan_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_comb_catalan_json(const char *aInputJson)
;

/*
 Computes the number of combinations C(n, k).
 */
rssn_
int32_t rssn_num_comb_combinations(uint64_t aN,
                                   uint64_t aK,
                                   double *aResult)
;

rssn_
rssn_BincodeBuffer rssn_num_comb_combinations_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_comb_combinations_json(const char *aInputJson)
;

/*
 Computes the factorial of n.
 */
rssn_
int32_t rssn_num_comb_factorial(uint64_t aN,
                                double *aResult)
;

rssn_
rssn_BincodeBuffer rssn_num_comb_factorial_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_comb_factorial_json(const char *aInputJson)
;

/*
 Computes the falling factorial.
 */
rssn_
int32_t rssn_num_comb_falling_factorial(double aX,
                                        uint64_t aN,
                                        double *aResult)
;

rssn_
rssn_BincodeBuffer rssn_num_comb_falling_factorial_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_comb_falling_factorial_json(const char *aInputJson)
;

/*
 Computes the number of permutations P(n, k).
 */
rssn_
int32_t rssn_num_comb_permutations(uint64_t aN,
                                   uint64_t aK,
                                   double *aResult)
;

rssn_
rssn_BincodeBuffer rssn_num_comb_permutations_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_comb_permutations_json(const char *aInputJson)
;

/*
 Computes the rising factorial.
 */
rssn_
int32_t rssn_num_comb_rising_factorial(double aX,
                                       uint64_t aN,
                                       double *aResult)
;

rssn_
rssn_BincodeBuffer rssn_num_comb_rising_factorial_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_comb_rising_factorial_json(const char *aInputJson)
;

/*
 Solves a linear recurrence relation numerically.
 */
rssn_
int32_t rssn_num_comb_solve_recurrence(const double *aCoeffs,
                                       size_t aCoeffsLen,
                                       const double *aInitialConditions,
                                       size_t aInitialLen,
                                       size_t aTargetN,
                                       double *aResult)
;

rssn_
rssn_BincodeBuffer rssn_num_comb_solve_recurrence_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_comb_solve_recurrence_json(const char *aInputJson)
;

/*
 Computes the Stirling numbers of the second kind S(n, k).
 */
rssn_
int32_t rssn_num_comb_stirling_second(uint64_t aN,
                                      uint64_t aK,
                                      double *aResult)
;

rssn_
rssn_BincodeBuffer rssn_num_comb_stirling_second_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_comb_stirling_second_json(const char *aInputJson)
;

/*
 Computes a contour integral of a symbolic expression.
 */
rssn_
int32_t rssn_num_complex_contour_integral(const rssn_Expr *aExprPtr,
                                          const char *aVarPtr,
                                          const double *aPathRe,
                                          const double *aPathIm,
                                          size_t aPathLen,
                                          double *aResRe,
                                          double *aResIm)
;

rssn_
rssn_BincodeBuffer rssn_num_complex_contour_integral_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_complex_contour_integral_json(const char *aInputJson)
;

/*
 Evaluates a symbolic expression to a complex number.
 */
rssn_
int32_t rssn_num_complex_eval(const rssn_Expr *aExprPtr,
                              const char *const *aVarNames,
                              const double *aVarRe,
                              const double *aVarIm,
                              size_t aNVars,
                              double *aResRe,
                              double *aResIm)
;

rssn_
rssn_BincodeBuffer rssn_num_complex_eval_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_complex_eval_json(const char *aInputJson)
;

/*
 Computes the residue of a symbolic expression.
 */
rssn_
int32_t rssn_num_complex_residue(const rssn_Expr *aExprPtr,
                                 const char *aVarPtr,
                                 double aZ0Re,
                                 double aZ0Im,
                                 double aRadius,
                                 size_t aNPoints,
                                 double *aResRe,
                                 double *aResIm)
;

/*
 Frees a pointer allocated by the coordinate transformation functions.
 */
rssn_
void rssn_num_coord_free(double *aPtr,
                         size_t aLen)
;

/*
 Computes the numerical Jacobian matrix.
 Returns a pointer to a flat array of doubles (row-major).
 */
rssn_
double *rssn_num_coord_jacobian(rssn_CoordinateSystem aFrom,
                                rssn_CoordinateSystem aTo,
                                const double *aAtPointPtr,
                                size_t aPointLen,
                                size_t *aOutRows,
                                size_t *aOutCols)
;

/*
 Transforms a point via Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_num_coord_transform_bincode(const uint8_t *aData,
                                                    size_t aLen)
;

/*
 Transforms a point using JSON.
 */
rssn_
char *rssn_num_coord_transform_json(const char *aJsonPtr)
;

/*
 Transforms a point from one coordinate system to another.

 # Arguments
 * `point_ptr` - Pointer to an array of doubles.
 * `point_len` - Number of elements in the point.
 * `from` - Source coordinate system.
 * `to` - Target coordinate system.
 * `out_len` - Pointer to store the number of elements in the resulting vector.

 # Returns
 A pointer to the transformed point (array of doubles), or null on error.
 */
rssn_
double *rssn_num_coord_transform_point(const double *aPointPtr,
                                       size_t aPointLen,
                                       rssn_CoordinateSystem aFrom,
                                       rssn_CoordinateSystem aTo,
                                       size_t *aOutLen)
;

/*
 Transforms a point from one coordinate system to another (pure numerical).
 */
rssn_
double *rssn_num_coord_transform_point_pure(const double *aPointPtr,
                                            size_t aPointLen,
                                            rssn_CoordinateSystem aFrom,
                                            rssn_CoordinateSystem aTo,
                                            size_t *aOutLen)
;

/*
 Transforms a point (pure numerical) via Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_num_coord_transform_pure_bincode(const uint8_t *aData,
                                                         size_t aLen)
;

/*
 Transforms a point (pure numerical) using JSON.
 */
rssn_
char *rssn_num_coord_transform_pure_json(const char *aJsonPtr)
;

/*
 Computes the Euler-Lagrange expression.
 Returns a pointer to a new Expr.
 */
rssn_
rssn_Expr *rssn_num_cov_euler_lagrange(const rssn_Expr *aLagrangian,
                                       const char *aTVar,
                                       const char *aPathVar,
                                       const char *aPathDotVar)
;

/*
 Evaluates the action for a given path.
 */
rssn_
int32_t rssn_num_cov_evaluate_action(const rssn_Expr *aLagrangian,
                                     const rssn_Expr *aPath,
                                     const char *aTVar,
                                     const char *aPathVar,
                                     const char *aPathDotVar,
                                     double aTStart,
                                     double aTEnd,
                                     double *aResult)
;

rssn_
rssn_BincodeBuffer rssn_num_cov_evaluate_action_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_cov_evaluate_action_json(const char *aInputJson)
;

/*
 Evaluates a cubic spline at a given x coordinate.
 */
rssn_
double rssn_num_cubic_spline_evaluate(const rssn_CubicSplineHandle *aHandle,
                                      double aX)
;

/*
 Frees a cubic spline handle.
 */
rssn_
void rssn_num_cubic_spline_free(rssn_CubicSplineHandle *aHandle)
;

/*
 Creates a cubic spline interpolator handle.
 */
rssn_
rssn_CubicSplineHandle *rssn_num_cubic_spline_interpolation(const double *aXCoords,
                                                            const double *aYCoords,
                                                            size_t aLen)
;

rssn_
rssn_BincodeBuffer rssn_num_cubic_spline_interpolation_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_cubic_spline_interpolation_json(const char *aInputPtr)
;

/*
 Computes the Christoffel symbols at a given point.
 Returns a flattened vector of size dim^3.
 */
rssn_
rssn_Vec<double> *rssn_num_dg_christoffel_symbols(rssn_CoordinateSystem aSystem,
                                                  const double *aPoint,
                                                  size_t aNVars)
;

rssn_
rssn_BincodeBuffer rssn_num_dg_christoffel_symbols_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_dg_christoffel_symbols_json(const char *aInputJson)
;

/*
 Computes the metric tensor at a given point.
 */
rssn_
rssn_Matrix<double> *rssn_num_dg_metric_tensor(rssn_CoordinateSystem aSystem,
                                               const double *aPoint,
                                               size_t aNVars)
;

rssn_
rssn_BincodeBuffer rssn_num_dg_metric_tensor_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_dg_metric_tensor_json(const char *aInputJson)
;

/*
 Computes the Ricci scalar at a given point.
 */
rssn_
int32_t rssn_num_dg_ricci_scalar(rssn_CoordinateSystem aSystem,
                                 const double *aPoint,
                                 size_t aNVars,
                                 double *aResult)
;

rssn_
rssn_BincodeBuffer rssn_num_dg_ricci_scalar_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_dg_ricci_scalar_json(const char *aInputJson)
;

/*
 Computes the Ricci tensor at a given point.
 */
rssn_
rssn_Matrix<double> *rssn_num_dg_ricci_tensor(rssn_CoordinateSystem aSystem,
                                              const double *aPoint,
                                              size_t aNVars)
;

rssn_
rssn_BincodeBuffer rssn_num_dg_ricci_tensor_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_dg_ricci_tensor_json(const char *aInputJson)
;

/*
 Compute error correction capability from minimum distance.
 */
rssn_
size_t rssn_num_error_correction_capability(size_t aMinDistance)
;

rssn_
rssn_BincodeBuffer rssn_num_error_correction_capability_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_error_correction_capability_json(const char *aInput)
;

/*
 Compute code rate.
 */
rssn_
double rssn_num_error_correction_code_rate(size_t aK,
                                           size_t aN)
;

rssn_
rssn_BincodeBuffer rssn_num_error_correction_code_rate_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_error_correction_code_rate_json(const char *aInput)
;

/*
 Compute CRC-16 checksum.

 # Safety
 `data_ptr` must be a valid pointer to `len` bytes.
 */
rssn_
uint16_t rssn_num_error_correction_crc16(const uint8_t *aDataPtr,
                                         size_t aLen)
;

rssn_
rssn_BincodeBuffer rssn_num_error_correction_crc16_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_error_correction_crc16_json(const char *aInput)
;

/*
 Compute CRC-32 checksum.

 # Safety
 `data_ptr` must be a valid pointer to `len` bytes.
 */
rssn_
uint32_t rssn_num_error_correction_crc32(const uint8_t *aDataPtr,
                                         size_t aLen)
;

rssn_
rssn_BincodeBuffer rssn_num_error_correction_crc32_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_error_correction_crc32_json(const char *aInput)
;

/*
 Verify CRC-32 checksum.

 # Safety
 `data_ptr` must be a valid pointer to `len` bytes.
 */
rssn_
int32_t rssn_num_error_correction_crc32_verify(const uint8_t *aDataPtr,
                                               size_t aLen,
                                               uint32_t aExpectedCrc)
;

rssn_
rssn_BincodeBuffer rssn_num_error_correction_crc32_verify_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_error_correction_crc32_verify_json(const char *aInput)
;

/*
 Compute CRC-8 checksum.

 # Safety
 `data_ptr` must be a valid pointer to `len` bytes.
 */
rssn_
uint8_t rssn_num_error_correction_crc8(const uint8_t *aDataPtr,
                                       size_t aLen)
;

rssn_
rssn_BincodeBuffer rssn_num_error_correction_crc8_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_error_correction_crc8_json(const char *aInput)
;

/*
 De-interleave data.

 # Safety
 `data_ptr` must be a valid pointer to `len` bytes.
 `out_ptr` must be a valid pointer to at least `len` bytes.
 */
rssn_
int32_t rssn_num_error_correction_deinterleave(const uint8_t *aDataPtr,
                                               size_t aLen,
                                               size_t aDepth,
                                               uint8_t *aOutPtr)
;

rssn_
rssn_BincodeBuffer rssn_num_error_correction_deinterleave_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_error_correction_deinterleave_json(const char *aInput)
;

/*
 Check if a Hamming codeword is valid.

 # Safety
 `codeword_ptr` must be a valid pointer to 7 bytes.
 */
rssn_
int32_t rssn_num_error_correction_hamming_check(const uint8_t *aCodewordPtr)
;

rssn_
rssn_BincodeBuffer rssn_num_error_correction_hamming_check_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_error_correction_hamming_check_json(const char *aInput)
;

/*
 Hamming decode a 7-bit codeword.

 # Safety
 `codeword_ptr` must be a valid pointer to 7 bytes.
 `out_ptr` must be a valid pointer to at least 4 bytes.
 `error_pos_ptr` must be a valid pointer.
 */
rssn_
int32_t rssn_num_error_correction_hamming_decode(const uint8_t *aCodewordPtr,
                                                 uint8_t *aOutPtr,
                                                 int32_t *aErrorPosPtr)
;

rssn_
rssn_BincodeBuffer rssn_num_error_correction_hamming_decode_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_error_correction_hamming_decode_json(const char *aInput)
;

/*
 Compute Hamming distance between two byte arrays.

 # Safety
 `a_ptr` and `b_ptr` must be valid pointers to `len` bytes each.
 */
rssn_
int32_t rssn_num_error_correction_hamming_distance(const uint8_t *aAPtr,
                                                   const uint8_t *aBPtr,
                                                   size_t aLen)
;

rssn_
rssn_BincodeBuffer rssn_num_error_correction_hamming_distance_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_error_correction_hamming_distance_json(const char *aInput)
;

/*
 Hamming encode a 4-bit data block.

 # Safety
 `data_ptr` must be a valid pointer to 4 bytes.
 `out_ptr` must be a valid pointer to at least 7 bytes.
 */
rssn_
int32_t rssn_num_error_correction_hamming_encode(const uint8_t *aDataPtr,
                                                 uint8_t *aOutPtr)
;

rssn_
rssn_BincodeBuffer rssn_num_error_correction_hamming_encode_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_error_correction_hamming_encode_json(const char *aInput)
;

/*
 Compute Hamming weight of a byte array.

 # Safety
 `data_ptr` must be a valid pointer to `len` bytes.
 */
rssn_
int32_t rssn_num_error_correction_hamming_weight(const uint8_t *aDataPtr,
                                                 size_t aLen)
;

rssn_
rssn_BincodeBuffer rssn_num_error_correction_hamming_weight_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_error_correction_hamming_weight_json(const char *aInput)
;

/*
 Interleave data.

 # Safety
 `data_ptr` must be a valid pointer to `len` bytes.
 `out_ptr` must be a valid pointer to at least `len` bytes.
 */
rssn_
int32_t rssn_num_error_correction_interleave(const uint8_t *aDataPtr,
                                             size_t aLen,
                                             size_t aDepth,
                                             uint8_t *aOutPtr)
;

rssn_
rssn_BincodeBuffer rssn_num_error_correction_interleave_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_error_correction_interleave_json(const char *aInput)
;

/*
 Check if a Reed-Solomon codeword is valid.

 # Safety
 `codeword_ptr` must be a valid pointer to `codeword_len` bytes.
 */
rssn_
int32_t rssn_num_error_correction_rs_check(const uint8_t *aCodewordPtr,
                                           size_t aCodewordLen,
                                           size_t aNParity)
;

rssn_
rssn_BincodeBuffer rssn_num_error_correction_rs_check_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_error_correction_rs_check_json(const char *aInput)
;

/*
 Reed-Solomon decode a codeword in place.

 # Safety
 `codeword_ptr` must be a valid pointer to `codeword_len` bytes.
 */
rssn_
int32_t rssn_num_error_correction_rs_decode(uint8_t *aCodewordPtr,
                                            size_t aCodewordLen,
                                            size_t aNParity)
;

rssn_
rssn_BincodeBuffer rssn_num_error_correction_rs_decode_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_error_correction_rs_decode_json(const char *aInput)
;

/*
 Reed-Solomon encode a message.

 # Safety
 `message_ptr` must be a valid pointer to `message_len` bytes.
 */
rssn_
int32_t rssn_num_error_correction_rs_encode(const uint8_t *aMessagePtr,
                                            size_t aMessageLen,
                                            size_t aNParity,
                                            uint8_t *aOutPtr,
                                            size_t *aOutLen)
;

rssn_
rssn_BincodeBuffer rssn_num_error_correction_rs_encode_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_error_correction_rs_encode_json(const char *aInput)
;

/*
 Compute error detection capability from minimum distance.
 */
rssn_
size_t rssn_num_error_detection_capability(size_t aMinDistance)
;

/*
 Evaluates an expression from a Bincode buffer.
 */
rssn_
rssn_BincodeBuffer rssn_num_eval_bincode(const uint8_t *aData,
                                         size_t aLen)
;

/*
 Evaluates an expression handle given variable values.

 # Arguments
 * `expr_ptr` - Pointer to the Expr object.
 * `vars` - Array of C-strings for variable names.
 * `vals` - Array of doubles for variable values.
 * `num_vars` - Number of variables.
 * `result` - Pointer to store the result.

 # Returns
 0 on success, -1 on failure.
 */
rssn_
int32_t rssn_num_eval_expr(const rssn_Expr *aExprPtr,
                           const char *const *aVars,
                           const double *aVals,
                           size_t aNumVars,
                           double *aResult)
;

/*
 Evaluates an expression from a JSON string.

 Input JSON format: `{"expr": <Expr>, "vars": {"x": 1.0, "y": 2.0}}`
 */
rssn_
char *rssn_num_eval_json(const char *aJsonPtr)
;

rssn_
rssn_BincodeBuffer rssn_num_fa_gram_schmidt_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_fa_gram_schmidt_json(const char *aInputJson)
;

/*
 Calculates the L-infinity norm.
 */
rssn_
double rssn_num_fa_infinity_norm(const double *aX,
                                 const double *aY,
                                 size_t aLen)
;

/*
 Calculates the inner product.
 */
rssn_
int32_t rssn_num_fa_inner_product(const double *aX1,
                                  const double *aY1,
                                  size_t aLen1,
                                  const double *aX2,
                                  const double *aY2,
                                  size_t aLen2,
                                  double *aResult)
;

rssn_
rssn_BincodeBuffer rssn_num_fa_inner_product_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_fa_inner_product_json(const char *aInputJson)
;

/*
 Calculates the L1 norm.
 */
rssn_
double rssn_num_fa_l1_norm(const double *aX,
                           const double *aY,
                           size_t aLen)
;

/*
 Calculates the L2 norm.
 */
rssn_
double rssn_num_fa_l2_norm(const double *aX,
                           const double *aY,
                           size_t aLen)
;

rssn_
rssn_BincodeBuffer rssn_num_fa_l2_norm_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_fa_l2_norm_json(const char *aInputJson)
;

rssn_
char *rssn_num_fea_beam_element_2d_stiffness_json(const char *aInput)
;

/*
 Computes bulk modulus from Young's modulus and Poisson's ratio.
 */
rssn_
double rssn_num_fea_bulk_modulus(double aYoungsModulus,
                                 double aPoissonsRatio)
;

rssn_
char *rssn_num_fea_create_rectangular_mesh_json(const char *aInput)
;

/*
 Computes and returns the stiffness value for a 1D linear element.
 k = E * A / L
 */
rssn_
double rssn_num_fea_linear_element_1d_stiffness(double aLength,
                                                double aYoungsModulus,
                                                double aArea)
;

rssn_
rssn_BincodeBuffer rssn_num_fea_linear_element_1d_stiffness_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_fea_linear_element_1d_stiffness_json(const char *aInput)
;

/*
 Creates aluminum material and returns shear modulus.
 */
rssn_
double rssn_num_fea_material_aluminum_shear_modulus()
;

/*
 Creates copper material and returns shear modulus.
 */
rssn_
double rssn_num_fea_material_copper_shear_modulus()
;

rssn_
char *rssn_num_fea_material_properties_json(const char *aInput)
;

rssn_
char *rssn_num_fea_material_steel_json(const char *aInput)
;

/*
 Creates steel material and returns shear modulus.
 */
rssn_
double rssn_num_fea_material_steel_shear_modulus()
;

/*
 Computes maximum shear stress from principal stresses.
 */
rssn_
double rssn_num_fea_max_shear_stress(double aSigma1,
                                     double aSigma2)
;

/*
 Computes principal stresses from stress components.
 Returns sigma1 in out_sigma1, sigma2 in out_sigma2, angle in out_angle.

 # Safety
 Pointers must be valid.
 */
rssn_
int32_t rssn_num_fea_principal_stresses(double aSx,
                                        double aSy,
                                        double aTxy,
                                        double *aOutSigma1,
                                        double *aOutSigma2,
                                        double *aOutAngle)
;

rssn_
rssn_BincodeBuffer rssn_num_fea_principal_stresses_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_fea_principal_stresses_json(const char *aInput)
;

rssn_
char *rssn_num_fea_safety_factor_json(const char *aInput)
;

/*
 Computes safety factor based on von Mises criterion.
 */
rssn_
double rssn_num_fea_safety_factor_von_mises(double aSx,
                                            double aSy,
                                            double aTxy,
                                            double aYieldStrength)
;

/*
 Computes shear modulus from Young's modulus and Poisson's ratio.
 */
rssn_
double rssn_num_fea_shear_modulus(double aYoungsModulus,
                                  double aPoissonsRatio)
;

/*
 Computes the conductivity value for a 1D thermal element.
 k = κ * A / L
 */
rssn_
double rssn_num_fea_thermal_element_1d_conductivity(double aLength,
                                                    double aConductivity,
                                                    double aArea)
;

rssn_
char *rssn_num_fea_thermal_element_1d_conductivity_json(const char *aInput)
;

/*
 Computes von Mises stress from plane stress components.
 */
rssn_
double rssn_num_fea_von_mises_stress(double aSx,
                                     double aSy,
                                     double aTxy)
;

rssn_
rssn_BincodeBuffer rssn_num_fea_von_mises_stress_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_fea_von_mises_stress_json(const char *aInput)
;

/*
 GF(2^8) addition.
 */
rssn_
uint8_t rssn_num_ff_gf256_add(uint8_t aA,
                              uint8_t aB)
;

/*
 GF(2^8) division.
 Returns 0 and sets error if divisor is 0.
 */
rssn_
uint8_t rssn_num_ff_gf256_div(uint8_t aA,
                              uint8_t aB)
;

/*
 GF(2^8) multiplication.
 */
rssn_
uint8_t rssn_num_ff_gf256_mul(uint8_t aA,
                              uint8_t aB)
;

/*
 GF(2^8) multiplication from JSON.
 */
rssn_
char *rssn_num_ff_gf256_mul_json(const char *aJsonPtr)
;

/*
 Performs addition in GF(p).
 */
rssn_
rssn_PrimeFieldElement *rssn_num_ff_pfe_add(const rssn_PrimeFieldElement *aA,
                                            const rssn_PrimeFieldElement *aB)
;

/*
 GF(p) addition via Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_num_ff_pfe_add_bincode(const uint8_t *aData,
                                               size_t aLen)
;

/*
 GF(p) addition from JSON.
 */
rssn_
char *rssn_num_ff_pfe_add_json(const char *aJsonPtr)
;

/*
 Frees a PrimeFieldElement.
 */
rssn_
void rssn_num_ff_pfe_free(rssn_PrimeFieldElement *aPfe)
;

/*
 Computes the inverse of a PrimeFieldElement.
 */
rssn_
rssn_PrimeFieldElement *rssn_num_ff_pfe_inverse(const rssn_PrimeFieldElement *aPfe)
;

/*
 Performs multiplication in GF(p).
 */
rssn_
rssn_PrimeFieldElement *rssn_num_ff_pfe_mul(const rssn_PrimeFieldElement *aA,
                                            const rssn_PrimeFieldElement *aB)
;

/*
 GF(p) multiplication via Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_num_ff_pfe_mul_bincode(const uint8_t *aData,
                                               size_t aLen)
;

/*
 GF(p) multiplication from JSON.
 */
rssn_
char *rssn_num_ff_pfe_mul_json(const char *aJsonPtr)
;

/*
 Creates a new PrimeFieldElement.
 */
rssn_
rssn_PrimeFieldElement *rssn_num_ff_pfe_new(uint64_t aValue,
                                            uint64_t aModulus)
;

/*
 Computes (pfe^exp) mod modulus.
 */
rssn_
rssn_PrimeFieldElement *rssn_num_ff_pfe_pow(const rssn_PrimeFieldElement *aPfe,
                                            uint64_t aExp)
;

rssn_
rssn_BincodeBuffer rssn_num_fft_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Fast Fourier Transform (FFT) in-place.

 # Arguments
 * `real` - Pointer to the real parts of the input/output sequence.
 * `imag` - Pointer to the imaginary parts of the input/output sequence.
 * `len` - Length of the sequence. Must be a power of two for optimal performance.

 # Returns
 0 on success, -1 on error.
 */
rssn_
int32_t rssn_num_fft_inplace(double *aReal,
                             double *aImag,
                             size_t aLen)
;

rssn_
char *rssn_num_fft_json(const char *aInputJson)
;

rssn_
char *rssn_num_fractal_bifurcation_json(const char *aInput)
;

/*
 Computes box-counting dimension.

 # Safety
 `points_ptr` must be a valid pointer to `num_points * 2` f64 values.
 */
rssn_
double rssn_num_fractal_box_counting_dim(const double *aPointsPtr,
                                         size_t aNumPoints,
                                         size_t aNumScales)
;

rssn_
rssn_BincodeBuffer rssn_num_fractal_box_counting_dim_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_fractal_box_counting_dim_json(const char *aInput)
;

/*
 Computes correlation dimension.

 # Safety
 `points_ptr` must be a valid pointer to `num_points * 2` f64 values.
 */
rssn_
double rssn_num_fractal_correlation_dim(const double *aPointsPtr,
                                        size_t aNumPoints,
                                        size_t aNumRadii)
;

rssn_
rssn_BincodeBuffer rssn_num_fractal_correlation_dim_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_fractal_correlation_dim_json(const char *aInput)
;

/*
 Generates Henon map points.

 # Safety
 `out_ptr` must be a valid pointer to at least `num_steps * 2` f64 values.
 */
rssn_
int32_t rssn_num_fractal_henon_map(double aX0,
                                   double aY0,
                                   size_t aNumSteps,
                                   double aA,
                                   double aB,
                                   double *aOutPtr)
;

rssn_
rssn_BincodeBuffer rssn_num_fractal_henon_map_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_fractal_henon_map_json(const char *aInput)
;

/*
 Computes the escape time for a single point in a Julia set.
 */
rssn_
uint32_t rssn_num_fractal_julia_escape_time(double aZReal,
                                            double aZImag,
                                            double aCReal,
                                            double aCImag,
                                            uint32_t aMaxIter)
;

rssn_
char *rssn_num_fractal_julia_escape_time_json(const char *aInput)
;

rssn_
rssn_BincodeBuffer rssn_num_fractal_julia_set_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_fractal_julia_set_json(const char *aInput)
;

/*
 Iterates the logistic map.

 # Safety
 `out_ptr` must be a valid pointer to at least `num_steps + 1` f64 values.
 */
rssn_
int32_t rssn_num_fractal_logistic_map(double aX0,
                                      double aR,
                                      size_t aNumSteps,
                                      double *aOutPtr)
;

rssn_
rssn_BincodeBuffer rssn_num_fractal_logistic_map_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_fractal_logistic_map_json(const char *aInput)
;

/*
 Generates Lorenz attractor points.

 # Safety
 `out_ptr` must be a valid pointer to at least `num_steps * 3` f64 values.
 */
rssn_
int32_t rssn_num_fractal_lorenz_attractor(double aX0,
                                          double aY0,
                                          double aZ0,
                                          double aDt,
                                          size_t aNumSteps,
                                          double *aOutPtr)
;

rssn_
rssn_BincodeBuffer rssn_num_fractal_lorenz_attractor_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_fractal_lorenz_attractor_custom_json(const char *aInput)
;

rssn_
char *rssn_num_fractal_lorenz_attractor_json(const char *aInput)
;

/*
 Computes the Lyapunov exponent for the logistic map.
 */
rssn_
double rssn_num_fractal_lyapunov_logistic(double aR,
                                          double aX0,
                                          size_t aTransient,
                                          size_t aNumIterations)
;

rssn_
rssn_BincodeBuffer rssn_num_fractal_lyapunov_logistic_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_fractal_lyapunov_logistic_json(const char *aInput)
;

/*
 Computes the Lyapunov exponent for the Lorenz system.
 */
rssn_
double rssn_num_fractal_lyapunov_lorenz(double aX0,
                                        double aY0,
                                        double aZ0,
                                        double aDt,
                                        size_t aNumSteps,
                                        double aSigma,
                                        double aRho,
                                        double aBeta)
;

rssn_
char *rssn_num_fractal_lyapunov_lorenz_json(const char *aInput)
;

/*
 Computes the escape time for a single point in the Mandelbrot set.
 */
rssn_
uint32_t rssn_num_fractal_mandelbrot_escape_time(double aCReal,
                                                 double aCImag,
                                                 uint32_t aMaxIter)
;

rssn_
rssn_BincodeBuffer rssn_num_fractal_mandelbrot_escape_time_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_fractal_mandelbrot_escape_time_json(const char *aInput)
;

rssn_
rssn_BincodeBuffer rssn_num_fractal_mandelbrot_set_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_fractal_mandelbrot_set_json(const char *aInput)
;

rssn_
char *rssn_num_fractal_rossler_attractor_json(const char *aInput)
;

rssn_
char *rssn_num_fractal_tinkerbell_map_json(const char *aInput)
;

/*
 Performs multivector addition.
 */
rssn_
rssn_Multivector3D *rssn_num_ga_add(const rssn_Multivector3D *aMv1,
                                    const rssn_Multivector3D *aMv2)
;

/*
 Bincode FFI for ga_add.
 */
rssn_
rssn_BincodeBuffer rssn_num_ga_add_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for ga_add.
 */
rssn_
char *rssn_num_ga_add_json(const char *aJsonPtr)
;

/*
 Creates a new Multivector3D.
 */
rssn_
rssn_Multivector3D *rssn_num_ga_create(double aS,
                                       double aV1,
                                       double aV2,
                                       double aV3,
                                       double aB12,
                                       double aB23,
                                       double aB31,
                                       double aPss)
;

/*
 Performs inner product.
 */
rssn_
rssn_Multivector3D *rssn_num_ga_dot(const rssn_Multivector3D *aMv1,
                                    const rssn_Multivector3D *aMv2)
;

/*
 Bincode FFI for ga_dot.
 */
rssn_
rssn_BincodeBuffer rssn_num_ga_dot_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for ga_dot.
 */
rssn_
char *rssn_num_ga_dot_json(const char *aJsonPtr)
;

/*
 Frees a Multivector3D.
 */
rssn_
void rssn_num_ga_free(rssn_Multivector3D *aMv)
;

/*
 Gets components of a Multivector3D.
 */
rssn_
int32_t rssn_num_ga_get_components(const rssn_Multivector3D *aMv,
                                   double *aS,
                                   double *aV1,
                                   double *aV2,
                                   double *aV3,
                                   double *aB12,
                                   double *aB23,
                                   double *aB31,
                                   double *aPss)
;

/*
 Returns the inverse of a Multivector3D.
 */
rssn_
rssn_Multivector3D *rssn_num_ga_inv(const rssn_Multivector3D *aMv)
;

/*
 Bincode FFI for ga_inv.
 */
rssn_
rssn_BincodeBuffer rssn_num_ga_inv_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for ga_inv.
 */
rssn_
char *rssn_num_ga_inv_json(const char *aJsonPtr)
;

/*
 Performs geometric product.
 */
rssn_
rssn_Multivector3D *rssn_num_ga_mul(const rssn_Multivector3D *aMv1,
                                    const rssn_Multivector3D *aMv2)
;

/*
 Bincode FFI for ga_mul.
 */
rssn_
rssn_BincodeBuffer rssn_num_ga_mul_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for ga_mul.
 */
rssn_
char *rssn_num_ga_mul_json(const char *aJsonPtr)
;

/*
 Returns the norm of a Multivector3D.
 */
rssn_
double rssn_num_ga_norm(const rssn_Multivector3D *aMv)
;

/*
 Bincode FFI for ga_norm.
 */
rssn_
rssn_BincodeBuffer rssn_num_ga_norm_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for ga_norm.
 */
rssn_
char *rssn_num_ga_norm_json(const char *aJsonPtr)
;

/*
 Returns the reverse of a Multivector3D.
 */
rssn_
rssn_Multivector3D *rssn_num_ga_reverse(const rssn_Multivector3D *aMv)
;

/*
 Bincode FFI for ga_reverse.
 */
rssn_
rssn_BincodeBuffer rssn_num_ga_reverse_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for ga_reverse.
 */
rssn_
char *rssn_num_ga_reverse_json(const char *aJsonPtr)
;

/*
 Performs multivector subtraction.
 */
rssn_
rssn_Multivector3D *rssn_num_ga_sub(const rssn_Multivector3D *aMv1,
                                    const rssn_Multivector3D *aMv2)
;

/*
 Bincode FFI for ga_sub.
 */
rssn_
rssn_BincodeBuffer rssn_num_ga_sub_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for ga_sub.
 */
rssn_
char *rssn_num_ga_sub_json(const char *aJsonPtr)
;

/*
 Performs outer product.
 */
rssn_
rssn_Multivector3D *rssn_num_ga_wedge(const rssn_Multivector3D *aMv1,
                                      const rssn_Multivector3D *aMv2)
;

/*
 Bincode FFI for ga_wedge.
 */
rssn_
rssn_BincodeBuffer rssn_num_ga_wedge_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for ga_wedge.
 */
rssn_
char *rssn_num_ga_wedge_json(const char *aJsonPtr)
;

/*
 Adds a directed edge.
 */
rssn_
void rssn_num_graph_add_edge(rssn_Graph *aGraph,
                             size_t aU,
                             size_t aV,
                             double aWeight)
;

/*
 Computes BFS.
 */
rssn_
int32_t rssn_num_graph_bfs(rssn_Graph *aGraph,
                           size_t aStartNode,
                           size_t *aDist)
;

rssn_
rssn_BincodeBuffer rssn_num_graph_bfs_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_graph_bfs_json(const char *aInputJson)
;

/*
 Computes Connected Components.
 Result array `components` must be allocated by caller with size `num_nodes`.
 */
rssn_
int32_t rssn_num_graph_connected_components(rssn_Graph *aGraph,
                                            size_t *aComponents)
;

rssn_
rssn_BincodeBuffer rssn_num_graph_connected_components_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_graph_connected_components_json(const char *aInputJson)
;

/*
 Creates a new graph.
 */
rssn_
rssn_Graph *rssn_num_graph_create(size_t aNumNodes)
;

/*
 Computes Dijkstra's algorithm.
 */
rssn_
int32_t rssn_num_graph_dijkstra(rssn_Graph *aGraph,
                                size_t aStartNode,
                                double *aDist,
                                ptrdiff_t *aPrev)
;

rssn_
rssn_BincodeBuffer rssn_num_graph_dijkstra_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_graph_dijkstra_json(const char *aInputJson)
;

/*
 Computes Floyd-Warshall.
 */
rssn_
int32_t rssn_num_graph_floyd_warshall(rssn_Graph *aGraph,
                                      double *aDistMatrix)
;

rssn_
rssn_BincodeBuffer rssn_num_graph_floyd_warshall_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_graph_floyd_warshall_json(const char *aInputJson)
;

/*
 Frees a graph.
 */
rssn_
void rssn_num_graph_free(rssn_Graph *aGraph)
;

/*
 Computes Minimum Spanning Tree (MST).
 Returns a new Graph handle.
 */
rssn_
rssn_Graph *rssn_num_graph_minimum_spanning_tree(rssn_Graph *aGraph)
;

rssn_
rssn_BincodeBuffer rssn_num_graph_minimum_spanning_tree_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_graph_minimum_spanning_tree_json(const char *aInputJson)
;

/*
 Computes PageRank.
 */
rssn_
int32_t rssn_num_graph_page_rank(rssn_Graph *aGraph,
                                 double aDampingFactor,
                                 double aTolerance,
                                 size_t aMaxIter,
                                 double *aScores)
;

rssn_
rssn_BincodeBuffer rssn_num_graph_page_rank_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_graph_page_rank_json(const char *aInputJson)
;

/*
 Computes the angle between two 3D vectors in radians.
 */
rssn_
double rssn_num_graphics_angle_between(double aX1,
                                       double aY1,
                                       double aZ1,
                                       double aX2,
                                       double aY2,
                                       double aZ2)
;

rssn_
char *rssn_num_graphics_angle_between_json(const char *aInput)
;

/*
 Bezier cubic curve evaluation.

 # Safety
 Pointers must be valid.
 */
rssn_
int32_t rssn_num_graphics_bezier_cubic(double aP0x,
                                       double aP0y,
                                       double aP0z,
                                       double aP1x,
                                       double aP1y,
                                       double aP1z,
                                       double aP2x,
                                       double aP2y,
                                       double aP2z,
                                       double aP3x,
                                       double aP3y,
                                       double aP3z,
                                       double aT,
                                       double *aOutX,
                                       double *aOutY,
                                       double *aOutZ)
;

rssn_
char *rssn_num_graphics_bezier_cubic_json(const char *aInput)
;

/*
 Computes the cross product of two 3D vectors.
 Result is stored in out_x, out_y, out_z.

 # Safety
 Pointers must be valid.
 */
rssn_
int32_t rssn_num_graphics_cross_product(double aX1,
                                        double aY1,
                                        double aZ1,
                                        double aX2,
                                        double aY2,
                                        double aZ2,
                                        double *aOutX,
                                        double *aOutY,
                                        double *aOutZ)
;

rssn_
rssn_BincodeBuffer rssn_num_graphics_cross_product_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_graphics_cross_product_json(const char *aInput)
;

/*
 Converts degrees to radians.
 */
rssn_
double rssn_num_graphics_degrees_to_radians(double aDegrees)
;

/*
 Computes the dot product of two 3D vectors.
 */
rssn_
double rssn_num_graphics_dot_product(double aX1,
                                     double aY1,
                                     double aZ1,
                                     double aX2,
                                     double aY2,
                                     double aZ2)
;

rssn_
rssn_BincodeBuffer rssn_num_graphics_dot_product_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_graphics_dot_product_json(const char *aInput)
;

rssn_
char *rssn_num_graphics_look_at_matrix_json(const char *aInput)
;

/*
 Computes the magnitude of a 3D vector.
 */
rssn_
double rssn_num_graphics_magnitude(double aX,
                                   double aY,
                                   double aZ)
;

rssn_
char *rssn_num_graphics_magnitude_json(const char *aInput)
;

/*
 Normalizes a 3D vector.

 # Safety
 Pointers must be valid.
 */
rssn_
int32_t rssn_num_graphics_normalize(double aX,
                                    double aY,
                                    double aZ,
                                    double *aOutX,
                                    double *aOutY,
                                    double *aOutZ)
;

rssn_
rssn_BincodeBuffer rssn_num_graphics_normalize_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_graphics_normalize_json(const char *aInput)
;

rssn_
char *rssn_num_graphics_perspective_matrix_json(const char *aInput)
;

/*
 Quaternion multiply.

 # Safety
 Pointers must be valid.
 */
rssn_
int32_t rssn_num_graphics_quaternion_multiply(double aW1,
                                              double aX1,
                                              double aY1,
                                              double aZ1,
                                              double aW2,
                                              double aX2,
                                              double aY2,
                                              double aZ2,
                                              double *aOutW,
                                              double *aOutX,
                                              double *aOutY,
                                              double *aOutZ)
;

rssn_
rssn_BincodeBuffer rssn_num_graphics_quaternion_multiply_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_graphics_quaternion_multiply_json(const char *aInput)
;

rssn_
char *rssn_num_graphics_quaternion_slerp_json(const char *aInput)
;

/*
 Converts radians to degrees.
 */
rssn_
double rssn_num_graphics_radians_to_degrees(double aRadians)
;

/*
 Ray-sphere intersection.
 Returns t value or -1 if no intersection.
 */
rssn_
double rssn_num_graphics_ray_sphere_intersection(double aRayOx,
                                                 double aRayOy,
                                                 double aRayOz,
                                                 double aRayDx,
                                                 double aRayDy,
                                                 double aRayDz,
                                                 double aSphereCx,
                                                 double aSphereCy,
                                                 double aSphereCz,
                                                 double aSphereR)
;

rssn_
char *rssn_num_graphics_ray_sphere_intersection_json(const char *aInput)
;

/*
 Computes the reflection vector.

 # Safety
 Pointers must be valid.
 */
rssn_
int32_t rssn_num_graphics_reflect(double aIx,
                                  double aIy,
                                  double aIz,
                                  double aNx,
                                  double aNy,
                                  double aNz,
                                  double *aOutX,
                                  double *aOutY,
                                  double *aOutZ)
;

rssn_
char *rssn_num_graphics_reflect_json(const char *aInput)
;

rssn_
char *rssn_num_graphics_rotation_matrix_axis_json(const char *aInput)
;

/*
 Rotation matrix around X axis.
 Output: 16 f64 values in row-major order.

 # Safety
 `out_ptr` must point to at least 16 f64 values.
 */
rssn_
int32_t rssn_num_graphics_rotation_matrix_x(double aAngleRad,
                                            double *aOutPtr)
;

rssn_
rssn_BincodeBuffer rssn_num_graphics_rotation_matrix_x_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_graphics_rotation_matrix_x_json(const char *aInput)
;

rssn_
char *rssn_num_graphics_rotation_matrix_y_json(const char *aInput)
;

rssn_
char *rssn_num_graphics_rotation_matrix_z_json(const char *aInput)
;

rssn_
char *rssn_num_graphics_scaling_matrix_json(const char *aInput)
;

rssn_
rssn_BincodeBuffer rssn_num_graphics_translation_matrix_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_graphics_translation_matrix_json(const char *aInput)
;

rssn_
rssn_BincodeBuffer rssn_num_ifft_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 Computes the Inverse Fast Fourier Transform (IFFT) in-place.
 */
rssn_
int32_t rssn_num_ifft_inplace(double *aReal,
                              double *aImag,
                              size_t aLen)
;

rssn_
char *rssn_num_ifft_json(const char *aInputJson)
;

/*
 Computes Lagrange interpolation and returns a Polynomial pointer.
 */
rssn_
rssn_Polynomial *rssn_num_lagrange_interpolation(const double *aXCoords,
                                                 const double *aYCoords,
                                                 size_t aLen)
;

rssn_
rssn_BincodeBuffer rssn_num_lagrange_interpolation_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_lagrange_interpolation_json(const char *aInputPtr)
;

rssn_
rssn_RssnMatrixHandle *rssn_num_matrix_add(const rssn_RssnMatrixHandle *aM1,
                                           const rssn_RssnMatrixHandle *aM2)
;

/*
 Matrix addition via Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_num_matrix_add_bincode(const uint8_t *aData,
                                               size_t aLen)
;

/*
 Evaluates a matrix addition from JSON.
 */
rssn_
char *rssn_num_matrix_add_json(const char *aJsonPtr)
;

/*
 Creates a new f64 matrix from dimensions and a raw data array.

 # Arguments
 * `rows` - Number of rows.
 * `cols` - Number of columns.
 * `data` - Pointer to an array of doubles in row-major order.

 # Returns
 A raw pointer to the Matrix object, or null on error.
 */
rssn_
rssn_RssnMatrixHandle *rssn_num_matrix_create(size_t aRows,
                                              size_t aCols,
                                              const double *aData)
;

/*
 Decomposes a matrix via Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_num_matrix_decompose_bincode(const uint8_t *aData,
                                                     size_t aLen)
;

/*
 Computes Cholesky decomposition: A = L * L^T.
 */
rssn_
int32_t rssn_num_matrix_decompose_cholesky(const rssn_RssnMatrixHandle *aMatrix,
                                           rssn_RssnMatrixHandle **aOutL)
;

/*
 Computes Symmetric Eigendecomposition: A = V * D * V^T.
 */
rssn_
int32_t rssn_num_matrix_decompose_eigen_symmetric(const rssn_RssnMatrixHandle *aMatrix,
                                                  rssn_RssnMatrixHandle **aOutValues,
                                                  rssn_RssnMatrixHandle **aOutVectors)
;

/*
 Decomposes a matrix from JSON.
 */
rssn_
char *rssn_num_matrix_decompose_json(const char *aJsonPtr)
;

/*
 Computes SVD decomposition: A = U * S * V^T.
 Returns 0 on success, -1 on error.
 */
rssn_
int32_t rssn_num_matrix_decompose_svd(const rssn_RssnMatrixHandle *aMatrix,
                                      rssn_RssnMatrixHandle **aOutU,
                                      rssn_RssnMatrixHandle **aOutS,
                                      rssn_RssnMatrixHandle **aOutV)
;

/*
 Computes determinant from JSON.
 */
rssn_
char *rssn_num_matrix_det_json(const char *aJsonPtr)
;

rssn_
int32_t rssn_num_matrix_determinant(const rssn_RssnMatrixHandle *aMatrix,
                                    double *aResult)
;

rssn_
void rssn_num_matrix_free(rssn_RssnMatrixHandle *aMatrix)
;

/*
 Returns the Frobenius norm.
 */
rssn_
double rssn_num_matrix_frobenius_norm(const rssn_RssnMatrixHandle *aMatrix)
;

rssn_
size_t rssn_num_matrix_get_cols(const rssn_RssnMatrixHandle *aMatrix)
;

rssn_
int32_t rssn_num_matrix_get_data(const rssn_RssnMatrixHandle *aMatrix,
                                 double *aBuffer)
;

rssn_
size_t rssn_num_matrix_get_rows(const rssn_RssnMatrixHandle *aMatrix)
;

/*
 Creates an identity matrix.
 */
rssn_
rssn_RssnMatrixHandle *rssn_num_matrix_identity(size_t aSize)
;

rssn_
rssn_RssnMatrixHandle *rssn_num_matrix_inverse(const rssn_RssnMatrixHandle *aMatrix)
;

/*
 Checks if it's identity.
 */
rssn_
int32_t rssn_num_matrix_is_identity(const rssn_RssnMatrixHandle *aMatrix,
                                    double aEpsilon)
;

/*
 Checks if it's orthogonal.
 */
rssn_
int32_t rssn_num_matrix_is_orthogonal(const rssn_RssnMatrixHandle *aMatrix,
                                      double aEpsilon)
;

rssn_
rssn_RssnMatrixHandle *rssn_num_matrix_mul(const rssn_RssnMatrixHandle *aM1,
                                           const rssn_RssnMatrixHandle *aM2)
;

/*
 Matrix multiplication via Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_num_matrix_mul_bincode(const uint8_t *aData,
                                               size_t aLen)
;

/*
 Evaluates a matrix multiplication from JSON.
 */
rssn_
char *rssn_num_matrix_mul_json(const char *aJsonPtr)
;

/*
 Returns the rank.
 */
rssn_
int32_t rssn_num_matrix_rank(const rssn_RssnMatrixHandle *aMatrix,
                             size_t *aOutRank)
;

/*
 Sets the backend for the matrix.
 0: Native, 1: Faer
 */
rssn_
int32_t rssn_num_matrix_set_backend(rssn_RssnMatrixHandle *aMatrix,
                                    int32_t aBackendId)
;

/*
 Sets backend for a matrix via Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_num_matrix_set_backend_bincode(const uint8_t *aData,
                                                       size_t aLen)
;

/*
 Sets backend for a matrix (returns new matrix with backend set) from JSON.
 */
rssn_
char *rssn_num_matrix_set_backend_json(const char *aJsonPtr)
;

/*
 Returns the trace.
 */
rssn_
int32_t rssn_num_matrix_trace(const rssn_RssnMatrixHandle *aMatrix,
                              double *aOutTrace)
;

rssn_
rssn_RssnMatrixHandle *rssn_num_matrix_transpose(const rssn_RssnMatrixHandle *aMatrix)
;

/*
 Applies periodic boundary condition to a 1D position.
 */
rssn_
double rssn_num_md_apply_pbc_1d(double aX,
                                double aBoxLength)
;

rssn_
rssn_BincodeBuffer rssn_num_md_apply_pbc_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_md_apply_pbc_json(const char *aInput)
;

/*
 Returns Avogadro's number.
 */
rssn_
double rssn_num_md_avogadro_number()
;

/*
 Returns Boltzmann constant in SI units.
 */
rssn_
double rssn_num_md_boltzmann_constant_si()
;

/*
 Calculates CFL number for MD stability.
 */
rssn_
double rssn_num_md_cfl_check(double aVelocity,
                             double aDt,
                             double aSigma)
;

rssn_
char *rssn_num_md_create_cubic_lattice_json(const char *aInput)
;

rssn_
char *rssn_num_md_harmonic_json(const char *aInput)
;

rssn_
rssn_BincodeBuffer rssn_num_md_lennard_jones_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_md_lennard_jones_json(const char *aInput)
;

/*
 Applies minimum image convention to a 1D distance.
 */
rssn_
double rssn_num_md_minimum_image_1d(double aDx,
                                    double aBoxLength)
;

rssn_
char *rssn_num_md_minimum_image_json(const char *aInput)
;

rssn_
char *rssn_num_md_morse_json(const char *aInput)
;

rssn_
char *rssn_num_md_system_properties_json(const char *aInput)
;

/*
 Returns temperature unit for argon in reduced units.
 */
rssn_
double rssn_num_md_temperature_unit_argon()
;

/*
 Computes the k-th branch of the complex arccosine.
 */
rssn_
void rssn_num_mv_complex_arccos_k(double aRe,
                                  double aIm,
                                  int32_t aK,
                                  int32_t aS,
                                  double *aResRe,
                                  double *aResIm)
;

/*
 Computes the k-th branch of the complex arcsine.
 */
rssn_
void rssn_num_mv_complex_arcsin_k(double aRe,
                                  double aIm,
                                  int32_t aK,
                                  double *aResRe,
                                  double *aResIm)
;

/*
 Computes the k-th branch of the complex arctangent.
 */
rssn_
void rssn_num_mv_complex_arctan_k(double aRe,
                                  double aIm,
                                  int32_t aK,
                                  double *aResRe,
                                  double *aResIm)
;

/*
 Computes the k-th branch of the complex logarithm.
 */
rssn_
void rssn_num_mv_complex_log_k(double aRe,
                               double aIm,
                               int32_t aK,
                               double *aResRe,
                               double *aResIm)
;

rssn_
rssn_BincodeBuffer rssn_num_mv_complex_log_k_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_mv_complex_log_k_json(const char *aJson)
;

/*
 Computes the k-th branch of the complex n-th root.
 */
rssn_
void rssn_num_mv_complex_nth_root_k(double aRe,
                                    double aIm,
                                    uint32_t aN,
                                    int32_t aK,
                                    double *aResRe,
                                    double *aResIm)
;

/*
 Computes the k-th branch of the complex power z^w.
 */
rssn_
void rssn_num_mv_complex_pow_k(double aZRe,
                               double aZIm,
                               double aWRe,
                               double aWIm,
                               int32_t aK,
                               double *aResRe,
                               double *aResIm)
;

rssn_
rssn_BincodeBuffer rssn_num_mv_complex_pow_k_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_mv_complex_pow_k_json(const char *aJson)
;

/*
 Computes the k-th branch of the complex square root.
 */
rssn_
void rssn_num_mv_complex_sqrt_k(double aRe,
                                double aIm,
                                int32_t aK,
                                double *aResRe,
                                double *aResIm)
;

rssn_
rssn_BincodeBuffer rssn_num_mv_complex_sqrt_k_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_mv_complex_sqrt_k_json(const char *aJson)
;

/*
 Finds a root of a complex function using Newton's method.
 */
rssn_
int32_t rssn_num_mv_newton_method_complex(const rssn_Expr *aFPtr,
                                          const rssn_Expr *aFPrimePtr,
                                          double aStartRe,
                                          double aStartIm,
                                          double aTolerance,
                                          size_t aMaxIter,
                                          double *aResRe,
                                          double *aResIm)
;

rssn_
rssn_BincodeBuffer rssn_num_mv_newton_method_complex_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_mv_newton_method_complex_json(const char *aInputJson)
;

/*
 Returns the number of prime factors and writes them to out_factors.
 out_factors must be large enough.
 */
rssn_
size_t rssn_num_nt_factorize(uint64_t aN,
                             uint64_t *aOutFactors)
;

/*
 Factorizes a number via Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_num_nt_factorize_bincode(const uint8_t *aData,
                                                 size_t aLen)
;

/*
 Factorizes a number from JSON.
 */
rssn_
char *rssn_num_nt_factorize_json(const char *aJsonPtr)
;

/*
 Computes the greatest common divisor (GCD).
 */
rssn_
uint64_t rssn_num_nt_gcd(uint64_t aA,
                         uint64_t aB)
;

/*
 Tests if a number is prime using Miller-Rabin.
 */
rssn_
bool rssn_num_nt_is_prime(uint64_t aN)
;

/*
 Computes the least common multiple (LCM).
 */
rssn_
uint64_t rssn_num_nt_lcm(uint64_t aA,
                         uint64_t aB)
;

/*
 Finds the modular multiplicative inverse.
 Returns 0 if no inverse exists (modulus cannot be 0).
 */
rssn_
int64_t rssn_num_nt_mod_inverse(int64_t aA,
                                int64_t aM)
;

/*
 Modular inverse from JSON.
 */
rssn_
char *rssn_num_nt_mod_inverse_json(const char *aJsonPtr)
;

/*
 Computes (base^exp) % modulus.
 */
rssn_
uint64_t rssn_num_nt_mod_pow(rssn_u128 aBase,
                             uint64_t aExp,
                             uint64_t aModulus)
;

/*
 Computes Euler's totient function φ(n).
 */
rssn_
uint64_t rssn_num_nt_phi(uint64_t aN)
;

/*
 Solves a system of ODEs and returns the results as a Matrix handle.
 */
rssn_
rssn_Matrix<double> *rssn_num_ode_solve(const rssn_Expr *const *aFuncs,
                                        size_t aNFuncs,
                                        const double *aY0,
                                        size_t aNY0,
                                        double aXStart,
                                        double aXEnd,
                                        size_t aNumSteps,
                                        int32_t aMethod)
;

rssn_
rssn_BincodeBuffer rssn_num_ode_solve_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_ode_solve_json(const char *aInputJson)
;

rssn_
double rssn_num_physics_blackbody_power(double aArea,
                                        double aTemperature)
;

rssn_
char *rssn_num_physics_blackbody_power_json(const char *aInput)
;

rssn_
double rssn_num_physics_boltzmann_constant()
;

rssn_
double rssn_num_physics_compton_wavelength(double aMass)
;

rssn_
double rssn_num_physics_coulomb_force(double aQ1,
                                      double aQ2,
                                      double aR)
;

rssn_
rssn_BincodeBuffer rssn_num_physics_coulomb_force_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_physics_coulomb_force_json(const char *aInput)
;

rssn_
double rssn_num_physics_cyclotron_radius(double aMass,
                                         double aVelocity,
                                         double aCharge,
                                         double aBField)
;

rssn_
double rssn_num_physics_damped_harmonic_oscillator(double aAmplitude,
                                                   double aOmega0,
                                                   double aGamma,
                                                   double aPhase,
                                                   double aTime)
;

rssn_
char *rssn_num_physics_damped_harmonic_oscillator_json(const char *aInput)
;

rssn_
double rssn_num_physics_de_broglie_wavelength(double aMomentum)
;

rssn_
char *rssn_num_physics_de_broglie_wavelength_json(const char *aInput)
;

rssn_
double rssn_num_physics_electric_field_point_charge(double aQ,
                                                    double aR)
;

rssn_
char *rssn_num_physics_electric_field_point_charge_json(const char *aInput)
;

rssn_
double rssn_num_physics_electric_potential_point_charge(double aQ,
                                                        double aR)
;

rssn_
double rssn_num_physics_electron_mass()
;

rssn_
double rssn_num_physics_elementary_charge()
;

rssn_
double rssn_num_physics_gravitational_constant()
;

rssn_
double rssn_num_physics_hydrogen_energy_level(uint64_t aN)
;

rssn_
rssn_BincodeBuffer rssn_num_physics_hydrogen_energy_level_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_physics_hydrogen_energy_level_json(const char *aInput)
;

rssn_
double rssn_num_physics_ideal_gas_pressure(double aN,
                                           double aT,
                                           double aV)
;

rssn_
rssn_BincodeBuffer rssn_num_physics_ideal_gas_pressure_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_physics_ideal_gas_pressure_json(const char *aInput)
;

rssn_
double rssn_num_physics_ideal_gas_temperature(double aP,
                                              double aV,
                                              double aN)
;

rssn_
double rssn_num_physics_ideal_gas_volume(double aN,
                                         double aT,
                                         double aP)
;

rssn_
double rssn_num_physics_length_contraction(double aProperLength,
                                           double aVelocity)
;

rssn_
double rssn_num_physics_lorentz_factor(double aVelocity)
;

rssn_
rssn_BincodeBuffer rssn_num_physics_lorentz_factor_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_physics_lorentz_factor_json(const char *aInput)
;

rssn_
double rssn_num_physics_lorentz_force(double aCharge,
                                      double aVelocity,
                                      double aEField,
                                      double aBField)
;

rssn_
double rssn_num_physics_magnetic_field_infinite_wire(double aCurrent,
                                                     double aR)
;

rssn_
double rssn_num_physics_mass_energy(double aMass)
;

rssn_
rssn_BincodeBuffer rssn_num_physics_mass_energy_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_physics_mass_energy_json(const char *aInput)
;

rssn_
double rssn_num_physics_maxwell_boltzmann_mean_speed(double aMass,
                                                     double aTemperature)
;

rssn_
char *rssn_num_physics_maxwell_boltzmann_mean_speed_json(const char *aInput)
;

rssn_
double rssn_num_physics_maxwell_boltzmann_rms_speed(double aMass,
                                                    double aTemperature)
;

rssn_
double rssn_num_physics_maxwell_boltzmann_speed_distribution(double aV,
                                                             double aMass,
                                                             double aTemperature)
;

rssn_
double rssn_num_physics_photon_energy(double aWavelength)
;

rssn_
char *rssn_num_physics_photon_energy_json(const char *aInput)
;

rssn_
double rssn_num_physics_photon_wavelength(double aEnergy)
;

rssn_
char *rssn_num_physics_photon_wavelength_json(const char *aInput)
;

rssn_
double rssn_num_physics_planck_constant()
;

rssn_
double rssn_num_physics_quantum_harmonic_oscillator_energy(uint64_t aN,
                                                           double aOmega)
;

rssn_
rssn_BincodeBuffer rssn_num_physics_quantum_harmonic_oscillator_energy_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_physics_quantum_harmonic_oscillator_energy_json(const char *aInput)
;

rssn_
double rssn_num_physics_relativistic_kinetic_energy(double aMass,
                                                    double aVelocity)
;

rssn_
double rssn_num_physics_relativistic_momentum(double aMass,
                                              double aVelocity)
;

rssn_
double rssn_num_physics_relativistic_velocity_addition(double aV,
                                                       double aW)
;

rssn_
char *rssn_num_physics_relativistic_velocity_addition_json(const char *aInput)
;

rssn_
double rssn_num_physics_simple_harmonic_oscillator(double aAmplitude,
                                                   double aOmega,
                                                   double aPhase,
                                                   double aTime)
;

rssn_
rssn_BincodeBuffer rssn_num_physics_simple_harmonic_oscillator_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_physics_simple_harmonic_oscillator_json(const char *aInput)
;

rssn_
double rssn_num_physics_speed_of_light()
;

rssn_
double rssn_num_physics_time_dilation(double aProperTime,
                                      double aVelocity)
;

rssn_
char *rssn_num_physics_time_dilation_json(const char *aInput)
;

rssn_
double rssn_num_physics_wien_displacement_wavelength(double aTemperature)
;

rssn_
char *rssn_num_physics_wien_displacement_wavelength_json(const char *aInput)
;

/*
 Adds two polynomials.
 */
rssn_
rssn_Polynomial *rssn_num_poly_add(const rssn_Polynomial *aA,
                                   const rssn_Polynomial *aB)
;

/*
 Adds two polynomials via Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_num_poly_add_bincode(const uint8_t *aData,
                                             size_t aLen)
;

/*
 Adds two polynomials from JSON.
 */
rssn_
char *rssn_num_poly_add_json(const char *aJsonPtr)
;

/*
 Creates a new polynomial from coefficients.
 */
rssn_
rssn_Polynomial *rssn_num_poly_create(const double *aCoeffs,
                                      size_t aLen)
;

/*
 Returns the degree of a polynomial.
 */
rssn_
size_t rssn_num_poly_degree(const rssn_Polynomial *aPoly)
;

/*
 Computes the derivative.
 */
rssn_
rssn_Polynomial *rssn_num_poly_derivative(const rssn_Polynomial *aPoly)
;

/*
 Evaluates a polynomial at x.
 */
rssn_
double rssn_num_poly_eval(const rssn_Polynomial *aPoly,
                          double aX)
;

/*
 Frees a polynomial object.
 */
rssn_
void rssn_num_poly_free(rssn_Polynomial *aPoly)
;

/*
 Computes the integral.
 */
rssn_
rssn_Polynomial *rssn_num_poly_integral(const rssn_Polynomial *aPoly)
;

/*
 Multiplies two polynomials.
 */
rssn_
rssn_Polynomial *rssn_num_poly_mul(const rssn_Polynomial *aA,
                                   const rssn_Polynomial *aB)
;

/*
 Multiplies two polynomials from JSON.
 */
rssn_
char *rssn_num_poly_mul_json(const char *aJsonPtr)
;

/*
 Subtracts two polynomials.
 */
rssn_
rssn_Polynomial *rssn_num_poly_sub(const rssn_Polynomial *aA,
                                   const rssn_Polynomial *aB)
;

rssn_
double rssn_num_pure_abs(double aX)
;

rssn_
double rssn_num_pure_acos(double aX)
;

rssn_
double rssn_num_pure_asin(double aX)
;

rssn_
double rssn_num_pure_atan(double aX)
;

rssn_
double rssn_num_pure_atan2(double aY,
                           double aX)
;

rssn_
double rssn_num_pure_cos(double aX)
;

rssn_
double rssn_num_pure_cosh(double aX)
;

rssn_
double rssn_num_pure_exp(double aX)
;

rssn_
double rssn_num_pure_ln(double aX)
;

rssn_
double rssn_num_pure_pow(double aBase,
                         double aExp)
;

/*
 Pure numerical functions exposed via FFI.
 */
rssn_
double rssn_num_pure_sin(double aX)
;

rssn_
double rssn_num_pure_sinh(double aX)
;

rssn_
double rssn_num_pure_sqrt(double aX)
;

rssn_
double rssn_num_pure_tan(double aX)
;

rssn_
double rssn_num_pure_tanh(double aX)
;

/*
 Computes the convolution of two sequences.
 */
rssn_
rssn_Matrix<double> *rssn_num_signal_convolve(const double *aA,
                                              size_t aALen,
                                              const double *aV,
                                              size_t aVLen)
;

rssn_
rssn_BincodeBuffer rssn_num_signal_convolve_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_signal_convolve_json(const char *aInputJson)
;

/*
 Computes the cross-correlation of two sequences.
 */
rssn_
rssn_Matrix<double> *rssn_num_signal_cross_correlation(const double *aA,
                                                       size_t aALen,
                                                       const double *aV,
                                                       size_t aVLen)
;

rssn_
rssn_BincodeBuffer rssn_num_signal_cross_correlation_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_signal_cross_correlation_json(const char *aInputJson)
;

/*
 Computes the FFT and returns a Matrix<Complex<f64>> as a Matrix<f64> (real, imag interleaved).
 */
rssn_
rssn_Matrix<double> *rssn_num_signal_fft(const double *aReal,
                                         const double *aImag,
                                         size_t aLen)
;

rssn_
rssn_BincodeBuffer rssn_num_signal_fft_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_signal_fft_json(const char *aInputJson)
;

/*
 Generates a Hamming window.
 */
rssn_
rssn_Matrix<double> *rssn_num_signal_hamming_window(size_t aN)
;

/*
 Generates a Hann window.
 */
rssn_
rssn_Matrix<double> *rssn_num_signal_hann_window(size_t aN)
;

/*
 Frees a `LinearSolution` object.
 */
rssn_
void rssn_num_solve_free_solution(rssn_LinearSolution *aPtr)
;

/*
 Gets the data of a unique solution.

 # Arguments
 * `ptr` - Pointer to the `LinearSolution`.
 * `buffer` - Buffer to store the solution vector.
 */
rssn_
void rssn_num_solve_get_unique_solution(const rssn_LinearSolution *aPtr,
                                        double *aBuffer)
;

/*
 Gets the length of the unique solution vector.
 */
rssn_
size_t rssn_num_solve_get_unique_solution_len(const rssn_LinearSolution *aPtr)
;

/*
 Checks if there is no solution.
 */
rssn_
bool rssn_num_solve_is_no_solution(const rssn_LinearSolution *aPtr)
;

/*
 Checks if the solution is unique.
 */
rssn_
bool rssn_num_solve_is_unique(const rssn_LinearSolution *aPtr)
;

/*
 Solves a linear system Ax = b.

 # Arguments
 * `matrix_ptr` - Pointer to the coefficient matrix A.
 * `vector_data` - Pointer to the constant vector b.
 * `vector_len` - Length of the vector b.

 # Returns
 A pointer to a `LinearSolution` object, or null on error.
 */
rssn_
rssn_LinearSolution *rssn_num_solve_linear_system_handle(const rssn_Matrix<double> *aMatrixPtr,
                                                         const double *aVectorData,
                                                         size_t aVectorLen)
;

/*
 Creates a new sparse CSR matrix from dimensions and triplet data.

 # Arguments
 * `rows` - Number of rows.
 * `cols` - Number of columns.
 * `row_indices` - Array of row indices.
 * `col_indices` - Array of column indices.
 * `values` - Array of values.
 * `nnz` - Number of non-zero elements (length of the input arrays).

 # Returns
 A raw pointer to the CsMat object, or null on error.
 */
rssn_
rssn_CsMat<double> *rssn_num_sparse_create(size_t aRows,
                                           size_t aCols,
                                           const size_t *aRowIndices,
                                           const size_t *aColIndices,
                                           const double *aValues,
                                           size_t aNnz)
;

/*
 Frees a sparse matrix object.
 */
rssn_
void rssn_num_sparse_free(rssn_CsMat<double> *aMatrix)
;

/*
 Computes the Frobenius norm.
 */
rssn_
double rssn_num_sparse_frobenius_norm(const rssn_CsMat<double> *aMatrix)
;

/*
 Returns the number of columns.
 */
rssn_
size_t rssn_num_sparse_get_cols(const rssn_CsMat<double> *aMatrix)
;

/*
 Returns the number of non-zero elements.
 */
rssn_
size_t rssn_num_sparse_get_nnz(const rssn_CsMat<double> *aMatrix)
;

/*
 Returns the number of rows.
 */
rssn_
size_t rssn_num_sparse_get_rows(const rssn_CsMat<double> *aMatrix)
;

rssn_
char *rssn_num_sparse_solve_cg_json(const char *aJsonPtr)
;

/*
 Sparse matrix-vector multiplication.

 result = matrix * vector
 */
rssn_
int32_t rssn_num_sparse_spmv(const rssn_CsMat<double> *aMatrix,
                             const double *aVector,
                             size_t aVecLen,
                             double *aResult)
;

/*
 Sparse matrix-vector multiplication via Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_num_sparse_spmv_bincode(const uint8_t *aData,
                                                size_t aLen)
;

/*
 Sparse matrix-vector multiplication from JSON.
 */
rssn_
char *rssn_num_sparse_spmv_json(const char *aJsonPtr)
;

/*
 Computes the trace.
 */
rssn_
int32_t rssn_num_sparse_trace(const rssn_CsMat<double> *aMatrix,
                              double *aOutTrace)
;

rssn_
double rssn_num_special_bessel_i0(double aX)
;

rssn_
double rssn_num_special_bessel_i1(double aX)
;

rssn_
double rssn_num_special_bessel_j0(double aX)
;

rssn_
rssn_BincodeBuffer rssn_num_special_bessel_j0_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_special_bessel_j0_json(const char *aInput)
;

rssn_
double rssn_num_special_bessel_j1(double aX)
;

rssn_
rssn_BincodeBuffer rssn_num_special_bessel_j1_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_special_bessel_j1_json(const char *aInput)
;

rssn_
double rssn_num_special_bessel_y0(double aX)
;

rssn_
double rssn_num_special_bessel_y1(double aX)
;

rssn_
double rssn_num_special_beta(double aA,
                             double aB)
;

rssn_
rssn_BincodeBuffer rssn_num_special_beta_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_special_beta_json(const char *aInput)
;

rssn_
double rssn_num_special_binomial(uint64_t aN,
                                 uint64_t aK)
;

rssn_
rssn_BincodeBuffer rssn_num_special_binomial_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_special_binomial_json(const char *aInput)
;

rssn_
double rssn_num_special_chebyshev_t(uint32_t aN,
                                    double aX)
;

rssn_
rssn_BincodeBuffer rssn_num_special_chebyshev_t_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_special_chebyshev_t_json(const char *aInput)
;

rssn_
double rssn_num_special_chebyshev_u(uint32_t aN,
                                    double aX)
;

rssn_
double rssn_num_special_digamma(double aX)
;

rssn_
rssn_BincodeBuffer rssn_num_special_digamma_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_special_digamma_json(const char *aInput)
;

rssn_
double rssn_num_special_double_factorial(uint64_t aN)
;

rssn_
double rssn_num_special_erf(double aX)
;

rssn_
rssn_BincodeBuffer rssn_num_special_erf_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_special_erf_json(const char *aInput)
;

rssn_
double rssn_num_special_erfc(double aX)
;

rssn_
rssn_BincodeBuffer rssn_num_special_erfc_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_special_erfc_json(const char *aInput)
;

rssn_
double rssn_num_special_factorial(uint64_t aN)
;

rssn_
rssn_BincodeBuffer rssn_num_special_factorial_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_special_factorial_json(const char *aInput)
;

rssn_
double rssn_num_special_gamma(double aX)
;

rssn_
rssn_BincodeBuffer rssn_num_special_gamma_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_special_gamma_json(const char *aInput)
;

rssn_
double rssn_num_special_hermite_h(uint32_t aN,
                                  double aX)
;

rssn_
rssn_BincodeBuffer rssn_num_special_hermite_h_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_special_hermite_h_json(const char *aInput)
;

rssn_
double rssn_num_special_inverse_erf(double aX)
;

rssn_
double rssn_num_special_laguerre_l(uint32_t aN,
                                   double aX)
;

rssn_
double rssn_num_special_legendre_p(uint32_t aN,
                                   double aX)
;

rssn_
rssn_BincodeBuffer rssn_num_special_legendre_p_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_special_legendre_p_json(const char *aInput)
;

rssn_
double rssn_num_special_ln_beta(double aA,
                                double aB)
;

rssn_
double rssn_num_special_ln_gamma(double aX)
;

rssn_
rssn_BincodeBuffer rssn_num_special_ln_gamma_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_special_ln_gamma_json(const char *aInput)
;

rssn_
double rssn_num_special_logit(double aP)
;

rssn_
double rssn_num_special_lower_incomplete_gamma(double aS,
                                               double aX)
;

rssn_
double rssn_num_special_regularized_beta(double aX,
                                         double aA,
                                         double aB)
;

rssn_
rssn_BincodeBuffer rssn_num_special_regularized_beta_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_special_regularized_beta_json(const char *aInput)
;

rssn_
double rssn_num_special_sigmoid(double aX)
;

rssn_
rssn_BincodeBuffer rssn_num_special_sigmoid_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_special_sigmoid_json(const char *aInput)
;

rssn_
double rssn_num_special_sinc(double aX)
;

rssn_
rssn_BincodeBuffer rssn_num_special_sinc_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_special_sinc_json(const char *aInput)
;

rssn_
double rssn_num_special_softplus(double aX)
;

rssn_
double rssn_num_special_upper_incomplete_gamma(double aS,
                                               double aX)
;

rssn_
double rssn_num_special_zeta(double aS)
;

/*
 Performs a chi-squared test.
 Returns chi-squared statistic via out_chi and p-value via out_p.
 */
rssn_
int32_t rssn_num_stats_chi_squared_test(const double *aObserved,
                                        const double *aExpected,
                                        size_t aLen,
                                        double *aOutChi,
                                        double *aOutP)
;

rssn_
rssn_BincodeBuffer rssn_num_stats_chi_squared_test_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_stats_chi_squared_test_json(const char *aInput)
;

/*
 Computes the Pearson correlation coefficient of two arrays.
 */
rssn_
double rssn_num_stats_correlation(const double *aData1,
                                  size_t aLen1,
                                  const double *aData2,
                                  size_t aLen2)
;

rssn_
rssn_BincodeBuffer rssn_num_stats_correlation_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_stats_correlation_json(const char *aInput)
;

/*
 Computes the covariance of two arrays.
 */
rssn_
double rssn_num_stats_covariance(const double *aData1,
                                 size_t aLen1,
                                 const double *aData2,
                                 size_t aLen2)
;

rssn_
rssn_BincodeBuffer rssn_num_stats_covariance_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_stats_covariance_json(const char *aInput)
;

/*
 Computes the coefficient of variation of an array.
 */
rssn_
double rssn_num_stats_cv(const double *aData,
                         size_t aLen)
;

/*
 Computes the geometric mean of an array.
 */
rssn_
double rssn_num_stats_geometric_mean(const double *aData,
                                     size_t aLen)
;

rssn_
char *rssn_num_stats_geometric_mean_json(const char *aInput)
;

/*
 Computes the harmonic mean of an array.
 */
rssn_
double rssn_num_stats_harmonic_mean(const double *aData,
                                    size_t aLen)
;

rssn_
char *rssn_num_stats_harmonic_mean_json(const char *aInput)
;

/*
 Performs simple linear regression.
 Returns slope via out_slope and intercept via out_intercept.
 */
rssn_
int32_t rssn_num_stats_linear_regression(const double *aX,
                                         const double *aY,
                                         size_t aLen,
                                         double *aOutSlope,
                                         double *aOutIntercept)
;

rssn_
rssn_BincodeBuffer rssn_num_stats_linear_regression_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_stats_linear_regression_json(const char *aInput)
;

/*
 Computes the mean of an array.
 */
rssn_
double rssn_num_stats_mean(const double *aData,
                           size_t aLen)
;

rssn_
rssn_BincodeBuffer rssn_num_stats_mean_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_stats_mean_json(const char *aInput)
;

/*
 Computes the range of an array.
 */
rssn_
double rssn_num_stats_range(const double *aData,
                            size_t aLen)
;

/*
 Computes the Shannon entropy of a probability distribution.
 */
rssn_
double rssn_num_stats_shannon_entropy(const double *aData,
                                      size_t aLen)
;

rssn_
rssn_BincodeBuffer rssn_num_stats_shannon_entropy_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_stats_shannon_entropy_json(const char *aInput)
;

/*
 Computes the standard error of an array.
 */
rssn_
double rssn_num_stats_standard_error(const double *aData,
                                     size_t aLen)
;

/*
 Computes the standard deviation of an array.
 */
rssn_
double rssn_num_stats_std_dev(const double *aData,
                              size_t aLen)
;

rssn_
rssn_BincodeBuffer rssn_num_stats_std_dev_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_stats_std_dev_json(const char *aInput)
;

/*
 Performs a two-sample t-test.
 Returns t-statistic via out_t and p-value via out_p.
 */
rssn_
int32_t rssn_num_stats_two_sample_t_test(const double *aSample1,
                                         size_t aLen1,
                                         const double *aSample2,
                                         size_t aLen2,
                                         double *aOutT,
                                         double *aOutP)
;

rssn_
rssn_BincodeBuffer rssn_num_stats_two_sample_t_test_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_stats_two_sample_t_test_json(const char *aInput)
;

/*
 Computes the variance of an array.
 */
rssn_
double rssn_num_stats_variance(const double *aData,
                               size_t aLen)
;

rssn_
rssn_BincodeBuffer rssn_num_stats_variance_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_stats_variance_json(const char *aInput)
;

/*
 Performs Welch's t-test.
 Returns t-statistic via out_t and p-value via out_p.
 */
rssn_
int32_t rssn_num_stats_welch_t_test(const double *aSample1,
                                    size_t aLen1,
                                    const double *aSample2,
                                    size_t aLen2,
                                    double *aOutT,
                                    double *aOutP)
;

rssn_
rssn_BincodeBuffer rssn_num_stats_welch_t_test_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_stats_welch_t_test_json(const char *aInput)
;

rssn_
rssn_BincodeBuffer rssn_num_stats_z_scores_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_stats_z_scores_json(const char *aInput)
;

/*
 Creates a new tensor from shape and data.
 */
rssn_
rssn_ArrayD<double> *rssn_num_tensor_create(const size_t *aShape,
                                            size_t aNdim,
                                            const double *aData,
                                            size_t aDataLen)
;

/*
 Frees a tensor object.
 */
rssn_
void rssn_num_tensor_free(rssn_ArrayD<double> *aTensor)
;

/*
 Returns the number of dimensions.
 */
rssn_
size_t rssn_num_tensor_get_ndim(const rssn_ArrayD<double> *aTensor)
;

/*
 Returns the shape of the tensor.
 */
rssn_
int32_t rssn_num_tensor_get_shape(const rssn_ArrayD<double> *aTensor,
                                  size_t *aOutShape)
;

/*
 Frobenius norm of a tensor.
 */
rssn_
double rssn_num_tensor_norm(const rssn_ArrayD<double> *aTensor)
;

/*
 Outer product of two tensors.
 */
rssn_
rssn_ArrayD<double> *rssn_num_tensor_outer_product(const rssn_ArrayD<double> *aA,
                                                   const rssn_ArrayD<double> *aB)
;

/*
 Outer product from JSON.
 */
rssn_
char *rssn_num_tensor_outer_product_json(const char *aJsonPtr)
;

/*
 Tensor contraction (tensordot).
 */
rssn_
rssn_ArrayD<double> *rssn_num_tensor_tensordot(const rssn_ArrayD<double> *aA,
                                               const rssn_ArrayD<double> *aB,
                                               const size_t *aAxesA,
                                               size_t aAxesALen,
                                               const size_t *aAxesB,
                                               size_t aAxesBLen)
;

/*
 Tensor contraction via Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_num_tensor_tensordot_bincode(const uint8_t *aData,
                                                     size_t aLen)
;

/*
 Tensor contraction from JSON.
 */
rssn_
char *rssn_num_tensor_tensordot_json(const char *aJsonPtr)
;

/*
 Computes the Betti numbers for a point cloud.
 */
rssn_
int32_t rssn_num_topology_betti_numbers(const double *const *aPoints,
                                        size_t aNPoints,
                                        size_t aDim,
                                        double aEpsilon,
                                        size_t aMaxDim,
                                        size_t *aResult)
;

rssn_
rssn_BincodeBuffer rssn_num_topology_betti_numbers_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_topology_betti_numbers_json(const char *aInputJson)
;

/*
 Computes the Euclidean distance between two points.
 */
rssn_
double rssn_num_topology_euclidean_distance(const double *aP1,
                                            const double *aP2,
                                            size_t aDim)
;

/*
 Finds the connected components of a graph.
 */
rssn_
rssn_Vec<rssn_Vec<size_t>> *rssn_num_topology_find_connected_components(const rssn_Graph *aGraphPtr)
;

rssn_
rssn_BincodeBuffer rssn_num_topology_persistence_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_topology_persistence_json(const char *aInputJson)
;

/*
 Computes the sum of two vectors.
 */
rssn_
rssn_Vec<double> *rssn_num_vec_add(const rssn_Vec<double> *aV1,
                                   const rssn_Vec<double> *aV2)
;

/*
 Computes the angle between two vectors.
 */
rssn_
int32_t rssn_num_vec_angle(const rssn_Vec<double> *aV1,
                           const rssn_Vec<double> *aV2,
                           double *aResult)
;

/*
 Creates a new numerical vector from a raw array of doubles.
 The caller is responsible for freeing the returned pointer using rssn_num_vec_free.
 */
rssn_
rssn_Vec<double> *rssn_num_vec_create(const double *aData,
                                      size_t aLen)
;

/*
 Computes the cross product of two 3D vectors.
 */
rssn_
rssn_Vec<double> *rssn_num_vec_cross_product(const rssn_Vec<double> *aV1,
                                             const rssn_Vec<double> *aV2)
;

/*
 Returns a pointer to the underlying data of a numerical vector.
 */
rssn_
const double *rssn_num_vec_data(const rssn_Vec<double> *aV)
;

/*
 Computes the dot product of two vectors.
 */
rssn_
int32_t rssn_num_vec_dot_product(const rssn_Vec<double> *aV1,
                                 const rssn_Vec<double> *aV2,
                                 double *aResult)
;

/*
 Frees a numerical vector allocated by the library.
 */
rssn_
void rssn_num_vec_free(rssn_Vec<double> *aV)
;

/*
 Returns the length of a numerical vector.
 */
rssn_
size_t rssn_num_vec_len(const rssn_Vec<double> *aV)
;

/*
 Computes the Lp norm of a vector.
 */
rssn_
int32_t rssn_num_vec_lp_norm(const rssn_Vec<double> *aV,
                             double aP,
                             double *aResult)
;

/*
 Computes the L2 norm of a vector.
 */
rssn_
int32_t rssn_num_vec_norm(const rssn_Vec<double> *aV,
                          double *aResult)
;

/*
 Normalizes a vector.
 */
rssn_
rssn_Vec<double> *rssn_num_vec_normalize(const rssn_Vec<double> *aV)
;

/*
 Projects v1 onto v2.
 */
rssn_
rssn_Vec<double> *rssn_num_vec_project(const rssn_Vec<double> *aV1,
                                       const rssn_Vec<double> *aV2)
;

/*
 Reflects v about n.
 */
rssn_
rssn_Vec<double> *rssn_num_vec_reflect(const rssn_Vec<double> *aV,
                                       const rssn_Vec<double> *aN)
;

/*
 Multiplies a vector by a scalar.
 */
rssn_
rssn_Vec<double> *rssn_num_vec_scalar_mul(const rssn_Vec<double> *aV,
                                          double aS)
;

/*
 Computes the difference of two vectors.
 */
rssn_
rssn_Vec<double> *rssn_num_vec_sub(const rssn_Vec<double> *aV1,
                                   const rssn_Vec<double> *aV2)
;

/*
 Computes the numerical curl of a 3D vector field at a point.
 */
rssn_
rssn_Vec<double> *rssn_num_vector_calculus_curl(const rssn_Expr *const *aFuncs,
                                                const char *const *aVars,
                                                const double *aPoint)
;

rssn_
rssn_BincodeBuffer rssn_num_vector_calculus_curl_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_vector_calculus_curl_json(const char *aInputJson)
;

/*
 Computes the numerical directional derivative of a function at a point.
 */
rssn_
int32_t rssn_num_vector_calculus_directional_derivative(const rssn_Expr *aF,
                                                        const char *const *aVars,
                                                        const double *aPoint,
                                                        const double *aDirection,
                                                        size_t aNVars,
                                                        double *aResult)
;

/*
 Computes the numerical divergence of a vector field at a point.
 */
rssn_
int32_t rssn_num_vector_calculus_divergence(const rssn_Expr *const *aFuncs,
                                            size_t aNFuncs,
                                            const char *const *aVars,
                                            const double *aPoint,
                                            size_t aNVars,
                                            double *aResult)
;

rssn_
rssn_BincodeBuffer rssn_num_vector_calculus_divergence_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_vector_calculus_divergence_json(const char *aInputJson)
;

/*
 Computes the numerical Laplacian of a scalar field at a point.
 */
rssn_
int32_t rssn_num_vector_calculus_laplacian(const rssn_Expr *aF,
                                           const char *const *aVars,
                                           const double *aPoint,
                                           size_t aNVars,
                                           double *aResult)
;

rssn_
rssn_BincodeBuffer rssn_num_vector_calculus_laplacian_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_num_vector_calculus_laplacian_json(const char *aInputJson)
;

/*
 Evaluates a power series at a point.
 */
rssn_
double rssn_numerical_evaluate_power_series(const rssn_Vec<double> *aCoeffs,
                                            double aAtPoint,
                                            double aX)
;

rssn_
int32_t rssn_numerical_gradient(size_t aExprH,
                                const char *const *aVars,
                                size_t aNumVars,
                                const double *aPoint,
                                size_t aPointLen,
                                double *aResultVec)
;

rssn_
rssn_BincodeBuffer rssn_numerical_gradient_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_numerical_gradient_json(const char *aInputJson)
;

rssn_
rssn_BincodeBuffer rssn_numerical_hessian_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_numerical_hessian_json(const char *aInputJson)
;

rssn_
int32_t rssn_numerical_integrate(size_t aExprH,
                                 const char *aVar,
                                 double aStart,
                                 double aEnd,
                                 size_t aNSteps,
                                 uint32_t aMethod,
                                 double *aResult)
;

rssn_
rssn_BincodeBuffer rssn_numerical_jacobian_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_numerical_jacobian_json(const char *aInputJson)
;

/*
 Performs numerical integration (quadrature) of a function.

 # Arguments
 * `expr_ptr` - Pointer to the `Expr` to integrate.
 * `var_ptr` - Pointer to the C string representing the variable of integration.
 * `a` - Lower bound of integration.
 * `b` - Upper bound of integration.
 * `n_steps` - Number of steps for non-adaptive methods.
 * `method` - Integration method:
     0 - Trapezoidal
     1 - Simpson
     2 - Adaptive
     3 - Romberg
     4 - Gauss-Legendre
 * `result` - Pointer to store the result.

 # Returns
 0 on success, -1 on error.
 */
rssn_
int32_t rssn_numerical_quadrature(const rssn_Expr *aExprPtr,
                                  const char *aVarPtr,
                                  double aA,
                                  double aB,
                                  size_t aNSteps,
                                  int32_t aMethod,
                                  double *aResult)
;

/*
 Performs numerical integration via Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_numerical_quadrature_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 Performs numerical integration via JSON.

 Input JSON format:
 {
   "expr": <Expr object>,
   "var": "x",
   "a": 0.0,
   "b": 1.0,
   "n_steps": 100,
   "method": "Simpson"
 }
 */
rssn_
char *rssn_numerical_quadrature_json(const char *aJsonPtr)
;

/*
 Computes the sum of a series.
 */
rssn_
int32_t rssn_numerical_sum_series(const rssn_Expr *aF,
                                  const char *aVar,
                                  int64_t aStart,
                                  int64_t aEnd,
                                  double *aResult)
;

rssn_
rssn_BincodeBuffer rssn_numerical_sum_series_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_numerical_sum_series_json(const char *aInputJson)
;

/*
 Computes the numerical Taylor series coefficients.
 Returns a pointer to a Vec<f64> containing the coefficients.
 */
rssn_
rssn_Vec<double> *rssn_numerical_taylor_coefficients(const rssn_Expr *aF,
                                                     const char *aVar,
                                                     double aAtPoint,
                                                     size_t aOrder)
;

rssn_
rssn_BincodeBuffer rssn_numerical_taylor_coefficients_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_numerical_taylor_coefficients_json(const char *aInputJson)
;

rssn_
rssn_Expr *rssn_one_sample_t_test(const rssn_Expr *const *aData,
                                  size_t aLen,
                                  const rssn_Expr *aTargetMean)
;

/*
 Frees an Operator.
 */
rssn_
void rssn_operator_free(rssn_Operator *aOpPtr)
;

/*
 Creates a new Operator from an expression.
 */
rssn_
rssn_Operator *rssn_operator_new(const rssn_Expr *aOp)
;

/*
 Generates a 4x4 orthographic projection matrix.
 */
rssn_
rssn_Expr *rssn_orthographic_projection(const rssn_Expr *aLeft,
                                        const rssn_Expr *aRight,
                                        const rssn_Expr *aBottom,
                                        const rssn_Expr *aTop,
                                        const rssn_Expr *aNear,
                                        const rssn_Expr *aFar)
;

/*
 Frees a ParametricCurve handle.
 */
rssn_
void rssn_parametric_curve_free(rssn_ParametricCurve *aCurve)
;

/*
 Creates a new ParametricCurve.
 */
rssn_
rssn_ParametricCurve *rssn_parametric_curve_new(const char *aRX,
                                                const char *aRY,
                                                const char *aRZ,
                                                const char *aTVar,
                                                const char *aTLower,
                                                const char *aTUpper)
;

/*
 Frees a ParametricSurface handle.
 */
rssn_
void rssn_parametric_surface_free(rssn_ParametricSurface *aSurface)
;

/*
 Creates a new ParametricSurface.
 */
rssn_
rssn_ParametricSurface *rssn_parametric_surface_new(const char *aRX,
                                                    const char *aRY,
                                                    const char *aRZ,
                                                    const char *aUVar,
                                                    const char *aULower,
                                                    const char *aUUpper,
                                                    const char *aVVar,
                                                    const char *aVLower,
                                                    const char *aVUpper)
;

/*
 Clears a ParsingCache.
 */
rssn_
void rssn_parsing_cache_clear(rssn_ParsingCache *aCache)
;

/*
 Frees a ParsingCache.
 */
rssn_
void rssn_parsing_cache_free(rssn_ParsingCache *aCache)
;

/*
 Retrieves an expression from the ParsingCache.
 Returns a pointer to the Expr (Arc<Expr> with incremented refcount), or null if not found.
 The caller is responsible for freeing the returned Expr (using the appropriate Expr free function).
 */
rssn_
rssn_Expr *rssn_parsing_cache_get(rssn_ParsingCache *aCache,
                                  const char *aInput)
;

/*
 Retrieves an expression from the ParsingCache as a bincode buffer.
 */
rssn_
rssn_BincodeBuffer rssn_parsing_cache_get_bincode(rssn_ParsingCache *aCache,
                                                  const char *aInput)
;

/*
 Retrieves an expression from the ParsingCache as a JSON string.
 Returns null if not found or error.
 */
rssn_
char *rssn_parsing_cache_get_json(rssn_ParsingCache *aCache,
                                  const char *aInput)
;

/*
 Creates a new ParsingCache.
 The caller is responsible for freeing the memory using rssn_parsing_cache_free.
 */
rssn_
rssn_ParsingCache *rssn_parsing_cache_new()
;

/*
 Stores an expression in the ParsingCache.
 The expr pointer is cloned (deep copy of the structure, but DAG nodes are shared).
 */
rssn_
void rssn_parsing_cache_set(rssn_ParsingCache *aCache,
                            const char *aInput,
                            const rssn_Expr *aExpr)
;

/*
 Stores an expression in the ParsingCache from a bincode buffer.
 */
rssn_
void rssn_parsing_cache_set_bincode(rssn_ParsingCache *aCache,
                                    const char *aInput,
                                    rssn_BincodeBuffer aBuffer)
;

/*
 Stores an expression in the ParsingCache from a JSON string.
 */
rssn_
void rssn_parsing_cache_set_json(rssn_ParsingCache *aCache,
                                 const char *aInput,
                                 const char *aJsonExpr)
;

rssn_
rssn_ExprList *rssn_partial_fraction_decomposition(const rssn_Expr *aExpr,
                                                   const char *aVar)
;

/*
 Computes a path integral.
 */
rssn_
rssn_Expr *rssn_path_integrate(const rssn_Expr *aExpr,
                               const char *aVar,
                               const rssn_Expr *aContour)
;

/*
 Pauli matrices σ_x, σ_y, σ_z.
 */
rssn_
void rssn_pauli_matrices(rssn_Expr **aSigmaX,
                         rssn_Expr **aSigmaY,
                         rssn_Expr **aSigmaZ)
;

rssn_
rssn_Expr *rssn_permutations(const rssn_Expr *aN,
                             const rssn_Expr *aK)
;

/*
 Generates a 4x4 perspective projection matrix.
 */
rssn_
rssn_Expr *rssn_perspective_projection(const rssn_Expr *aFovy,
                                       const rssn_Expr *aAspect,
                                       const rssn_Expr *aNear,
                                       const rssn_Expr *aFar)
;

rssn_
int32_t rssn_physics_advection_diffusion_1d(const double *aInitialCond,
                                            size_t aLen,
                                            double aDx,
                                            double aC,
                                            double aD,
                                            double aDt,
                                            size_t aSteps,
                                            double *aResultPtr)
;

/*
 Solves a 2D Laplace problem using BEM and returns the results as a flat array.
 The `bcs_type` array should be 0 for Potential and 1 for Flux.
 # Safety
 This function is unsafe because it dereferences pointers.
 */
rssn_
int32_t rssn_physics_bem_solve_laplace_2d(const double *aPointsX,
                                          const double *aPointsY,
                                          const int32_t *aBcsType,
                                          const double *aBcsValue,
                                          size_t aN,
                                          double *aOutU,
                                          double *aOutQ)
;

rssn_
rssn_BincodeBuffer rssn_physics_bem_solve_laplace_2d_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_physics_bem_solve_laplace_2d_json(const char *aInput)
;

/*
 Solves 1D heat equation using CN and returns a flat array of doubles.
 The caller is responsible for freeing the memory using rssn_free_f64_array.
 */
rssn_
double *rssn_physics_cnm_solve_heat_1d(const double *aInitialCondition,
                                       size_t aN,
                                       double aDx,
                                       double aDt,
                                       double aDCoeff,
                                       size_t aSteps,
                                       size_t *aOutSize)
;

rssn_
rssn_BincodeBuffer rssn_physics_cnm_solve_heat_2d_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_physics_cnm_solve_heat_2d_json(const char *aInput)
;

/*
 Simulates the gravity semi-implicit Euler scenario and returns the results as a Matrix handle.
 */
rssn_
rssn_Matrix<double> *rssn_physics_em_simulate_gravity_semi_implicit()
;

/*
 Simulates the oscillator forward Euler scenario and returns the results as a Matrix handle.
 */
rssn_
rssn_Matrix<double> *rssn_physics_em_simulate_oscillator_forward()
;

/*
 Simulates the stiff decay scenario using backward Euler and returns a Matrix handle.
 */
rssn_
rssn_Matrix<double> *rssn_physics_em_simulate_stiff_decay_backward()
;

rssn_
rssn_BincodeBuffer rssn_physics_em_solve_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_physics_em_solve_json(const char *aInput)
;

rssn_
char *rssn_physics_fdm_burgers_json(const char *aInput)
;

/*
 Returns a pointer to the grid data.
 */
rssn_
double *rssn_physics_fdm_grid_data(rssn_FdmGrid<double> *aGrid)
;

/*
 Frees a FdmGrid handle.
 */
rssn_
void rssn_physics_fdm_grid_free(rssn_FdmGrid<double> *aGrid)
;

/*
 Returns the size of the grid data.
 */
rssn_
size_t rssn_physics_fdm_grid_len(rssn_FdmGrid<double> *aGrid)
;

/*
 Creates a new FdmGrid handle with the given dimensions.
 */
rssn_
rssn_FdmGrid<double> *rssn_physics_fdm_grid_new(size_t aD1,
                                                size_t aD2,
                                                size_t aD3)
;

rssn_
char *rssn_physics_fdm_heat_json(const char *aInput)
;

rssn_
char *rssn_physics_fdm_poisson_json(const char *aInput)
;

/*
 Simulates 2D heat conduction and returns a new FdmGrid handle.
 */
rssn_
rssn_FdmGrid<double> *rssn_physics_fdm_simulate_heat_2d()
;

/*
 Simulates 2D wave propagation and returns a new FdmGrid handle.
 */
rssn_
rssn_FdmGrid<double> *rssn_physics_fdm_simulate_wave_2d()
;

rssn_
rssn_BincodeBuffer rssn_physics_fdm_wave_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_physics_fdm_wave_json(const char *aInput)
;

/*
 Solves 1D Poisson using FEM and returns a flat array of doubles.
 The caller is responsible for freeing the memory using rssn_free_f64_array.
 */
rssn_
double *rssn_physics_fem_solve_poisson_1d(size_t aNElements,
                                          double aDomainLength,
                                          size_t *aOutSize)
;

rssn_
rssn_BincodeBuffer rssn_physics_fem_solve_poisson_1d_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_physics_fem_solve_poisson_1d_json(const char *aInput)
;

rssn_
char *rssn_physics_fvm_advection_json(const char *aInput)
;

/*
 Returns a pointer to the mesh data.
 */
rssn_
double *rssn_physics_fvm_mesh_data(rssn_Mesh *aMesh)
;

/*
 Frees a Mesh handle.
 */
rssn_
void rssn_physics_fvm_mesh_free(rssn_Mesh *aMesh)
;

/*
 Creates a new Mesh handle.
 */
rssn_
rssn_Mesh *rssn_physics_fvm_mesh_new(size_t aNumCells,
                                     double aDomainSize)
;

/*
 Simulates 1D advection and returns the final values in a new buffer.
 */
rssn_
double *rssn_physics_fvm_simulate_advection_1d()
;

rssn_
rssn_BincodeBuffer rssn_physics_fvm_swe_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_physics_fvm_swe_json(const char *aInput)
;

/*
 Simulates the dam break scenario and returns the final particle positions as a Matrix handle (Nx2).
 */
rssn_
rssn_Matrix<double> *rssn_physics_mm_simulate_dam_break()
;

rssn_
char *rssn_physics_mm_simulate_dam_break_json()
;

/*
 Adds a particle to the SPH system.
 */
rssn_
void rssn_physics_mm_sph_add_particle(rssn_SPHSystem *aSystem,
                                      double aX,
                                      double aY,
                                      double aVx,
                                      double aVy,
                                      double aMass)
;

/*
 Creates a new SPH system.
 */
rssn_
rssn_SPHSystem *rssn_physics_mm_sph_create(double aH,
                                           double aBoundsX,
                                           double aBoundsY)
;

/*
 Frees an SPH system.
 */
rssn_
void rssn_physics_mm_sph_free(rssn_SPHSystem *aSystem)
;

/*
 Returns the number of particles in the SPH system.
 */
rssn_
size_t rssn_physics_mm_sph_get_particle_count(rssn_SPHSystem *aSystem)
;

/*
 Gets particle positions as a Matrix (Nx2).
 */
rssn_
rssn_Matrix<double> *rssn_physics_mm_sph_get_positions(rssn_SPHSystem *aSystem)
;

/*
 Updates the SPH system by one time step.
 */
rssn_
void rssn_physics_mm_sph_update(rssn_SPHSystem *aSystem,
                                double aDt)
;

rssn_
rssn_BincodeBuffer rssn_physics_mm_sph_update_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_physics_mm_sph_update_json(const char *aInput)
;

/*
 Solves 1D Poisson using Multigrid and returns a flat array of doubles.
 The `out_size` will be set to `n + 2` (including boundaries).
 The caller is responsible for freeing the memory using rssn_free_f64_mtm_array.
 */
rssn_
double *rssn_physics_mtm_solve_poisson_1d(size_t aNInterior,
                                          const double *aF,
                                          size_t aNumCycles,
                                          size_t *aOutSize)
;

rssn_
char *rssn_physics_mtm_solve_poisson_1d_json(const char *aInput)
;

/*
 Solves 2D Poisson using Multigrid and returns a flat array of doubles.
 The `out_size` will be set to `n * n`.
 */
rssn_
double *rssn_physics_mtm_solve_poisson_2d(size_t aN,
                                          const double *aF,
                                          size_t aNumCycles,
                                          size_t *aOutSize)
;

rssn_
rssn_BincodeBuffer rssn_physics_mtm_solve_poisson_2d_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_physics_mtm_solve_poisson_2d_json(const char *aInput)
;

rssn_
char *rssn_physics_rkm_damped_oscillator_json(const char *aInput)
;

rssn_
rssn_BincodeBuffer rssn_physics_rkm_lorenz_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_physics_rkm_lorenz_json(const char *aInput)
;

rssn_
char *rssn_physics_rkm_lotka_volterra_json(const char *aInput)
;

/*
 Simulates the damped oscillator scenario and returns the results as a Matrix handle.
 */
rssn_
rssn_Matrix<double> *rssn_physics_rkm_simulate_damped_oscillator()
;

/*
 Simulates the Lorenz attractor scenario and returns the results as a Matrix handle.
 */
rssn_
rssn_Matrix<double> *rssn_physics_rkm_simulate_lorenz()
;

/*
 Simulates the Lotka-Volterra predator-prey scenario and returns the results as a Matrix handle.
 */
rssn_
rssn_Matrix<double> *rssn_physics_rkm_simulate_lotka_volterra()
;

/*
 Simulates the Van der Pol oscillator scenario and returns the results as a Matrix handle.
 */
rssn_
rssn_Matrix<double> *rssn_physics_rkm_simulate_vanderpol()
;

rssn_
char *rssn_physics_rkm_vanderpol_json(const char *aInput)
;

/*
 Runs a 2D FDTD simulation and returns the final Ez field as a Matrix handle (WxH).
 */
rssn_
rssn_Matrix<double> *rssn_physics_sim_fdtd_run_2d(size_t aWidth,
                                                  size_t aHeight,
                                                  size_t aTimeSteps,
                                                  size_t aSourceX,
                                                  size_t aSourceY,
                                                  double aSourceFreq)
;

rssn_
rssn_BincodeBuffer rssn_physics_sim_fdtd_run_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_physics_sim_fdtd_run_json(const char *aInput)
;

/*
 Runs a geodesic simulation and returns the resulting path as a Matrix handle (Nx2).
 */
rssn_
rssn_Matrix<double> *rssn_physics_sim_geodesic_run(double aBlackHoleMass,
                                                   double aR0,
                                                   double aRdot0,
                                                   double aPhi0,
                                                   double aPhidot0,
                                                   double aProperTimeEnd,
                                                   double aInitialDt)
;

rssn_
rssn_BincodeBuffer rssn_physics_sim_geodesic_run_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_physics_sim_geodesic_run_json(const char *aInput)
;

rssn_
rssn_BincodeBuffer rssn_physics_sim_gpe_run_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 Runs the GPE ground state finder and returns the result as a Matrix handle (Nx x Ny).
 */
rssn_
rssn_Matrix<double> *rssn_physics_sim_gpe_run_ground_state_finder(size_t aNx,
                                                                  size_t aNy,
                                                                  double aLx,
                                                                  double aLy,
                                                                  double aDTau,
                                                                  size_t aTimeSteps,
                                                                  double aG,
                                                                  double aTrapStrength)
;

rssn_
char *rssn_physics_sim_gpe_run_json(const char *aInput)
;

/*
 Frees the Ising result handle.
 */
rssn_
void rssn_physics_sim_ising_free_result(rssn_IsingResultHandle aHandle)
;

/*
 Runs a 2D Ising model simulation and returns the final grid as a Matrix handle and the magnetization.
 */
rssn_
rssn_IsingResultHandle rssn_physics_sim_ising_run(size_t aWidth,
                                                  size_t aHeight,
                                                  double aTemperature,
                                                  size_t aMcSteps)
;

rssn_
rssn_BincodeBuffer rssn_physics_sim_ising_run_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_physics_sim_ising_run_json(const char *aInput)
;

rssn_
rssn_BincodeBuffer rssn_physics_sim_linear_elasticity_run_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_physics_sim_linear_elasticity_run_json(const char *aInput)
;

/*
 Runs the 2D cantilever beam scenario and returns the displacement results as a Matrix handle (Nx2).
 */
rssn_
rssn_Matrix<double> *rssn_physics_sim_linear_elasticity_simulate_cantilever()
;

/*
 Frees the result handles.
 */
rssn_
void rssn_physics_sim_navier_stokes_free_results(rssn_NavierStokesResultHandles aHandles)
;

rssn_
rssn_BincodeBuffer rssn_physics_sim_navier_stokes_run_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_physics_sim_navier_stokes_run_json(const char *aInput)
;

/*
 Runs the lid-driven cavity simulation and returns handles to the U, V, and P matrices.
 */
rssn_
rssn_NavierStokesResultHandles rssn_physics_sim_navier_stokes_run_lid_driven_cavity(size_t aNx,
                                                                                    size_t aNy,
                                                                                    double aRe,
                                                                                    double aDt,
                                                                                    size_t aNIter,
                                                                                    double aLidVelocity)
;

/*
 Runs a Schrodinger simulation and returns the final probability density as a Matrix handle (NxxNy).
 */
rssn_
rssn_Matrix<double> *rssn_physics_sim_schrodinger_run_2d(size_t aNx,
                                                         size_t aNy,
                                                         double aLx,
                                                         double aLy,
                                                         double aDt,
                                                         size_t aTimeSteps,
                                                         double aHbar,
                                                         double aMass,
                                                         const double *aPotentialPtr,
                                                         const double *aInitialPsiRePtr,
                                                         const double *aInitialPsiImPtr)
;

rssn_
rssn_BincodeBuffer rssn_physics_sim_schrodinger_run_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_physics_sim_schrodinger_run_json(const char *aInput)
;

/*
 Simulates the 1D advection-diffusion scenario and returns the results as a Matrix handle (1xN).
 */
rssn_
rssn_Matrix<double> *rssn_physics_sm_simulate_1d_advection()
;

/*
 Simulates the 2D advection-diffusion scenario and returns the results as a Matrix handle (WxH).
 */
rssn_
rssn_Matrix<double> *rssn_physics_sm_simulate_2d_advection()
;

rssn_
char *rssn_physics_sm_solve_advection_1d_json(const char *aInput)
;

rssn_
rssn_BincodeBuffer rssn_physics_sm_solve_advection_2d_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_physics_sm_solve_advection_2d_json(const char *aInput)
;

/*
 Returns the symbolic representation of Pi.
 */
rssn_
rssn_Expr *rssn_pi()
;

/*
 Returns Pi as bincode.
 */
rssn_
rssn_BincodeBuffer rssn_pi_bincode()
;

/*
 Returns Pi as JSON.
 */
rssn_ char *rssn_pi_json() ;

/*
 Executes a command on a loaded plugin.

 # Arguments
 * `plugin_name_ptr` - A null-terminated UTF-8 string representing the plugin's name.
 * `command_ptr` - A null-terminated UTF-8 string for the command to execute.
 * `args_handle` - A handle to the `Expr` object to be passed as an argument.

 # Returns
 A handle to the resulting `Expr` object on success, or 0 on failure.
 On failure, an error message can be retrieved with `rssn_get_last_error`.
 */
rssn_
size_t rssn_plugin_execute(const char *aPluginNamePtr,
                           const char *aCommandPtr,
                           size_t aArgsHandle)
;

/*
 Executes a plugin command.

 # Arguments
 * `name` - Plugin name.
 * `command` - Command string.
 * `args_handle` - Handle to the argument expression.

 # Returns
 Handle to the result expression, or 0 on error.
 */
rssn_
size_t rssn_plugins_execute(const char *aName,
                            const char *aCommand,
                            size_t aArgsHandle)
;

/*
 Executes a plugin command via Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_plugins_execute_bincode(const uint8_t *aData,
                                                size_t aLen)
;

/*
 Executes a plugin command via JSON (args passed as JSON expr).
 */
rssn_
char *rssn_plugins_execute_json(const char *aJsonPtr)
;

/*
 Returns a JSON array of loaded plugin names.

 The caller must free the string using `rssn_free_string`.
 */
rssn_
char *rssn_plugins_get_loaded()
;

/*
 Loads plugins from a specified directory.

 # Arguments
 * `path` - Path to the plugin directory.

 # Returns
 True if successful, false otherwise.
 */
rssn_
bool rssn_plugins_load(const char *aPath)
;

/*
 Unloads a plugin by name.
 */
rssn_
bool rssn_plugins_unload(const char *aName)
;

/*
 Compresses a point. Returns the x-coordinate string. sets *is_odd to the parity.
 */
rssn_
char *rssn_point_compress(const rssn_CurvePoint *aPoint,
                          bool *aIsOddOut)
;

/*
 Decompresses a point.
 */
rssn_
rssn_CurvePoint *rssn_point_decompress(const char *aXStr,
                                       bool aIsOdd,
                                       const rssn_EllipticCurve *aCurve)
;

rssn_
rssn_Expr *rssn_poles_get(const rssn_Vec<rssn_Expr> *aPoles,
                          size_t aIndex)
;

rssn_
size_t rssn_poles_len(const rssn_Vec<rssn_Expr> *aPoles)
;

/*
 Adds two polynomials over a general finite field.

 # Safety
 Caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_poly_add_gf(const rssn_Expr *aP1,
                            const rssn_Expr *aP2,
                            const rssn_Arc<rssn_FiniteField> *aField)
;

/*
 Adds two polynomials over GF(2^8).

 # Safety
 Caller must ensure pointers are valid. Result is allocated and must be freed.
 */
rssn_
uint8_t *rssn_poly_add_gf256(const uint8_t *aP1,
                             size_t aP1Len,
                             const uint8_t *aP2,
                             size_t aP2Len,
                             size_t *aOutLen)
;

rssn_
int32_t rssn_poly_degree(size_t aExprHandle,
                         const char *aVarPtr,
                         int64_t *aResult)
;

/*
 Computes the formal derivative of a polynomial in GF(2^8).

 # Safety
 Caller must ensure pointer is valid. Result is allocated and must be freed.
 */
rssn_
uint8_t *rssn_poly_derivative_gf256(const uint8_t *aPoly,
                                    size_t aLen,
                                    size_t *aOutLen)
;

/*
 Computes polynomial derivative over finite field (Handle)
 */
rssn_
rssn_FiniteFieldPolynomial *rssn_poly_derivative_gf_handle(const rssn_FiniteFieldPolynomial *aPoly)
;

/*
 Evaluates a polynomial over GF(2^8) at point x.

 # Safety
 Caller must ensure `poly` is a valid pointer to an array of `len` bytes.
 */
rssn_
uint8_t rssn_poly_eval_gf256(const uint8_t *aPoly,
                             size_t aLen,
                             uint8_t aX)
;

/*
 Computes the GCD of two polynomials over GF(2^8).

 # Safety
 Caller must ensure pointers are valid. Result is allocated and must be freed.
 */
rssn_
uint8_t *rssn_poly_gcd_gf256(const uint8_t *aP1,
                             size_t aP1Len,
                             const uint8_t *aP2,
                             size_t aP2Len,
                             size_t *aOutLen)
;

/*
 Computes polynomial GCD over finite field (Handle)
 */
rssn_
rssn_FiniteFieldPolynomial *rssn_poly_gcd_gf_handle(const rssn_FiniteFieldPolynomial *aA,
                                                    const rssn_FiniteFieldPolynomial *aB)
;

rssn_
int32_t rssn_poly_is_polynomial(size_t aExprHandle,
                                const char *aVarPtr,
                                bool *aResult)
;

rssn_
int32_t rssn_poly_long_division(size_t aNHandle,
                                size_t aDHandle,
                                const char *aVarPtr,
                                size_t *aQHandle,
                                size_t *aRHandle)
;

/*
 Multiplies two polynomials over a general finite field.

 # Safety
 Caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_poly_mul_gf(const rssn_Expr *aP1,
                            const rssn_Expr *aP2,
                            const rssn_Arc<rssn_FiniteField> *aField)
;

/*
 Multiplies two polynomials over GF(2^8).

 # Safety
 Caller must ensure pointers are valid. Result is allocated and must be freed.
 */
rssn_
uint8_t *rssn_poly_mul_gf256(const uint8_t *aP1,
                             size_t aP1Len,
                             const uint8_t *aP2,
                             size_t aP2Len,
                             size_t *aOutLen)
;

/*
 Scales a polynomial by a constant in GF(2^8).

 # Safety
 Caller must ensure pointer is valid. Result is allocated and must be freed.
 */
rssn_
uint8_t *rssn_poly_scale_gf256(const uint8_t *aPoly,
                               size_t aLen,
                               uint8_t aScalar,
                               size_t *aOutLen)
;

/*
 Computes the symbolic Polygamma function ψ⁽ⁿ⁾(z).
 */
rssn_
rssn_Expr *rssn_polygamma(const rssn_Expr *aN,
                          const rssn_Expr *aZ)
;

/*
 Frees a polygon mesh.
 */
rssn_
void rssn_polygon_mesh_free(rssn_PolygonMesh *aMesh)
;

/*
 Creates a new polygon mesh.
 */
rssn_
rssn_PolygonMesh *rssn_polygon_mesh_new(const rssn_Vector *aVertices,
                                        size_t aVertexCount)
;

/*
 Triangulates a polygon mesh.
 */
rssn_
rssn_PolygonMesh *rssn_polygon_mesh_triangulate(const rssn_PolygonMesh *aMesh)
;

rssn_
rssn_Expr *rssn_polynomial_regression(const rssn_Expr *const *aXData,
                                      const rssn_Expr *const *aYData,
                                      size_t aLen,
                                      size_t aDegree)
;

/*
 Creates a power expression: base^exp.
 */
rssn_
rssn_Expr *rssn_pow(const rssn_Expr *aBase,
                    const rssn_Expr *aExp)
;

/*
 Creates a power expression from bincode: base^exp.

 # Arguments
 * `base_buffer` - Bincode-serialized base Expr
 * `exp_buffer` - Bincode-serialized exponent Expr
 */
rssn_
rssn_BincodeBuffer rssn_pow_bincode(rssn_BincodeBuffer aBaseBuffer,
                                    rssn_BincodeBuffer aExpBuffer)
;

/*
 Creates a power expression from JSON: base^exp.

 # Arguments
 * `json_base` - JSON-serialized base Expr
 * `json_exp` - JSON-serialized exponent Expr
 */
rssn_
char *rssn_pow_json(const char *aJsonBase,
                    const char *aJsonExp)
;

/*
 Calculates power: F . v.
 */
rssn_
rssn_Expr *rssn_power(const rssn_Vector *aForce,
                      const rssn_Vector *aVelocity)
;

/*
 Calculates the Poynting vector.
 */
rssn_
rssn_Vector *rssn_poynting_vector(const rssn_Vector *aEField,
                                  const rssn_Vector *aBField)
;

/*
 Adds two prime field elements (Handle)
 */
rssn_
rssn_PrimeFieldElement *rssn_prime_field_element_add_handle(const rssn_PrimeFieldElement *aA,
                                                            const rssn_PrimeFieldElement *aB)
;

/*
 Frees a prime field element (Handle)
 */
rssn_
void rssn_prime_field_element_free_handle(rssn_PrimeFieldElement *aElem)
;

/*
 Computes the inverse of a prime field element (Handle)
 */
rssn_
rssn_PrimeFieldElement *rssn_prime_field_element_inverse_handle(const rssn_PrimeFieldElement *aElem)
;

/*
 Multiplies two prime field elements (Handle)
 */
rssn_
rssn_PrimeFieldElement *rssn_prime_field_element_mul_handle(const rssn_PrimeFieldElement *aA,
                                                            const rssn_PrimeFieldElement *aB)
;

/*
 Creates a new prime field element (Handle)
 Returns a boxed pointer to the element
 */
rssn_
rssn_PrimeFieldElement *rssn_prime_field_element_new_handle(const rssn_BigInt *aValue,
                                                            const rssn_BigInt *aModulus)
;

/*
 Computes the probability density |ψ(x)|^2.
 */
rssn_
rssn_Expr *rssn_probability_density(const rssn_Ket *aPsi)
;

rssn_
rssn_Expr *rssn_product_handle(const rssn_Expr *aExpr,
                               const char *aVar,
                               const rssn_Expr *aLower,
                               const rssn_Expr *aUpper)
;

rssn_
rssn_Expr *rssn_project(const rssn_HilbertSpace *aSpace,
                        const rssn_Expr *aF,
                        const rssn_Expr *aG)
;

/*
 Lagrangian density for QCD.
 */
rssn_
rssn_Expr *rssn_qcd_lagrangian(const rssn_Expr *aPsiBar,
                               const rssn_Expr *aPsi,
                               const rssn_Expr *aGMu,
                               const rssn_Expr *aM,
                               const rssn_Expr *aGs)
;

/*
 Lagrangian density for QED.
 */
rssn_
rssn_Expr *rssn_qed_lagrangian(const rssn_Expr *aPsiBar,
                               const rssn_Expr *aPsi,
                               const rssn_Expr *aAMu,
                               const rssn_Expr *aM,
                               const rssn_Expr *aE)
;

/*
 Computes a propagator for a particle in QFT.
 */
rssn_
rssn_Expr *rssn_qft_propagator(const rssn_Expr *aP,
                               const rssn_Expr *aM,
                               bool aIsFermion)
;

/*
 Scattering cross-section.
 */
rssn_
rssn_Expr *rssn_qft_scattering_cross_section(const rssn_Expr *aMatrixElement,
                                             const rssn_Expr *aFlux,
                                             const rssn_Expr *aPhaseSpace)
;

/*
 Findings roots of a polynomial from coefficients.

 # Arguments
 * `coeffs_ptr` - Pointer to the coefficients array (f64).
 * `len` - Number of coefficients.
 * `tolerance` - The tolerance for root finding.

 # Returns
 A pointer to a `Vec<f64>` containing the sorted real roots, or null on error.
 */
rssn_
rssn_Vec<double> *rssn_real_roots_find_roots(const double *aCoeffsPtr,
                                             size_t aLen,
                                             double aTolerance)
;

rssn_
rssn_BincodeBuffer rssn_real_roots_find_roots_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
char *rssn_real_roots_find_roots_json(const char *aJsonPtr)
;

/*
 Frees a roots vector.
 */
rssn_
void rssn_real_roots_free_vec(rssn_Vec<double> *aPtr)
;

/*
 Gets the data of the roots vector.
 */
rssn_
void rssn_real_roots_get_vec_data(const rssn_Vec<double> *aPtr,
                                  double *aBuffer)
;

/*
 Gets the length of the roots vector.
 */
rssn_
size_t rssn_real_roots_get_vec_len(const rssn_Vec<double> *aPtr)
;

/*
 Generates a 3x3 2D reflection matrix across a line.
 */
rssn_
rssn_Expr *rssn_reflection_2d(const rssn_Expr *aAngle)
;

/*
 Generates a 4x4 3D reflection matrix across a plane.
 */
rssn_
rssn_Expr *rssn_reflection_3d(const rssn_Expr *aNx,
                              const rssn_Expr *aNy,
                              const rssn_Expr *aNz)
;

/*
 Computes the regularized lower incomplete gamma function P(a, x).
 */
rssn_
double rssn_regularized_gamma_p(double aA,
                                double aX)
;

/*
 Computes the regularized upper incomplete gamma function Q(a, x).
 */
rssn_
double rssn_regularized_gamma_q(double aA,
                                double aX)
;

/*
 Computes the regularized incomplete beta function Iₓ(a, b).
 */
rssn_
double rssn_regularized_incomplete_beta(double aA,
                                        double aB,
                                        double aX)
;

rssn_
rssn_Representation *rssn_representation_create(const rssn_Expr *const *aElementsPtr,
                                                size_t aElementsLen,
                                                const rssn_Expr *const *aKeysPtr,
                                                const rssn_Expr *const *aValuesPtr,
                                                size_t aMapLen)
;

rssn_
void rssn_representation_free(rssn_Representation *aPtr)
;

rssn_
bool rssn_representation_is_valid(const rssn_Representation *aRep,
                                  const rssn_Group *aGroup)
;

/*
 Frees a rewrite rule.

 # Safety
 The caller must ensure `rule` was created by this module and hasn't been freed yet.
 */
rssn_
void rssn_rewrite_rule_free(rssn_RewriteRule *aRule)
;

/*
 Gets the LHS of a rewrite rule.

 Returns a new owned Expr pointer that must be freed by the caller.

 # Safety
 The caller must ensure `rule` is a valid RewriteRule pointer.
 */
rssn_
rssn_Expr *rssn_rewrite_rule_get_lhs(const rssn_RewriteRule *aRule)
;

/*
 Gets the RHS of a rewrite rule.

 Returns a new owned Expr pointer that must be freed by the caller.

 # Safety
 The caller must ensure `rule` is a valid RewriteRule pointer.
 */
rssn_
rssn_Expr *rssn_rewrite_rule_get_rhs(const rssn_RewriteRule *aRule)
;

/*
 Creates a new rewrite rule from lhs and rhs expressions.

 # Safety
 The caller must ensure `lhs` and `rhs` are valid Expr pointers.
 */
rssn_
rssn_RewriteRule *rssn_rewrite_rule_new(const rssn_Expr *aLhs,
                                        const rssn_Expr *aRhs)
;

/*
 Creates a rewrite rule from Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_rewrite_rule_new_bincode(rssn_BincodeBuffer aInput)
;

/*
 Creates a rewrite rule from JSON.

 Input: JSON object with "lhs" and "rhs" fields (both Expr)
 Output: JSON-serialized RewriteRule
 */
rssn_
char *rssn_rewrite_rule_new_json(const char *aJsonStr)
;

/*
 Converts a rewrite rule to a string representation.

 The returned string must be freed using `rssn_free_string`.

 # Safety
 The caller must free the returned string.
 */
rssn_
char *rssn_rewrite_rule_to_string(const rssn_RewriteRule *aRule)
;

/*
 Converts a rewrite rule to a human-readable string (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_rewrite_rule_to_string_bincode(rssn_BincodeBuffer aInput)
;

/*
 Converts a rewrite rule to a human-readable string (JSON).

 Input: JSON-serialized RewriteRule
 Output: JSON object with "string" field
 */
rssn_
char *rssn_rewrite_rule_to_string_json(const char *aJsonStr)
;

/*
 Integrates an expression using the Risch-Norman algorithm (Handle)
 */
rssn_
rssn_Expr *rssn_risch_norman_integrate_handle(const rssn_Expr *aExpr,
                                              const char *aX)
;

/*
 Computes the rising factorial (Pochhammer symbol) (x)ₙ.
 */
rssn_
double rssn_rising_factorial(double aX,
                             uint32_t aN)
;

/*
 Generates a 3x3 2D rotation matrix.
 */
rssn_
rssn_Expr *rssn_rotation_2d(const rssn_Expr *aAngle)
;

/*
 Generates a 4x4 3D rotation matrix around the X-axis.
 */
rssn_
rssn_Expr *rssn_rotation_3d_x(const rssn_Expr *aAngle)
;

/*
 Generates a 4x4 3D rotation matrix around the Y-axis.
 */
rssn_
rssn_Expr *rssn_rotation_3d_y(const rssn_Expr *aAngle)
;

/*
 Generates a 4x4 3D rotation matrix around the Z-axis.
 */
rssn_
rssn_Expr *rssn_rotation_3d_z(const rssn_Expr *aAngle)
;

/*
 Generates a 4x4 3D rotation matrix around an arbitrary axis.
 */
rssn_
rssn_Expr *rssn_rotation_axis_angle(const rssn_Vector *aAxis,
                                    const rssn_Expr *aAngle)
;

/*
 Checks if a Reed-Solomon codeword is valid without attempting correction.

 # Safety
 Caller must ensure `codeword` points to `codeword_len` bytes.
 Returns 1 if valid, 0 if invalid, -1 on error.
 */
rssn_
int32_t rssn_rs_check(const uint8_t *aCodeword,
                      size_t aCodewordLen,
                      size_t aNSym)
;

/*
 Decodes a Reed-Solomon codeword, correcting errors if possible.

 # Safety
 Caller must ensure `codeword` is valid. Returns allocated memory that must be freed.
 */
rssn_
uint8_t *rssn_rs_decode(const uint8_t *aCodeword,
                        size_t aCodewordLen,
                        size_t aNSym,
                        size_t *aOutLen)
;

/*
 Encodes data using Reed-Solomon code with n_sym error correction symbols.

 # Safety
 Caller must ensure `data` is valid. Returns allocated memory that must be freed.
 */
rssn_
uint8_t *rssn_rs_encode(const uint8_t *aData,
                        size_t aDataLen,
                        size_t aNSym,
                        size_t *aOutLen)
;

/*
 Estimates the number of errors in a Reed-Solomon codeword.

 # Safety
 Caller must ensure `codeword` points to `codeword_len` bytes.
 Returns error count or -1 on error.
 */
rssn_
int32_t rssn_rs_error_count(const uint8_t *aCodeword,
                            size_t aCodewordLen,
                            size_t aNSym)
;

/*
 Frees memory allocated by rs_encode or rs_decode.

 # Safety
 Caller must ensure `ptr` was returned by rssn_rs_encode or rssn_rs_decode.
 */
rssn_
void rssn_rs_free(uint8_t *aPtr,
                  size_t aLen)
;

/*
 Frees a rules vector.

 # Safety
 The caller must ensure `rules` was created by this module and hasn't been freed yet.
 */
rssn_
void rssn_rules_vec_free(rssn_Vec<rssn_RewriteRule> *aRules)
;

/*
 Gets a rule from a rules vector by index.

 Returns a new owned RewriteRule pointer that must be freed by the caller.

 # Safety
 The caller must ensure `rules` is a valid Vec<RewriteRule> pointer.
 */
rssn_
rssn_RewriteRule *rssn_rules_vec_get(const rssn_Vec<rssn_RewriteRule> *aRules,
                                     size_t aIndex)
;

/*
 Gets the length of a rules vector.

 # Safety
 The caller must ensure `rules` is a valid Vec<RewriteRule> pointer.
 */
rssn_
size_t rssn_rules_vec_len(const rssn_Vec<rssn_RewriteRule> *aRules)
;

/*
 Lagrangian density for a free real scalar field.
 */
rssn_
rssn_Expr *rssn_scalar_field_lagrangian(const rssn_Expr *aPhi,
                                        const rssn_Expr *aM)
;

/*
 Generates a 3x3 2D scaling matrix.
 */
rssn_
rssn_Expr *rssn_scaling_2d(const rssn_Expr *aSx,
                           const rssn_Expr *aSy)
;

/*
 Generates a 4x4 3D scaling matrix.
 */
rssn_
rssn_Expr *rssn_scaling_3d(const rssn_Expr *aSx,
                           const rssn_Expr *aSy,
                           const rssn_Expr *aSz)
;

/*
 Scattering amplitude.
 */
rssn_
rssn_Expr *rssn_scattering_amplitude(const rssn_Ket *aInitialState,
                                     const rssn_Ket *aFinalState,
                                     const rssn_Operator *aPotential)
;

/*
 Calculates Schwarzschild radius.
 */
rssn_
rssn_Expr *rssn_schwarzschild_radius(const rssn_Expr *aMass)
;

rssn_
rssn_ConvergenceResult *rssn_series_analyze_convergence_handle(const rssn_Expr *aSeries,
                                                               const char *aVar)
;

rssn_
rssn_BincodeBuffer rssn_series_bincode_analyze_convergence(rssn_BincodeBuffer aSeriesBuf,
                                                           rssn_BincodeBuffer aVarBuf)
;

rssn_
char *rssn_series_json_analyze_convergence(const char *aSeriesJson,
                                           const char *aVarJson)
;

rssn_
rssn_Expr *rssn_shannon_entropy(const rssn_Expr *const *aProbs,
                                size_t aLen)
;

/*
 Generates a 3x3 2D shear matrix.
 */
rssn_
rssn_Expr *rssn_shear_2d(const rssn_Expr *aShx,
                         const rssn_Expr *aShy)
;

rssn_
rssn_Expr *rssn_simple_linear_regression(const rssn_Expr *const *aXData,
                                         const rssn_Expr *const *aYData,
                                         size_t aLen)
;

/*
 Creates a new Simplex (Handle)
 */
rssn_
rssn_Simplex *rssn_simplex_create(const size_t *aVerticesPtr,
                                  size_t aLen)
;

/*
 Gets the dimension of a Simplex
 */
rssn_
size_t rssn_simplex_dimension(const rssn_Simplex *aPtr)
;

/*
 Frees a Simplex handle
 */
rssn_
void rssn_simplex_free(rssn_Simplex *aPtr)
;

/*
 Adds a simplex to a SimplicialComplex
 */
rssn_
void rssn_simplicial_complex_add_simplex(rssn_SimplicialComplex *aComplexPtr,
                                         const size_t *aVerticesPtr,
                                         size_t aLen)
;

/*
 Applies the symbolic boundary operator to a SymbolicChain
 */
rssn_
rssn_SymbolicChain *rssn_simplicial_complex_apply_symbolic_boundary_operator(const rssn_SimplicialComplex *aComplexPtr,
                                                                             const rssn_SymbolicChain *aChainPtr)
;

/*
 Creates a new SimplicialComplex (Handle)
 */
rssn_
rssn_SimplicialComplex *rssn_simplicial_complex_create()
;

/*
 Gets the dimension of a SimplicialComplex
 */
rssn_
int rssn_simplicial_complex_dimension(const rssn_SimplicialComplex *aPtr)
;

/*
 Computes the Euler characteristic
 */
rssn_
ptrdiff_t rssn_simplicial_complex_euler_characteristic(const rssn_SimplicialComplex *aPtr)
;

/*
 Frees a SimplicialComplex handle
 */
rssn_
void rssn_simplicial_complex_free(rssn_SimplicialComplex *aPtr)
;

/*
 Gets the symbolic boundary matrix for dimension k
 */
rssn_
rssn_Expr *rssn_simplicial_complex_get_symbolic_boundary_matrix(const rssn_SimplicialComplex *aComplexPtr,
                                                                size_t aK)
;

/*
 Simplifies an expression using the legacy simplifier.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_
rssn_Expr *rssn_simplify(const rssn_Expr *aExpr)
;

/*
 Simplifies an expression using the DAG-based simplifier.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_
rssn_Expr *rssn_simplify_dag(const rssn_Expr *aExpr)
;

/*
 Simplifies a logical expression using handle-based FFI.

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_
rssn_Expr *rssn_simplify_logic_handle(const rssn_Expr *aExpr)
;

/*
 Simplifies radical expressions (Handle)
 */
rssn_
rssn_Expr *rssn_simplify_radicals_handle(const rssn_Expr *aExpr)
;

/*
 Creates a sine expression: sin(expr).

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_
rssn_Expr *rssn_sin(const rssn_Expr *aExpr)
;

/*
 Creates a sine expression from bincode: sin(expr).

 # Arguments
 * `expr_buffer` - Bincode-serialized Expr

 # Returns
 Bincode-serialized Expr
 */
rssn_
rssn_BincodeBuffer rssn_sin_bincode(rssn_BincodeBuffer aExprBuffer)
;

/*
 Creates a sine expression from JSON: sin(expr).

 # Arguments
 * `json_expr` - JSON-serialized Expr

 # Returns
 JSON-serialized Expr or null on error
 */
rssn_
char *rssn_sin_json(const char *aJsonExpr)
;

/*
 Computes the normalized sinc function sin(πx)/(πx).
 */
rssn_
double rssn_sinc(double aX)
;

rssn_
rssn_Expr **rssn_so3_generators(size_t *aOutLen)
;

rssn_
int32_t rssn_solve(size_t aExprH,
                   const char *aVar,
                   size_t *aResultH)
;

/*
 Solves the airfoil singular integral equation.
 */
rssn_
rssn_Expr *rssn_solve_airfoil_equation(const rssn_Expr *aFX,
                                       const char *aVarX,
                                       const char *aVarT)
;

/*
 Solves the airfoil singular integral equation (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_solve_airfoil_equation_bincode(const uint8_t *aInputPtr,
                                                       size_t aInputLen)
;

/*
 Solves the airfoil singular integral equation (JSON).
 */
rssn_
char *rssn_solve_airfoil_equation_json(const char *aInputJson)
;

/*
 Solves a Bernoulli ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
rssn_Expr *rssn_solve_bernoulli_ode(const rssn_Expr *aEquation,
                                    const char *aFunc,
                                    const char *aVar)
;

/*
 Solves a second-order ODE by reduction of order with a known solution.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_by_reduction_of_order(const rssn_Expr *aEquation,
                                            const char *aFunc,
                                            const char *aVar,
                                            const rssn_Expr *aY1)
;

/*
 Solves a Cauchy-Euler ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
rssn_Expr *rssn_solve_cauchy_euler_ode(const rssn_Expr *aEquation,
                                       const char *aFunc,
                                       const char *aVar)
;

/*
 Solves a Diophantine equation.

 # Safety
 `equation` must be a valid pointer to an `Expr`.
 `vars_ptr` must be a valid pointer to an array of C strings of length `vars_len`.
 */
rssn_
rssn_Expr *rssn_solve_diophantine_handle(const rssn_Expr *aEquation,
                                         const char *const *aVarsPtr,
                                         int aVarsLen)
;

/*
 Generates and attempts to solve the Euler-Lagrange equation.

 # Safety
 The caller must ensure `lagrangian` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
rssn_Expr *rssn_solve_euler_lagrange(const rssn_Expr *aLagrangian,
                                     const char *aFunc,
                                     const char *aVar)
;

/*
 Solves an exact ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
rssn_Expr *rssn_solve_exact_ode(const rssn_Expr *aEquation,
                                const char *aFunc,
                                const char *aVar)
;

/*
 Solves a first-order linear ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
rssn_Expr *rssn_solve_first_order_linear_ode(const rssn_Expr *aEquation,
                                             const char *aFunc,
                                             const char *aVar)
;

rssn_
rssn_Vec<rssn_Expr> *rssn_solve_handle(const rssn_Expr *aExpr,
                                       const char *aVar)
;

/*
 Solves the 1D heat equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_heat_equation_1d(const rssn_Expr *aEquation,
                                       const char *aFunc,
                                       const char *const *aVars,
                                       size_t aVarsLen)
;

/*
 Solves the Helmholtz equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_helmholtz_equation(const rssn_Expr *aEquation,
                                         const char *aFunc,
                                         const char *const *aVars,
                                         size_t aVarsLen)
;

/*
 Solves the Klein-Gordon equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_klein_gordon_equation(const rssn_Expr *aEquation,
                                            const char *aFunc,
                                            const char *const *aVars,
                                            size_t aVarsLen)
;

/*
 Solves the 2D Laplace equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_laplace_equation_2d(const rssn_Expr *aEquation,
                                          const char *aFunc,
                                          const char *const *aVars,
                                          size_t aVarsLen)
;

/*
 Bincode FFI for solving linear systems.
 */
rssn_
rssn_BincodeBuffer rssn_solve_linear_system_bincode(rssn_BincodeBuffer aBuffer)
;

rssn_
rssn_Vec<rssn_Expr> *rssn_solve_linear_system_handle(const rssn_Expr *aSystem,
                                                     const rssn_Vec<rssn_String> *aVars)
;

/*
 JSON FFI for solving linear systems.
 */
rssn_
char *rssn_solve_linear_system_json(const char *aJsonPtr)
;

/*
 Solves an ordinary differential equation.

 # Safety
 The caller must ensure `ode_expr` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
rssn_Expr *rssn_solve_ode(const rssn_Expr *aOdeExpr,
                          const char *aFunc,
                          const char *aVar)
;

/*
 Solves a partial differential equation using automatic method selection.

 # Safety
 The caller must ensure `pde_expr` is a valid Expr pointer, `func` and `vars` are valid C strings,
 and `vars_len` accurately represents the number of variables.
 */
rssn_
rssn_Expr *rssn_solve_pde(const rssn_Expr *aPdeExpr,
                          const char *aFunc,
                          const char *const *aVars,
                          size_t aVarsLen)
;

/*
 Solves a PDE using the method of characteristics.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_pde_by_characteristics(const rssn_Expr *aEquation,
                                             const char *aFunc,
                                             const char *const *aVars,
                                             size_t aVarsLen)
;

/*
 Solves the 2D Poisson equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_poisson_equation_2d(const rssn_Expr *aEquation,
                                          const char *aFunc,
                                          const char *const *aVars,
                                          size_t aVarsLen)
;

/*
 Solves a Riccati ODE with a known particular solution.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_riccati_ode(const rssn_Expr *aEquation,
                                  const char *aFunc,
                                  const char *aVar,
                                  const rssn_Expr *aY1)
;

/*
 Solves the Schrödinger equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_schrodinger_equation(const rssn_Expr *aEquation,
                                           const char *aFunc,
                                           const char *const *aVars,
                                           size_t aVarsLen)
;

/*
 Solves a separable ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
rssn_Expr *rssn_solve_separable_ode(const rssn_Expr *aEquation,
                                    const char *aFunc,
                                    const char *aVar)
;

/*
 Solves the 1D wave equation using D'Alembert's formula.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_wave_equation_1d_dalembert(const rssn_Expr *aEquation,
                                                 const char *aFunc,
                                                 const char *const *aVars,
                                                 size_t aVarsLen)
;

/*
 Spin operator S = hbar/2 * σ.
 */
rssn_
rssn_Expr *rssn_spin_operator(const rssn_Expr *aPauli)
;

/*
 Creates a square root expression: sqrt(expr).
 */
rssn_
rssn_Expr *rssn_sqrt(const rssn_Expr *aExpr)
;

/*
 Creates a square root expression from bincode: sqrt(expr).
 */
rssn_
rssn_BincodeBuffer rssn_sqrt_bincode(rssn_BincodeBuffer aExprBuffer)
;

/*
 Creates a square root expression from JSON: sqrt(expr).
 */
rssn_
char *rssn_sqrt_json(const char *aJsonExpr)
;

/*
 Frees a State.
 */
rssn_
void rssn_state_free(rssn_State *aState)
;

/*
 Gets the intermediate value from the state.
 The returned string must be freed by the caller using rssn_free_string.
 */
rssn_
char *rssn_state_get_intermediate_value(const rssn_State *aState)
;

/*
 Gets the intermediate value from a bincode state buffer.
 Returns the value as a bincode buffer containing a String.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
rssn_BincodeBuffer rssn_state_get_intermediate_value_bincode(rssn_BincodeBuffer aStateBuffer)
;

/*
 Gets the intermediate value from a JSON state string.
 Returns the value as a plain string (not JSON-encoded).
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_state_get_intermediate_value_json(const char *aJsonState)
;

/*
 Creates a new State.
 The caller is responsible for freeing the memory using rssn_state_free.
 */
rssn_
rssn_State *rssn_state_new()
;

/*
 Creates a new State and returns it as a bincode buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
rssn_BincodeBuffer rssn_state_new_bincode()
;

/*
 Creates a new State and returns it as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_state_new_json()
;

/*
 Sets the intermediate value in the state.
 */
rssn_
void rssn_state_set_intermediate_value(rssn_State *aState,
                                       const char *aValue)
;

/*
 Sets the intermediate value in a bincode state buffer and returns the updated buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
rssn_BincodeBuffer rssn_state_set_intermediate_value_bincode(rssn_BincodeBuffer aStateBuffer,
                                                             rssn_BincodeBuffer aValueBuffer)
;

/*
 Sets the intermediate value in a JSON state string and returns the updated JSON.
 The caller must free the returned string using rssn_free_string.
 */
rssn_
char *rssn_state_set_intermediate_value_json(const char *aJsonState,
                                             const char *aValue)
;

rssn_
int32_t rssn_stats_covariance(const double *aD1,
                              const double *aD2,
                              size_t aLen,
                              double *aResult)
;

rssn_
int32_t rssn_stats_mean(const double *aData,
                        size_t aLen,
                        double *aResult)
;

rssn_
int32_t rssn_stats_std_dev(const double *aData,
                           size_t aLen,
                           double *aResult)
;

rssn_
int32_t rssn_stats_variance(const double *aData,
                            size_t aLen,
                            double *aResult)
;

/*
 Computes the symbolic standard deviation of a set of expressions.

 # Safety
 The caller must ensure `data` is a valid pointer to an array of `Expr` pointers of size `len`.
 */
rssn_
rssn_Expr *rssn_std_dev(const rssn_Expr *const *aData,
                        size_t aLen)
;

rssn_
rssn_Expr *rssn_stirling_number_second_kind(size_t aN,
                                            size_t aK)
;

/*
 Represents Stokes' theorem (Handle)
 */
rssn_
rssn_Expr *rssn_stokes_theorem_handle(const rssn_Vector *aVectorFieldPtr,
                                      const rssn_Expr *aSurfacePtr)
;

/*
 Generates the Sturm sequence for a given polynomial (Handle)
 */
rssn_
rssn_Vec<rssn_Expr> *rssn_sturm_sequence_handle(const rssn_Expr *aExprPtr,
                                                const char *aVarPtr)
;

rssn_
rssn_Expr **rssn_su2_generators(size_t *aOutLen)
;

/*
 Substitutes a variable with an expression.
 */
rssn_
rssn_Expr *rssn_substitute(const rssn_Expr *aExpr,
                           const char *aVar,
                           const rssn_Expr *aReplacement)
;

rssn_
rssn_Expr *rssn_summation_handle(const rssn_Expr *aExpr,
                                 const char *aVar,
                                 const rssn_Expr *aLower,
                                 const rssn_Expr *aUpper)
;

/*
 Computes the surface integral (flux) of a vector field.
 */
rssn_
char *rssn_surface_integral(const char *aFieldX,
                            const char *aFieldY,
                            const char *aFieldZ,
                            const rssn_ParametricSurface *aSurface)
;

/*
 Computes the surface integral (flux) of a vector field (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_surface_integral_bincode(const uint8_t *aInputPtr,
                                                 size_t aInputLen)
;

/*
 Computes the surface integral (flux) of a vector field (JSON).
 */
rssn_
char *rssn_surface_integral_json(const char *aInputJson)
;

/*
 Adds a term to a SymbolicChain
 */
rssn_
bool rssn_symbolic_chain_add_term(rssn_SymbolicChain *aChainPtr,
                                  const rssn_Simplex *aSimplexPtr,
                                  const rssn_Expr *aCoeffPtr)
;

/*
 Creates a new SymbolicChain (Handle)
 */
rssn_
rssn_SymbolicChain *rssn_symbolic_chain_create(size_t aDimension)
;

/*
 Frees a SymbolicChain handle
 */
rssn_
void rssn_symbolic_chain_free(rssn_SymbolicChain *aPtr)
;

rssn_
rssn_Group *rssn_symmetric_group_create(size_t aN)
;

/*
 Creates a tangent expression: tan(expr).
 */
rssn_
rssn_Expr *rssn_tan(const rssn_Expr *aExpr)
;

/*
 Creates a tangent expression from bincode: tan(expr).
 */
rssn_
rssn_BincodeBuffer rssn_tan_bincode(rssn_BincodeBuffer aExprBuffer)
;

/*
 Creates a tangent expression from JSON: tan(expr).
 */
rssn_
char *rssn_tan_json(const char *aJsonExpr)
;

rssn_
rssn_Expr *rssn_taylor_series_handle(const rssn_Expr *aExpr,
                                     const char *aVar,
                                     const rssn_Expr *aCenter,
                                     size_t aOrder)
;

rssn_
rssn_Tensor *rssn_tensor_add_handle(const rssn_Tensor *aT1,
                                    const rssn_Tensor *aT2)
;

rssn_
rssn_Tensor *rssn_tensor_contract_handle(const rssn_Tensor *aT,
                                         size_t aAxis1,
                                         size_t aAxis2)
;

rssn_
rssn_Tensor *rssn_tensor_outer_product_handle(const rssn_Tensor *aT1,
                                              const rssn_Tensor *aT2)
;

rssn_
rssn_Tensor *rssn_tensor_scalar_mul_handle(const rssn_Tensor *aT,
                                           const rssn_Expr *aScalar)
;

/*
 Allocates and returns a test string ("pong") to the caller.

 This function serves as a more advanced health check for the FFI interface.
 It allows the client to verify two things:
 1. That the FFI function can be called successfully.
 2. That memory allocated in Rust can be safely passed to and then freed by the client
    by calling `free_string` on the returned pointer.

 Returns a pointer to a null-terminated C string. The caller is responsible for freeing this string.
 */
rssn_
char *rssn_test_string_passing()
;

/*
 Time-dependent Schrödinger equation.
 */
rssn_
rssn_Expr *rssn_time_dependent_schrodinger_equation(const rssn_Operator *aHamiltonian,
                                                    const rssn_Ket *aWaveFunction)
;

/*
 Converts a logical expression to Conjunctive Normal Form (CNF) using handle-based FFI.

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_
rssn_Expr *rssn_to_cnf_handle(const rssn_Expr *aExpr)
;

/*
 Converts a logical expression to Disjunctive Normal Form (DNF) using handle-based FFI.

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_
rssn_Expr *rssn_to_dnf_handle(const rssn_Expr *aExpr)
;

/*
 Calculates torque: r x F.
 */
rssn_
rssn_Vector *rssn_torque(const rssn_Vector *aR,
                         const rssn_Vector *aForce)
;

rssn_
rssn_Vec<rssn_Expr> *rssn_transform_contravariant_vector_handle(const rssn_Vec<rssn_Expr> *aComps,
                                                                rssn_CoordinateSystem aFrom,
                                                                rssn_CoordinateSystem aTo)
;

rssn_
rssn_Vec<rssn_Expr> *rssn_transform_covariant_vector_handle(const rssn_Vec<rssn_Expr> *aComps,
                                                            rssn_CoordinateSystem aFrom,
                                                            rssn_CoordinateSystem aTo)
;

rssn_
rssn_Vec<rssn_Expr> *rssn_transform_curl_handle(const rssn_Vec<rssn_Expr> *aComps,
                                                rssn_CoordinateSystem aFrom)
;

rssn_
rssn_Expr *rssn_transform_divergence_handle(const rssn_Vec<rssn_Expr> *aComps,
                                            rssn_CoordinateSystem aFrom)
;

rssn_
rssn_Expr *rssn_transform_expression_handle(const rssn_Expr *aExpr,
                                            rssn_CoordinateSystem aFrom,
                                            rssn_CoordinateSystem aTo)
;

rssn_
rssn_Vec<rssn_Expr> *rssn_transform_gradient_handle(const rssn_Expr *aScalar,
                                                    const rssn_Vec<rssn_String> *aVars,
                                                    rssn_CoordinateSystem aFrom,
                                                    rssn_CoordinateSystem aTo)
;

rssn_
rssn_Vec<rssn_Expr> *rssn_transform_point_handle(const rssn_Vec<rssn_Expr> *aPoint,
                                                 rssn_CoordinateSystem aFrom,
                                                 rssn_CoordinateSystem aTo)
;

/*
 Generates a 3x3 2D translation matrix.

 # Safety
 All Expr pointers must be valid.
 */
rssn_
rssn_Expr *rssn_translation_2d(const rssn_Expr *aTx,
                               const rssn_Expr *aTy)
;

/*
 Generates a 4x4 3D translation matrix.
 */
rssn_
rssn_Expr *rssn_translation_3d(const rssn_Expr *aTx,
                               const rssn_Expr *aTy,
                               const rssn_Expr *aTz)
;

rssn_
rssn_Expr *rssn_two_sample_t_test(const rssn_Expr *const *aData1,
                                  size_t aLen1,
                                  const rssn_Expr *const *aData2,
                                  size_t aLen2,
                                  const rssn_Expr *aMuDiff)
;

/*
 Computes the uncertainty ΔA.
 */
rssn_
rssn_Expr *rssn_uncertainty(const rssn_Operator *aOp,
                            const rssn_Ket *aPsi)
;

rssn_
rssn_Expr *rssn_unify_expression_handle(const rssn_Expr *aExpr)
;

/*
 Computes the symbolic variance of a set of expressions.

 # Safety
 The caller must ensure `data` is a valid pointer to an array of `Expr` pointers of size `len`.
 */
rssn_
rssn_Expr *rssn_variance(const rssn_Expr *const *aData,
                         size_t aLen)
;

/*
 Bincode FFI for vec_add.
 */
rssn_
rssn_BincodeBuffer rssn_vec_add_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for vec_add.
 */
rssn_
char *rssn_vec_add_json(const char *aJsonPtr)
;

/*
 Bincode FFI for angle.
 */
rssn_
rssn_BincodeBuffer rssn_vec_angle_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for angle.
 */
rssn_
char *rssn_vec_angle_json(const char *aJsonPtr)
;

/*
 Bincode FFI for cosine_similarity.
 */
rssn_
rssn_BincodeBuffer rssn_vec_cosine_similarity_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for cosine_similarity.
 */
rssn_
char *rssn_vec_cosine_similarity_json(const char *aJsonPtr)
;

/*
 Bincode FFI for cross_product.
 */
rssn_
rssn_BincodeBuffer rssn_vec_cross_product_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for cross_product.
 */
rssn_
char *rssn_vec_cross_product_json(const char *aJsonPtr)
;

/*
 Bincode FFI for distance.
 */
rssn_
rssn_BincodeBuffer rssn_vec_distance_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for distance.
 */
rssn_
char *rssn_vec_distance_json(const char *aJsonPtr)
;

/*
 Computes the dot product of two vectors.
 */
rssn_
int32_t rssn_vec_dot_product(const double *aD1,
                             size_t aL1,
                             const double *aD2,
                             size_t aL2,
                             double *aResult)
;

/*
 Bincode FFI for dot_product.
 */
rssn_
rssn_BincodeBuffer rssn_vec_dot_product_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for dot_product.
 */
rssn_
char *rssn_vec_dot_product_json(const char *aJsonPtr)
;

/*
 Bincode FFI for is_orthogonal.
 */
rssn_
rssn_BincodeBuffer rssn_vec_is_orthogonal_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for is_orthogonal.
 */
rssn_
char *rssn_vec_is_orthogonal_json(const char *aJsonPtr)
;

/*
 Bincode FFI for is_parallel.
 */
rssn_
rssn_BincodeBuffer rssn_vec_is_parallel_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for is_parallel.
 */
rssn_
char *rssn_vec_is_parallel_json(const char *aJsonPtr)
;

/*
 Bincode FFI for lerp.
 */
rssn_
rssn_BincodeBuffer rssn_vec_lerp_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for lerp.
 */
rssn_
char *rssn_vec_lerp_json(const char *aJsonPtr)
;

/*
 Bincode FFI for lp_norm.
 */
rssn_
rssn_BincodeBuffer rssn_vec_lp_norm_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for lp_norm.
 */
rssn_
char *rssn_vec_lp_norm_json(const char *aJsonPtr)
;

/*
 Computes the L2 norm of a vector.
 */
rssn_
int32_t rssn_vec_norm(const double *aData,
                      size_t aLen,
                      double *aResult)
;

/*
 Bincode FFI for norm.
 */
rssn_
rssn_BincodeBuffer rssn_vec_norm_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for norm ($L_2$).
 */
rssn_
char *rssn_vec_norm_json(const char *aJsonPtr)
;

/*
 Bincode FFI for normalize.
 */
rssn_
rssn_BincodeBuffer rssn_vec_normalize_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for normalize.
 */
rssn_
char *rssn_vec_normalize_json(const char *aJsonPtr)
;

/*
 Bincode FFI for project.
 */
rssn_
rssn_BincodeBuffer rssn_vec_project_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for project.
 */
rssn_
char *rssn_vec_project_json(const char *aJsonPtr)
;

/*
 Bincode FFI for reflect.
 */
rssn_
rssn_BincodeBuffer rssn_vec_reflect_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for reflect.
 */
rssn_
char *rssn_vec_reflect_json(const char *aJsonPtr)
;

/*
 Bincode FFI for scalar_mul.
 */
rssn_
rssn_BincodeBuffer rssn_vec_scalar_mul_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for scalar_mul.
 */
rssn_
char *rssn_vec_scalar_mul_json(const char *aJsonPtr)
;

/*
 Bincode FFI for vec_sub.
 */
rssn_
rssn_BincodeBuffer rssn_vec_sub_bincode(rssn_BincodeBuffer aBuffer)
;

/*
 JSON FFI for vec_sub.
 */
rssn_
char *rssn_vec_sub_json(const char *aJsonPtr)
;

rssn_
rssn_Vector *rssn_vector_cross_handle(const rssn_Vector *aV1,
                                      const rssn_Vector *aV2)
;

rssn_
rssn_Expr *rssn_vector_dot_handle(const rssn_Vector *aV1,
                                  const rssn_Vector *aV2)
;

/*
 Frees a Vector.
 */
rssn_
void rssn_vector_free(rssn_Vector *aVec)
;

rssn_
rssn_Expr *rssn_vector_magnitude_handle(const rssn_Vector *aV)
;

rssn_
rssn_Vector *rssn_vector_normalize_handle(const rssn_Vector *aV)
;

/*
 Verifies a definite integral (Handle)
 */
rssn_
bool rssn_verify_definite_integral_handle(const rssn_Expr *aIntegrandPtr,
                                          const char *aVarPtr,
                                          double aLower,
                                          double aUpper,
                                          const rssn_Expr *aSymbolicResultPtr)
;

/*
 Verifies a derivative (Handle)
 */
rssn_
bool rssn_verify_derivative_handle(const rssn_Expr *aOriginalFuncPtr,
                                   const rssn_Expr *aDerivativeFuncPtr,
                                   const char *aVarPtr)
;

/*
 Verifies an equation solution (Handle)
 */
rssn_
bool rssn_verify_equation_solution_handle(const rssn_Expr *const *aEquationsPtr,
                                          int aEquationsLen,
                                          const char *const *aSolVarsPtr,
                                          const rssn_Expr *const *aSolExprsPtr,
                                          int aSolLen,
                                          const char *const *aFreeVarsPtr,
                                          int aFreeVarsLen)
;

/*
 Verifies an indefinite integral (Handle)
 */
rssn_
bool rssn_verify_indefinite_integral_handle(const rssn_Expr *aIntegrandPtr,
                                            const rssn_Expr *aIntegralResultPtr,
                                            const char *aVarPtr)
;

/*
 Verifies a limit (Handle)
 */
rssn_
bool rssn_verify_limit_handle(const rssn_Expr *aFPtr,
                              const char *aVarPtr,
                              const rssn_Expr *aTargetPtr,
                              const rssn_Expr *aLimitValPtr)
;

/*
 Verifies a matrix inverse (Handle)
 */
rssn_
bool rssn_verify_matrix_inverse_handle(const rssn_Expr *aOriginalPtr,
                                       const rssn_Expr *aInversePtr)
;

/*
 Verifies an ODE solution (Handle)
 */
rssn_
bool rssn_verify_ode_solution_handle(const rssn_Expr *aOdePtr,
                                     const rssn_Expr *aSolutionPtr,
                                     const char *aFuncNamePtr,
                                     const char *aVarPtr)
;

/*
 Frees a Volterra integral equation.
 */
rssn_
void rssn_volterra_free(rssn_VolterraEquation *aPtr)
;

/*
 Creates a new Volterra integral equation.
 */
rssn_
rssn_VolterraEquation *rssn_volterra_new(const rssn_Expr *aYX,
                                         const rssn_Expr *aFX,
                                         const rssn_Expr *aLambda,
                                         const rssn_Expr *aKernel,
                                         const rssn_Expr *aLowerBound,
                                         const char *aVarX,
                                         const char *aVarT)
;

/*
 Solves a Volterra equation by differentiation.
 */
rssn_
rssn_Expr *rssn_volterra_solve_by_differentiation(const rssn_VolterraEquation *aEq)
;

/*
 Solves a Volterra equation by differentiation (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_volterra_solve_by_differentiation_bincode(const uint8_t *aInputPtr,
                                                                  size_t aInputLen)
;

/*
 Solves a Volterra equation by differentiation (JSON).
 */
rssn_
char *rssn_volterra_solve_by_differentiation_json(const char *aInputJson)
;

/*
 Solves a Volterra equation using successive approximations.
 */
rssn_
rssn_Expr *rssn_volterra_solve_successive(const rssn_VolterraEquation *aEq,
                                          size_t aIterations)
;

/*
 Solves a Volterra equation using successive approximations (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_volterra_solve_successive_bincode(const uint8_t *aInputPtr,
                                                          size_t aInputLen)
;

/*
 Solves a Volterra equation using successive approximations (JSON).
 */
rssn_
char *rssn_volterra_solve_successive_json(const char *aInputJson)
;

/*
 Frees a Volume handle.
 */
rssn_
void rssn_volume_free(rssn_Volume *aVolume)
;

/*
 Computes the volume integral of a scalar field.
 */
rssn_
char *rssn_volume_integral(const char *aScalarField,
                           const rssn_Volume *aVolume)
;

/*
 Computes the volume integral of a scalar field (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_volume_integral_bincode(const uint8_t *aInputPtr,
                                                size_t aInputLen)
;

/*
 Computes the volume integral of a scalar field (JSON).
 */
rssn_
char *rssn_volume_integral_json(const char *aInputJson)
;

/*
 Creates a new Volume.
 */
rssn_
rssn_Volume *rssn_volume_new(const char *aZLower,
                             const char *aZUpper,
                             const char *aYLower,
                             const char *aYUpper,
                             const char *aXLower,
                             const char *aXUpper,
                             const char *aXVar,
                             const char *aYVar,
                             const char *aZVar)
;

/*
 Computes the wedge product of two differential forms (Handle)
 */
rssn_
rssn_DifferentialForm *rssn_wedge_product_handle(const rssn_DifferentialForm *aForm1Ptr,
                                                 const rssn_DifferentialForm *aForm2Ptr)
;

/*
 Calculates work done by a variable force field along a path.
 */
rssn_
rssn_Expr *rssn_work_line_integral(const rssn_Vector *aForceField,
                                   const rssn_ParametricCurve *aPath)
;

rssn_
rssn_Expr *rssn_z_differentiation(const rssn_Expr *aFZ,
                                  const char *aOutVar)
;

rssn_
rssn_Expr *rssn_z_scaling(const rssn_Expr *aFZ,
                          const rssn_Expr *aA,
                          const char *aOutVar)
;

rssn_
rssn_Expr *rssn_z_test(const rssn_Expr *const *aData,
                       size_t aLen,
                       const rssn_Expr *aTargetMean,
                       const rssn_Expr *aPopStdDev)
;

rssn_
rssn_Expr *rssn_z_time_shift(const rssn_Expr *aFZ,
                             const rssn_Expr *aK,
                             const char *aOutVar)
;

rssn_
rssn_Expr *rssn_z_transform(const rssn_Expr *aExpr,
                            const char *aInVar,
                            const char *aOutVar)
;

/*
 Computes the symbolic Riemann zeta function ζ(s).
 */
rssn_
rssn_Expr *rssn_zeta(const rssn_Expr *aArg)
;

/*
 Computes the Riemann zeta function ζ(s).
 */
rssn_
double rssn_zeta_numerical(double aS)
;

rssn_
DEPRECATED_WITH_NOTE
char *stats_percentile(const char *aJsonPtr)
;

rssn_
DEPRECATED_WITH_NOTE
char *stats_simple_linear_regression(const char *aJsonPtr)
;

/*
 Computes the Fast Fourier Transform (FFT) of a sequence of complex numbers.
 */
rssn_
DEPRECATED_WITH_NOTE
char *transforms_fft(const char *aJsonPtr)
;

/*
 Computes the Inverse Fast Fourier Transform (IFFT) of a sequence of complex numbers.
 */
rssn_
DEPRECATED_WITH_NOTE
char *transforms_ifft(const char *aJsonPtr)
;

rssn_
DEPRECATED_WITH_NOTE
char *vector_scalar_mul(const char *aJsonPtr)
;

}  // extern "C"

}  // namespace rssn

#endif  // RSSN_H
