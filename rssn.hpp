#ifndef RSSN_H
#define RSSN_H

/* Generated with cbindgen:0.29.2 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <cstdarg>
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <ostream>
#include <new>

namespace rssn {

/*
 Represents the result of a convergence test.
 */
enum class rssn_ConvergenceResult {
    /*
     The series is determined to converge.
     */
    Converges,
    /*
     The series is determined to diverge.
     */
    Diverges,
    /*
     The convergence could not be determined with the available tests.
     */
    Inconclusive,
};

/*
 Defines the monomial ordering to be used in polynomial division.
 */
enum class rssn_MonomialOrder {
    Lexicographical,
    GradedLexicographical,
    GradedReverseLexicographical,
};

enum class rssn_CoordinateSystem {
    Cartesian,
    Cylindrical,
    Spherical,
};

/*
 Represents a Banach space, a complete normed vector space.

 This implementation specifically models L^p([a, b]), the space of functions for which
 the p-th power of their absolute value is Lebesgue integrable.
 */
struct rssn_BanachSpace;

/*
 Represents a complex dynamical system defined by z_{n+1} = f(z_n) + c.
 */
struct rssn_ComplexDynamicalSystem;

/*
 A thread-safe cache for computation results.

 This cache stores the mapping from expressions to their computed values.
 It avoids re-computing the value of the same expression multiple times.
 */
struct rssn_ComputationResultCache;

struct rssn_CriticalPoint;

/*
 Represents a differential k-form.

 A k-form is a mathematical object that can be integrated over a k-dimensional manifold.
 It is a sum of terms, where each term is a scalar function (coefficient) multiplied by
 a wedge product of k basis 1-forms (like dx, dy, etc.).

 For example, a 2-form in R^3 could be `f(x,y,z) dx^dy + g(x,y,z) dx^dz`.

 Here, the basis wedge products (e.g., `dx^dy`) are represented by a bitmask (`blade`).
 If `vars = ["x", "y", "z"]`, then `dx` is `1<<0`, `dy` is `1<<1`, `dz` is `1<<2`.
 The wedge product `dx^dy` corresponds to the bitmask `(1<<0) | (1<<1) = 3`.
 */
struct rssn_DifferentialForm;

/*
 The central enum representing a mathematical expression in the symbolic system.

 `Expr` is an Abstract Syntax Tree (AST) that can represent a wide variety of
 mathematical objects and operations. Manual implementations for `Debug`, `Clone`,
 `PartialEq`, `Eq`, and `Hash` are provided to handle variants containing types
 that do not derive these traits automatically (e.g., `f64`, `Arc<dyn Distribution>`).
 */
struct rssn_Expr;

struct rssn_FiniteFieldPolynomial;

/*
 Represents a Fredholm integral equation of the second kind.

 The equation has the form: `y(x) = f(x) + lambda * integral_a_b(K(x, t) * y(t) dt)`,
 where `y(x)` is the unknown function to be solved for.
 */
struct rssn_FredholmEquation;

/*
 Represents a group with its multiplication table.
 */
struct rssn_Group;

template<typename K = void, typename V = void, typename Hasher = void>
struct rssn_HashMap;

/*
 Represents a Hilbert space, a complete inner product space.
 This implementation specifically models L^2([a, b]), the space of square-integrable
 complex-valued functions on an interval [a, b].
 */
struct rssn_HilbertSpace;

/*
 Represents an Iterated Function System (IFS).

 An IFS is a finite set of contraction mappings on a complete metric space.
 It is often used to construct fractals (e.g., Sierpinski triangle, Barnsley fern).
 */
struct rssn_IteratedFunctionSystem;

/*
 Represents a Lie algebra, defined by its name and basis elements.
 */
struct rssn_LieAlgebra;

/*
 Represents common linear operators that act on functions in a vector space.
 */
struct rssn_LinearOperator;

/*
 Represents a Möbius transformation: f(z) = (az + b) / (cz + d)
 */
struct rssn_MobiusTransformation;

/*
 Represents a multivector in a Clifford algebra.

 The basis blades are represented by a bitmask. E.g., in 3D:
 001 (1) -> e1, 010 (2) -> e2, 100 (4) -> e3
 011 (3) -> e12, 101 (5) -> e13, 110 (6) -> e23
 111 (7) -> e123 (pseudoscalar)
 */
struct rssn_Multivector;

/*
 Represents a parameterized curve C given by r(t).
 */
struct rssn_ParametricCurve;

/*
 Represents a parameterized surface S given by r(u, v).
 */
struct rssn_ParametricSurface;

/*
 A thread-safe cache for parsed expressions.

 This cache stores the mapping from input strings to parsed `Expr` objects.
 It avoids re-parsing the same string multiple times.
 */
struct rssn_ParsingCache;

/*
 Represents the analytic continuation of a function along a path.
 It is stored as a chain of series expansions, each centered at a point on the path.
 */
struct rssn_PathContinuation;

/*
 Represents an element in a prime field GF(p), where p is the modulus.

 The value is stored as a `u64`, and all arithmetic operations are performed
 modulo the specified `modulus`.
 */
struct rssn_PrimeFieldElement;

/*
 Represents a group representation.
 */
struct rssn_Representation;

/*
 Represents a rewrite rule, e.g., `lhs -> rhs`.
 */
struct rssn_RewriteRule;

/*
 Represents a k-simplex as a set of its vertex indices.
 */
struct rssn_Simplex;

/*
 Represents a simplicial complex.
 */
struct rssn_SimplicialComplex;

/*
 Represents a singularity type in complex analysis.
 */
struct rssn_SingularityType;

/*
 Represents a sparse multivariate polynomial.

 A sparse polynomial is stored as a map from `Monomial`s to their `Expr` coefficients.
 This representation is highly efficient for polynomials with a small number of non-zero
 terms relative to the degree, such as `x^1000 + 1`.
 */
struct rssn_SparsePolynomial;

/*
 Represents the state of a computation.

 This struct holds intermediate values and other context information
 required during a computation.
 */
struct rssn_State;

struct rssn_String;

/*
 Represents a k-chain as a formal linear combination of k-simplices (symbolic version).
 */
struct rssn_SymbolicChain;

struct rssn_Tensor;

template<typename T = void>
struct rssn_Vec;

/*
 Represents a symbolic vector in 3D space.
 */
struct rssn_Vector;

/*
 Represents a Volterra integral equation of the second kind.

 The equation has the form: `y(x) = f(x) + lambda * integral_a_x(K(x, t) * y(t) dt)`.
 It is similar to the Fredholm equation, but the upper limit of integration is the variable `x`.
 */
struct rssn_VolterraEquation;

/*
 Represents a volume V for triple integration.
 Defines the integration order as dz dy dx.
 */
struct rssn_Volume;

/*
 A buffer containing binary data from bincode serialization.

 The caller is responsible for freeing this buffer using `rssn_free_bincode_buffer`.
 */
struct rssn_BincodeBuffer {
    /*
     Pointer to the binary data.
     */
    uint8_t *mData;
    /*
     Length of the binary data in bytes.
     */
    size_t mLen;
};

/*
 Opaque type for Graph<String> to work with cbindgen
 */
struct rssn_RssnGraph {
    uint8_t mPrivate[0];
};

struct rssn_FfiPoint {
    double mX;
    double mY;
};

extern "C" {

rssn_
rssn_Expr *calculate_residue(const rssn_Expr *aFunc,
                             const char *aVar,
                             const rssn_Expr *aSingularity)
;

rssn_
rssn_BincodeBuffer calculate_residue_bincode(rssn_BincodeBuffer aFuncBincode,
                                             const char *aVar,
                                             rssn_BincodeBuffer aSingularityBincode)
;

rssn_
char *calculate_residue_json(const char *aFuncJson,
                             const char *aVar,
                             const char *aSingularityJson)
;

rssn_
rssn_Expr *cauchy_derivative_formula(const rssn_Expr *aFunc,
                                     const char *aVar,
                                     const rssn_Expr *aZ0,
                                     size_t aN)
;

rssn_
rssn_BincodeBuffer cauchy_derivative_formula_bincode(rssn_BincodeBuffer aFuncBincode,
                                                     const char *aVar,
                                                     rssn_BincodeBuffer aZ0Bincode,
                                                     size_t aN)
;

rssn_
char *cauchy_derivative_formula_json(const char *aFuncJson,
                                     const char *aVar,
                                     const char *aZ0Json,
                                     size_t aN)
;

rssn_
rssn_Expr *cauchy_integral_formula(const rssn_Expr *aFunc,
                                   const char *aVar,
                                   const rssn_Expr *aZ0)
;

rssn_
rssn_BincodeBuffer cauchy_integral_formula_bincode(rssn_BincodeBuffer aFuncBincode,
                                                   const char *aVar,
                                                   rssn_BincodeBuffer aZ0Bincode)
;

rssn_
char *cauchy_integral_formula_json(const char *aFuncJson,
                                   const char *aVar,
                                   const char *aZ0Json)
;

rssn_
rssn_SingularityType *classify_singularity(const rssn_Expr *aFunc,
                                           const char *aVar,
                                           const rssn_Expr *aSingularity,
                                           size_t aOrder)
;

rssn_
rssn_BincodeBuffer classify_singularity_bincode(rssn_BincodeBuffer aFuncBincode,
                                                const char *aVar,
                                                rssn_BincodeBuffer aSingularityBincode,
                                                size_t aOrder)
;

rssn_
char *classify_singularity_json(const char *aFuncJson,
                                const char *aVar,
                                const char *aSingularityJson,
                                size_t aOrder)
;

rssn_ rssn_Expr *complex_arg(const rssn_Expr *aZ) ;

rssn_ rssn_BincodeBuffer complex_arg_bincode(rssn_BincodeBuffer aZBincode) ;

rssn_ char *complex_arg_json(const char *aZJson) ;

rssn_ double complex_distance(const rssn_Expr *aP1, const rssn_Expr *aP2) ;

rssn_
double complex_distance_bincode(rssn_BincodeBuffer aP1Bincode,
                                rssn_BincodeBuffer aP2Bincode)
;

rssn_ double complex_distance_json(const char *aP1Json, const char *aP2Json) ;

rssn_ rssn_Expr *complex_exp(const rssn_Expr *aZ) ;

rssn_ rssn_BincodeBuffer complex_exp_bincode(rssn_BincodeBuffer aZBincode) ;

rssn_ char *complex_exp_json(const char *aZJson) ;

rssn_ rssn_Expr *complex_log(const rssn_Expr *aZ) ;

rssn_ rssn_BincodeBuffer complex_log_bincode(rssn_BincodeBuffer aZBincode) ;

rssn_ char *complex_log_json(const char *aZJson) ;

rssn_ rssn_Expr *complex_modulus(const rssn_Expr *aZ) ;

rssn_ rssn_BincodeBuffer complex_modulus_bincode(rssn_BincodeBuffer aZBincode) ;

rssn_ char *complex_modulus_json(const char *aZJson) ;

rssn_
rssn_Expr *contour_integral_residue_theorem(const rssn_Expr *aFunc,
                                            const char *aVar,
                                            const rssn_Expr *const *aSingularities,
                                            size_t aSingularitiesLen)
;

rssn_
rssn_BincodeBuffer contour_integral_residue_theorem_bincode(rssn_BincodeBuffer aFuncBincode,
                                                            const char *aVar,
                                                            rssn_BincodeBuffer aSingularitiesBincode)
;

rssn_
char *contour_integral_residue_theorem_json(const char *aFuncJson,
                                            const char *aVar,
                                            const char *aSingularitiesJson)
;

rssn_
double estimate_radius_of_convergence(const rssn_Expr *aSeriesExpr,
                                      const char *aVar,
                                      const rssn_Expr *aCenter,
                                      size_t aOrder)
;

rssn_
double estimate_radius_of_convergence_bincode(rssn_BincodeBuffer aSeriesExprBincode,
                                              const char *aVar,
                                              rssn_BincodeBuffer aCenterBincode,
                                              size_t aOrder)
;

rssn_
double estimate_radius_of_convergence_json(const char *aSeriesExprJson,
                                           const char *aVar,
                                           const char *aCenterJson,
                                           size_t aOrder)
;

/*
 Computes the definite integral of an `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *expr_definite_integrate(rssn_Expr *aHandle,
                                   const char *aVarPtr,
                                   rssn_Expr *aLowerHandle,
                                   rssn_Expr *aUpperHandle)
;

/*
 Differentiates an `Expr` and returns a handle to the new, derivative expression.
 */
rssn_ DEPRECATED_WITH_NOTE rssn_Expr *expr_differentiate(rssn_Expr *aHandle, const char *aVarPtr) ;

/*
 Computes the indefinite integral of an `Expr` and returns a handle to the new expression.
 */
rssn_ DEPRECATED_WITH_NOTE rssn_Expr *expr_integrate(rssn_Expr *aHandle, const char *aVarPtr) ;

/*
 Computes the limit of an `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *expr_limit(rssn_Expr *aHandle,
                      const char *aVarPtr,
                      rssn_Expr *aToHandle)
;

/*
 Simplifies an `Expr` and returns a handle to the new, simplified expression.

 The caller is responsible for freeing the returned handle using `expr_free`.
 */
rssn_ DEPRECATED_WITH_NOTE rssn_Expr *expr_simplify(rssn_Expr *aHandle) ;

/*
 Solves an equation for a given variable and returns the solutions as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *expr_solve(rssn_Expr *aHandle, const char *aVarPtr) ;

/*
 Substitutes a variable in an `Expr` with another `Expr` and returns a handle to the new expression.
 */
rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *expr_substitute(rssn_Expr *aHandle,
                           const char *aVarPtr,
                           rssn_Expr *aReplacementHandle)
;

/*
 Converts an expression to a LaTeX string.

 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_ char *expr_to_latex(rssn_Expr *aHandle) ;

/*
 Converts an expression to a formatted, pretty-printed string.

 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_ char *expr_to_pretty_string(rssn_Expr *aHandle) ;

/*
 Returns the string representation of an `Expr` handle.

 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_ char *expr_to_string(rssn_Expr *aHandle) ;

/*
 Attempts to unify the units within an expression.

 Returns a JSON string representing a `FfiResult` which contains either the
 new `Expr` object in the `ok` field or an error message in the `err` field.
 The caller can then use `expr_from_json` to get a handle to the new expression.
 The caller is responsible for freeing the returned string using `free_string`.
 */
rssn_ char *expr_unify_expression(rssn_Expr *aHandle) ;

/*
 Frees a C string that was allocated by this library.
 */
rssn_ void free_string(char *aS) ;

/*
 Evaluates a point on a Bézier curve and returns the coordinates as a JSON string.
 */
rssn_ char *interpolate_bezier_curve(const char *aJsonPtr) ;

/*
 Computes a Lagrange interpolating polynomial and returns its coefficients as a JSON string.
 */
rssn_ char *interpolate_lagrange(const char *aJsonPtr) ;

rssn_
rssn_Expr *laurent_series(const rssn_Expr *aFunc,
                          const char *aVar,
                          const rssn_Expr *aCenter,
                          size_t aOrder)
;

rssn_
rssn_BincodeBuffer laurent_series_bincode(rssn_BincodeBuffer aFuncBincode,
                                          const char *aVar,
                                          rssn_BincodeBuffer aCenterBincode,
                                          size_t aOrder)
;

rssn_
char *laurent_series_json(const char *aFuncJson,
                          const char *aVar,
                          const char *aCenterJson,
                          size_t aOrder)
;

/*
 Adds two matrices and returns a handle to the new matrix expression.
 */
rssn_ DEPRECATED_WITH_NOTE rssn_Expr *matrix_add(rssn_Expr *aH1, rssn_Expr *aH2) ;

/*
 Computes the characteristic polynomial of a matrix and returns the result as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_characteristic_polynomial(rssn_Expr *aHandle,
                                       const char *aVarPtr)
;

/*
 Computes the determinant of a matrix and returns a handle to the resulting expression.
 */
rssn_ DEPRECATED_WITH_NOTE rssn_Expr *matrix_determinant(rssn_Expr *aHandle) ;

/*
 Computes the eigenvalue decomposition of a matrix and returns the eigenvalues and eigenvectors as a JSON string.
 */
rssn_
DEPRECATED_WITH_NOTE
char *matrix_eigen_decomposition(rssn_Expr *aHandle)
;

/*
 Creates an identity matrix of a given size and returns a handle to it.
 */
rssn_ DEPRECATED_WITH_NOTE rssn_Expr *matrix_identity(size_t aSize) ;

/*
 Inverts a matrix and returns a handle to the new matrix expression.
 */
rssn_ DEPRECATED_WITH_NOTE rssn_Expr *matrix_inverse(rssn_Expr *aHandle) ;

/*
 Computes the LU decomposition of a matrix and returns the L and U matrices as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *matrix_lu_decomposition(rssn_Expr *aHandle) ;

/*
 Multiplies two matrices and returns a handle to the new matrix expression.
 */
rssn_ DEPRECATED_WITH_NOTE rssn_Expr *matrix_mul(rssn_Expr *aH1, rssn_Expr *aH2) ;

/*
 Computes the null space of a matrix and returns the result as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *matrix_null_space(rssn_Expr *aHandle) ;

/*
 Computes the Reduced Row Echelon Form (RREF) of a matrix and returns the result as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *matrix_rref(rssn_Expr *aHandle) ;

/*
 Multiplies a matrix by a scalar and returns a handle to the new matrix expression.
 */
rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *matrix_scalar_mul(rssn_Expr *aScalarHandle,
                             rssn_Expr *aMatrixHandle)
;

/*
 Subtracts the second matrix from the first and returns a handle to the new matrix expression.
 */
rssn_ DEPRECATED_WITH_NOTE rssn_Expr *matrix_sub(rssn_Expr *aH1, rssn_Expr *aH2) ;

/*
 Computes the trace of a matrix and returns the result as a JSON string.
 */
rssn_ DEPRECATED_WITH_NOTE char *matrix_trace(rssn_Expr *aHandle) ;

/*
 Transposes a matrix and returns a handle to the new matrix expression.
 */
rssn_ DEPRECATED_WITH_NOTE rssn_Expr *matrix_transpose(rssn_Expr *aHandle) ;

rssn_
rssn_Expr *mobius_transformation_apply(const rssn_MobiusTransformation *aMobius,
                                       const rssn_Expr *aZ)
;

rssn_
rssn_BincodeBuffer mobius_transformation_apply_bincode(rssn_BincodeBuffer aMobiusBincode,
                                                       rssn_BincodeBuffer aZBincode)
;

rssn_ char *mobius_transformation_apply_json(const char *aMobiusJson, const char *aZJson) ;

rssn_
rssn_MobiusTransformation *mobius_transformation_compose(const rssn_MobiusTransformation *aMobius1,
                                                         const rssn_MobiusTransformation *aMobius2)
;

rssn_
rssn_BincodeBuffer mobius_transformation_compose_bincode(rssn_BincodeBuffer aMobius1Bincode,
                                                         rssn_BincodeBuffer aMobius2Bincode)
;

rssn_ char *mobius_transformation_compose_json(const char *aMobius1Json, const char *aMobius2Json) ;

rssn_ rssn_MobiusTransformation *mobius_transformation_identity() ;

rssn_ rssn_BincodeBuffer mobius_transformation_identity_bincode() ;

rssn_ char *mobius_transformation_identity_json() ;

rssn_
rssn_MobiusTransformation *mobius_transformation_inverse(const rssn_MobiusTransformation *aMobius)
;

rssn_ rssn_BincodeBuffer mobius_transformation_inverse_bincode(rssn_BincodeBuffer aMobiusBincode) ;

rssn_ char *mobius_transformation_inverse_json(const char *aMobiusJson) ;

rssn_
rssn_MobiusTransformation *mobius_transformation_new(const rssn_Expr *aA,
                                                     const rssn_Expr *aB,
                                                     const rssn_Expr *aC,
                                                     const rssn_Expr *aD)
;

rssn_
rssn_BincodeBuffer mobius_transformation_new_bincode(rssn_BincodeBuffer aABincode,
                                                     rssn_BincodeBuffer aBBincode,
                                                     rssn_BincodeBuffer aCBincode,
                                                     rssn_BincodeBuffer aDBincode)
;

rssn_
char *mobius_transformation_new_json(const char *aAJson,
                                     const char *aBJson,
                                     const char *aCJson,
                                     const char *aDJson)
;

rssn_ DEPRECATED_WITH_NOTE char *nt_mod_inverse(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *nt_mod_pow(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *numerical_gradient(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *numerical_integrate(const char *aJsonPtr) ;

rssn_
char *path_continuation_continue_along_path(rssn_PathContinuation *aPc,
                                            const rssn_Expr *const *aPathPoints,
                                            size_t aPathPointsLen)
;

rssn_
rssn_BincodeBuffer path_continuation_continue_along_path_bincode(rssn_BincodeBuffer aPcBincode,
                                                                 rssn_BincodeBuffer aPathPointsBincode)
;

rssn_
char *path_continuation_continue_along_path_json(const char *aPcJson,
                                                 const char *aPathPointsJson)
;

rssn_ rssn_Expr *path_continuation_get_final_expression(const rssn_PathContinuation *aPc) ;

rssn_
rssn_BincodeBuffer path_continuation_get_final_expression_bincode(rssn_BincodeBuffer aPcBincode)
;

rssn_ char *path_continuation_get_final_expression_json(const char *aPcJson) ;

rssn_
rssn_PathContinuation *path_continuation_new(const rssn_Expr *aFunc,
                                             const char *aVar,
                                             const rssn_Expr *aStartPoint,
                                             size_t aOrder)
;

rssn_
rssn_BincodeBuffer path_continuation_new_bincode(rssn_BincodeBuffer aFuncBincode,
                                                 const char *aVar,
                                                 rssn_BincodeBuffer aStartPointBincode,
                                                 size_t aOrder)
;

rssn_
char *path_continuation_new_json(const char *aFuncJson,
                                 const char *aVar,
                                 const char *aStartPointJson,
                                 size_t aOrder)
;

rssn_ DEPRECATED_WITH_NOTE char *physics_solve_advection_diffusion_1d(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE int64_t poly_degree(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE rssn_Expr *poly_from_coeffs_vec(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE bool poly_is_polynomial(const char *aJsonPtr) ;

rssn_
DEPRECATED_WITH_NOTE
rssn_Expr *poly_leading_coefficient(rssn_Expr *aHandle,
                                    const char *aVarPtr)
;

rssn_ DEPRECATED_WITH_NOTE char *poly_long_division(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *poly_to_coeffs_vec(const char *aJsonPtr) ;

/*
 Checks if an expression contains a variable (handle-based)
 */
rssn_ bool polynomial_contains_var_handle(const rssn_Expr *aExprHandle, const char *aVar) ;

/*
 Computes the degree of a polynomial (handle-based)
 */
rssn_ int64_t polynomial_degree_handle(const rssn_Expr *aExprHandle, const char *aVar) ;

/*
 Frees an Expr handle
 */
rssn_ void polynomial_free_expr_handle(rssn_Expr *aExprHandle) ;

/*
 Checks if an expression is a polynomial in the given variable (handle-based)
 */
rssn_ bool polynomial_is_polynomial_handle(const rssn_Expr *aExprHandle, const char *aVar) ;

/*
 Finds the leading coefficient of a polynomial (handle-based)
 */
rssn_
rssn_Expr *polynomial_leading_coefficient_handle(const rssn_Expr *aExprHandle,
                                                 const char *aVar)
;

/*
 Performs polynomial long division (handle-based)
 */
rssn_
void polynomial_long_division_handle(const rssn_Expr *aDividendHandle,
                                     const rssn_Expr *aDivisorHandle,
                                     const char *aVar,
                                     rssn_Expr **aQuotientOut,
                                     rssn_Expr **aRemainderOut)
;

/*
 Computes absolute value (magnitude) of complex number (Handle)
 */
rssn_ rssn_Expr *rssn_abs_handle(const rssn_Expr *aZ) ;

rssn_ rssn_Expr *rssn_adjoint_representation_algebra(const rssn_Expr *aX, const rssn_Expr *aY) ;

rssn_ rssn_Expr *rssn_adjoint_representation_group(const rssn_Expr *aG, const rssn_Expr *aX) ;

rssn_
rssn_Expr *rssn_analytic_continuation_handle(const rssn_Expr *aExpr,
                                             const char *aVar,
                                             const rssn_Expr *aOrigCenter,
                                             const rssn_Expr *aNewCenter,
                                             size_t aOrder)
;

rssn_
rssn_ConvergenceResult rssn_analyze_convergence_handle(const rssn_Expr *aTerm,
                                                       const char *aVar)
;

/*
 Analyzes stability of a fixed point (Handle)
 */
rssn_
rssn_Expr *rssn_analyze_stability(const rssn_Expr *aMapPtr,
                                  const char *aVar,
                                  const rssn_Expr *aFixedPointPtr)
;

/*
 Applies a set of rewrite rules to an expression until a normal form is reached.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `rules` is a valid array.
 */
rssn_
rssn_Expr *rssn_apply_rules_to_normal_form(const rssn_Expr *aExpr,
                                           const rssn_RewriteRule *const *aRules,
                                           size_t aRulesLen)
;

/*
 Applies rewrite rules to an expression (Bincode).
 */
rssn_ rssn_BincodeBuffer rssn_apply_rules_to_normal_form_bincode(rssn_BincodeBuffer aInput) ;

/*
 Applies rewrite rules to an expression (JSON).

 Input: JSON object with "expr" and "rules" fields
 Output: JSON-serialized Expr (the normal form)
 */
rssn_ char *rssn_apply_rules_to_normal_form_json(const char *aJsonStr) ;

/*
 Checks if two graphs are potentially isomorphic using WL test.
 */
rssn_ int rssn_are_isomorphic_heuristic(const rssn_RssnGraph *aG1, const rssn_RssnGraph *aG2) ;

rssn_
bool rssn_are_orthogonal(const rssn_HilbertSpace *aSpace,
                         const rssn_Expr *aF,
                         const rssn_Expr *aG)
;

/*
 Computes argument (angle) of complex number (Handle)
 */
rssn_ rssn_Expr *rssn_arg_handle(const rssn_Expr *aZ) ;

rssn_
rssn_Expr *rssn_asymptotic_expansion_handle(const rssn_Expr *aExpr,
                                            const char *aVar,
                                            const rssn_Expr *aPoint,
                                            size_t aOrder)
;

rssn_ rssn_Expr *rssn_banach_norm(const rssn_BanachSpace *aSpace, const rssn_Expr *aF) ;

rssn_
rssn_BanachSpace *rssn_banach_space_create(const char *aVar,
                                           const rssn_Expr *aLowerBound,
                                           const rssn_Expr *aUpperBound,
                                           const rssn_Expr *aP)
;

rssn_ void rssn_banach_space_free(rssn_BanachSpace *aPtr) ;

rssn_ rssn_Expr *rssn_bell_number(size_t aN) ;

/*
 Computes absolute value (magnitude) of complex number (Bincode)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_abs(rssn_BincodeBuffer aZBuf) ;

rssn_
rssn_BincodeBuffer rssn_bincode_adjoint_representation_algebra(rssn_BincodeBuffer aXBuf,
                                                               rssn_BincodeBuffer aYBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_adjoint_representation_group(rssn_BincodeBuffer aGBuf,
                                                             rssn_BincodeBuffer aXBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_analytic_continuation(rssn_BincodeBuffer aExprBuf,
                                                      rssn_BincodeBuffer aVarBuf,
                                                      rssn_BincodeBuffer aOrigCenterBuf,
                                                      rssn_BincodeBuffer aNewCenterBuf,
                                                      rssn_BincodeBuffer aOrderBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_analyze_convergence(rssn_BincodeBuffer aTermBuf,
                                                    rssn_BincodeBuffer aVarBuf)
;

/*
 Analyzes stability of a fixed point (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_analyze_stability(rssn_BincodeBuffer aMapBuf,
                                                  const char *aVar,
                                                  rssn_BincodeBuffer aFixedPointBuf)
;

/*
 Checks if two graphs are isomorphic.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_are_isomorphic_heuristic(rssn_BincodeBuffer aInputBuf) ;

/*
 Computes argument (angle) of complex number (Bincode)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_arg(rssn_BincodeBuffer aZBuf) ;

rssn_
rssn_BincodeBuffer rssn_bincode_asymptotic_expansion(rssn_BincodeBuffer aExprBuf,
                                                     rssn_BincodeBuffer aVarBuf,
                                                     rssn_BincodeBuffer aPointBuf,
                                                     rssn_BincodeBuffer aOrderBuf)
;

rssn_ rssn_BincodeBuffer rssn_bincode_bell_number(size_t aN) ;

/*
 Computes the boundary of a domain (Bincode)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_boundary(rssn_BincodeBuffer aDomainBuf) ;

rssn_
rssn_BincodeBuffer rssn_bincode_buchberger(rssn_BincodeBuffer aBasisBuf,
                                           rssn_BincodeBuffer aOrderBuf)
;

/*
 Calculates residue using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_calculate_residue(rssn_BincodeBuffer aExprBuf,
                                                  const char *aVar,
                                                  rssn_BincodeBuffer aPoleBuf)
;

rssn_ rssn_BincodeBuffer rssn_bincode_catalan_number(size_t aN) ;

rssn_ rssn_BincodeBuffer rssn_bincode_character(rssn_BincodeBuffer aRepBuf) ;

/*
 Checks analytic using Bincode.
 */
rssn_ bool rssn_bincode_check_analytic(rssn_BincodeBuffer aExprBuf, const char *aVar) ;

rssn_ bool rssn_bincode_check_jacobi_identity(rssn_BincodeBuffer aAlgebraBuf) ;

rssn_ rssn_BincodeBuffer rssn_bincode_chinese_remainder(rssn_BincodeBuffer aCongruencesBuf) ;

/*
 Exact chromatic number.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_chromatic_number_exact(rssn_BincodeBuffer aGraphBuf) ;

/*
 Classifies a PDE (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_bincode_classify_pde(rssn_BincodeBuffer aEquationBuf,
                                             const char *aFunc,
                                             rssn_BincodeBuffer aVarsBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_combinations(rssn_BincodeBuffer aNBuf,
                                             rssn_BincodeBuffer aKBuf)
;

rssn_ rssn_BincodeBuffer rssn_bincode_commutator_table(rssn_BincodeBuffer aAlgebraBuf) ;

/*
 Finds fixed points (Bincode)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_complex_system_fixed_points(rssn_BincodeBuffer aSystemBuf) ;

/*
 Iterates the system once (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_complex_system_iterate(rssn_BincodeBuffer aSystemBuf,
                                                       rssn_BincodeBuffer aZBuf)
;

/*
 Creates a new Mandelbrot family system (Bincode)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_complex_system_new_mandelbrot(rssn_BincodeBuffer aCBuf) ;

rssn_ rssn_BincodeBuffer rssn_bincode_coordinates_get_metric_tensor(rssn_BincodeBuffer aSystemBuf) ;

/*
 Computes the symbolic Pearson correlation coefficient using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_correlation(rssn_BincodeBuffer aData1Buf,
                                            rssn_BincodeBuffer aData2Buf)
;

/*
 Counts the number of distinct real roots in an interval (Bincode)
 */
rssn_
int64_t rssn_bincode_count_real_roots_in_interval(rssn_BincodeBuffer aExprBuf,
                                                  const char *aVarPtr,
                                                  double aA,
                                                  double aB)
;

/*
 Computes the symbolic covariance of two sets of expressions using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_covariance(rssn_BincodeBuffer aData1Buf,
                                           rssn_BincodeBuffer aData2Buf)
;

rssn_ rssn_BincodeBuffer rssn_bincode_cyclic_group_create(size_t aN) ;

/*
 Computes definite integral using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_definite_integrate(rssn_BincodeBuffer aExprBuf,
                                                   const char *aVar,
                                                   rssn_BincodeBuffer aLowerBuf,
                                                   rssn_BincodeBuffer aUpperBuf)
;

/*
 Denests a nested square root (Bincode)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_denest_sqrt(rssn_BincodeBuffer aExprBuf) ;

/*
 Differentiates an expression using Bincode.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_differentiate(rssn_BincodeBuffer aExprBuf, const char *aVar) ;

rssn_ rssn_BincodeBuffer rssn_bincode_dihedral_group_create(size_t aN) ;

rssn_ rssn_BincodeBuffer rssn_bincode_dist_bernoulli(rssn_BincodeBuffer aPBuf) ;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_beta(rssn_BincodeBuffer aAlphaBuf,
                                          rssn_BincodeBuffer aBetaBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_binomial(rssn_BincodeBuffer aNBuf,
                                              rssn_BincodeBuffer aPBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_cdf(rssn_BincodeBuffer aDistBuf,
                                         rssn_BincodeBuffer aXBuf)
;

rssn_ rssn_BincodeBuffer rssn_bincode_dist_expectation(rssn_BincodeBuffer aDistBuf) ;

rssn_ rssn_BincodeBuffer rssn_bincode_dist_exponential(rssn_BincodeBuffer aRateBuf) ;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_gamma(rssn_BincodeBuffer aShapeBuf,
                                           rssn_BincodeBuffer aRateBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_mgf(rssn_BincodeBuffer aDistBuf,
                                         rssn_BincodeBuffer aTBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_normal(rssn_BincodeBuffer aMeanBuf,
                                            rssn_BincodeBuffer aStdDevBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_pdf(rssn_BincodeBuffer aDistBuf,
                                         rssn_BincodeBuffer aXBuf)
;

rssn_ rssn_BincodeBuffer rssn_bincode_dist_poisson(rssn_BincodeBuffer aRateBuf) ;

rssn_ rssn_BincodeBuffer rssn_bincode_dist_student_t(rssn_BincodeBuffer aNuBuf) ;

rssn_
rssn_BincodeBuffer rssn_bincode_dist_uniform(rssn_BincodeBuffer aMinBuf,
                                             rssn_BincodeBuffer aMaxBuf)
;

rssn_ rssn_BincodeBuffer rssn_bincode_dist_variance(rssn_BincodeBuffer aDistBuf) ;

/*
 Evaluates at point using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_evaluate_at_point(rssn_BincodeBuffer aExprBuf,
                                                  const char *aVar,
                                                  rssn_BincodeBuffer aValueBuf)
;

rssn_ rssn_BincodeBuffer rssn_bincode_evaluate_numerical(rssn_BincodeBuffer aExprBuf) ;

rssn_ rssn_BincodeBuffer rssn_bincode_exponential_map(rssn_BincodeBuffer aXBuf, size_t aOrder) ;

rssn_
rssn_BincodeBuffer rssn_bincode_extended_gcd(rssn_BincodeBuffer aABuf,
                                             rssn_BincodeBuffer aBBuf)
;

/*
 Computes the exterior derivative of a differential form (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_exterior_derivative(rssn_BincodeBuffer aFormBuf,
                                                    rssn_BincodeBuffer aVarsBuf)
;

/*
 Factors a polynomial over a finite field (Bincode)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_factor_gf(rssn_BincodeBuffer aPolyBuf) ;

/*
 Finds constrained extrema (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_find_constrained_extrema(rssn_BincodeBuffer aExprBuf,
                                                         rssn_BincodeBuffer aConstraintsBuf,
                                                         rssn_BincodeBuffer aVarsBuf)
;

/*
 Finds extrema of a function (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_find_extrema(rssn_BincodeBuffer aExprBuf,
                                             rssn_BincodeBuffer aVarsBuf)
;

/*
 Finds fixed points of a 1D map (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_find_fixed_points(rssn_BincodeBuffer aMapBuf,
                                                  const char *aVar)
;

/*
 Finds pole order using Bincode.
 */
rssn_
size_t rssn_bincode_find_pole_order(rssn_BincodeBuffer aExprBuf,
                                    const char *aVar,
                                    rssn_BincodeBuffer aPoleBuf)
;

/*
 Finds poles using Bincode.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_find_poles(rssn_BincodeBuffer aExprBuf, const char *aVar) ;

/*
 Gets the degree of a finite field polynomial (Bincode)
 */
rssn_ int64_t rssn_bincode_finite_field_polynomial_degree(rssn_BincodeBuffer aPolyBuf) ;

/*
 Performs polynomial long division (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_finite_field_polynomial_long_division(rssn_BincodeBuffer aDividendBuf,
                                                                      rssn_BincodeBuffer aDivisorBuf)
;

/*
 Creates a new finite field polynomial (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_finite_field_polynomial_new(rssn_BincodeBuffer aCoeffsBuf,
                                                            rssn_BincodeBuffer aModulusBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_fourier_series(rssn_BincodeBuffer aExprBuf,
                                               rssn_BincodeBuffer aVarBuf,
                                               rssn_BincodeBuffer aPeriodBuf,
                                               rssn_BincodeBuffer aOrderBuf)
;

/*
 Represents Gauss's theorem (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_gauss_theorem(rssn_BincodeBuffer aVectorFieldBuf,
                                              rssn_BincodeBuffer aVolumeBuf)
;

/*
 Computes general multi-valued arccos (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_general_arccos(rssn_BincodeBuffer aZBuf,
                                               rssn_BincodeBuffer aKBuf,
                                               rssn_BincodeBuffer aSBuf)
;

/*
 Computes general multi-valued arcsin (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_general_arcsin(rssn_BincodeBuffer aZBuf,
                                               rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued arctan (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_general_arctan(rssn_BincodeBuffer aZBuf,
                                               rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued logarithm (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_general_log(rssn_BincodeBuffer aZBuf,
                                            rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued n-th root (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_general_nth_root(rssn_BincodeBuffer aZBuf,
                                                 rssn_BincodeBuffer aNBuf,
                                                 rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued power (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_general_power(rssn_BincodeBuffer aZBuf,
                                              rssn_BincodeBuffer aWBuf,
                                              rssn_BincodeBuffer aKBuf)
;

/*
 Computes general multi-valued square root (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_general_sqrt(rssn_BincodeBuffer aZBuf,
                                             rssn_BincodeBuffer aKBuf)
;

/*
 Represents the generalized Stokes' theorem (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_generalized_stokes_theorem(rssn_BincodeBuffer aOmegaBuf,
                                                           rssn_BincodeBuffer aManifoldBuf,
                                                           rssn_BincodeBuffer aVarsBuf)
;

/*
 Gets real and imaginary parts using Bincode.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_get_real_imag_parts(rssn_BincodeBuffer aExprBuf) ;

rssn_
rssn_BincodeBuffer rssn_bincode_gram_schmidt(rssn_BincodeBuffer aSpaceBuf,
                                             rssn_BincodeBuffer aBasisBuf)
;

/*
 Adds an edge to the graph.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_add_edge(rssn_BincodeBuffer aInputBuf) ;

/*
 Adds a node to the graph.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_add_node(rssn_BincodeBuffer aInputBuf) ;

/*
 Gets the adjacency matrix.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_adjacency_matrix(rssn_BincodeBuffer aGraphBuf) ;

/*
 Performs BFS traversal.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_bfs(rssn_BincodeBuffer aInputBuf) ;

/*
 Performs BFS traversal.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_bfs_api(rssn_BincodeBuffer aInputBuf) ;

/*
 Finds maximum matching in bipartite graph.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_bipartite_maximum_matching(rssn_BincodeBuffer aInputBuf)
;

/*
 Finds bridges and articulation points.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_bridges_and_articulation_points(rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes the Cartesian product of two graphs.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_cartesian_product(rssn_BincodeBuffer aInputBuf) ;

/*
 Computes the complement of a graph.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_complement(rssn_BincodeBuffer aGraphBuf) ;

/*
 Finds connected components.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_connected_components(rssn_BincodeBuffer aGraphBuf) ;

/*
 Finds connected components.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_connected_components_api(rssn_BincodeBuffer aGraphBuf) ;

/*
 Performs DFS traversal.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_dfs(rssn_BincodeBuffer aInputBuf) ;

/*
 Performs DFS traversal.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_dfs_api(rssn_BincodeBuffer aInputBuf) ;

/*
 Computes maximum flow using Dinic's algorithm.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_dinic_max_flow(rssn_BincodeBuffer aInputBuf) ;

/*
 Computes the disjoint union of two graphs.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_disjoint_union(rssn_BincodeBuffer aInputBuf) ;

/*
 Computes maximum flow using Edmonds-Karp.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_edmonds_karp_max_flow(rssn_BincodeBuffer aInputBuf) ;

/*
 Checks if graph has a cycle.
 */
rssn_ bool rssn_bincode_graph_has_cycle(rssn_BincodeBuffer aGraphBuf) ;

/*
 Checks if graph has a cycle.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_has_cycle_api(rssn_BincodeBuffer aGraphBuf) ;

/*
 Creates an induced subgraph.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_induced_subgraph(rssn_BincodeBuffer aInputBuf) ;

/*
 Computes the intersection of two graphs.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_intersection(rssn_BincodeBuffer aInputBuf) ;

/*
 Checks if graph is bipartite.
 */
rssn_ bool rssn_bincode_graph_is_bipartite(rssn_BincodeBuffer aGraphBuf) ;

/*
 Checks if graph is bipartite.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_is_bipartite_api(rssn_BincodeBuffer aGraphBuf) ;

/*
 Checks if graph is connected.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_is_connected(rssn_BincodeBuffer aGraphBuf) ;

/*
 Computes the join of two graphs.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_join(rssn_BincodeBuffer aInputBuf) ;

/*
 Computes MST using Kruskal's algorithm.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_kruskal_mst(rssn_BincodeBuffer aGraphBuf) ;

/*
 Computes MST using Kruskal's algorithm.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_kruskal_mst_api(rssn_BincodeBuffer aGraphBuf) ;

/*
 Gets the Laplacian matrix.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_laplacian_matrix(rssn_BincodeBuffer aGraphBuf) ;

/*
 Computes maximum flow.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_max_flow(rssn_BincodeBuffer aInputBuf) ;

/*
 Creates a new graph from bincode specification.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_new(rssn_BincodeBuffer aSpecBuf) ;

/*
 Finds strongly connected components.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_graph_strongly_connected_components(rssn_BincodeBuffer aGraphBuf)
;

/*
 Computes the Tensor product of two graphs.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_tensor_product(rssn_BincodeBuffer aInputBuf) ;

/*
 Performs topological sort.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_topological_sort(rssn_BincodeBuffer aGraphBuf) ;

/*
 Computes the union of two graphs.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_graph_union(rssn_BincodeBuffer aInputBuf) ;

/*
 Greedy coloring.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_greedy_coloring(rssn_BincodeBuffer aGraphBuf) ;

/*
 Represents Green's theorem (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_greens_theorem(rssn_BincodeBuffer aPBuf,
                                               rssn_BincodeBuffer aQBuf,
                                               rssn_BincodeBuffer aDomainBuf)
;

rssn_ rssn_BincodeBuffer rssn_bincode_group_center(rssn_BincodeBuffer aGroupBuf) ;

rssn_ rssn_BincodeBuffer rssn_bincode_group_conjugacy_classes(rssn_BincodeBuffer aGroupBuf) ;

rssn_ rssn_BincodeBuffer rssn_bincode_group_create(rssn_BincodeBuffer aBuf) ;

rssn_
size_t rssn_bincode_group_element_order(rssn_BincodeBuffer aGroupBuf,
                                        rssn_BincodeBuffer aABuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_group_inverse(rssn_BincodeBuffer aGroupBuf,
                                              rssn_BincodeBuffer aABuf)
;

rssn_ bool rssn_bincode_group_is_abelian(rssn_BincodeBuffer aGroupBuf) ;

rssn_
rssn_BincodeBuffer rssn_bincode_group_multiply(rssn_BincodeBuffer aGroupBuf,
                                               rssn_BincodeBuffer aABuf,
                                               rssn_BincodeBuffer aBBuf)
;

/*
 Computes Hessian matrix (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_hessian_matrix(rssn_BincodeBuffer aExprBuf,
                                               rssn_BincodeBuffer aVarsBuf)
;

/*
 Simplifies an expression using the heuristic simplifier (Bincode input/output).
 */
rssn_ rssn_BincodeBuffer rssn_bincode_heuristic_simplify(rssn_BincodeBuffer aExprBuf) ;

rssn_ rssn_BincodeBuffer rssn_bincode_hilbert_space_create(rssn_BincodeBuffer aBuf) ;

/*
 Creates a new IteratedFunctionSystem (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_ifs_create(rssn_BincodeBuffer aFunctionsBuf,
                                           rssn_BincodeBuffer aProbabilitiesBuf,
                                           rssn_BincodeBuffer aVariablesBuf)
;

/*
 Calculates similarity dimension (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_ifs_similarity_dimension(rssn_BincodeBuffer aScalingFactorsBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_inner_product(rssn_BincodeBuffer aSpaceBuf,
                                              rssn_BincodeBuffer aFBuf,
                                              rssn_BincodeBuffer aGBuf)
;

/*
 Integrates an expression using Bincode.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_integrate(rssn_BincodeBuffer aExprBuf, const char *aVar) ;

/*
 Integrates a rational function (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_integrate_rational_function(rssn_BincodeBuffer aExprBuf,
                                                            rssn_BincodeBuffer aXBuf)
;

rssn_ rssn_BincodeBuffer rssn_bincode_is_prime(rssn_BincodeBuffer aNBuf) ;

/*
 Checks if a logical expression is satisfiable using bincode-based FFI.

 Returns a bincode buffer containing:
 - `Some(true)` if satisfiable
 - `Some(false)` if unsatisfiable
 - `None` if the expression contains quantifiers (undecidable)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_is_satisfiable(rssn_BincodeBuffer aExprBuf) ;

/*
 Isolates real roots in an interval (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_isolate_real_roots(rssn_BincodeBuffer aExprBuf,
                                                   const char *aVarPtr,
                                                   double aPrecision)
;

rssn_ rssn_BincodeBuffer rssn_bincode_klein_four_group_create() ;

rssn_
rssn_BincodeBuffer rssn_bincode_laurent_series(rssn_BincodeBuffer aExprBuf,
                                               rssn_BincodeBuffer aVarBuf,
                                               rssn_BincodeBuffer aCenterBuf,
                                               rssn_BincodeBuffer aOrderBuf)
;

rssn_ rssn_BincodeBuffer rssn_bincode_lie_algebra_so3() ;

rssn_ rssn_BincodeBuffer rssn_bincode_lie_algebra_su2() ;

rssn_
rssn_BincodeBuffer rssn_bincode_lie_bracket(rssn_BincodeBuffer aXBuf,
                                            rssn_BincodeBuffer aYBuf)
;

/*
 Computes limit using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_limit(rssn_BincodeBuffer aExprBuf,
                                      const char *aVar,
                                      rssn_BincodeBuffer aPointBuf)
;

/*
 Returns Lorenz system equations (Bincode)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_lorenz_system() ;

/*
 Calculates Lyapunov exponent (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_lyapunov_exponent(rssn_BincodeBuffer aMapBuf,
                                                  const char *aVar,
                                                  rssn_BincodeBuffer aInitialXBuf,
                                                  size_t aNIterations)
;

rssn_
rssn_BincodeBuffer rssn_bincode_matrix_add(rssn_BincodeBuffer aM1Buf,
                                           rssn_BincodeBuffer aM2Buf)
;

rssn_ rssn_BincodeBuffer rssn_bincode_matrix_determinant(rssn_BincodeBuffer aMatrixBuf) ;

rssn_ rssn_BincodeBuffer rssn_bincode_matrix_inverse(rssn_BincodeBuffer aMatrixBuf) ;

rssn_
rssn_BincodeBuffer rssn_bincode_matrix_mul(rssn_BincodeBuffer aM1Buf,
                                           rssn_BincodeBuffer aM2Buf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_matrix_solve_linear_system(rssn_BincodeBuffer aABuf,
                                                           rssn_BincodeBuffer aBBuf)
;

rssn_ rssn_BincodeBuffer rssn_bincode_matrix_transpose(rssn_BincodeBuffer aMatrixBuf) ;

/*
 Computes the symbolic mean of a set of expressions using Bincode.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_mean(rssn_BincodeBuffer aDataBuf) ;

/*
 Computes geometric product (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_multivector_geometric_product(rssn_BincodeBuffer aABuf,
                                                              rssn_BincodeBuffer aBBuf)
;

/*
 Computes grade projection (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_multivector_grade_projection(rssn_BincodeBuffer aMvBuf,
                                                             uint32_t aGrade)
;

/*
 Computes inner product (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_multivector_inner_product(rssn_BincodeBuffer aABuf,
                                                          rssn_BincodeBuffer aBBuf)
;

/*
 Computes magnitude (Bincode)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_multivector_magnitude(rssn_BincodeBuffer aMvBuf) ;

/*
 Computes outer product (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_multivector_outer_product(rssn_BincodeBuffer aABuf,
                                                          rssn_BincodeBuffer aBBuf)
;

/*
 Computes reverse (Bincode)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_multivector_reverse(rssn_BincodeBuffer aMvBuf) ;

/*
 Creates a new scalar multivector (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_multivector_scalar(uint32_t aP,
                                                   uint32_t aQ,
                                                   uint32_t aR,
                                                   rssn_BincodeBuffer aValueBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_nonlinear_regression(rssn_BincodeBuffer aDataBuf,
                                                     rssn_BincodeBuffer aModelBuf,
                                                     rssn_BincodeBuffer aVarsBuf,
                                                     rssn_BincodeBuffer aParamsBuf)
;

rssn_ rssn_BincodeBuffer rssn_bincode_norm(rssn_BincodeBuffer aSpaceBuf, rssn_BincodeBuffer aFBuf) ;

rssn_
rssn_BincodeBuffer rssn_bincode_one_sample_t_test(rssn_BincodeBuffer aDataBuf,
                                                  rssn_BincodeBuffer aTargetMeanBuf)
;

/*
 Computes path integral using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_path_integrate(rssn_BincodeBuffer aExprBuf,
                                               const char *aVar,
                                               rssn_BincodeBuffer aContourBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_permutations(rssn_BincodeBuffer aNBuf,
                                             rssn_BincodeBuffer aKBuf)
;

/*
 Computes polynomial derivative over finite field (Bincode)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_poly_derivative_gf(rssn_BincodeBuffer aPolyBuf) ;

rssn_
rssn_BincodeBuffer rssn_bincode_poly_division_multivariate(rssn_BincodeBuffer aDividendBuf,
                                                           rssn_BincodeBuffer aDivisorsBuf,
                                                           rssn_BincodeBuffer aOrderBuf)
;

/*
 Computes polynomial GCD over finite field (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_poly_gcd_gf(rssn_BincodeBuffer aABuf,
                                            rssn_BincodeBuffer aBBuf)
;

/*
 Checks if an expression contains a variable (bincode)
 */
rssn_ bool rssn_bincode_polynomial_contains_var(rssn_BincodeBuffer aExprBuf, const char *aVar) ;

/*
 Computes the degree of a polynomial (bincode)
 */
rssn_ int64_t rssn_bincode_polynomial_degree(rssn_BincodeBuffer aExprBuf, const char *aVar) ;

/*
 Checks if an expression is a polynomial in the given variable (bincode)
 */
rssn_ bool rssn_bincode_polynomial_is_polynomial(rssn_BincodeBuffer aExprBuf, const char *aVar) ;

/*
 Finds the leading coefficient of a polynomial (bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_polynomial_leading_coefficient(rssn_BincodeBuffer aExprBuf,
                                                               const char *aVar)
;

/*
 Performs polynomial long division (bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_polynomial_long_division(rssn_BincodeBuffer aDividendBuf,
                                                         rssn_BincodeBuffer aDivisorBuf,
                                                         const char *aVar)
;

rssn_
rssn_BincodeBuffer rssn_bincode_polynomial_regression(rssn_BincodeBuffer aDataBuf,
                                                      size_t aDegree)
;

/*
 Converts polynomial to coefficient vector (bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_polynomial_to_coeffs_vec(rssn_BincodeBuffer aExprBuf,
                                                         const char *aVar)
;

/*
 Adds two prime field elements (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_prime_field_element_add(rssn_BincodeBuffer aABuf,
                                                        rssn_BincodeBuffer aBBuf)
;

/*
 Divides two prime field elements (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_prime_field_element_div(rssn_BincodeBuffer aABuf,
                                                        rssn_BincodeBuffer aBBuf)
;

/*
 Computes the inverse of a prime field element (Bincode)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_prime_field_element_inverse(rssn_BincodeBuffer aElemBuf) ;

/*
 Multiplies two prime field elements (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_prime_field_element_mul(rssn_BincodeBuffer aABuf,
                                                        rssn_BincodeBuffer aBBuf)
;

/*
 Creates a new prime field element (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_prime_field_element_new(rssn_BincodeBuffer aValueBuf,
                                                        rssn_BincodeBuffer aModulusBuf)
;

/*
 Subtracts two prime field elements (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_prime_field_element_sub(rssn_BincodeBuffer aABuf,
                                                        rssn_BincodeBuffer aBBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_product(rssn_BincodeBuffer aExprBuf,
                                        rssn_BincodeBuffer aVarBuf,
                                        rssn_BincodeBuffer aLowerBuf,
                                        rssn_BincodeBuffer aUpperBuf)
;

rssn_ rssn_BincodeBuffer rssn_bincode_representation_create(rssn_BincodeBuffer aBuf) ;

rssn_
bool rssn_bincode_representation_is_valid(rssn_BincodeBuffer aRepBuf,
                                          rssn_BincodeBuffer aGroupBuf)
;

/*
 Integrates an expression using the Risch-Norman algorithm (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_risch_norman_integrate(rssn_BincodeBuffer aExprBuf,
                                                       rssn_BincodeBuffer aXBuf)
;

rssn_ rssn_BincodeBuffer rssn_bincode_simple_linear_regression(rssn_BincodeBuffer aDataBuf) ;

/*
 Creates a new Simplex (Bincode)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_simplex_create(rssn_BincodeBuffer aVerticesBuf) ;

/*
 Gets the dimension of a Simplex (Bincode)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_simplex_dimension(rssn_BincodeBuffer aSimplexBuf) ;

/*
 Adds a simplex to a SimplicialComplex (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_simplicial_complex_add_simplex(rssn_BincodeBuffer aComplexBuf,
                                                               rssn_BincodeBuffer aVerticesBuf)
;

/*
 Applies the symbolic boundary operator to a SymbolicChain (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_simplicial_complex_apply_symbolic_boundary_operator(rssn_BincodeBuffer aComplexBuf,
                                                                                    rssn_BincodeBuffer aChainBuf)
;

/*
 Creates a new SimplicialComplex (Bincode)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_simplicial_complex_create() ;

/*
 Gets the symbolic boundary matrix for dimension k (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_simplicial_complex_get_symbolic_boundary_matrix(rssn_BincodeBuffer aComplexBuf,
                                                                                size_t aK)
;

/*
 Simplifies an expression using the legacy simplifier (Bincode input/output).
 */
rssn_ rssn_BincodeBuffer rssn_bincode_simplify(rssn_BincodeBuffer aExprBuf) ;

/*
 Simplifies an expression using the DAG-based simplifier (Bincode input/output).
 */
rssn_ rssn_BincodeBuffer rssn_bincode_simplify_dag(rssn_BincodeBuffer aExprBuf) ;

/*
 Simplifies a logical expression using bincode-based FFI.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_simplify_logic(rssn_BincodeBuffer aExprBuf) ;

/*
 Simplifies radical expressions (Bincode)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_simplify_radicals(rssn_BincodeBuffer aExprBuf) ;

rssn_ rssn_BincodeBuffer rssn_bincode_so3_generators() ;

rssn_
rssn_BincodeBuffer rssn_bincode_solve(rssn_BincodeBuffer aExprBuf,
                                      rssn_BincodeBuffer aVarBuf)
;

/*
 Solves a Bernoulli ODE using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_bernoulli_ode(rssn_BincodeBuffer aEquationBuf,
                                                    const char *aFunc,
                                                    const char *aVar)
;

/*
 Solves by reduction of order using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_by_reduction_of_order(rssn_BincodeBuffer aEquationBuf,
                                                            const char *aFunc,
                                                            const char *aVar,
                                                            rssn_BincodeBuffer aY1Buf)
;

/*
 Solves a Cauchy-Euler ODE using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_cauchy_euler_ode(rssn_BincodeBuffer aEquationBuf,
                                                       const char *aFunc,
                                                       const char *aVar)
;

rssn_
rssn_BincodeBuffer rssn_bincode_solve_diophantine(rssn_BincodeBuffer aEquationBuf,
                                                  rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves an exact ODE using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_exact_ode(rssn_BincodeBuffer aEquationBuf,
                                                const char *aFunc,
                                                const char *aVar)
;

/*
 Solves a first-order linear ODE using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_first_order_linear_ode(rssn_BincodeBuffer aEquationBuf,
                                                             const char *aFunc,
                                                             const char *aVar)
;

/*
 Solves the 1D heat equation (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_heat_equation_1d(rssn_BincodeBuffer aEquationBuf,
                                                       const char *aFunc,
                                                       rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves the 2D Laplace equation (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_laplace_equation_2d(rssn_BincodeBuffer aEquationBuf,
                                                          const char *aFunc,
                                                          rssn_BincodeBuffer aVarsBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_solve_linear_system(rssn_BincodeBuffer aSystemBuf,
                                                    rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves an ODE using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_ode(rssn_BincodeBuffer aOdeBuf,
                                          const char *aFunc,
                                          const char *aVar)
;

/*
 Solves a PDE using Bincode with automatic method selection.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_pde(rssn_BincodeBuffer aPdeBuf,
                                          const char *aFunc,
                                          rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves a PDE using the method of characteristics (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_pde_by_characteristics(rssn_BincodeBuffer aEquationBuf,
                                                             const char *aFunc,
                                                             rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves a Riccati ODE using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_riccati_ode(rssn_BincodeBuffer aEquationBuf,
                                                  const char *aFunc,
                                                  const char *aVar,
                                                  rssn_BincodeBuffer aY1Buf)
;

/*
 Solves a separable ODE using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_separable_ode(rssn_BincodeBuffer aEquationBuf,
                                                    const char *aFunc,
                                                    const char *aVar)
;

rssn_
rssn_BincodeBuffer rssn_bincode_solve_system(rssn_BincodeBuffer aEquationsBuf,
                                             rssn_BincodeBuffer aVarsBuf)
;

/*
 Solves the 1D wave equation (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_bincode_solve_wave_equation_1d(rssn_BincodeBuffer aEquationBuf,
                                                       const char *aFunc,
                                                       rssn_BincodeBuffer aVarsBuf)
;

/*
 Computes square-free factorization (Bincode)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_square_free_factorization_gf(rssn_BincodeBuffer aPolyBuf) ;

/*
 Computes the symbolic standard deviation of a set of expressions using Bincode.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_std_dev(rssn_BincodeBuffer aDataBuf) ;

rssn_ rssn_BincodeBuffer rssn_bincode_stirling_number_second_kind(size_t aN, size_t aK) ;

/*
 Represents Stokes' theorem (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_stokes_theorem(rssn_BincodeBuffer aVectorFieldBuf,
                                               rssn_BincodeBuffer aSurfaceBuf)
;

/*
 Generates the Sturm sequence for a given polynomial (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_sturm_sequence(rssn_BincodeBuffer aExprBuf,
                                               const char *aVarPtr)
;

rssn_ rssn_BincodeBuffer rssn_bincode_su2_generators() ;

/*
 Substitutes using Bincode.
 */
rssn_
rssn_BincodeBuffer rssn_bincode_substitute(rssn_BincodeBuffer aExprBuf,
                                           const char *aVar,
                                           rssn_BincodeBuffer aReplacementBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_summation(rssn_BincodeBuffer aExprBuf,
                                          rssn_BincodeBuffer aVarBuf,
                                          rssn_BincodeBuffer aLowerBuf,
                                          rssn_BincodeBuffer aUpperBuf)
;

/*
 Adds a term to a SymbolicChain (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_symbolic_chain_add_term(rssn_BincodeBuffer aChainBuf,
                                                        rssn_BincodeBuffer aSimplexBuf,
                                                        rssn_BincodeBuffer aCoeffBuf)
;

/*
 Creates a new SymbolicChain (Bincode)
 */
rssn_ rssn_BincodeBuffer rssn_bincode_symbolic_chain_create(size_t aDimension) ;

rssn_ rssn_BincodeBuffer rssn_bincode_symmetric_group_create(size_t aN) ;

rssn_
rssn_BincodeBuffer rssn_bincode_taylor_series(rssn_BincodeBuffer aExprBuf,
                                              rssn_BincodeBuffer aVarBuf,
                                              rssn_BincodeBuffer aCenterBuf,
                                              rssn_BincodeBuffer aOrderBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_tensor_add(rssn_BincodeBuffer aT1Buf,
                                           rssn_BincodeBuffer aT2Buf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_tensor_outer_product(rssn_BincodeBuffer aT1Buf,
                                                     rssn_BincodeBuffer aT2Buf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_tensor_scalar_mul(rssn_BincodeBuffer aTBuf,
                                                  rssn_BincodeBuffer aScalarBuf)
;

/*
 Converts a logical expression to Conjunctive Normal Form (CNF) using bincode-based FFI.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_to_cnf(rssn_BincodeBuffer aExprBuf) ;

/*
 Converts a logical expression to Disjunctive Normal Form (DNF) using bincode-based FFI.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_to_dnf(rssn_BincodeBuffer aExprBuf) ;

rssn_
rssn_BincodeBuffer rssn_bincode_transform_contravariant_vector(rssn_BincodeBuffer aCompsBuf,
                                                               rssn_BincodeBuffer aFromBuf,
                                                               rssn_BincodeBuffer aToBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_transform_covariant_vector(rssn_BincodeBuffer aCompsBuf,
                                                           rssn_BincodeBuffer aFromBuf,
                                                           rssn_BincodeBuffer aToBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_transform_curl(rssn_BincodeBuffer aCompsBuf,
                                               rssn_BincodeBuffer aFromBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_transform_divergence(rssn_BincodeBuffer aCompsBuf,
                                                     rssn_BincodeBuffer aFromBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_transform_expression(rssn_BincodeBuffer aExprBuf,
                                                     rssn_BincodeBuffer aFromBuf,
                                                     rssn_BincodeBuffer aToBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_transform_gradient(rssn_BincodeBuffer aScalarBuf,
                                                   rssn_BincodeBuffer aVarsBuf,
                                                   rssn_BincodeBuffer aFromBuf,
                                                   rssn_BincodeBuffer aToBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_transform_point(rssn_BincodeBuffer aPointBuf,
                                                rssn_BincodeBuffer aFromBuf,
                                                rssn_BincodeBuffer aToBuf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_two_sample_t_test(rssn_BincodeBuffer aData1Buf,
                                                  rssn_BincodeBuffer aData2Buf,
                                                  rssn_BincodeBuffer aMuDiffBuf)
;

rssn_ rssn_BincodeBuffer rssn_bincode_unify_expression(rssn_BincodeBuffer aExprBuf) ;

/*
 Computes the symbolic variance of a set of expressions using Bincode.
 */
rssn_ rssn_BincodeBuffer rssn_bincode_variance(rssn_BincodeBuffer aDataBuf) ;

rssn_
rssn_BincodeBuffer rssn_bincode_vector_cross(rssn_BincodeBuffer aV1Buf,
                                             rssn_BincodeBuffer aV2Buf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_vector_dot(rssn_BincodeBuffer aV1Buf,
                                           rssn_BincodeBuffer aV2Buf)
;

rssn_ rssn_BincodeBuffer rssn_bincode_vector_magnitude(rssn_BincodeBuffer aVBuf) ;

rssn_ rssn_BincodeBuffer rssn_bincode_vector_normalize(rssn_BincodeBuffer aVBuf) ;

/*
 Computes the wedge product of two differential forms (Bincode)
 */
rssn_
rssn_BincodeBuffer rssn_bincode_wedge_product(rssn_BincodeBuffer aForm1Buf,
                                              rssn_BincodeBuffer aForm2Buf)
;

rssn_
rssn_BincodeBuffer rssn_bincode_z_test(rssn_BincodeBuffer aDataBuf,
                                       rssn_BincodeBuffer aTargetMeanBuf,
                                       rssn_BincodeBuffer aPopStdDevBuf)
;

/*
 Computes binomial coefficient C(n, k).
 */
rssn_ char *rssn_binomial_coefficient(size_t aN, size_t aK) ;

/*
 Computes binomial coefficient C(n, k) and returns as JSON string.
 */
rssn_ char *rssn_binomial_coefficient_json(size_t aN, size_t aK) ;

/*
 Computes the boundary of a domain (Handle)
 */
rssn_ rssn_Expr *rssn_boundary_handle(const rssn_Expr *aDomainPtr) ;

rssn_
rssn_Vec<rssn_SparsePolynomial> *rssn_buchberger_handle(const rssn_Vec<rssn_SparsePolynomial> *aBasis,
                                                        rssn_MonomialOrder aOrder)
;

/*
 Calculates the residue of a complex function at a given pole.
 */
rssn_
rssn_Expr *rssn_calculate_residue(const rssn_Expr *aExpr,
                                  const char *aVar,
                                  const rssn_Expr *aPole)
;

rssn_
int32_t rssn_calculus_definite_integrate(size_t aExprH,
                                         const char *aVar,
                                         size_t aLowerH,
                                         size_t aUpperH,
                                         size_t *aResultH)
;

rssn_ int32_t rssn_calculus_differentiate(size_t aExprH, const char *aVar, size_t *aResultH) ;

rssn_ int32_t rssn_calculus_integrate(size_t aExprH, const char *aVar, size_t *aResultH) ;

rssn_ int32_t rssn_calculus_limit(size_t aExprH, const char *aVar, size_t aToH, size_t *aResultH) ;

rssn_
int32_t rssn_calculus_substitute(size_t aExprH,
                                 const char *aVar,
                                 size_t aReplacementH,
                                 size_t *aResultH)
;

/*
 Expands an expression using algebraic rules.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ rssn_Expr *rssn_cas_expand(const rssn_Expr *aExpr) ;

/*
 Expands an expression using algebraic rules (Bincode).
 */
rssn_ rssn_BincodeBuffer rssn_cas_expand_bincode(rssn_BincodeBuffer aInput) ;

/*
 Expands an expression using algebraic rules (JSON).
 */
rssn_ char *rssn_cas_expand_json(const char *aJsonStr) ;

/*
 Factorizes an expression.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ rssn_Expr *rssn_cas_factorize(const rssn_Expr *aExpr) ;

/*
 Factorizes an expression (Bincode).
 */
rssn_ rssn_BincodeBuffer rssn_cas_factorize_bincode(rssn_BincodeBuffer aInput) ;

/*
 Factorizes an expression (JSON).
 */
rssn_ char *rssn_cas_factorize_json(const char *aJsonStr) ;

/*
 Normalizes an expression to a canonical form.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ rssn_Expr *rssn_cas_normalize(const rssn_Expr *aExpr) ;

/*
 Normalizes an expression to a canonical form (Bincode).
 */
rssn_ rssn_BincodeBuffer rssn_cas_normalize_bincode(rssn_BincodeBuffer aInput) ;

/*
 Normalizes an expression to a canonical form (JSON).
 */
rssn_ char *rssn_cas_normalize_json(const char *aJsonStr) ;

/*
 Simplifies an expression using a set of polynomial side-relations.

 # Arguments
 * `expr` - The expression to simplify.
 * `relations` - Array of pointers to relation expressions (e.g., `x^2 + y^2 - 1`).
 * `relations_len` - Number of relations.
 * `vars` - Array of C strings representing variable ordering.
 * `vars_len` - Number of variables.
 * `order_int` - Monomial ordering: 0=Lex, 1=GradedLex, 2=GradedReverseLex.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_cas_simplify_with_relations(const rssn_Expr *aExpr,
                                            const rssn_Expr *const *aRelations,
                                            size_t aRelationsLen,
                                            const char *const *aVars,
                                            size_t aVarsLen,
                                            int32_t aOrderInt)
;

/*
 Simplifies an expression using a set of polynomial side-relations (Bincode).
 */
rssn_ rssn_BincodeBuffer rssn_cas_simplify_with_relations_bincode(rssn_BincodeBuffer aInput) ;

/*
 Simplifies an expression using a set of polynomial side-relations (JSON).
 */
rssn_ char *rssn_cas_simplify_with_relations_json(const char *aJsonStr) ;

rssn_ rssn_Expr *rssn_catalan_number(size_t aN) ;

rssn_
void rssn_character(const rssn_Representation *aRep,
                    size_t *aOutLen,
                    rssn_Expr ***aOutKeys,
                    rssn_Expr ***aOutValues)
;

/*
 Checks if an expression is analytic with respect to a variable.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `var` is a valid C string.
 */
rssn_ bool rssn_check_analytic(const rssn_Expr *aExpr, const char *aVar) ;

rssn_ bool rssn_check_jacobi_identity(const rssn_LieAlgebra *aAlgebra) ;

/*
 Solves a system of congruences using the Chinese Remainder Theorem.

 # Safety
 `remainders` and `moduli` must be valid pointers to arrays of `Expr` pointers of length `len`.
 */
rssn_
rssn_Expr *rssn_chinese_remainder_handle(const rssn_Expr *const *aRemainders,
                                         const rssn_Expr *const *aModuli,
                                         int aLen)
;

/*
 Finds the chromatic number exactly (NP-hard).
 */
rssn_ size_t rssn_chromatic_number_exact(const rssn_RssnGraph *aGraph) ;

/*
 Computes the number of combinations (nCk).
 */
rssn_ int32_t rssn_comb_combinations(uint64_t aN, uint64_t aK, double *aResult) ;

/*
 Computes the factorial of a number.
 */
rssn_ int32_t rssn_comb_factorial(uint64_t aN, double *aResult) ;

/*
 Computes the number of permutations (nPk).
 */
rssn_ int32_t rssn_comb_permutations(uint64_t aN, uint64_t aK, double *aResult) ;

rssn_ rssn_Expr *rssn_combinations(const rssn_Expr *aN, const rssn_Expr *aK) ;

rssn_
rssn_Expr **rssn_commutator_table(const rssn_LieAlgebra *aAlgebra,
                                  size_t *aOutRows,
                                  size_t *aOutCols)
;

/*
 Finds fixed points (Handle)
 */
rssn_
rssn_Expr **rssn_complex_system_fixed_points(const rssn_ComplexDynamicalSystem *aSystemPtr,
                                             size_t *aOutLen)
;

/*
 Frees a ComplexDynamicalSystem handle
 */
rssn_ void rssn_complex_system_free(rssn_ComplexDynamicalSystem *aPtr) ;

/*
 Iterates the system once (Handle)
 */
rssn_
rssn_Expr *rssn_complex_system_iterate(const rssn_ComplexDynamicalSystem *aSystemPtr,
                                       const rssn_Expr *aZPtr)
;

/*
 Creates a new Mandelbrot family system (Handle)
 */
rssn_ rssn_ComplexDynamicalSystem *rssn_complex_system_new_mandelbrot(const rssn_Expr *aCPtr) ;

/*
 Clears a ComputationResultCache.
 */
rssn_ void rssn_computation_result_cache_clear(rssn_ComputationResultCache *aCache) ;

/*
 Frees a ComputationResultCache.
 */
rssn_ void rssn_computation_result_cache_free(rssn_ComputationResultCache *aCache) ;

/*
 Retrieves a value from the ComputationResultCache.
 Returns a C string (char*) which must be freed by the caller using rssn_free_string.
 Returns null if not found.
 */
rssn_
char *rssn_computation_result_cache_get(rssn_ComputationResultCache *aCache,
                                        const rssn_Expr *aExpr)
;

/*
 Retrieves a value from the ComputationResultCache using a bincode expression key.
 */
rssn_
rssn_BincodeBuffer rssn_computation_result_cache_get_bincode(rssn_ComputationResultCache *aCache,
                                                             rssn_BincodeBuffer aExprBuffer)
;

/*
 Retrieves a value from the ComputationResultCache using a JSON expression key.
 Returns the value as a JSON string (e.g. "\"result\"").
 */
rssn_
char *rssn_computation_result_cache_get_json(rssn_ComputationResultCache *aCache,
                                             const char *aJsonExpr)
;

/*
 Creates a new ComputationResultCache.
 The caller is responsible for freeing the memory using rssn_computation_result_cache_free.
 */
rssn_ rssn_ComputationResultCache *rssn_computation_result_cache_new() ;

/*
 Stores a value in the ComputationResultCache.
 */
rssn_
void rssn_computation_result_cache_set(rssn_ComputationResultCache *aCache,
                                       const rssn_Expr *aExpr,
                                       const char *aValue)
;

/*
 Stores a value in the ComputationResultCache using bincode buffers.
 */
rssn_
void rssn_computation_result_cache_set_bincode(rssn_ComputationResultCache *aCache,
                                               rssn_BincodeBuffer aExprBuffer,
                                               rssn_BincodeBuffer aValueBuffer)
;

/*
 Stores a value in the ComputationResultCache using JSON strings.
 */
rssn_
void rssn_computation_result_cache_set_json(rssn_ComputationResultCache *aCache,
                                            const char *aJsonExpr,
                                            const char *aJsonValue)
;

rssn_ rssn_Expr *rssn_coordinates_get_metric_tensor_handle(rssn_CoordinateSystem aSystem) ;

/*
 Computes the symbolic Pearson correlation coefficient.

 # Safety
 The caller must ensure `data1` and `data2` are valid pointers to arrays of `Expr` pointers.
 */
rssn_
rssn_Expr *rssn_correlation(const rssn_Expr *const *aData1,
                            size_t aLen1,
                            const rssn_Expr *const *aData2,
                            size_t aLen2)
;

/*
 Creates a cosine expression: cos(expr).
 */
rssn_ rssn_Expr *rssn_cos(const rssn_Expr *aExpr) ;

/*
 Creates a cosine expression from bincode: cos(expr).
 */
rssn_ rssn_BincodeBuffer rssn_cos_bincode(rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a cosine expression from JSON: cos(expr).
 */
rssn_ char *rssn_cos_json(const char *aJsonExpr) ;

/*
 Counts the number of distinct real roots in an interval (Handle)
 */
rssn_
int64_t rssn_count_real_roots_in_interval_handle(const rssn_Expr *aExprPtr,
                                                 const char *aVarPtr,
                                                 double aA,
                                                 double aB)
;

/*
 Computes the symbolic covariance of two sets of expressions.

 # Safety
 The caller must ensure `data1` and `data2` are valid pointers to arrays of `Expr` pointers.
 */
rssn_
rssn_Expr *rssn_covariance(const rssn_Expr *const *aData1,
                           size_t aLen1,
                           const rssn_Expr *const *aData2,
                           size_t aLen2)
;

/*
 Creates a grid complex
 */
rssn_ rssn_SimplicialComplex *rssn_create_grid_complex(size_t aWidth, size_t aHeight) ;

/*
 Creates a torus complex
 */
rssn_ rssn_SimplicialComplex *rssn_create_torus_complex(size_t aM, size_t aN) ;

rssn_ rssn_Group *rssn_cyclic_group_create(size_t aN) ;

/*
 Computes the definite integral of an expression.
 */
rssn_
rssn_Expr *rssn_definite_integrate(const rssn_Expr *aExpr,
                                   const char *aVar,
                                   const rssn_Expr *aLower,
                                   const rssn_Expr *aUpper)
;

/*
 Denests a nested square root (Handle)
 */
rssn_ rssn_Expr *rssn_denest_sqrt_handle(const rssn_Expr *aExpr) ;

/*
 Differentiates an expression: d/d(var) expr.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `var` is a valid C string.
 */
rssn_ rssn_Expr *rssn_differentiate(const rssn_Expr *aExpr, const char *aVar) ;

rssn_ rssn_Group *rssn_dihedral_group_create(size_t aN) ;

rssn_ rssn_Expr *rssn_dist_bernoulli(const rssn_Expr *aP) ;

rssn_ rssn_Expr *rssn_dist_beta(const rssn_Expr *aAlpha, const rssn_Expr *aBeta) ;

rssn_ rssn_Expr *rssn_dist_binomial(const rssn_Expr *aN, const rssn_Expr *aP) ;

rssn_ rssn_Expr *rssn_dist_cdf(const rssn_Expr *aDist, const rssn_Expr *aX) ;

rssn_ rssn_Expr *rssn_dist_expectation(const rssn_Expr *aDist) ;

rssn_ rssn_Expr *rssn_dist_exponential(const rssn_Expr *aRate) ;

rssn_ rssn_Expr *rssn_dist_gamma(const rssn_Expr *aShape, const rssn_Expr *aRate) ;

rssn_ rssn_Expr *rssn_dist_mgf(const rssn_Expr *aDist, const rssn_Expr *aT) ;

rssn_ rssn_Expr *rssn_dist_normal(const rssn_Expr *aMean, const rssn_Expr *aStdDev) ;

rssn_ rssn_Expr *rssn_dist_pdf(const rssn_Expr *aDist, const rssn_Expr *aX) ;

rssn_ rssn_Expr *rssn_dist_poisson(const rssn_Expr *aRate) ;

rssn_ rssn_Expr *rssn_dist_student_t(const rssn_Expr *aNu) ;

rssn_ rssn_Expr *rssn_dist_uniform(const rssn_Expr *aMin, const rssn_Expr *aMax) ;

rssn_ rssn_Expr *rssn_dist_variance(const rssn_Expr *aDist) ;

/*
 Returns the symbolic representation of Euler's number (e).
 */
rssn_ rssn_Expr *rssn_e() ;

/*
 Returns Euler's number (e) as bincode.
 */
rssn_ rssn_BincodeBuffer rssn_e_bincode() ;

/*
 Returns Euler's number (e) as JSON.
 */
rssn_ char *rssn_e_json() ;

/*
 Evaluates an expression at a given point.
 */
rssn_
rssn_Expr *rssn_evaluate_at_point(const rssn_Expr *aExpr,
                                  const char *aVar,
                                  const rssn_Expr *aValue)
;

rssn_ double rssn_evaluate_numerical_handle(const rssn_Expr *aExpr) ;

/*
 Creates an exponential expression: e^(expr).
 */
rssn_ rssn_Expr *rssn_exp(const rssn_Expr *aExpr) ;

/*
 Creates an exponential expression from bincode: e^(expr).
 */
rssn_ rssn_BincodeBuffer rssn_exp_bincode(rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates an exponential expression from JSON: e^(expr).
 */
rssn_ char *rssn_exp_json(const char *aJsonExpr) ;

/*
 Expands a symbolic expression.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ rssn_Expr *rssn_expand(const rssn_Expr *aExpr) ;

/*
 Expands a symbolic expression from bincode.
 */
rssn_ rssn_BincodeBuffer rssn_expand_bincode(rssn_BincodeBuffer aExprBuffer) ;

/*
 Expands a symbolic expression from JSON.
 */
rssn_ char *rssn_expand_json(const char *aJsonExpr) ;

rssn_ rssn_Expr *rssn_exponential_map(const rssn_Expr *aX, size_t aOrder) ;

/*
 Creates an expression from a JSON string and returns a thread-safe handle.

 Returns 0 if the JSON is invalid.
 */
rssn_ size_t rssn_expr_create(const char *aJsonPtr) ;

/*
 Frees the memory associated with an expression handle.
 */
rssn_ void rssn_expr_free(size_t aHandle) ;

/*
 Simplifies an expression handle and returns a handle to the new, simplified expression.

 Returns 0 on error (e.g., invalid handle).
 */
rssn_ size_t rssn_expr_simplify(const size_t *aHandle) ;

/*
 Computes the Extended GCD of two expressions.

 # Safety
 `a` and `b` must be valid pointers to `Expr`.
 */
rssn_ rssn_Expr *rssn_extended_gcd_handle(const rssn_Expr *aA, const rssn_Expr *aB) ;

/*
 Computes the exterior derivative of a differential form (Handle)
 */
rssn_
rssn_DifferentialForm *rssn_exterior_derivative_handle(const rssn_DifferentialForm *aFormPtr,
                                                       const char *const *aVarsPtr,
                                                       int aVarsLen)
;

/*
 Factors a polynomial over a finite field (Handle)
 */
rssn_
rssn_Vec<rssn_FiniteFieldPolynomial> *rssn_factor_gf_handle(const rssn_FiniteFieldPolynomial *aPoly)
;

/*
 Computes the Fast Fourier Transform (FFT) of a sequence of complex numbers in-place.
 */
rssn_ int32_t rssn_fft(rssn_Complex<double> *aData, size_t aLen) ;

/*
 Finds constrained extrema (Handle)
 */
rssn_
rssn_Vec<rssn_HashMap<rssn_Expr, rssn_Expr>> *rssn_find_constrained_extrema_handle(const rssn_Expr *aExprPtr,
                                                                                   const rssn_Vec<rssn_Expr> *aConstraintsPtr,
                                                                                   const char *const *aVarsPtr,
                                                                                   int aVarsLen)
;

/*
 Finds extrema of a function (Handle)
 */
rssn_
rssn_Vec<rssn_CriticalPoint> *rssn_find_extrema_handle(const rssn_Expr *aExprPtr,
                                                       const char *const *aVarsPtr,
                                                       int aVarsLen)
;

/*
 Finds fixed points of a 1D map (Handle)
 */
rssn_
rssn_Expr **rssn_find_fixed_points(const rssn_Expr *aMapPtr,
                                   const char *aVar,
                                   size_t *aOutLen)
;

/*
 Finds the order of a pole.
 */
rssn_
size_t rssn_find_pole_order(const rssn_Expr *aExpr,
                            const char *aVar,
                            const rssn_Expr *aPole)
;

/*
 Finds poles of an expression.
 */
rssn_ rssn_Vec<rssn_Expr> *rssn_find_poles(const rssn_Expr *aExpr, const char *aVar) ;

rssn_
rssn_Expr *rssn_fourier_series_handle(const rssn_Expr *aExpr,
                                      const char *aVar,
                                      const rssn_Expr *aPeriod,
                                      size_t aOrder)
;

/*
 Frees a Fredholm integral equation.
 */
rssn_ void rssn_fredholm_free(rssn_FredholmEquation *aPtr) ;

/*
 Creates a new Fredholm integral equation.
 */
rssn_
rssn_FredholmEquation *rssn_fredholm_new(const rssn_Expr *aYX,
                                         const rssn_Expr *aFX,
                                         const rssn_Expr *aLambda,
                                         const rssn_Expr *aKernel,
                                         const rssn_Expr *aLowerBound,
                                         const rssn_Expr *aUpperBound,
                                         const char *aVarX,
                                         const char *aVarT)
;

/*
 Solves a Fredholm equation using the Neumann series method.
 */
rssn_ rssn_Expr *rssn_fredholm_solve_neumann(const rssn_FredholmEquation *aEq, size_t aIterations) ;

/*
 Solves a Fredholm equation using the Neumann series method (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_fredholm_solve_neumann_bincode(const uint8_t *aInputPtr,
                                                       size_t aInputLen)
;

/*
 Solves a Fredholm equation using the Neumann series method (JSON).
 */
rssn_ char *rssn_fredholm_solve_neumann_json(const char *aInputJson) ;

/*
 Solves a Fredholm equation with a separable kernel.
 */
rssn_
rssn_Expr *rssn_fredholm_solve_separable(const rssn_FredholmEquation *aEq,
                                         const rssn_Expr *const *aAFuncs,
                                         size_t aALen,
                                         const rssn_Expr *const *aBFuncs,
                                         size_t aBLen)
;

/*
 Solves a Fredholm equation with a separable kernel (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_fredholm_solve_separable_bincode(const uint8_t *aInputPtr,
                                                         size_t aInputLen)
;

/*
 Solves a Fredholm equation with a separable kernel (JSON).
 */
rssn_ char *rssn_fredholm_solve_separable_json(const char *aInputJson) ;

/*
 Frees a bincode buffer allocated by an FFI function.

 # Safety
 The buffer must have been allocated by an FFI function that returns `BincodeBuffer`.
 This function should only be called once per buffer.
 */
rssn_ void rssn_free_bincode_buffer(rssn_BincodeBuffer aBuffer) ;

/*
 Frees a Vec<CriticalPoint> handle
 */
rssn_ void rssn_free_critical_point_vec_handle(rssn_Vec<rssn_CriticalPoint> *aPtr) ;

/*
 Frees a DifferentialForm handle
 */
rssn_ void rssn_free_differential_form_handle(rssn_DifferentialForm *aPtr) ;

/*
 Frees an Expr pointer created by this module.

 # Safety
 The caller must ensure `expr` was created by this module and hasn't been freed yet.
 */
rssn_ void rssn_free_expr(rssn_Expr *aExpr) ;

/*
 Frees a Vec<Expr> handle
 */
rssn_ void rssn_free_expr_vec_handle(rssn_Vec<rssn_Expr> *aPtr) ;

/*
 Frees a multivector (Handle)
 */
rssn_ void rssn_free_multivector_handle(rssn_Multivector *aPtr) ;

rssn_ void rssn_free_poles(rssn_Vec<rssn_Expr> *aPoles) ;

/*
 Frees a vector of polynomials (Handle)
 */
rssn_ void rssn_free_poly_vec_handle(rssn_Vec<rssn_FiniteFieldPolynomial> *aPtr) ;

/*
 Frees a Vec<HashMap<Expr, Expr>> handle
 */
rssn_ void rssn_free_solution_vec_handle(rssn_Vec<rssn_HashMap<rssn_Expr, rssn_Expr>> *aPtr) ;

/*
 Frees a string allocated by an FFI function.

 # Safety
 The string must have been allocated by an FFI function that returns `*mut c_char`.
 This function should only be called once per string.
 */
rssn_ void rssn_free_string(char *aS) ;

/*
 Frees a C string returned by other functions.
 */
rssn_ void rssn_free_string_api(char *aPtr) ;

/*
 Represents Gauss's theorem (Handle)
 */
rssn_
rssn_Expr *rssn_gauss_theorem_handle(const rssn_Vector *aVectorFieldPtr,
                                     const rssn_Expr *aVolumePtr)
;

/*
 Computes general multi-valued arccos (Handle)
 */
rssn_
rssn_Expr *rssn_general_arccos_handle(const rssn_Expr *aZ,
                                      const rssn_Expr *aK,
                                      const rssn_Expr *aS)
;

/*
 Computes general multi-valued arcsin (Handle)
 */
rssn_ rssn_Expr *rssn_general_arcsin_handle(const rssn_Expr *aZ, const rssn_Expr *aK) ;

/*
 Computes general multi-valued arctan (Handle)
 */
rssn_ rssn_Expr *rssn_general_arctan_handle(const rssn_Expr *aZ, const rssn_Expr *aK) ;

/*
 Computes general multi-valued logarithm (Handle)
 */
rssn_ rssn_Expr *rssn_general_log_handle(const rssn_Expr *aZ, const rssn_Expr *aK) ;

/*
 Computes general multi-valued n-th root (Handle)
 */
rssn_
rssn_Expr *rssn_general_nth_root_handle(const rssn_Expr *aZ,
                                        const rssn_Expr *aN,
                                        const rssn_Expr *aK)
;

/*
 Computes general multi-valued power (Handle)
 */
rssn_
rssn_Expr *rssn_general_power_handle(const rssn_Expr *aZ,
                                     const rssn_Expr *aW,
                                     const rssn_Expr *aK)
;

/*
 Computes general multi-valued square root (Handle)
 */
rssn_ rssn_Expr *rssn_general_sqrt_handle(const rssn_Expr *aZ, const rssn_Expr *aK) ;

/*
 Represents the generalized Stokes' theorem (Handle)
 */
rssn_
rssn_Expr *rssn_generalized_stokes_theorem_handle(const rssn_DifferentialForm *aOmegaPtr,
                                                  const rssn_Expr *aManifoldPtr,
                                                  const char *const *aVarsPtr,
                                                  int aVarsLen)
;

/*
 Returns the build date as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_build_date() ;

/*
 Returns the build date as a bincode buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_ rssn_BincodeBuffer rssn_get_build_date_bincode() ;

/*
 Returns the build date as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_build_date_json() ;

/*
 Returns all build information as a bincode buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_ rssn_BincodeBuffer rssn_get_build_info_bincode() ;

/*
 Returns all build information as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_build_info_json() ;

/*
 Returns the cargo target triple as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_cargo_target_triple() ;

/*
 Returns the commit SHA as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_commit_sha() ;

/*
 Returns the commit SHA as a bincode buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_ rssn_BincodeBuffer rssn_get_commit_sha_bincode() ;

/*
 Returns the commit SHA as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_commit_sha_json() ;

/*
 Retrieves the last error message set by an FFI function on the current thread.

 The returned pointer is valid until the next call to an FFI function on the same thread.
 The caller should not free this pointer.
 */
rssn_ const char *rssn_get_last_error() ;

/*
 Gets real and imaginary parts of an expression.
 Returns a pointer to a tuple (Expr, Expr) - represented as Vec<Expr> of size 2 for simplicity?
 Or return two out pointers?
 I'll return a Vec<Expr> of size 2.
 */
rssn_ rssn_Vec<rssn_Expr> *rssn_get_real_imag_parts(const rssn_Expr *aExpr) ;

/*
 Returns the rustc version as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_rustc_version() ;

/*
 Returns the system info as a C string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_get_system_info() ;

rssn_
rssn_Expr **rssn_gram_schmidt(const rssn_HilbertSpace *aSpace,
                              const rssn_Expr *const *aBasisPtr,
                              size_t aBasisLen,
                              size_t *aOutLen)
;

/*
 Adds an edge to the graph.
 */
rssn_
void rssn_graph_add_edge(rssn_RssnGraph *aPtr,
                         const char *aFromLabel,
                         const char *aToLabel,
                         const rssn_Expr *aWeight)
;

/*
 Adds a node to the graph.
 */
rssn_ size_t rssn_graph_add_node(rssn_RssnGraph *aPtr, const char *aLabel) ;

/*
 Gets the adjacency matrix of the graph.
 */
rssn_ rssn_Expr *rssn_graph_adjacency_matrix(const rssn_RssnGraph *aPtr) ;

/*
 Performs BFS traversal from a start node.
 Returns a JSON string containing the node IDs in visit order.
 */
rssn_ char *rssn_graph_bfs(const rssn_RssnGraph *aPtr, size_t aStartNode) ;

/*
 Performs BFS traversal starting from a given node.
 Returns a JSON array of node indices in visit order.
 */
rssn_ char *rssn_graph_bfs_api(const rssn_RssnGraph *aGraph, size_t aStartNode) ;

/*
 Finds maximum matching in a bipartite graph.
 partition_json should be a JSON array of 0s and 1s indicating the partition.
 Returns a JSON array of [u, v] pairs representing the matching.
 */
rssn_
char *rssn_graph_bipartite_maximum_matching(const rssn_RssnGraph *aGraph,
                                            const char *aPartitionJson)
;

/*
 Finds bridges and articulation points.
 Returns a JSON object with "bridges" and "articulation_points" fields.
 */
rssn_ char *rssn_graph_bridges_and_articulation_points_api(const rssn_RssnGraph *aGraph) ;

/*
 Computes the Cartesian product of two graphs.
 */
rssn_
rssn_RssnGraph *rssn_graph_cartesian_product(const rssn_RssnGraph *aPtr1,
                                             const rssn_RssnGraph *aPtr2)
;

/*
 Computes the complement of a graph.
 */
rssn_ rssn_RssnGraph *rssn_graph_complement(const rssn_RssnGraph *aPtr) ;

/*
 Finds connected components.
 Returns a JSON string containing the components.
 */
rssn_ char *rssn_graph_connected_components(const rssn_RssnGraph *aPtr) ;

/*
 Finds all connected components in an undirected graph.
 Returns a JSON array of arrays, where each inner array is a component.
 */
rssn_ char *rssn_graph_connected_components_api(const rssn_RssnGraph *aGraph) ;

/*
 Performs DFS traversal from a start node.
 Returns a JSON string containing the node IDs in visit order.
 */
rssn_ char *rssn_graph_dfs(const rssn_RssnGraph *aPtr, size_t aStartNode) ;

/*
 Performs DFS traversal starting from a given node.
 Returns a JSON array of node indices in visit order.
 */
rssn_ char *rssn_graph_dfs_api(const rssn_RssnGraph *aGraph, size_t aStartNode) ;

/*
 Computes maximum flow using Dinic's algorithm.
 */
rssn_ double rssn_graph_dinic_max_flow(const rssn_RssnGraph *aGraph, size_t aSource, size_t aSink) ;

/*
 Computes the disjoint union of two graphs.
 */
rssn_
rssn_RssnGraph *rssn_graph_disjoint_union(const rssn_RssnGraph *aPtr1,
                                          const rssn_RssnGraph *aPtr2)
;

/*
 Computes maximum flow using Edmonds-Karp algorithm.
 */
rssn_
double rssn_graph_edmonds_karp_max_flow(const rssn_RssnGraph *aGraph,
                                        size_t aSource,
                                        size_t aSink)
;

/*
 Frees a graph.
 */
rssn_ void rssn_graph_free(rssn_RssnGraph *aPtr) ;

/*
 Checks if the graph has a cycle.
 */
rssn_ int rssn_graph_has_cycle(const rssn_RssnGraph *aPtr) ;

/*
 Checks if the graph has a cycle.
 */
rssn_ int rssn_graph_has_cycle_api(const rssn_RssnGraph *aGraph) ;

/*
 Gets the incidence matrix of the graph.
 */
rssn_ rssn_Expr *rssn_graph_incidence_matrix(const rssn_RssnGraph *aPtr) ;

/*
 Creates an induced subgraph.
 */
rssn_
rssn_RssnGraph *rssn_graph_induced_subgraph(const rssn_RssnGraph *aPtr,
                                            const char *const *aNodeLabels,
                                            size_t aCount)
;

/*
 Computes the intersection of two graphs.
 */
rssn_
rssn_RssnGraph *rssn_graph_intersection(const rssn_RssnGraph *aPtr1,
                                        const rssn_RssnGraph *aPtr2)
;

/*
 Checks if the graph is bipartite.
 Returns 1 if bipartite, 0 otherwise.
 */
rssn_ int rssn_graph_is_bipartite(const rssn_RssnGraph *aPtr) ;

/*
 Checks if a graph is bipartite.
 Returns a JSON array of partition assignments (0 or 1 for each node), or null if not bipartite.
 */
rssn_ char *rssn_graph_is_bipartite_api(const rssn_RssnGraph *aGraph) ;

/*
 Checks if the graph is connected.
 */
rssn_ int rssn_graph_is_connected(const rssn_RssnGraph *aGraph) ;

/*
 Computes the join of two graphs.
 */
rssn_ rssn_RssnGraph *rssn_graph_join(const rssn_RssnGraph *aPtr1, const rssn_RssnGraph *aPtr2) ;

/*
 Computes minimum spanning tree using Kruskal's algorithm.
 Returns a JSON string containing the MST edges.
 */
rssn_ char *rssn_graph_kruskal_mst(const rssn_RssnGraph *aPtr) ;

/*
 Computes the minimum spanning tree using Kruskal's algorithm.
 Returns a new graph containing only the MST edges.
 */
rssn_ rssn_RssnGraph *rssn_graph_kruskal_mst_api(const rssn_RssnGraph *aGraph) ;

/*
 Gets the Laplacian matrix of the graph.
 */
rssn_ rssn_Expr *rssn_graph_laplacian_matrix(const rssn_RssnGraph *aPtr) ;

/*
 Computes maximum flow using Edmonds-Karp algorithm.
 */
rssn_ double rssn_graph_max_flow(const rssn_RssnGraph *aPtr, size_t aSource, size_t aSink) ;

/*
 Creates a new graph.
 */
rssn_ rssn_RssnGraph *rssn_graph_new(int aIsDirected) ;

/*
 Gets the number of nodes in the graph.
 */
rssn_ size_t rssn_graph_node_count(const rssn_RssnGraph *aPtr) ;

/*
 Finds all strongly connected components in a directed graph.
 Returns a JSON array of arrays.
 */
rssn_ char *rssn_graph_strongly_connected_components(const rssn_RssnGraph *aGraph) ;

/*
 Computes the Tensor product of two graphs.
 */
rssn_
rssn_RssnGraph *rssn_graph_tensor_product(const rssn_RssnGraph *aPtr1,
                                          const rssn_RssnGraph *aPtr2)
;

/*
 Performs topological sort on a DAG.
 Returns a JSON array of node indices in topological order, or null if the graph has a cycle.
 */
rssn_ char *rssn_graph_topological_sort(const rssn_RssnGraph *aGraph) ;

/*
 Computes the union of two graphs.
 */
rssn_ rssn_RssnGraph *rssn_graph_union(const rssn_RssnGraph *aPtr1, const rssn_RssnGraph *aPtr2) ;

/*
 Finds a valid vertex coloring using greedy heuristic.
 Returns a JSON object mapping node IDs to colors.
 */
rssn_ char *rssn_greedy_coloring(const rssn_RssnGraph *aGraph) ;

/*
 Represents Green's theorem (Handle)
 */
rssn_
rssn_Expr *rssn_greens_theorem_handle(const rssn_Expr *aPPtr,
                                      const rssn_Expr *aQPtr,
                                      const rssn_Expr *aDomainPtr)
;

rssn_ rssn_Expr **rssn_group_center(const rssn_Group *aGroup, size_t *aOutLen) ;

rssn_
rssn_Group *rssn_group_create(const rssn_Expr *const *aElementsPtr,
                              size_t aElementsLen,
                              const rssn_Expr *const *aKeysAPtr,
                              const rssn_Expr *const *aKeysBPtr,
                              const rssn_Expr *const *aValuesPtr,
                              size_t aTableLen,
                              const rssn_Expr *aIdentityPtr)
;

rssn_ size_t rssn_group_element_order(const rssn_Group *aGroup, const rssn_Expr *aA) ;

rssn_ void rssn_group_free(rssn_Group *aPtr) ;

rssn_ rssn_Expr *rssn_group_inverse(const rssn_Group *aGroup, const rssn_Expr *aA) ;

rssn_ bool rssn_group_is_abelian(const rssn_Group *aGroup) ;

rssn_
rssn_Expr *rssn_group_multiply(const rssn_Group *aGroup,
                               const rssn_Expr *aA,
                               const rssn_Expr *aB)
;

/*
 Clears all expressions from the handle manager.

 **Warning**: This invalidates all existing handles.

 # Safety
 This function is always safe to call, but will invalidate all handles.
 */
rssn_ void rssn_handle_clear() ;

/*
 Clears all handles (Bincode).
 */
rssn_ rssn_BincodeBuffer rssn_handle_clear_bincode() ;

/*
 Clears all handles (JSON).

 Output: JSON object with "cleared" boolean field
 */
rssn_ char *rssn_handle_clear_json() ;

/*
 Clones an expression handle, creating a new handle pointing to the same expression.

 Returns 0 if the source handle doesn't exist.

 # Safety
 This function is safe to call with any handle value.
 */
rssn_ size_t rssn_handle_clone(size_t aHandle) ;

/*
 Clones a handle (Bincode).
 */
rssn_ rssn_BincodeBuffer rssn_handle_clone_bincode(rssn_BincodeBuffer aInput) ;

/*
 Clones a handle (JSON).

 Input: JSON object with "handle" field
 Output: JSON object with "new_handle" field
 */
rssn_ char *rssn_handle_clone_json(const char *aJsonStr) ;

/*
 Returns the number of expressions currently managed.

 # Safety
 This function is always safe to call.
 */
rssn_ size_t rssn_handle_count() ;

/*
 Checks if a handle exists in the manager.

 # Safety
 This function is safe to call with any handle value.
 */
rssn_ bool rssn_handle_exists(size_t aHandle) ;

/*
 Checks if a handle exists (Bincode).
 */
rssn_ rssn_BincodeBuffer rssn_handle_exists_bincode(rssn_BincodeBuffer aInput) ;

/*
 Checks if a handle exists (JSON).

 Input: JSON object with "handle" field
 Output: JSON object with "exists" boolean field
 */
rssn_ char *rssn_handle_exists_json(const char *aJsonStr) ;

/*
 Frees a handle from the manager.

 Returns true if the handle was found and freed, false otherwise.

 # Safety
 This function is safe to call with any handle value.
 */
rssn_ bool rssn_handle_free(size_t aHandle) ;

/*
 Frees a handle (Bincode).
 */
rssn_ rssn_BincodeBuffer rssn_handle_free_bincode(rssn_BincodeBuffer aInput) ;

/*
 Frees a handle (JSON).

 Input: JSON object with "handle" field
 Output: JSON object with "freed" boolean field
 */
rssn_ char *rssn_handle_free_json(const char *aJsonStr) ;

/*
 Retrieves an expression from the handle manager.

 Returns a new owned Expr pointer that must be freed by the caller.

 # Safety
 The caller must ensure the returned pointer is freed using `rssn_free_expr`.
 */
rssn_ rssn_Expr *rssn_handle_get(size_t aHandle) ;

/*
 Returns a list of all active handles as a JSON array string.

 The returned string must be freed using `rssn_free_string`.

 # Safety
 The caller must free the returned string.
 */
rssn_ char *rssn_handle_get_all() ;

/*
 Returns all active handles (Bincode).
 */
rssn_ rssn_BincodeBuffer rssn_handle_get_all_bincode() ;

/*
 Retrieves an expression by handle (Bincode).
 */
rssn_ rssn_BincodeBuffer rssn_handle_get_bincode(rssn_BincodeBuffer aInput) ;

/*
 Retrieves an expression by handle (JSON).

 Input: JSON object with "handle" field
 Output: JSON-serialized Expr
 */
rssn_ char *rssn_handle_get_json(const char *aJsonStr) ;

/*
 Inserts an expression into the handle manager and returns a unique handle.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ size_t rssn_handle_insert(const rssn_Expr *aExpr) ;

/*
 Inserts an expression (Bincode) into the handle manager.
 */
rssn_ rssn_BincodeBuffer rssn_handle_insert_bincode(rssn_BincodeBuffer aInput) ;

/*
 Inserts an expression (JSON) into the handle manager.

 Input: JSON-serialized Expr
 Output: JSON object with "handle" field
 */
rssn_ char *rssn_handle_insert_json(const char *aJsonStr) ;

/*
 Returns handle manager statistics (JSON).

 Output: JSON object with "count" and "handles" fields
 */
rssn_ char *rssn_handle_stats_json() ;

/*
 Converts an expression handle to a string representation.

 The returned string must be freed using `rssn_free_string`.

 # Safety
 The caller must free the returned string.
 */
rssn_ char *rssn_handle_to_string(size_t aHandle) ;

/*
 Computes Hessian matrix (Handle)
 */
rssn_
rssn_Expr *rssn_hessian_matrix_handle(const rssn_Expr *aExprPtr,
                                      const char *const *aVarsPtr,
                                      int aVarsLen)
;

/*
 Simplifies an expression using the heuristic simplifier.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ rssn_Expr *rssn_heuristic_simplify(const rssn_Expr *aExpr) ;

rssn_
rssn_HilbertSpace *rssn_hilbert_space_create(const char *aVar,
                                             const rssn_Expr *aLowerBound,
                                             const rssn_Expr *aUpperBound)
;

rssn_ void rssn_hilbert_space_free(rssn_HilbertSpace *aPtr) ;

/*
 Computes the Inverse Fast Fourier Transform (IFFT) of a sequence of complex numbers in-place.
 */
rssn_ int32_t rssn_ifft(rssn_Complex<double> *aData, size_t aLen) ;

/*
 Creates a new IteratedFunctionSystem (Handle)
 */
rssn_
rssn_IteratedFunctionSystem *rssn_ifs_create(rssn_Expr *const *aFunctionsPtr,
                                             size_t aFunctionsLen,
                                             rssn_Expr *const *aProbabilitiesPtr,
                                             size_t aProbabilitiesLen,
                                             const char *const *aVariablesPtr,
                                             size_t aVariablesLen)
;

/*
 Frees an IteratedFunctionSystem handle
 */
rssn_ void rssn_ifs_free(rssn_IteratedFunctionSystem *aPtr) ;

/*
 Calculates similarity dimension (Handle)
 */
rssn_ rssn_Expr *rssn_ifs_similarity_dimension(rssn_Expr *const *aScalingFactorsPtr, size_t aLen) ;

/*
 Initializes the plugin manager with a specified plugin directory.

 This function must be called before any plugin operations are performed.

 # Arguments
 * `plugin_dir_ptr` - A null-terminated UTF-8 string for the plugin directory path.

 # Returns
 0 on success, -1 on failure. On failure, an error message can be retrieved
 with `rssn_get_last_error`.
 */
rssn_ int32_t rssn_init_plugin_manager(const char *aPluginDirPtr) ;

rssn_
rssn_Expr *rssn_inner_product(const rssn_HilbertSpace *aSpace,
                              const rssn_Expr *aF,
                              const rssn_Expr *aG)
;

/*
 Integrates an expression: int(expr) d(var).

 # Safety
 The caller must ensure `expr` is a valid Expr pointer and `var` is a valid C string.
 */
rssn_ rssn_Expr *rssn_integrate(const rssn_Expr *aExpr, const char *aVar) ;

/*
 Integrates a rational function (Handle)
 */
rssn_ rssn_Expr *rssn_integrate_rational_function_handle(const rssn_Expr *aExpr, const char *aX) ;

/*
 Evaluates a point on a Bezier curve defined by control points.
 */
rssn_
int32_t rssn_interp_bezier_curve(const rssn_FfiPoint *aPointsPtr,
                                 size_t aNumPoints,
                                 double aT,
                                 rssn_FfiPoint *aResultPtr)
;

/*
 Computes a Lagrange interpolating polynomial from a set of points.
 Returns a handle to the resulting polynomial expression.
 */
rssn_
int32_t rssn_interp_lagrange(const rssn_FfiPoint *aPointsPtr,
                             size_t aNumPoints,
                             size_t *aResultHandle)
;

/*
 Checks if an expression is prime.

 # Safety
 `n` must be a valid pointer to an `Expr`.
 */
rssn_ rssn_Expr *rssn_is_prime_handle(const rssn_Expr *aN) ;

/*
 Checks if a logical expression is satisfiable using handle-based FFI.

 Returns:
 - 1 if satisfiable
 - 0 if unsatisfiable
 - -1 if the expression contains quantifiers (undecidable)

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_ int32_t rssn_is_satisfiable_handle(const rssn_Expr *aExpr) ;

/*
 Computes absolute value (magnitude) of complex number (JSON)
 */
rssn_ char *rssn_json_abs(const char *aZJson) ;

rssn_ char *rssn_json_adjoint_representation_algebra(const char *aXJson, const char *aYJson) ;

rssn_ char *rssn_json_adjoint_representation_group(const char *aGJson, const char *aXJson) ;

rssn_
char *rssn_json_analytic_continuation(const char *aExprJson,
                                      const char *aVarJson,
                                      const char *aOrigCenterJson,
                                      const char *aNewCenterJson,
                                      const char *aOrderJson)
;

rssn_ char *rssn_json_analyze_convergence(const char *aTermJson, const char *aVarJson) ;

/*
 Analyzes stability of a fixed point (JSON)
 */
rssn_
char *rssn_json_analyze_stability(const char *aMapJson,
                                  const char *aVar,
                                  const char *aFixedPointJson)
;

/*
 Checks if two graphs are isomorphic.
 Input: {"g1": Graph, "g2": Graph}
 Output: bool
 */
rssn_ char *rssn_json_are_isomorphic_heuristic(const char *aJson) ;

/*
 Computes argument (angle) of complex number (JSON)
 */
rssn_ char *rssn_json_arg(const char *aZJson) ;

rssn_
char *rssn_json_asymptotic_expansion(const char *aExprJson,
                                     const char *aVarJson,
                                     const char *aPointJson,
                                     const char *aOrderJson)
;

rssn_ char *rssn_json_bell_number(size_t aN) ;

/*
 Computes the boundary of a domain (JSON)
 */
rssn_ char *rssn_json_boundary(const char *aDomainJson) ;

rssn_ char *rssn_json_buchberger(const char *aBasisJson, const char *aOrderJson) ;

/*
 Calculates residue using JSON.
 */
rssn_
char *rssn_json_calculate_residue(const char *aExprJson,
                                  const char *aVar,
                                  const char *aPoleJson)
;

rssn_ char *rssn_json_catalan_number(size_t aN) ;

rssn_ char *rssn_json_character(const char *aRepJson) ;

/*
 Checks analytic using JSON.
 */
rssn_ bool rssn_json_check_analytic(const char *aExprJson, const char *aVar) ;

rssn_ bool rssn_json_check_jacobi_identity(const char *aAlgebraJson) ;

rssn_ char *rssn_json_chinese_remainder(const char *aCongruencesJson) ;

/*
 Exact chromatic number.
 Input: Graph
 Output: usize
 */
rssn_ char *rssn_json_chromatic_number_exact(const char *aJson) ;

/*
 Classifies a PDE and suggests solution methods (JSON).
 */
rssn_
char *rssn_json_classify_pde(const char *aEquationJson,
                             const char *aFunc,
                             const char *aVarsJson)
;

rssn_ char *rssn_json_combinations(const char *aNJson, const char *aKJson) ;

rssn_ char *rssn_json_commutator_table(const char *aAlgebraJson) ;

/*
 Finds fixed points (JSON)
 */
rssn_ char *rssn_json_complex_system_fixed_points(const char *aSystemJson) ;

/*
 Iterates the system once (JSON)
 */
rssn_ char *rssn_json_complex_system_iterate(const char *aSystemJson, const char *aZJson) ;

/*
 Creates a new Mandelbrot family system (JSON)
 */
rssn_ char *rssn_json_complex_system_new_mandelbrot(const char *aCJson) ;

rssn_ char *rssn_json_coordinates_get_metric_tensor(rssn_CoordinateSystem aSystem) ;

/*
 Computes the symbolic Pearson correlation coefficient using JSON.
 */
rssn_ char *rssn_json_correlation(const char *aData1Json, const char *aData2Json) ;

/*
 Counts the number of distinct real roots in an interval (JSON)
 */
rssn_
int64_t rssn_json_count_real_roots_in_interval(const char *aExprJson,
                                               const char *aVarPtr,
                                               double aA,
                                               double aB)
;

/*
 Computes the symbolic covariance of two sets of expressions using JSON.
 */
rssn_ char *rssn_json_covariance(const char *aData1Json, const char *aData2Json) ;

rssn_ char *rssn_json_cyclic_group_create(size_t aN) ;

/*
 Computes definite integral using JSON.
 */
rssn_
char *rssn_json_definite_integrate(const char *aExprJson,
                                   const char *aVar,
                                   const char *aLowerJson,
                                   const char *aUpperJson)
;

/*
 Denests a nested square root (JSON)
 */
rssn_ char *rssn_json_denest_sqrt(const char *aExprJson) ;

/*
 Differentiates an expression using JSON.
 */
rssn_ char *rssn_json_differentiate(const char *aExprJson, const char *aVar) ;

rssn_ char *rssn_json_dihedral_group_create(size_t aN) ;

rssn_ char *rssn_json_dist_bernoulli(const char *aPJson) ;

rssn_ char *rssn_json_dist_beta(const char *aAlphaJson, const char *aBetaJson) ;

rssn_ char *rssn_json_dist_binomial(const char *aNJson, const char *aPJson) ;

rssn_ char *rssn_json_dist_cdf(const char *aDistJson, const char *aXJson) ;

rssn_ char *rssn_json_dist_expectation(const char *aDistJson) ;

rssn_ char *rssn_json_dist_exponential(const char *aRateJson) ;

rssn_ char *rssn_json_dist_gamma(const char *aShapeJson, const char *aRateJson) ;

rssn_ char *rssn_json_dist_mgf(const char *aDistJson, const char *aTJson) ;

rssn_ char *rssn_json_dist_normal(const char *aMeanJson, const char *aStdDevJson) ;

rssn_ char *rssn_json_dist_pdf(const char *aDistJson, const char *aXJson) ;

rssn_ char *rssn_json_dist_poisson(const char *aRateJson) ;

rssn_ char *rssn_json_dist_student_t(const char *aNuJson) ;

rssn_ char *rssn_json_dist_uniform(const char *aMinJson, const char *aMaxJson) ;

rssn_ char *rssn_json_dist_variance(const char *aDistJson) ;

/*
 Evaluates at point using JSON.
 */
rssn_
char *rssn_json_evaluate_at_point(const char *aExprJson,
                                  const char *aVar,
                                  const char *aValueJson)
;

rssn_ char *rssn_json_evaluate_numerical(const char *aExprJson) ;

rssn_ char *rssn_json_exponential_map(const char *aXJson, size_t aOrder) ;

rssn_ char *rssn_json_extended_gcd(const char *aAJson, const char *aBJson) ;

/*
 Computes the exterior derivative of a differential form (JSON)
 */
rssn_ char *rssn_json_exterior_derivative(const char *aFormJson, const char *aVarsJson) ;

/*
 Factors a polynomial over a finite field (JSON)
 */
rssn_ char *rssn_json_factor_gf(const char *aPolyJson) ;

/*
 Finds constrained extrema (JSON)
 */
rssn_
char *rssn_json_find_constrained_extrema(const char *aExprJson,
                                         const char *aConstraintsJson,
                                         const char *aVarsJson)
;

/*
 Finds extrema of a function (JSON)
 */
rssn_ char *rssn_json_find_extrema(const char *aExprJson, const char *aVarsJson) ;

/*
 Finds fixed points of a 1D map (JSON)
 */
rssn_ char *rssn_json_find_fixed_points(const char *aMapJson, const char *aVar) ;

/*
 Finds pole order using JSON.
 */
rssn_
size_t rssn_json_find_pole_order(const char *aExprJson,
                                 const char *aVar,
                                 const char *aPoleJson)
;

/*
 Finds poles using JSON.
 */
rssn_ char *rssn_json_find_poles(const char *aExprJson, const char *aVar) ;

/*
 Gets the degree of a finite field polynomial (JSON)
 */
rssn_ int64_t rssn_json_finite_field_polynomial_degree(const char *aPolyJson) ;

/*
 Performs polynomial long division (JSON)
 */
rssn_
char *rssn_json_finite_field_polynomial_long_division(const char *aDividendJson,
                                                      const char *aDivisorJson)
;

/*
 Creates a new finite field polynomial (JSON)
 */
rssn_
char *rssn_json_finite_field_polynomial_new(const char *aCoeffsJson,
                                            const char *aModulusJson)
;

rssn_
char *rssn_json_fourier_series(const char *aExprJson,
                               const char *aVarJson,
                               const char *aPeriodJson,
                               const char *aOrderJson)
;

/*
 Represents Gauss's theorem (JSON)
 */
rssn_ char *rssn_json_gauss_theorem(const char *aVectorFieldJson, const char *aVolumeJson) ;

/*
 Computes general multi-valued arccos (JSON)
 */
rssn_ char *rssn_json_general_arccos(const char *aZJson, const char *aKJson, const char *aSJson) ;

/*
 Computes general multi-valued arcsin (JSON)
 */
rssn_ char *rssn_json_general_arcsin(const char *aZJson, const char *aKJson) ;

/*
 Computes general multi-valued arctan (JSON)
 */
rssn_ char *rssn_json_general_arctan(const char *aZJson, const char *aKJson) ;

/*
 Computes general multi-valued logarithm (JSON)
 */
rssn_ char *rssn_json_general_log(const char *aZJson, const char *aKJson) ;

/*
 Computes general multi-valued n-th root (JSON)
 */
rssn_ char *rssn_json_general_nth_root(const char *aZJson, const char *aNJson, const char *aKJson) ;

/*
 Computes general multi-valued power (JSON)
 */
rssn_ char *rssn_json_general_power(const char *aZJson, const char *aWJson, const char *aKJson) ;

/*
 Computes general multi-valued square root (JSON)
 */
rssn_ char *rssn_json_general_sqrt(const char *aZJson, const char *aKJson) ;

/*
 Represents the generalized Stokes' theorem (JSON)
 */
rssn_
char *rssn_json_generalized_stokes_theorem(const char *aOmegaJson,
                                           const char *aManifoldJson,
                                           const char *aVarsJson)
;

/*
 Gets real and imaginary parts using JSON.
 */
rssn_ char *rssn_json_get_real_imag_parts(const char *aExprJson) ;

rssn_ char *rssn_json_gram_schmidt(const char *aSpaceJson, const char *aBasisJson) ;

/*
 Adds an edge to the graph.
 Input JSON: {"graph": <graph>, "from": "label1", "to": "label2", "weight": <expr>}
 */
rssn_ char *rssn_json_graph_add_edge(const char *aJson) ;

/*
 Adds a node to the graph.
 Input JSON: {"graph": <graph>, "label": "node_label"}
 Returns updated graph as JSON.
 */
rssn_ char *rssn_json_graph_add_node(const char *aJson) ;

/*
 Gets the adjacency matrix of the graph.
 Input JSON: <graph>
 Returns Expr (matrix) as JSON.
 */
rssn_ char *rssn_json_graph_adjacency_matrix(const char *aJson) ;

/*
 Performs BFS traversal.
 Input JSON: {"graph": <graph>, "start_node": <index>}
 */
rssn_ char *rssn_json_graph_bfs(const char *aJson) ;

/*
 Performs BFS traversal.
 Input: {"graph": Graph, "start_node": usize}
 Output: [usize]
 */
rssn_ char *rssn_json_graph_bfs_api(const char *aJson) ;

/*
 Finds maximum matching in bipartite graph.
 Input: {"graph": Graph, "partition": [i8]}
 Output: [(usize, usize)]
 */
rssn_ char *rssn_json_graph_bipartite_maximum_matching(const char *aJson) ;

/*
 Finds bridges and articulation points.
 Input: Graph
 Output: {"bridges": [(usize, usize)], "articulation_points": [usize]}
 */
rssn_ char *rssn_json_graph_bridges_and_articulation_points(const char *aJson) ;

/*
 Computes the Cartesian product of two graphs.
 */
rssn_ char *rssn_json_graph_cartesian_product(const char *aJson) ;

/*
 Computes the complement of a graph.
 */
rssn_ char *rssn_json_graph_complement(const char *aJson) ;

/*
 Finds connected components.
 */
rssn_ char *rssn_json_graph_connected_components(const char *aJson) ;

/*
 Finds connected components.
 Input: Graph
 Output: [[usize]] (array of arrays)
 */
rssn_ char *rssn_json_graph_connected_components_api(const char *aJson) ;

/*
 Performs DFS traversal.
 */
rssn_ char *rssn_json_graph_dfs(const char *aJson) ;

/*
 Performs DFS traversal.
 Input: {"graph": Graph, "start_node": usize}
 Output: [usize] (array of node indices)
 */
rssn_ char *rssn_json_graph_dfs_api(const char *aJson) ;

/*
 Computes maximum flow using Dinic's algorithm.
 Input: {"graph": Graph, "source": usize, "sink": usize}
 Output: f64
 */
rssn_ char *rssn_json_graph_dinic_max_flow(const char *aJson) ;

/*
 Computes the disjoint union of two graphs.
 */
rssn_ char *rssn_json_graph_disjoint_union(const char *aJson) ;

/*
 Computes maximum flow using Edmonds-Karp.
 Input: {"graph": Graph, "source": usize, "sink": usize}
 Output: f64
 */
rssn_ char *rssn_json_graph_edmonds_karp_max_flow(const char *aJson) ;

/*
 Checks if graph has a cycle.
 */
rssn_ char *rssn_json_graph_has_cycle(const char *aJson) ;

/*
 Checks if graph has a cycle.
 Input: Graph
 Output: bool
 */
rssn_ char *rssn_json_graph_has_cycle_api(const char *aJson) ;

/*
 Creates an induced subgraph.
 Input JSON: {"graph": <graph>, "nodes": ["label1", "label2"]}
 */
rssn_ char *rssn_json_graph_induced_subgraph(const char *aJson) ;

/*
 Computes the intersection of two graphs.
 */
rssn_ char *rssn_json_graph_intersection(const char *aJson) ;

/*
 Checks if graph is bipartite.
 */
rssn_ char *rssn_json_graph_is_bipartite(const char *aJson) ;

/*
 Checks if graph is bipartite.
 Input: Graph
 Output: [i8] or null
 */
rssn_ char *rssn_json_graph_is_bipartite_api(const char *aJson) ;

/*
 Checks if graph is connected.
 Input: Graph
 Output: bool
 */
rssn_ char *rssn_json_graph_is_connected(const char *aJson) ;

/*
 Computes the join of two graphs.
 */
rssn_ char *rssn_json_graph_join(const char *aJson) ;

/*
 Computes MST using Kruskal's algorithm.
 */
rssn_ char *rssn_json_graph_kruskal_mst(const char *aJson) ;

/*
 Computes MST using Kruskal's algorithm.
 Input: Graph
 Output: Graph (MST)
 */
rssn_ char *rssn_json_graph_kruskal_mst_api(const char *aJson) ;

/*
 Gets the Laplacian matrix of the graph.
 */
rssn_ char *rssn_json_graph_laplacian_matrix(const char *aJson) ;

/*
 Computes maximum flow.
 Input JSON: {"graph": <graph>, "source": <index>, "sink": <index>}
 */
rssn_ char *rssn_json_graph_max_flow(const char *aJson) ;

/*
 Creates a new graph from JSON specification.
 JSON format: {"is_directed": true/false}
 */
rssn_ char *rssn_json_graph_new(const char *aJson) ;

/*
 Finds strongly connected components.
 Input: Graph
 Output: [[usize]]
 */
rssn_ char *rssn_json_graph_strongly_connected_components(const char *aJson) ;

/*
 Computes the Tensor product of two graphs.
 */
rssn_ char *rssn_json_graph_tensor_product(const char *aJson) ;

/*
 Performs topological sort.
 Input: Graph
 Output: [usize] or null
 */
rssn_ char *rssn_json_graph_topological_sort(const char *aJson) ;

/*
 Computes the union of two graphs.
 Input JSON: {"g1": <graph>, "g2": <graph>}
 */
rssn_ char *rssn_json_graph_union(const char *aJson) ;

/*
 Greedy coloring.
 Input: Graph
 Output: {node_id: color_id}
 */
rssn_ char *rssn_json_greedy_coloring(const char *aJson) ;

/*
 Represents Green's theorem (JSON)
 */
rssn_
char *rssn_json_greens_theorem(const char *aPJson,
                               const char *aQJson,
                               const char *aDomainJson)
;

rssn_ char *rssn_json_group_center(const char *aGroupJson) ;

rssn_ char *rssn_json_group_conjugacy_classes(const char *aGroupJson) ;

rssn_ char *rssn_json_group_create(const char *aJsonStr) ;

rssn_ size_t rssn_json_group_element_order(const char *aGroupJson, const char *aAJson) ;

rssn_ char *rssn_json_group_inverse(const char *aGroupJson, const char *aAJson) ;

rssn_ bool rssn_json_group_is_abelian(const char *aGroupJson) ;

rssn_
char *rssn_json_group_multiply(const char *aGroupJson,
                               const char *aAJson,
                               const char *aBJson)
;

/*
 Computes Hessian matrix (JSON)
 */
rssn_ char *rssn_json_hessian_matrix(const char *aExprJson, const char *aVarsJson) ;

/*
 Simplifies an expression using the heuristic simplifier (JSON input/output).
 */
rssn_ char *rssn_json_heuristic_simplify(const char *aExprJson) ;

rssn_ char *rssn_json_hilbert_space_create(const char *aJsonStr) ;

/*
 Creates a new IteratedFunctionSystem (JSON)
 */
rssn_
char *rssn_json_ifs_create(const char *aFunctionsJson,
                           const char *aProbabilitiesJson,
                           const char *aVariablesJson)
;

/*
 Calculates similarity dimension (JSON)
 */
rssn_ char *rssn_json_ifs_similarity_dimension(const char *aScalingFactorsJson) ;

rssn_
char *rssn_json_inner_product(const char *aSpaceJson,
                              const char *aFJson,
                              const char *aGJson)
;

/*
 Integrates an expression using JSON.
 */
rssn_ char *rssn_json_integrate(const char *aExprJson, const char *aVar) ;

/*
 Integrates a rational function (JSON)
 */
rssn_ char *rssn_json_integrate_rational_function(const char *aExprJson, const char *aXJson) ;

rssn_ char *rssn_json_is_prime(const char *aNJson) ;

/*
 Checks if a logical expression is satisfiable using JSON-based FFI.

 Returns a JSON string containing:
 - `{"result": "satisfiable"}` if satisfiable
 - `{"result": "unsatisfiable"}` if unsatisfiable
 - `{"result": "undecidable"}` if the expression contains quantifiers
 */
rssn_ char *rssn_json_is_satisfiable(const char *aExprJson) ;

/*
 Isolates real roots in an interval (JSON)
 */
rssn_
char *rssn_json_isolate_real_roots(const char *aExprJson,
                                   const char *aVarPtr,
                                   double aPrecision)
;

rssn_ char *rssn_json_klein_four_group_create() ;

rssn_
char *rssn_json_laurent_series(const char *aExprJson,
                               const char *aVarJson,
                               const char *aCenterJson,
                               const char *aOrderJson)
;

rssn_ char *rssn_json_lie_algebra_so3() ;

rssn_ char *rssn_json_lie_algebra_su2() ;

rssn_ char *rssn_json_lie_bracket(const char *aXJson, const char *aYJson) ;

/*
 Computes limit using JSON.
 */
rssn_ char *rssn_json_limit(const char *aExprJson, const char *aVar, const char *aPointJson) ;

/*
 Returns Lorenz system equations (JSON)
 */
rssn_ char *rssn_json_lorenz_system() ;

/*
 Calculates Lyapunov exponent (JSON)
 */
rssn_
char *rssn_json_lyapunov_exponent(const char *aMapJson,
                                  const char *aVar,
                                  const char *aInitialXJson,
                                  size_t aNIterations)
;

rssn_ char *rssn_json_matrix_add(const char *aM1Json, const char *aM2Json) ;

rssn_ char *rssn_json_matrix_determinant(const char *aMatrixJson) ;

rssn_ char *rssn_json_matrix_inverse(const char *aMatrixJson) ;

rssn_ char *rssn_json_matrix_mul(const char *aM1Json, const char *aM2Json) ;

rssn_ char *rssn_json_matrix_solve_linear_system(const char *aAJson, const char *aBJson) ;

rssn_ char *rssn_json_matrix_transpose(const char *aMatrixJson) ;

/*
 Computes the symbolic mean of a set of expressions using JSON.
 */
rssn_ char *rssn_json_mean(const char *aDataJson) ;

/*
 Computes geometric product (JSON)
 */
rssn_ char *rssn_json_multivector_geometric_product(const char *aAJson, const char *aBJson) ;

/*
 Computes grade projection (JSON)
 */
rssn_ char *rssn_json_multivector_grade_projection(const char *aMvJson, uint32_t aGrade) ;

/*
 Computes inner product (JSON)
 */
rssn_ char *rssn_json_multivector_inner_product(const char *aAJson, const char *aBJson) ;

/*
 Computes magnitude (JSON)
 */
rssn_ char *rssn_json_multivector_magnitude(const char *aMvJson) ;

/*
 Computes outer product (JSON)
 */
rssn_ char *rssn_json_multivector_outer_product(const char *aAJson, const char *aBJson) ;

/*
 Computes reverse (JSON)
 */
rssn_ char *rssn_json_multivector_reverse(const char *aMvJson) ;

/*
 Creates a new scalar multivector (JSON)
 */
rssn_
char *rssn_json_multivector_scalar(uint32_t aP,
                                   uint32_t aQ,
                                   uint32_t aR,
                                   const char *aValueJson)
;

rssn_
char *rssn_json_nonlinear_regression(const char *aDataJson,
                                     const char *aModelJson,
                                     const char *aVarsJson,
                                     const char *aParamsJson)
;

rssn_ char *rssn_json_norm(const char *aSpaceJson, const char *aFJson) ;

rssn_ char *rssn_json_one_sample_t_test(const char *aDataJson, const char *aTargetMeanJson) ;

/*
 Computes path integral using JSON.
 */
rssn_
char *rssn_json_path_integrate(const char *aExprJson,
                               const char *aVar,
                               const char *aContourJson)
;

rssn_ char *rssn_json_permutations(const char *aNJson, const char *aKJson) ;

/*
 Computes polynomial derivative over finite field (JSON)
 */
rssn_ char *rssn_json_poly_derivative_gf(const char *aPolyJson) ;

rssn_
char *rssn_json_poly_division_multivariate(const char *aDividendJson,
                                           const char *aDivisorsJson,
                                           const char *aOrderJson)
;

/*
 Computes polynomial GCD over finite field (JSON)
 */
rssn_ char *rssn_json_poly_gcd_gf(const char *aAJson, const char *aBJson) ;

/*
 Checks if an expression contains a variable (JSON)
 */
rssn_ bool rssn_json_polynomial_contains_var(const char *aExprJson, const char *aVar) ;

/*
 Computes the degree of a polynomial (JSON)
 */
rssn_ int64_t rssn_json_polynomial_degree(const char *aExprJson, const char *aVar) ;

/*
 Checks if an expression is a polynomial in the given variable (JSON)
 */
rssn_ bool rssn_json_polynomial_is_polynomial(const char *aExprJson, const char *aVar) ;

/*
 Finds the leading coefficient of a polynomial (JSON)
 */
rssn_ char *rssn_json_polynomial_leading_coefficient(const char *aExprJson, const char *aVar) ;

/*
 Performs polynomial long division (JSON)
 */
rssn_
char *rssn_json_polynomial_long_division(const char *aDividendJson,
                                         const char *aDivisorJson,
                                         const char *aVar)
;

rssn_ char *rssn_json_polynomial_regression(const char *aDataJson, size_t aDegree) ;

/*
 Converts polynomial to coefficient vector (JSON)
 */
rssn_ char *rssn_json_polynomial_to_coeffs_vec(const char *aExprJson, const char *aVar) ;

/*
 Adds two prime field elements (JSON)
 */
rssn_ char *rssn_json_prime_field_element_add(const char *aAJson, const char *aBJson) ;

/*
 Divides two prime field elements (JSON)
 */
rssn_ char *rssn_json_prime_field_element_div(const char *aAJson, const char *aBJson) ;

/*
 Computes the inverse of a prime field element (JSON)
 */
rssn_ char *rssn_json_prime_field_element_inverse(const char *aElemJson) ;

/*
 Multiplies two prime field elements (JSON)
 */
rssn_ char *rssn_json_prime_field_element_mul(const char *aAJson, const char *aBJson) ;

/*
 Creates a new prime field element (JSON)
 */
rssn_ char *rssn_json_prime_field_element_new(const char *aValueJson, const char *aModulusJson) ;

/*
 Subtracts two prime field elements (JSON)
 */
rssn_ char *rssn_json_prime_field_element_sub(const char *aAJson, const char *aBJson) ;

rssn_
char *rssn_json_product(const char *aExprJson,
                        const char *aVarJson,
                        const char *aLowerJson,
                        const char *aUpperJson)
;

rssn_ char *rssn_json_representation_create(const char *aJsonStr) ;

rssn_ bool rssn_json_representation_is_valid(const char *aRepJson, const char *aGroupJson) ;

/*
 Integrates an expression using the Risch-Norman algorithm (JSON)
 */
rssn_ char *rssn_json_risch_norman_integrate(const char *aExprJson, const char *aXJson) ;

rssn_ char *rssn_json_simple_linear_regression(const char *aDataJson) ;

/*
 Creates a new Simplex (JSON)
 */
rssn_ char *rssn_json_simplex_create(const char *aVerticesJson) ;

/*
 Gets the dimension of a Simplex (JSON)
 */
rssn_ char *rssn_json_simplex_dimension(const char *aSimplexJson) ;

/*
 Adds a simplex to a SimplicialComplex (JSON)
 */
rssn_
char *rssn_json_simplicial_complex_add_simplex(const char *aComplexJson,
                                               const char *aVerticesJson)
;

/*
 Applies the symbolic boundary operator to a SymbolicChain (JSON)
 */
rssn_
char *rssn_json_simplicial_complex_apply_symbolic_boundary_operator(const char *aComplexJson,
                                                                    const char *aChainJson)
;

/*
 Creates a new SimplicialComplex (JSON)
 */
rssn_ char *rssn_json_simplicial_complex_create() ;

/*
 Gets the symbolic boundary matrix for dimension k (JSON)
 */
rssn_
char *rssn_json_simplicial_complex_get_symbolic_boundary_matrix(const char *aComplexJson,
                                                                size_t aK)
;

/*
 Simplifies an expression using the legacy simplifier (JSON input/output).
 */
rssn_ char *rssn_json_simplify(const char *aExprJson) ;

/*
 Simplifies an expression using the DAG-based simplifier (JSON input/output).
 */
rssn_ char *rssn_json_simplify_dag(const char *aExprJson) ;

/*
 Simplifies a logical expression using JSON-based FFI.
 */
rssn_ char *rssn_json_simplify_logic(const char *aExprJson) ;

/*
 Simplifies radical expressions (JSON)
 */
rssn_ char *rssn_json_simplify_radicals(const char *aExprJson) ;

rssn_ char *rssn_json_so3_generators() ;

rssn_ char *rssn_json_solve(const char *aExprJson, const char *aVarJson) ;

/*
 Solves a Bernoulli ODE using JSON.
 */
rssn_
char *rssn_json_solve_bernoulli_ode(const char *aEquationJson,
                                    const char *aFunc,
                                    const char *aVar)
;

/*
 Solves by reduction of order using JSON.
 */
rssn_
char *rssn_json_solve_by_reduction_of_order(const char *aEquationJson,
                                            const char *aFunc,
                                            const char *aVar,
                                            const char *aY1Json)
;

/*
 Solves a Cauchy-Euler ODE using JSON.
 */
rssn_
char *rssn_json_solve_cauchy_euler_ode(const char *aEquationJson,
                                       const char *aFunc,
                                       const char *aVar)
;

rssn_ char *rssn_json_solve_diophantine(const char *aEquationJson, const char *aVarsJson) ;

/*
 Solves an exact ODE using JSON.
 */
rssn_
char *rssn_json_solve_exact_ode(const char *aEquationJson,
                                const char *aFunc,
                                const char *aVar)
;

/*
 Solves a first-order linear ODE using JSON.
 */
rssn_
char *rssn_json_solve_first_order_linear_ode(const char *aEquationJson,
                                             const char *aFunc,
                                             const char *aVar)
;

/*
 Solves the 1D heat equation (JSON).
 */
rssn_
char *rssn_json_solve_heat_equation_1d(const char *aEquationJson,
                                       const char *aFunc,
                                       const char *aVarsJson)
;

/*
 Solves the 2D Laplace equation (JSON).
 */
rssn_
char *rssn_json_solve_laplace_equation_2d(const char *aEquationJson,
                                          const char *aFunc,
                                          const char *aVarsJson)
;

rssn_ char *rssn_json_solve_linear_system(const char *aSystemJson, const char *aVarsJson) ;

/*
 Solves an ODE using JSON.
 */
rssn_ char *rssn_json_solve_ode(const char *aOdeJson, const char *aFunc, const char *aVar) ;

/*
 Solves a PDE using JSON with automatic method selection.
 */
rssn_ char *rssn_json_solve_pde(const char *aPdeJson, const char *aFunc, const char *aVarsJson) ;

/*
 Solves a PDE using the method of characteristics (JSON).
 */
rssn_
char *rssn_json_solve_pde_by_characteristics(const char *aEquationJson,
                                             const char *aFunc,
                                             const char *aVarsJson)
;

/*
 Solves the 2D Poisson equation (JSON).
 */
rssn_
char *rssn_json_solve_poisson_equation_2d(const char *aEquationJson,
                                          const char *aFunc,
                                          const char *aVarsJson)
;

/*
 Solves a Riccati ODE using JSON.
 */
rssn_
char *rssn_json_solve_riccati_ode(const char *aEquationJson,
                                  const char *aFunc,
                                  const char *aVar,
                                  const char *aY1Json)
;

/*
 Solves a separable ODE using JSON.
 */
rssn_
char *rssn_json_solve_separable_ode(const char *aEquationJson,
                                    const char *aFunc,
                                    const char *aVar)
;

rssn_ char *rssn_json_solve_system(const char *aEquationsJson, const char *aVarsJson) ;

/*
 Solves the 1D wave equation using D'Alembert's formula (JSON).
 */
rssn_
char *rssn_json_solve_wave_equation_1d(const char *aEquationJson,
                                       const char *aFunc,
                                       const char *aVarsJson)
;

/*
 Computes square-free factorization (JSON)
 */
rssn_ char *rssn_json_square_free_factorization_gf(const char *aPolyJson) ;

/*
 Computes the symbolic standard deviation of a set of expressions using JSON.
 */
rssn_ char *rssn_json_std_dev(const char *aDataJson) ;

rssn_ char *rssn_json_stirling_number_second_kind(size_t aN, size_t aK) ;

/*
 Represents Stokes' theorem (JSON)
 */
rssn_ char *rssn_json_stokes_theorem(const char *aVectorFieldJson, const char *aSurfaceJson) ;

/*
 Generates the Sturm sequence for a given polynomial (JSON)
 */
rssn_ char *rssn_json_sturm_sequence(const char *aExprJson, const char *aVarPtr) ;

rssn_ char *rssn_json_su2_generators() ;

/*
 Substitutes using JSON.
 */
rssn_
char *rssn_json_substitute(const char *aExprJson,
                           const char *aVar,
                           const char *aReplacementJson)
;

rssn_
char *rssn_json_summation(const char *aExprJson,
                          const char *aVarJson,
                          const char *aLowerJson,
                          const char *aUpperJson)
;

/*
 Adds a term to a SymbolicChain (JSON)
 */
rssn_
char *rssn_json_symbolic_chain_add_term(const char *aChainJson,
                                        const char *aSimplexJson,
                                        const char *aCoeffJson)
;

/*
 Creates a new SymbolicChain (JSON)
 */
rssn_ char *rssn_json_symbolic_chain_create(size_t aDimension) ;

rssn_ char *rssn_json_symmetric_group_create(size_t aN) ;

rssn_
char *rssn_json_taylor_series(const char *aExprJson,
                              const char *aVarJson,
                              const char *aCenterJson,
                              const char *aOrderJson)
;

rssn_ char *rssn_json_tensor_add(const char *aT1Json, const char *aT2Json) ;

rssn_ char *rssn_json_tensor_contract(const char *aTJson, size_t aAxis1, size_t aAxis2) ;

rssn_ char *rssn_json_tensor_outer_product(const char *aT1Json, const char *aT2Json) ;

rssn_ char *rssn_json_tensor_scalar_mul(const char *aTJson, const char *aScalarJson) ;

/*
 Converts a logical expression to Conjunctive Normal Form (CNF) using JSON-based FFI.
 */
rssn_ char *rssn_json_to_cnf(const char *aExprJson) ;

/*
 Converts a logical expression to Disjunctive Normal Form (DNF) using JSON-based FFI.
 */
rssn_ char *rssn_json_to_dnf(const char *aExprJson) ;

rssn_
char *rssn_json_transform_contravariant_vector(const char *aCompsJson,
                                               rssn_CoordinateSystem aFrom,
                                               rssn_CoordinateSystem aTo)
;

rssn_
char *rssn_json_transform_covariant_vector(const char *aCompsJson,
                                           rssn_CoordinateSystem aFrom,
                                           rssn_CoordinateSystem aTo)
;

rssn_ char *rssn_json_transform_curl(const char *aCompsJson, rssn_CoordinateSystem aFrom) ;

rssn_ char *rssn_json_transform_divergence(const char *aCompsJson, rssn_CoordinateSystem aFrom) ;

rssn_
char *rssn_json_transform_expression(const char *aExprJson,
                                     rssn_CoordinateSystem aFrom,
                                     rssn_CoordinateSystem aTo)
;

rssn_
char *rssn_json_transform_gradient(const char *aScalarJson,
                                   const char *aVarsJson,
                                   rssn_CoordinateSystem aFrom,
                                   rssn_CoordinateSystem aTo)
;

rssn_
char *rssn_json_transform_point(const char *aPointJson,
                                rssn_CoordinateSystem aFrom,
                                rssn_CoordinateSystem aTo)
;

rssn_
char *rssn_json_two_sample_t_test(const char *aData1Json,
                                  const char *aData2Json,
                                  const char *aMuDiffJson)
;

rssn_ char *rssn_json_unify_expression(const char *aExprJson) ;

/*
 Computes the symbolic variance of a set of expressions using JSON.
 */
rssn_ char *rssn_json_variance(const char *aDataJson) ;

rssn_ char *rssn_json_vector_cross(const char *aV1Json, const char *aV2Json) ;

rssn_
char *rssn_json_vector_curl(const char *aVJson,
                            const char *aXVar,
                            const char *aYVar,
                            const char *aZVar)
;

rssn_
char *rssn_json_vector_divergence(const char *aVJson,
                                  const char *aXVar,
                                  const char *aYVar,
                                  const char *aZVar)
;

rssn_ char *rssn_json_vector_dot(const char *aV1Json, const char *aV2Json) ;

rssn_
char *rssn_json_vector_gradient(const char *aScalarFieldJson,
                                const char *aXVar,
                                const char *aYVar,
                                const char *aZVar)
;

rssn_ char *rssn_json_vector_magnitude(const char *aVJson) ;

rssn_ char *rssn_json_vector_normalize(const char *aVJson) ;

/*
 Computes the wedge product of two differential forms (JSON)
 */
rssn_ char *rssn_json_wedge_product(const char *aForm1Json, const char *aForm2Json) ;

rssn_
char *rssn_json_z_test(const char *aDataJson,
                       const char *aTargetMeanJson,
                       const char *aPopStdDevJson)
;

rssn_ rssn_Group *rssn_klein_four_group_create() ;

/*
 Applies the Knuth-Bendix completion algorithm to a set of equations.

 Returns a pointer to a Vec<RewriteRule> on success, or null on failure.

 # Safety
 The caller must ensure `equations` is a valid array of Expr pointers.
 */
rssn_
rssn_Vec<rssn_RewriteRule> *rssn_knuth_bendix(const rssn_Expr *const *aEquations,
                                              size_t aEquationsLen)
;

/*
 Applies the Knuth-Bendix completion algorithm (Bincode).
 */
rssn_ rssn_BincodeBuffer rssn_knuth_bendix_bincode(rssn_BincodeBuffer aInput) ;

/*
 Applies the Knuth-Bendix completion algorithm (JSON).

 Input: JSON array of equations (Expr::Eq)
 Output: JSON array of RewriteRule objects
 */
rssn_ char *rssn_knuth_bendix_json(const char *aJsonStr) ;

rssn_
rssn_Expr *rssn_laurent_series_handle(const rssn_Expr *aExpr,
                                      const char *aVar,
                                      const rssn_Expr *aCenter,
                                      size_t aOrder)
;

rssn_ void rssn_lie_algebra_free(rssn_LieAlgebra *aPtr) ;

rssn_ rssn_Expr *rssn_lie_algebra_get_basis_element(const rssn_LieAlgebra *aPtr, size_t aIndex) ;

rssn_ size_t rssn_lie_algebra_get_dimension(const rssn_LieAlgebra *aPtr) ;

rssn_ char *rssn_lie_algebra_get_name(const rssn_LieAlgebra *aPtr) ;

rssn_ rssn_LieAlgebra *rssn_lie_algebra_so3_create() ;

rssn_ rssn_LieAlgebra *rssn_lie_algebra_su2_create() ;

rssn_ rssn_Expr *rssn_lie_bracket(const rssn_Expr *aX, const rssn_Expr *aY) ;

/*
 Computes the limit of an expression: limit(expr, var -> point).

 # Safety
 The caller must ensure `expr` and `point` are valid Expr pointers and `var` is a valid C string.
 */
rssn_ rssn_Expr *rssn_limit(const rssn_Expr *aExpr, const char *aVar, const rssn_Expr *aPoint) ;

/*
 Computes the line integral of a scalar field along a curve.
 */
rssn_
char *rssn_line_integral_scalar(const char *aScalarField,
                                const rssn_ParametricCurve *aCurve)
;

/*
 Computes the line integral of a scalar field (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_line_integral_scalar_bincode(const uint8_t *aInputPtr,
                                                     size_t aInputLen)
;

/*
 Computes the line integral of a scalar field (JSON).
 */
rssn_ char *rssn_line_integral_scalar_json(const char *aInputJson) ;

/*
 Computes the line integral of a vector field along a curve.
 */
rssn_
char *rssn_line_integral_vector(const char *aFieldX,
                                const char *aFieldY,
                                const char *aFieldZ,
                                const rssn_ParametricCurve *aCurve)
;

/*
 Computes the line integral of a vector field (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_line_integral_vector_bincode(const uint8_t *aInputPtr,
                                                     size_t aInputLen)
;

/*
 Computes the line integral of a vector field (JSON).
 */
rssn_ char *rssn_line_integral_vector_json(const char *aInputJson) ;

rssn_
rssn_Expr *rssn_linear_operator_apply(const rssn_LinearOperator *aOp,
                                      const rssn_Expr *aExpr)
;

rssn_ rssn_LinearOperator *rssn_linear_operator_derivative_create(const char *aVar) ;

rssn_ void rssn_linear_operator_free(rssn_LinearOperator *aPtr) ;

rssn_
rssn_LinearOperator *rssn_linear_operator_integral_create(const rssn_Expr *aLowerBound,
                                                          const char *aVar)
;

/*
 Creates a natural logarithm expression: ln(expr).
 */
rssn_ rssn_Expr *rssn_ln(const rssn_Expr *aExpr) ;

/*
 Creates a natural logarithm expression from bincode: ln(expr).
 */
rssn_ rssn_BincodeBuffer rssn_ln_bincode(rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a natural logarithm expression from JSON: ln(expr).
 */
rssn_ char *rssn_ln_json(const char *aJsonExpr) ;

/*
 Returns Lorenz system equations (Handle)
 */
rssn_ bool rssn_lorenz_system(rssn_Expr **aDxOut, rssn_Expr **aDyOut, rssn_Expr **aDzOut) ;

/*
 Calculates Lyapunov exponent (Handle)
 */
rssn_
rssn_Expr *rssn_lyapunov_exponent(const rssn_Expr *aMapPtr,
                                  const char *aVar,
                                  const rssn_Expr *aInitialXPtr,
                                  size_t aNIterations)
;

rssn_ int32_t rssn_matrix_add(size_t aH1, size_t aH2, size_t *aResultH) ;

rssn_ rssn_Expr *rssn_matrix_add_handle(const rssn_Expr *aM1, const rssn_Expr *aM2) ;

rssn_ int32_t rssn_matrix_determinant(size_t aH, size_t *aResultH) ;

rssn_ rssn_Expr *rssn_matrix_determinant_handle(const rssn_Expr *aMatrix) ;

rssn_ int32_t rssn_matrix_identity(size_t aSize, size_t *aResultH) ;

rssn_ int32_t rssn_matrix_inverse(size_t aH, size_t *aResultH) ;

rssn_ rssn_Expr *rssn_matrix_inverse_handle(const rssn_Expr *aMatrix) ;

rssn_ int32_t rssn_matrix_mul(size_t aH1, size_t aH2, size_t *aResultH) ;

rssn_ rssn_Expr *rssn_matrix_mul_handle(const rssn_Expr *aM1, const rssn_Expr *aM2) ;

rssn_ int32_t rssn_matrix_scalar_mul(size_t aScalarH, size_t aMatrixH, size_t *aResultH) ;

rssn_ rssn_Expr *rssn_matrix_solve_linear_system_handle(const rssn_Expr *aA, const rssn_Expr *aB) ;

rssn_ int32_t rssn_matrix_sub(size_t aH1, size_t aH2, size_t *aResultH) ;

rssn_ int32_t rssn_matrix_transpose(size_t aH, size_t *aResultH) ;

rssn_ rssn_Expr *rssn_matrix_transpose_handle(const rssn_Expr *aMatrix) ;

/*
 Computes the symbolic mean of a set of expressions.

 # Safety
 The caller must ensure `data` is a valid pointer to an array of `Expr` pointers of size `len`.
 */
rssn_ rssn_Expr *rssn_mean(const rssn_Expr *const *aData, size_t aLen) ;

/*
 Computes geometric product (Handle)
 */
rssn_
rssn_Multivector *rssn_multivector_geometric_product_handle(const rssn_Multivector *aA,
                                                            const rssn_Multivector *aB)
;

/*
 Computes grade projection (Handle)
 */
rssn_
rssn_Multivector *rssn_multivector_grade_projection_handle(const rssn_Multivector *aMv,
                                                           uint32_t aGrade)
;

/*
 Computes inner product (Handle)
 */
rssn_
rssn_Multivector *rssn_multivector_inner_product_handle(const rssn_Multivector *aA,
                                                        const rssn_Multivector *aB)
;

/*
 Computes magnitude (Handle)
 */
rssn_ rssn_Expr *rssn_multivector_magnitude_handle(const rssn_Multivector *aMv) ;

/*
 Computes outer product (Handle)
 */
rssn_
rssn_Multivector *rssn_multivector_outer_product_handle(const rssn_Multivector *aA,
                                                        const rssn_Multivector *aB)
;

/*
 Computes reverse (Handle)
 */
rssn_ rssn_Multivector *rssn_multivector_reverse_handle(const rssn_Multivector *aMv) ;

/*
 Creates a new scalar multivector (Handle)
 */
rssn_
rssn_Multivector *rssn_multivector_scalar_handle(uint32_t aP,
                                                 uint32_t aQ,
                                                 uint32_t aR,
                                                 const rssn_Expr *aValue)
;

rssn_
rssn_Expr *rssn_nonlinear_regression(const rssn_Expr *const *aXData,
                                     const rssn_Expr *const *aYData,
                                     size_t aLen,
                                     const rssn_Expr *aModel,
                                     const char *const *aVars,
                                     size_t aVarsLen,
                                     const char *const *aParams,
                                     size_t aParamsLen)
;

rssn_ rssn_Expr *rssn_norm(const rssn_HilbertSpace *aSpace, const rssn_Expr *aF) ;

/*
 Computes the greatest common divisor (GCD) of two numbers.

 Returns 0 on success, -1 on error.
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_ int32_t rssn_nt_gcd(uint64_t aA, uint64_t aB, uint64_t *aResult) ;

/*
 Checks if a number is prime using the Miller-Rabin test.

 Returns 0 on success, -1 on error.
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_ int32_t rssn_nt_is_prime(uint64_t aN, bool *aResult) ;

/*
 Computes the modular multiplicative inverse.

 Returns 0 on success, -1 on error (e.g., if no inverse exists).
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_ int32_t rssn_nt_mod_inverse(int64_t aA, int64_t aB, int64_t *aResult) ;

/*
 Computes modular exponentiation (base^exp % modulus).

 Returns 0 on success, -1 on error.
 On error, call `rssn_get_last_error` to get the error message.
 */
rssn_ int32_t rssn_nt_mod_pow(uint64_t aBase, uint64_t aExp, uint64_t aModulus, uint64_t *aResult) ;

rssn_
int32_t rssn_numerical_gradient(size_t aExprH,
                                const char *const *aVars,
                                size_t aNumVars,
                                const double *aPoint,
                                size_t aPointLen,
                                double *aResultVec)
;

rssn_
int32_t rssn_numerical_integrate(size_t aExprH,
                                 const char *aVar,
                                 double aStart,
                                 double aEnd,
                                 size_t aNSteps,
                                 uint32_t aMethod,
                                 double *aResult)
;

rssn_
rssn_Expr *rssn_one_sample_t_test(const rssn_Expr *const *aData,
                                  size_t aLen,
                                  const rssn_Expr *aTargetMean)
;

/*
 Frees a ParametricCurve handle.
 */
rssn_ void rssn_parametric_curve_free(rssn_ParametricCurve *aCurve) ;

/*
 Creates a new ParametricCurve.
 */
rssn_
rssn_ParametricCurve *rssn_parametric_curve_new(const char *aRX,
                                                const char *aRY,
                                                const char *aRZ,
                                                const char *aTVar,
                                                const char *aTLower,
                                                const char *aTUpper)
;

/*
 Frees a ParametricSurface handle.
 */
rssn_ void rssn_parametric_surface_free(rssn_ParametricSurface *aSurface) ;

/*
 Creates a new ParametricSurface.
 */
rssn_
rssn_ParametricSurface *rssn_parametric_surface_new(const char *aRX,
                                                    const char *aRY,
                                                    const char *aRZ,
                                                    const char *aUVar,
                                                    const char *aULower,
                                                    const char *aUUpper,
                                                    const char *aVVar,
                                                    const char *aVLower,
                                                    const char *aVUpper)
;

/*
 Clears a ParsingCache.
 */
rssn_ void rssn_parsing_cache_clear(rssn_ParsingCache *aCache) ;

/*
 Frees a ParsingCache.
 */
rssn_ void rssn_parsing_cache_free(rssn_ParsingCache *aCache) ;

/*
 Retrieves an expression from the ParsingCache.
 Returns a pointer to the Expr (Arc<Expr> with incremented refcount), or null if not found.
 The caller is responsible for freeing the returned Expr (using the appropriate Expr free function).
 */
rssn_ rssn_Expr *rssn_parsing_cache_get(rssn_ParsingCache *aCache, const char *aInput) ;

/*
 Retrieves an expression from the ParsingCache as a bincode buffer.
 */
rssn_
rssn_BincodeBuffer rssn_parsing_cache_get_bincode(rssn_ParsingCache *aCache,
                                                  const char *aInput)
;

/*
 Retrieves an expression from the ParsingCache as a JSON string.
 Returns null if not found or error.
 */
rssn_ char *rssn_parsing_cache_get_json(rssn_ParsingCache *aCache, const char *aInput) ;

/*
 Creates a new ParsingCache.
 The caller is responsible for freeing the memory using rssn_parsing_cache_free.
 */
rssn_ rssn_ParsingCache *rssn_parsing_cache_new() ;

/*
 Stores an expression in the ParsingCache.
 The expr pointer is cloned (deep copy of the structure, but DAG nodes are shared).
 */
rssn_
void rssn_parsing_cache_set(rssn_ParsingCache *aCache,
                            const char *aInput,
                            const rssn_Expr *aExpr)
;

/*
 Stores an expression in the ParsingCache from a bincode buffer.
 */
rssn_
void rssn_parsing_cache_set_bincode(rssn_ParsingCache *aCache,
                                    const char *aInput,
                                    rssn_BincodeBuffer aBuffer)
;

/*
 Stores an expression in the ParsingCache from a JSON string.
 */
rssn_
void rssn_parsing_cache_set_json(rssn_ParsingCache *aCache,
                                 const char *aInput,
                                 const char *aJsonExpr)
;

/*
 Computes a path integral.
 */
rssn_
rssn_Expr *rssn_path_integrate(const rssn_Expr *aExpr,
                               const char *aVar,
                               const rssn_Expr *aContour)
;

rssn_ rssn_Expr *rssn_permutations(const rssn_Expr *aN, const rssn_Expr *aK) ;

rssn_
int32_t rssn_physics_advection_diffusion_1d(const double *aInitialCond,
                                            size_t aLen,
                                            double aDx,
                                            double aC,
                                            double aD,
                                            double aDt,
                                            size_t aSteps,
                                            double *aResultPtr)
;

/*
 Returns the symbolic representation of Pi.
 */
rssn_ rssn_Expr *rssn_pi() ;

/*
 Returns Pi as bincode.
 */
rssn_ rssn_BincodeBuffer rssn_pi_bincode() ;

/*
 Returns Pi as JSON.
 */
rssn_ char *rssn_pi_json() ;

/*
 Executes a command on a loaded plugin.

 # Arguments
 * `plugin_name_ptr` - A null-terminated UTF-8 string representing the plugin's name.
 * `command_ptr` - A null-terminated UTF-8 string for the command to execute.
 * `args_handle` - A handle to the `Expr` object to be passed as an argument.

 # Returns
 A handle to the resulting `Expr` object on success, or 0 on failure.
 On failure, an error message can be retrieved with `rssn_get_last_error`.
 */
rssn_
size_t rssn_plugin_execute(const char *aPluginNamePtr,
                           const char *aCommandPtr,
                           size_t aArgsHandle)
;

rssn_ rssn_Expr *rssn_poles_get(const rssn_Vec<rssn_Expr> *aPoles, size_t aIndex) ;

rssn_ size_t rssn_poles_len(const rssn_Vec<rssn_Expr> *aPoles) ;

rssn_ int32_t rssn_poly_degree(size_t aExprHandle, const char *aVarPtr, int64_t *aResult) ;

/*
 Computes polynomial derivative over finite field (Handle)
 */
rssn_
rssn_FiniteFieldPolynomial *rssn_poly_derivative_gf_handle(const rssn_FiniteFieldPolynomial *aPoly)
;

/*
 Computes polynomial GCD over finite field (Handle)
 */
rssn_
rssn_FiniteFieldPolynomial *rssn_poly_gcd_gf_handle(const rssn_FiniteFieldPolynomial *aA,
                                                    const rssn_FiniteFieldPolynomial *aB)
;

rssn_ int32_t rssn_poly_is_polynomial(size_t aExprHandle, const char *aVarPtr, bool *aResult) ;

rssn_
int32_t rssn_poly_long_division(size_t aNHandle,
                                size_t aDHandle,
                                const char *aVarPtr,
                                size_t *aQHandle,
                                size_t *aRHandle)
;

rssn_
rssn_Expr *rssn_polynomial_regression(const rssn_Expr *const *aXData,
                                      const rssn_Expr *const *aYData,
                                      size_t aLen,
                                      size_t aDegree)
;

/*
 Creates a power expression: base^exp.
 */
rssn_ rssn_Expr *rssn_pow(const rssn_Expr *aBase, const rssn_Expr *aExp) ;

/*
 Creates a power expression from bincode: base^exp.

 # Arguments
 * `base_buffer` - Bincode-serialized base Expr
 * `exp_buffer` - Bincode-serialized exponent Expr
 */
rssn_
rssn_BincodeBuffer rssn_pow_bincode(rssn_BincodeBuffer aBaseBuffer,
                                    rssn_BincodeBuffer aExpBuffer)
;

/*
 Creates a power expression from JSON: base^exp.

 # Arguments
 * `json_base` - JSON-serialized base Expr
 * `json_exp` - JSON-serialized exponent Expr
 */
rssn_ char *rssn_pow_json(const char *aJsonBase, const char *aJsonExp) ;

/*
 Adds two prime field elements (Handle)
 */
rssn_
rssn_PrimeFieldElement *rssn_prime_field_element_add_handle(const rssn_PrimeFieldElement *aA,
                                                            const rssn_PrimeFieldElement *aB)
;

/*
 Frees a prime field element (Handle)
 */
rssn_ void rssn_prime_field_element_free_handle(rssn_PrimeFieldElement *aElem) ;

/*
 Computes the inverse of a prime field element (Handle)
 */
rssn_
rssn_PrimeFieldElement *rssn_prime_field_element_inverse_handle(const rssn_PrimeFieldElement *aElem)
;

/*
 Multiplies two prime field elements (Handle)
 */
rssn_
rssn_PrimeFieldElement *rssn_prime_field_element_mul_handle(const rssn_PrimeFieldElement *aA,
                                                            const rssn_PrimeFieldElement *aB)
;

/*
 Creates a new prime field element (Handle)
 Returns a boxed pointer to the element
 */
rssn_
rssn_PrimeFieldElement *rssn_prime_field_element_new_handle(const rssn_BigInt *aValue,
                                                            const rssn_BigInt *aModulus)
;

rssn_
rssn_Expr *rssn_product_handle(const rssn_Expr *aExpr,
                               const char *aVar,
                               const rssn_Expr *aLower,
                               const rssn_Expr *aUpper)
;

rssn_
rssn_Expr *rssn_project(const rssn_HilbertSpace *aSpace,
                        const rssn_Expr *aF,
                        const rssn_Expr *aG)
;

rssn_
rssn_Representation *rssn_representation_create(const rssn_Expr *const *aElementsPtr,
                                                size_t aElementsLen,
                                                const rssn_Expr *const *aKeysPtr,
                                                const rssn_Expr *const *aValuesPtr,
                                                size_t aMapLen)
;

rssn_ void rssn_representation_free(rssn_Representation *aPtr) ;

rssn_ bool rssn_representation_is_valid(const rssn_Representation *aRep, const rssn_Group *aGroup) ;

/*
 Frees a rewrite rule.

 # Safety
 The caller must ensure `rule` was created by this module and hasn't been freed yet.
 */
rssn_ void rssn_rewrite_rule_free(rssn_RewriteRule *aRule) ;

/*
 Gets the LHS of a rewrite rule.

 Returns a new owned Expr pointer that must be freed by the caller.

 # Safety
 The caller must ensure `rule` is a valid RewriteRule pointer.
 */
rssn_ rssn_Expr *rssn_rewrite_rule_get_lhs(const rssn_RewriteRule *aRule) ;

/*
 Gets the RHS of a rewrite rule.

 Returns a new owned Expr pointer that must be freed by the caller.

 # Safety
 The caller must ensure `rule` is a valid RewriteRule pointer.
 */
rssn_ rssn_Expr *rssn_rewrite_rule_get_rhs(const rssn_RewriteRule *aRule) ;

/*
 Creates a new rewrite rule from lhs and rhs expressions.

 # Safety
 The caller must ensure `lhs` and `rhs` are valid Expr pointers.
 */
rssn_ rssn_RewriteRule *rssn_rewrite_rule_new(const rssn_Expr *aLhs, const rssn_Expr *aRhs) ;

/*
 Creates a rewrite rule from Bincode.
 */
rssn_ rssn_BincodeBuffer rssn_rewrite_rule_new_bincode(rssn_BincodeBuffer aInput) ;

/*
 Creates a rewrite rule from JSON.

 Input: JSON object with "lhs" and "rhs" fields (both Expr)
 Output: JSON-serialized RewriteRule
 */
rssn_ char *rssn_rewrite_rule_new_json(const char *aJsonStr) ;

/*
 Converts a rewrite rule to a string representation.

 The returned string must be freed using `rssn_free_string`.

 # Safety
 The caller must free the returned string.
 */
rssn_ char *rssn_rewrite_rule_to_string(const rssn_RewriteRule *aRule) ;

/*
 Converts a rewrite rule to a human-readable string (Bincode).
 */
rssn_ rssn_BincodeBuffer rssn_rewrite_rule_to_string_bincode(rssn_BincodeBuffer aInput) ;

/*
 Converts a rewrite rule to a human-readable string (JSON).

 Input: JSON-serialized RewriteRule
 Output: JSON object with "string" field
 */
rssn_ char *rssn_rewrite_rule_to_string_json(const char *aJsonStr) ;

/*
 Integrates an expression using the Risch-Norman algorithm (Handle)
 */
rssn_ rssn_Expr *rssn_risch_norman_integrate_handle(const rssn_Expr *aExpr, const char *aX) ;

/*
 Frees a rules vector.

 # Safety
 The caller must ensure `rules` was created by this module and hasn't been freed yet.
 */
rssn_ void rssn_rules_vec_free(rssn_Vec<rssn_RewriteRule> *aRules) ;

/*
 Gets a rule from a rules vector by index.

 Returns a new owned RewriteRule pointer that must be freed by the caller.

 # Safety
 The caller must ensure `rules` is a valid Vec<RewriteRule> pointer.
 */
rssn_
rssn_RewriteRule *rssn_rules_vec_get(const rssn_Vec<rssn_RewriteRule> *aRules,
                                     size_t aIndex)
;

/*
 Gets the length of a rules vector.

 # Safety
 The caller must ensure `rules` is a valid Vec<RewriteRule> pointer.
 */
rssn_ size_t rssn_rules_vec_len(const rssn_Vec<rssn_RewriteRule> *aRules) ;

rssn_
rssn_ConvergenceResult *rssn_series_analyze_convergence_handle(const rssn_Expr *aSeries,
                                                               const char *aVar)
;

rssn_
rssn_BincodeBuffer rssn_series_bincode_analyze_convergence(rssn_BincodeBuffer aSeriesBuf,
                                                           rssn_BincodeBuffer aVarBuf)
;

rssn_ char *rssn_series_json_analyze_convergence(const char *aSeriesJson, const char *aVarJson) ;

rssn_
rssn_Expr *rssn_simple_linear_regression(const rssn_Expr *const *aXData,
                                         const rssn_Expr *const *aYData,
                                         size_t aLen)
;

/*
 Creates a new Simplex (Handle)
 */
rssn_ rssn_Simplex *rssn_simplex_create(const size_t *aVerticesPtr, size_t aLen) ;

/*
 Gets the dimension of a Simplex
 */
rssn_ size_t rssn_simplex_dimension(const rssn_Simplex *aPtr) ;

/*
 Frees a Simplex handle
 */
rssn_ void rssn_simplex_free(rssn_Simplex *aPtr) ;

/*
 Adds a simplex to a SimplicialComplex
 */
rssn_
void rssn_simplicial_complex_add_simplex(rssn_SimplicialComplex *aComplexPtr,
                                         const size_t *aVerticesPtr,
                                         size_t aLen)
;

/*
 Applies the symbolic boundary operator to a SymbolicChain
 */
rssn_
rssn_SymbolicChain *rssn_simplicial_complex_apply_symbolic_boundary_operator(const rssn_SimplicialComplex *aComplexPtr,
                                                                             const rssn_SymbolicChain *aChainPtr)
;

/*
 Creates a new SimplicialComplex (Handle)
 */
rssn_ rssn_SimplicialComplex *rssn_simplicial_complex_create() ;

/*
 Gets the dimension of a SimplicialComplex
 */
rssn_ int rssn_simplicial_complex_dimension(const rssn_SimplicialComplex *aPtr) ;

/*
 Computes the Euler characteristic
 */
rssn_ ptrdiff_t rssn_simplicial_complex_euler_characteristic(const rssn_SimplicialComplex *aPtr) ;

/*
 Frees a SimplicialComplex handle
 */
rssn_ void rssn_simplicial_complex_free(rssn_SimplicialComplex *aPtr) ;

/*
 Gets the symbolic boundary matrix for dimension k
 */
rssn_
rssn_Expr *rssn_simplicial_complex_get_symbolic_boundary_matrix(const rssn_SimplicialComplex *aComplexPtr,
                                                                size_t aK)
;

/*
 Simplifies an expression using the legacy simplifier.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ rssn_Expr *rssn_simplify(const rssn_Expr *aExpr) ;

/*
 Simplifies an expression using the DAG-based simplifier.

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ rssn_Expr *rssn_simplify_dag(const rssn_Expr *aExpr) ;

/*
 Simplifies a logical expression using handle-based FFI.

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_ rssn_Expr *rssn_simplify_logic_handle(const rssn_Expr *aExpr) ;

/*
 Simplifies radical expressions (Handle)
 */
rssn_ rssn_Expr *rssn_simplify_radicals_handle(const rssn_Expr *aExpr) ;

/*
 Creates a sine expression: sin(expr).

 # Safety
 The caller must ensure `expr` is a valid Expr pointer.
 */
rssn_ rssn_Expr *rssn_sin(const rssn_Expr *aExpr) ;

/*
 Creates a sine expression from bincode: sin(expr).

 # Arguments
 * `expr_buffer` - Bincode-serialized Expr

 # Returns
 Bincode-serialized Expr
 */
rssn_ rssn_BincodeBuffer rssn_sin_bincode(rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a sine expression from JSON: sin(expr).

 # Arguments
 * `json_expr` - JSON-serialized Expr

 # Returns
 JSON-serialized Expr or null on error
 */
rssn_ char *rssn_sin_json(const char *aJsonExpr) ;

rssn_ rssn_Expr **rssn_so3_generators(size_t *aOutLen) ;

rssn_ int32_t rssn_solve(size_t aExprH, const char *aVar, size_t *aResultH) ;

/*
 Solves the airfoil singular integral equation.
 */
rssn_
rssn_Expr *rssn_solve_airfoil_equation(const rssn_Expr *aFX,
                                       const char *aVarX,
                                       const char *aVarT)
;

/*
 Solves the airfoil singular integral equation (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_solve_airfoil_equation_bincode(const uint8_t *aInputPtr,
                                                       size_t aInputLen)
;

/*
 Solves the airfoil singular integral equation (JSON).
 */
rssn_ char *rssn_solve_airfoil_equation_json(const char *aInputJson) ;

/*
 Solves a Bernoulli ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
rssn_Expr *rssn_solve_bernoulli_ode(const rssn_Expr *aEquation,
                                    const char *aFunc,
                                    const char *aVar)
;

/*
 Solves a second-order ODE by reduction of order with a known solution.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_by_reduction_of_order(const rssn_Expr *aEquation,
                                            const char *aFunc,
                                            const char *aVar,
                                            const rssn_Expr *aY1)
;

/*
 Solves a Cauchy-Euler ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
rssn_Expr *rssn_solve_cauchy_euler_ode(const rssn_Expr *aEquation,
                                       const char *aFunc,
                                       const char *aVar)
;

/*
 Solves a Diophantine equation.

 # Safety
 `equation` must be a valid pointer to an `Expr`.
 `vars_ptr` must be a valid pointer to an array of C strings of length `vars_len`.
 */
rssn_
rssn_Expr *rssn_solve_diophantine_handle(const rssn_Expr *aEquation,
                                         const char *const *aVarsPtr,
                                         int aVarsLen)
;

/*
 Solves an exact ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
rssn_Expr *rssn_solve_exact_ode(const rssn_Expr *aEquation,
                                const char *aFunc,
                                const char *aVar)
;

/*
 Solves a first-order linear ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
rssn_Expr *rssn_solve_first_order_linear_ode(const rssn_Expr *aEquation,
                                             const char *aFunc,
                                             const char *aVar)
;

rssn_ rssn_Vec<rssn_Expr> *rssn_solve_handle(const rssn_Expr *aExpr, const char *aVar) ;

/*
 Solves the 1D heat equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_heat_equation_1d(const rssn_Expr *aEquation,
                                       const char *aFunc,
                                       const char *const *aVars,
                                       size_t aVarsLen)
;

/*
 Solves the Helmholtz equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_helmholtz_equation(const rssn_Expr *aEquation,
                                         const char *aFunc,
                                         const char *const *aVars,
                                         size_t aVarsLen)
;

/*
 Solves the Klein-Gordon equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_klein_gordon_equation(const rssn_Expr *aEquation,
                                            const char *aFunc,
                                            const char *const *aVars,
                                            size_t aVarsLen)
;

/*
 Solves the 2D Laplace equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_laplace_equation_2d(const rssn_Expr *aEquation,
                                          const char *aFunc,
                                          const char *const *aVars,
                                          size_t aVarsLen)
;

rssn_
rssn_Vec<rssn_Expr> *rssn_solve_linear_system_handle(const rssn_Expr *aSystem,
                                                     const rssn_Vec<rssn_String> *aVars)
;

/*
 Solves an ordinary differential equation.

 # Safety
 The caller must ensure `ode_expr` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
rssn_Expr *rssn_solve_ode(const rssn_Expr *aOdeExpr,
                          const char *aFunc,
                          const char *aVar)
;

/*
 Solves a partial differential equation using automatic method selection.

 # Safety
 The caller must ensure `pde_expr` is a valid Expr pointer, `func` and `vars` are valid C strings,
 and `vars_len` accurately represents the number of variables.
 */
rssn_
rssn_Expr *rssn_solve_pde(const rssn_Expr *aPdeExpr,
                          const char *aFunc,
                          const char *const *aVars,
                          size_t aVarsLen)
;

/*
 Solves a PDE using the method of characteristics.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_pde_by_characteristics(const rssn_Expr *aEquation,
                                             const char *aFunc,
                                             const char *const *aVars,
                                             size_t aVarsLen)
;

/*
 Solves the 2D Poisson equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_poisson_equation_2d(const rssn_Expr *aEquation,
                                          const char *aFunc,
                                          const char *const *aVars,
                                          size_t aVarsLen)
;

/*
 Solves a Riccati ODE with a known particular solution.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_riccati_ode(const rssn_Expr *aEquation,
                                  const char *aFunc,
                                  const char *aVar,
                                  const rssn_Expr *aY1)
;

/*
 Solves the Schrödinger equation.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_schrodinger_equation(const rssn_Expr *aEquation,
                                           const char *aFunc,
                                           const char *const *aVars,
                                           size_t aVarsLen)
;

/*
 Solves a separable ODE.

 # Safety
 The caller must ensure `equation` is a valid Expr pointer, and `func` and `var` are valid C strings.
 */
rssn_
rssn_Expr *rssn_solve_separable_ode(const rssn_Expr *aEquation,
                                    const char *aFunc,
                                    const char *aVar)
;

/*
 Solves the 1D wave equation using D'Alembert's formula.

 # Safety
 The caller must ensure all pointers are valid.
 */
rssn_
rssn_Expr *rssn_solve_wave_equation_1d_dalembert(const rssn_Expr *aEquation,
                                                 const char *aFunc,
                                                 const char *const *aVars,
                                                 size_t aVarsLen)
;

/*
 Creates a square root expression: sqrt(expr).
 */
rssn_ rssn_Expr *rssn_sqrt(const rssn_Expr *aExpr) ;

/*
 Creates a square root expression from bincode: sqrt(expr).
 */
rssn_ rssn_BincodeBuffer rssn_sqrt_bincode(rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a square root expression from JSON: sqrt(expr).
 */
rssn_ char *rssn_sqrt_json(const char *aJsonExpr) ;

/*
 Frees a State.
 */
rssn_ void rssn_state_free(rssn_State *aState) ;

/*
 Gets the intermediate value from the state.
 The returned string must be freed by the caller using rssn_free_string.
 */
rssn_ char *rssn_state_get_intermediate_value(const rssn_State *aState) ;

/*
 Gets the intermediate value from a bincode state buffer.
 Returns the value as a bincode buffer containing a String.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
rssn_BincodeBuffer rssn_state_get_intermediate_value_bincode(rssn_BincodeBuffer aStateBuffer)
;

/*
 Gets the intermediate value from a JSON state string.
 Returns the value as a plain string (not JSON-encoded).
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_state_get_intermediate_value_json(const char *aJsonState) ;

/*
 Creates a new State.
 The caller is responsible for freeing the memory using rssn_state_free.
 */
rssn_ rssn_State *rssn_state_new() ;

/*
 Creates a new State and returns it as a bincode buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_ rssn_BincodeBuffer rssn_state_new_bincode() ;

/*
 Creates a new State and returns it as a JSON string.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_state_new_json() ;

/*
 Sets the intermediate value in the state.
 */
rssn_ void rssn_state_set_intermediate_value(rssn_State *aState, const char *aValue) ;

/*
 Sets the intermediate value in a bincode state buffer and returns the updated buffer.
 The caller must free the returned buffer using rssn_free_bincode_buffer.
 */
rssn_
rssn_BincodeBuffer rssn_state_set_intermediate_value_bincode(rssn_BincodeBuffer aStateBuffer,
                                                             rssn_BincodeBuffer aValueBuffer)
;

/*
 Sets the intermediate value in a JSON state string and returns the updated JSON.
 The caller must free the returned string using rssn_free_string.
 */
rssn_ char *rssn_state_set_intermediate_value_json(const char *aJsonState, const char *aValue) ;

rssn_
int32_t rssn_stats_covariance(const double *aD1,
                              const double *aD2,
                              size_t aLen,
                              double *aResult)
;

rssn_ int32_t rssn_stats_mean(const double *aData, size_t aLen, double *aResult) ;

rssn_ int32_t rssn_stats_std_dev(const double *aData, size_t aLen, double *aResult) ;

rssn_ int32_t rssn_stats_variance(const double *aData, size_t aLen, double *aResult) ;

/*
 Computes the symbolic standard deviation of a set of expressions.

 # Safety
 The caller must ensure `data` is a valid pointer to an array of `Expr` pointers of size `len`.
 */
rssn_ rssn_Expr *rssn_std_dev(const rssn_Expr *const *aData, size_t aLen) ;

rssn_ rssn_Expr *rssn_stirling_number_second_kind(size_t aN, size_t aK) ;

/*
 Represents Stokes' theorem (Handle)
 */
rssn_
rssn_Expr *rssn_stokes_theorem_handle(const rssn_Vector *aVectorFieldPtr,
                                      const rssn_Expr *aSurfacePtr)
;

/*
 Generates the Sturm sequence for a given polynomial (Handle)
 */
rssn_
rssn_Vec<rssn_Expr> *rssn_sturm_sequence_handle(const rssn_Expr *aExprPtr,
                                                const char *aVarPtr)
;

rssn_ rssn_Expr **rssn_su2_generators(size_t *aOutLen) ;

/*
 Substitutes a variable with an expression.
 */
rssn_
rssn_Expr *rssn_substitute(const rssn_Expr *aExpr,
                           const char *aVar,
                           const rssn_Expr *aReplacement)
;

rssn_
rssn_Expr *rssn_summation_handle(const rssn_Expr *aExpr,
                                 const char *aVar,
                                 const rssn_Expr *aLower,
                                 const rssn_Expr *aUpper)
;

/*
 Computes the surface integral (flux) of a vector field.
 */
rssn_
char *rssn_surface_integral(const char *aFieldX,
                            const char *aFieldY,
                            const char *aFieldZ,
                            const rssn_ParametricSurface *aSurface)
;

/*
 Computes the surface integral (flux) of a vector field (Bincode).
 */
rssn_ rssn_BincodeBuffer rssn_surface_integral_bincode(const uint8_t *aInputPtr, size_t aInputLen) ;

/*
 Computes the surface integral (flux) of a vector field (JSON).
 */
rssn_ char *rssn_surface_integral_json(const char *aInputJson) ;

/*
 Adds a term to a SymbolicChain
 */
rssn_
bool rssn_symbolic_chain_add_term(rssn_SymbolicChain *aChainPtr,
                                  const rssn_Simplex *aSimplexPtr,
                                  const rssn_Expr *aCoeffPtr)
;

/*
 Creates a new SymbolicChain (Handle)
 */
rssn_ rssn_SymbolicChain *rssn_symbolic_chain_create(size_t aDimension) ;

/*
 Frees a SymbolicChain handle
 */
rssn_ void rssn_symbolic_chain_free(rssn_SymbolicChain *aPtr) ;

rssn_ rssn_Group *rssn_symmetric_group_create(size_t aN) ;

/*
 Creates a tangent expression: tan(expr).
 */
rssn_ rssn_Expr *rssn_tan(const rssn_Expr *aExpr) ;

/*
 Creates a tangent expression from bincode: tan(expr).
 */
rssn_ rssn_BincodeBuffer rssn_tan_bincode(rssn_BincodeBuffer aExprBuffer) ;

/*
 Creates a tangent expression from JSON: tan(expr).
 */
rssn_ char *rssn_tan_json(const char *aJsonExpr) ;

rssn_
rssn_Expr *rssn_taylor_series_handle(const rssn_Expr *aExpr,
                                     const char *aVar,
                                     const rssn_Expr *aCenter,
                                     size_t aOrder)
;

rssn_ rssn_Tensor *rssn_tensor_add_handle(const rssn_Tensor *aT1, const rssn_Tensor *aT2) ;

rssn_
rssn_Tensor *rssn_tensor_contract_handle(const rssn_Tensor *aT,
                                         size_t aAxis1,
                                         size_t aAxis2)
;

rssn_
rssn_Tensor *rssn_tensor_outer_product_handle(const rssn_Tensor *aT1,
                                              const rssn_Tensor *aT2)
;

rssn_ rssn_Tensor *rssn_tensor_scalar_mul_handle(const rssn_Tensor *aT, const rssn_Expr *aScalar) ;

/*
 Allocates and returns a test string ("pong") to the caller.

 This function serves as a more advanced health check for the FFI interface.
 It allows the client to verify two things:
 1. That the FFI function can be called successfully.
 2. That memory allocated in Rust can be safely passed to and then freed by the client
    by calling `free_string` on the returned pointer.

 Returns a pointer to a null-terminated C string. The caller is responsible for freeing this string.
 */
rssn_ char *rssn_test_string_passing() ;

/*
 Converts a logical expression to Conjunctive Normal Form (CNF) using handle-based FFI.

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_ rssn_Expr *rssn_to_cnf_handle(const rssn_Expr *aExpr) ;

/*
 Converts a logical expression to Disjunctive Normal Form (DNF) using handle-based FFI.

 # Safety
 The caller must ensure that `expr` is a valid pointer to an `Expr`.
 */
rssn_ rssn_Expr *rssn_to_dnf_handle(const rssn_Expr *aExpr) ;

rssn_
rssn_Vec<rssn_Expr> *rssn_transform_contravariant_vector_handle(const rssn_Vec<rssn_Expr> *aComps,
                                                                rssn_CoordinateSystem aFrom,
                                                                rssn_CoordinateSystem aTo)
;

rssn_
rssn_Vec<rssn_Expr> *rssn_transform_covariant_vector_handle(const rssn_Vec<rssn_Expr> *aComps,
                                                            rssn_CoordinateSystem aFrom,
                                                            rssn_CoordinateSystem aTo)
;

rssn_
rssn_Vec<rssn_Expr> *rssn_transform_curl_handle(const rssn_Vec<rssn_Expr> *aComps,
                                                rssn_CoordinateSystem aFrom)
;

rssn_
rssn_Expr *rssn_transform_divergence_handle(const rssn_Vec<rssn_Expr> *aComps,
                                            rssn_CoordinateSystem aFrom)
;

rssn_
rssn_Expr *rssn_transform_expression_handle(const rssn_Expr *aExpr,
                                            rssn_CoordinateSystem aFrom,
                                            rssn_CoordinateSystem aTo)
;

rssn_
rssn_Vec<rssn_Expr> *rssn_transform_gradient_handle(const rssn_Expr *aScalar,
                                                    const rssn_Vec<rssn_String> *aVars,
                                                    rssn_CoordinateSystem aFrom,
                                                    rssn_CoordinateSystem aTo)
;

rssn_
rssn_Vec<rssn_Expr> *rssn_transform_point_handle(const rssn_Vec<rssn_Expr> *aPoint,
                                                 rssn_CoordinateSystem aFrom,
                                                 rssn_CoordinateSystem aTo)
;

rssn_
rssn_Expr *rssn_two_sample_t_test(const rssn_Expr *const *aData1,
                                  size_t aLen1,
                                  const rssn_Expr *const *aData2,
                                  size_t aLen2,
                                  const rssn_Expr *aMuDiff)
;

rssn_ rssn_Expr *rssn_unify_expression_handle(const rssn_Expr *aExpr) ;

/*
 Computes the symbolic variance of a set of expressions.

 # Safety
 The caller must ensure `data` is a valid pointer to an array of `Expr` pointers of size `len`.
 */
rssn_ rssn_Expr *rssn_variance(const rssn_Expr *const *aData, size_t aLen) ;

/*
 Computes the dot product of two vectors.
 */
rssn_
int32_t rssn_vec_dot_product(const double *aD1,
                             size_t aL1,
                             const double *aD2,
                             size_t aL2,
                             double *aResult)
;

/*
 Computes the L2 norm of a vector.
 */
rssn_ int32_t rssn_vec_norm(const double *aData, size_t aLen, double *aResult) ;

rssn_ rssn_Vector *rssn_vector_cross_handle(const rssn_Vector *aV1, const rssn_Vector *aV2) ;

rssn_ rssn_Expr *rssn_vector_dot_handle(const rssn_Vector *aV1, const rssn_Vector *aV2) ;

rssn_ rssn_Expr *rssn_vector_magnitude_handle(const rssn_Vector *aV) ;

rssn_ rssn_Vector *rssn_vector_normalize_handle(const rssn_Vector *aV) ;

/*
 Frees a Volterra integral equation.
 */
rssn_ void rssn_volterra_free(rssn_VolterraEquation *aPtr) ;

/*
 Creates a new Volterra integral equation.
 */
rssn_
rssn_VolterraEquation *rssn_volterra_new(const rssn_Expr *aYX,
                                         const rssn_Expr *aFX,
                                         const rssn_Expr *aLambda,
                                         const rssn_Expr *aKernel,
                                         const rssn_Expr *aLowerBound,
                                         const char *aVarX,
                                         const char *aVarT)
;

/*
 Solves a Volterra equation by differentiation.
 */
rssn_ rssn_Expr *rssn_volterra_solve_by_differentiation(const rssn_VolterraEquation *aEq) ;

/*
 Solves a Volterra equation by differentiation (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_volterra_solve_by_differentiation_bincode(const uint8_t *aInputPtr,
                                                                  size_t aInputLen)
;

/*
 Solves a Volterra equation by differentiation (JSON).
 */
rssn_ char *rssn_volterra_solve_by_differentiation_json(const char *aInputJson) ;

/*
 Solves a Volterra equation using successive approximations.
 */
rssn_
rssn_Expr *rssn_volterra_solve_successive(const rssn_VolterraEquation *aEq,
                                          size_t aIterations)
;

/*
 Solves a Volterra equation using successive approximations (Bincode).
 */
rssn_
rssn_BincodeBuffer rssn_volterra_solve_successive_bincode(const uint8_t *aInputPtr,
                                                          size_t aInputLen)
;

/*
 Solves a Volterra equation using successive approximations (JSON).
 */
rssn_ char *rssn_volterra_solve_successive_json(const char *aInputJson) ;

/*
 Frees a Volume handle.
 */
rssn_ void rssn_volume_free(rssn_Volume *aVolume) ;

/*
 Computes the volume integral of a scalar field.
 */
rssn_ char *rssn_volume_integral(const char *aScalarField, const rssn_Volume *aVolume) ;

/*
 Computes the volume integral of a scalar field (Bincode).
 */
rssn_ rssn_BincodeBuffer rssn_volume_integral_bincode(const uint8_t *aInputPtr, size_t aInputLen) ;

/*
 Computes the volume integral of a scalar field (JSON).
 */
rssn_ char *rssn_volume_integral_json(const char *aInputJson) ;

/*
 Creates a new Volume.
 */
rssn_
rssn_Volume *rssn_volume_new(const char *aZLower,
                             const char *aZUpper,
                             const char *aYLower,
                             const char *aYUpper,
                             const char *aXLower,
                             const char *aXUpper,
                             const char *aXVar,
                             const char *aYVar,
                             const char *aZVar)
;

/*
 Computes the wedge product of two differential forms (Handle)
 */
rssn_
rssn_DifferentialForm *rssn_wedge_product_handle(const rssn_DifferentialForm *aForm1Ptr,
                                                 const rssn_DifferentialForm *aForm2Ptr)
;

rssn_
rssn_Expr *rssn_z_test(const rssn_Expr *const *aData,
                       size_t aLen,
                       const rssn_Expr *aTargetMean,
                       const rssn_Expr *aPopStdDev)
;

rssn_ DEPRECATED_WITH_NOTE char *stats_percentile(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *stats_simple_linear_regression(const char *aJsonPtr) ;

/*
 Computes the Fast Fourier Transform (FFT) of a sequence of complex numbers.
 */
rssn_ DEPRECATED_WITH_NOTE char *transforms_fft(const char *aJsonPtr) ;

/*
 Computes the Inverse Fast Fourier Transform (IFFT) of a sequence of complex numbers.
 */
rssn_ DEPRECATED_WITH_NOTE char *transforms_ifft(const char *aJsonPtr) ;

rssn_ DEPRECATED_WITH_NOTE char *vector_scalar_mul(const char *aJsonPtr) ;

}  // extern "C"

}  // namespace rssn

#endif  // RSSN_H
